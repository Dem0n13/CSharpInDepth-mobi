<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><meta name="generator" content="ABBYY FineReader 11"/><meta name="author" content="Jon Skeet"/><title>C# in Depth</title>
</head>
<body><div><img src="images/1.png"/></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">The best C# book available for intermediate to expert developers. Experienced .NET developers who think they know everything there is to know about the C# language will almost certainly learn more than a thing or two in this book. It is an interesting cover-to-cover read, and will be a handy desktop reference as well. I recommend this book to anyone who wants to become a C# expert.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Alvin Ashcraft, DZone review</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Simply put,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> C# in Depth </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is perhaps the best computer book I’ve read.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Craig Pelkie, Author, System iNetwork</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">I have been developing in C# from the very beginning and this book had some nice surprises even for me. I was especially impressed with the excellent coverage of delegates, anonymous methods, covariance and contravariance. Even if you are a seasoned developer,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> C# in Depth </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">will teach you something new about the C# language... This book truly has depth that no other C# language book can touch.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Adam J. Wolf Southeast Valley .NET User Group</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">I enjoyed reading the whole book; it is well-written—the samples are easy to understand.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">I actually found it very easy to engage into the whole lambda expressions topic and really liked the chapter about lambda expressions.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—-Jose Rolando Guay Paz</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Web Developer, CSW Solutions</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">This book wraps up the author’s great knowfedge of the inner workings of C# and hands it over to readers in a well-written, concise, usable book.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Jim Holmes Author of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Windows Developer Power Tools</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Every term is used appropriately and in the right context, every example is spot-on and contains the least amount of code that shows the full extent of the feature...this is a rare treat.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Franck Jeannin, Amazon UK reviewer</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">If you have developed using C# for several years now, and would like to know the internals, this book is absolutely right for you.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Golo Roden, Author, Speaker, and Trainer for .NET and related technologies</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">If there’s one must-have book for .NET developers, this is it. Jon Sheet provides everything you need to know about C# mazes, with particular attention to LINQ. The author really knows his stuff and provides invaluable comments about C# features.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Luigi Zambetti, Developer, Milan</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">This book is the best C# reference money can buy at the moment.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—-Jan Van Ryswyck, ElegantCode.com</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Jon Skeet’s writing style is clear and concise and he’s got lots of great examples.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Peter Kellner, Blogger</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">A first-class book about C#.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Teemu Keiski, ASP.NET MVP, AspInsider</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Become a C# 3 maestro!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Fabrice Marguerie, C# MVP, author of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">LINQ in Action The best C# book I’ve ever read.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Chris Mullins, C# MVP</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Clear and concise.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Robin Shahan, GoldMail.com</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">A treat!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Anil Radhakrishna, ASP.NET MVP</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Reveals C#’s powerful mysteries.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Christopher Haupt, BuildingWebApps.com</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">So good, it hurts my head.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—J.D. Conley, Hive7 Inc.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Enriches the beginner, polishes the expert.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">—Josh Cronemeyer ThoughtWorks</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For online information and ordering of this and other Manning books, please visit <a href="http://www.manning.com">www.manning.com</a>. The publisher offers discounts on this book when ordered in quantity. For more information, please contact</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Special Sales Department Manning Publications Co.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">180 Broad St.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Suite 1323</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Stamford, CT 06901</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Email: <a href="mailto:orders@manning.com">orders@manning.com</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">©2011 by Manning Publications Co. All rights reserved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by means electronic, mechanical, photocopying, or otherwise, without prior written permission of the publisher.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in the book, and Manning Publications was aware of a trademark claim, the designations have been printed in initial caps or all caps.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">® Recognizing the importance of preserving what has been written, it is Manning’s policy to have the books we publish printed on acid-free paper, and we exert our best efforts to that end. Recognizing also our responsibility to conserve the resources of our planet, Manning books are printed on paper that is at least 15 percent recycled and processed without the use of elemental chlorine.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Manning Publications Co. &nbsp;&nbsp;&nbsp;Development &nbsp;&nbsp;&nbsp;editor: &nbsp;&nbsp;&nbsp;Jeff Bleiel</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">180 Broad St. &nbsp;&nbsp;&nbsp;Copyeditor: &nbsp;&nbsp;&nbsp;Benjamin Berg</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Suite 1323 &nbsp;&nbsp;&nbsp;Proofreader: &nbsp;&nbsp;&nbsp;Katie Tennant</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Stamford, CT 06901 &nbsp;&nbsp;&nbsp;Typesetter: &nbsp;&nbsp;&nbsp;Dottie Marsico</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Cover designer: &nbsp;&nbsp;&nbsp;Marija Tudor</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ISBN 978-1-935182-47-4</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Printed in the United States of America</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">12 34567 89 10 - MAL - 15 14 13 12 11 10</font></p>
<p><a name="bookmark0"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">brief contents</font></p>
<p><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;"><a href="#bookmark1">Part</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">1 &nbsp;&nbsp;&nbsp;Preparing</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">for</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">the</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">journey</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">.......................................</font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">1</font></a></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">1<a href="#bookmark2"> &nbsp;&nbsp;&nbsp;■ The changing face of C# development 3</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a href="#bookmark3">2 &nbsp;&nbsp;&nbsp;■</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> Core foundations: building on C# 1 &nbsp;&nbsp;&nbsp;27</font></a></p>
<p><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;"><a href="#bookmark4">Part</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">2 &nbsp;&nbsp;&nbsp;C# 2: solving</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">the</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">issues</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">of</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">C# 1............................55</font></a></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">3<a href="#bookmark5"> &nbsp;&nbsp;&nbsp;■ Parameterized typing with generics 57</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">4<a href="#bookmark6"> &nbsp;&nbsp;&nbsp;■ Saying nothing with nullable types 103</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">5<a href="#bookmark7"> &nbsp;&nbsp;&nbsp;■ Fast-tracked delegates 130</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">6<a href="#bookmark8"> &nbsp;&nbsp;&nbsp;■ Implementing iterators the easy way 156</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">7<a href="#bookmark9"> &nbsp;&nbsp;&nbsp;■ Concluding C# 2: the final features 179</a></font></p>
<p><a name="bookmark10"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;"><a href="#bookmark11">Part</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">3 &nbsp;&nbsp;&nbsp;C# 3: revolutionizing</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">how</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">we</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">code</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">....................</font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">201</font></a></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">8<a href="#bookmark12"> &nbsp;&nbsp;&nbsp;■ Cutting fluff with a smart compiler 203</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">9<a href="#bookmark13"> &nbsp;&nbsp;&nbsp;■ Lambda expressions and expression trees 227</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">10<a href="#bookmark14"> &nbsp;&nbsp;&nbsp;■ Extension methods 256</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">11<a href="#bookmark15"> &nbsp;&nbsp;&nbsp;■ Query expressions and LINQ to Objects 279</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">12<a href="#bookmark16"> &nbsp;&nbsp;&nbsp;■ LINQ beyond collections 321</a></font></p>
<p><a name="bookmark17"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;"><a href="#bookmark18">Part</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">4 C# 4: playing</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">nicely</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">with</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> </font><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">others</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">.........................</font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">363</font></a></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">13<a href="#bookmark19"> &nbsp;&nbsp;&nbsp;■ Minor changes to simplify code 365</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">14<a href="#bookmark20"> &nbsp;&nbsp;&nbsp;■ Dynamic binding in a static language 401</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">15<a href="#bookmark21"> &nbsp;&nbsp;&nbsp;■ Letting your code speak more clearly with Code Contracts 452</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">16<a href="#bookmark22"> &nbsp;&nbsp;&nbsp;■ Whither now? 490</a></font></p>
<p><a name="bookmark23"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">contents</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark24">foreword xix</a> <a href="#bookmark25">preface xxi</a> <a href="#bookmark26">acknowledgments xxiii</a> <a href="#bookmark27">about this book xxv</a></font></p>
<p><a name="bookmark1"></a><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;"><a href="#bookmark28">Part</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;">1 Preparing</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">for</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">the</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">journey</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> .</font></a></p><div>
<p><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;">1</font></p></div><br clear="all"/>
<p><a name="bookmark29"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a href="#bookmark2">The changing face of C# development 3</a></font></p>
<p><a name="bookmark30"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark31">1.1 &nbsp;&nbsp;&nbsp;Starting with a simple data type 4</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark32">The Product type in C# 1 &nbsp;&nbsp;&nbsp;4 &nbsp;&nbsp;&nbsp;</a>■<a href="#bookmark33"> &nbsp;&nbsp;&nbsp;Strongly &nbsp;&nbsp;&nbsp;typed collections in</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark33">C# 2 &nbsp;&nbsp;&nbsp;6 </a>■<a href="#bookmark34"> Automatically implemented properties in C# 3 &nbsp;&nbsp;&nbsp;7</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark35">Named arguments in C# 4 &nbsp;&nbsp;&nbsp;7</a></font></p>
<p><a name="bookmark36"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark37">1.2 &nbsp;&nbsp;&nbsp;Sorting and filtering 9</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark38">Sorting products by name 9 </a>■<a href="#bookmark39"> Querying collections 12</a></font></p>
<p><a name="bookmark40"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark41">1.3 &nbsp;&nbsp;&nbsp;Handling an absence of data 14</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark42">Representing an unknown price 14 </a>■<a href="#bookmark43"> Optional parameters</a> <a href="#bookmark43">and default values 15</a></font></p>
<p><a name="bookmark44"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark45">1.4 &nbsp;&nbsp;&nbsp;Introducing LINQ 16</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark46">Query expressions and in-process queries 16 </a>■<a href="#bookmark47"> Querying</a> <a href="#bookmark47">XML 17 </a>■<a href="#bookmark48"> LINQ to SQL 18</a></font></p>
<p><a name="bookmark49"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark50">1.5 &nbsp;&nbsp;&nbsp;COM and dynamic typing 19</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark51">Simplifying COM interoperability 19</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark52"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Interoperating with a</a> <a href="#bookmark52">dynamic language 20</a></font></p>
<p><a name="bookmark53"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark54">1.6 &nbsp;&nbsp;&nbsp;Dissecting the .NET platform 21</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark55">C#, the language 22</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark56"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Runtime 22</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark57"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Framework libraries 22</font></a></p>
<p><a name="bookmark58"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark59">1.7 &nbsp;&nbsp;&nbsp;Making your code super awesome 23</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark60">Presenting full programs as snippets 23</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark61"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Didactic code isn’t</a> <a href="#bookmark61">production code 24</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark62"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Your new best friend: the language</a> <a href="#bookmark62">specification 25</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark63">1.8 &nbsp;&nbsp;&nbsp;Summary 26</a></font></p>
<p><a name="bookmark64"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a href="#bookmark65">Core foundations: building on C# 1 &nbsp;&nbsp;&nbsp;27</a></font></p>
<p><a name="bookmark66"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark67">2.1 &nbsp;&nbsp;&nbsp;Delegates 28</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark68">A recipe for simple delegates 28</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark69"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Combining and removing</a> <a href="#bookmark69">delegates 33</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark70"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">A brief diversion into events 34</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark71"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Summary</a> <a href="#bookmark71">of delegates 35</a></font></p>
<p><a name="bookmark72"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark73">2.2 &nbsp;&nbsp;&nbsp;Type system characteristics 36</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark74">C#’s place in the world of type systems 36</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark75"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">When is C# 1’s</a> <a href="#bookmark75">type system not rich enough ? &nbsp;&nbsp;&nbsp;39</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;</a>■<a href="#bookmark76"> &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Summary &nbsp;&nbsp;&nbsp;of &nbsp;&nbsp;&nbsp;type &nbsp;&nbsp;&nbsp;system</font></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark76">characteristics 42</a></font></p>
<p><a name="bookmark77"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark78">2.3 &nbsp;&nbsp;&nbsp;Value types and reference types 42</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark79">Values and references in the real world 43</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark80"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Value and reference</a> <a href="#bookmark80">type fundamentals 43</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark81"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Dispelling myths 45</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark82"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Boxing and</a> <a href="#bookmark82">unboxing 47</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark83"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Summary of value types and reference types 48</font></a></p>
<p><a name="bookmark84"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark85">2.4 &nbsp;&nbsp;&nbsp;Beyond C# 1: new features on a solid base 48</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark86">Features related to delegates 49</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark87"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Features related to the type</a> <a href="#bookmark87">system 51</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark88"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Features related to value types 53</font></a></p>
<p><a name="bookmark89"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark90">2.5 &nbsp;&nbsp;&nbsp;Summary 54</a></font></p>
<p><a name="bookmark4"></a><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;"><a href="#bookmark91">Part</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;">2 C# 2: solving</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">the</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">issues</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">of</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;">C#.....................155</font></a></p>
<p><a name="bookmark92"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a href="#bookmark5">Parameterized typing with generics 57</a></font></p>
<p><a name="bookmark93"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark94">3.1 &nbsp;&nbsp;&nbsp;Why generics are necessary 58</a></font></p>
<p><a name="bookmark95"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark96">3.2 Simple generics for everyday use 60</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark97">Learning by example: a generic dictionary 60</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark98"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Generic types</a> <a href="#bookmark98">and type parameters 62</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark99"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Generic methods and reading generic</a> <a href="#bookmark99">declarations 65</a></font></p>
<p><a name="bookmark100"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark101">3.3 &nbsp;&nbsp;&nbsp;Beyond the basics 68</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark102">Type constraints 69 </a>■<a href="#bookmark103"> Type inference for type arguments of generic</a> <a href="#bookmark103">methods 74 </a>■<a href="#bookmark104"> Implementing generics 75</a></font></p>
<p><a name="bookmark105"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark106">3.4 &nbsp;&nbsp;&nbsp;Advanced generics 81</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark107">Static fields and static constructors 81 </a>■<a href="#bookmark108"> How the JIT compiler</a> <a href="#bookmark108">handles generics 83 </a>■<a href="#bookmark109"> Generic iteration 85 </a>■<a href="#bookmark110"> Reflection and</a> <a href="#bookmark110">generics 88</a></font></p>
<p><a name="bookmark111"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark112">3.5 Limitations of generics in C# and other languages 91</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark113">Lack of generic variance 92 </a>■<a href="#bookmark114"> Lack of operator constraints or a</a> <a href="#bookmark114">“numeric” constraint 97 </a>■<a href="#bookmark115"> Lack of generic properties, indexers,</a> <a href="#bookmark115">and other member types 98</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark116"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Comparison with C++ templates 99</a> <a href="#bookmark117">Comparison with Java generics &nbsp;&nbsp;&nbsp;100</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark118">3.6 &nbsp;&nbsp;&nbsp;Summary 101</a></font></p>
<p><a name="bookmark119"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Saying nothing with nullable types 103</font></p>
<p><a name="bookmark120"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark121">4.1 What do you do when you just don’t have a value? 104</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark122">Why value type variables can’t be null 104 </a>■<a href="#bookmark123"> Patterns for</a> <a href="#bookmark123">representing null values in C# 1 &nbsp;&nbsp;&nbsp;105</a></font></p>
<p><a name="bookmark124"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark125">4.2 &nbsp;&nbsp;&nbsp;System.Nullable&lt;T&gt;and System.Nullable 107</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark126">IntroducingNullable&lt;T&gt; 107 </a>■<a href="#bookmark127"> BoxingNullable&lt;T&gt;and</a> <a href="#bookmark127">unboxing 110 </a>■<a href="#bookmark128"> Equality of Nullable&lt;T&gt; instances 111</a> <a href="#bookmark129">Support from the nongeneric Nullable class 111</a></font></p>
<p><a name="bookmark130"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark131">4.3 &nbsp;&nbsp;&nbsp;C# 2’s syntactic sugar for nullable types 112</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark132">The ? modifier 113 </a>■<a href="#bookmark133"> Assigning and comparing with null 114</a> <a href="#bookmark134">Nullable conversions and operators 116</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark135"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Nullable logic 119</a> <a href="#bookmark136">Using the </a>as operator with nullable types 120 ■<a href="#bookmark137"> The null</a> <a href="#bookmark137">coalescing operator 121</a></font></p>
<p><a name="bookmark138"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark139">4.4 Novel uses of nullable types 124</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark140">Trying an operation without using output parameters 124</a> <a href="#bookmark141">Painless comparisons with the null coalescing operator 126</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark142">4.5 &nbsp;&nbsp;&nbsp;Summary 129</a></font></p>
<p><a name="bookmark143"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Fast-tracked delegates 130</font></p>
<p><a name="bookmark144"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark145">5.1 &nbsp;&nbsp;&nbsp;Saying goodbye to awkward delegate syntax 131</a></font></p>
<p><a name="bookmark146"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark147">5.2 Method group conversions &nbsp;&nbsp;&nbsp;133</a></font></p>
<p><a name="bookmark148"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark149">5.3 &nbsp;&nbsp;&nbsp;Covariance and contravariance 134</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark150">Contravariance for delegate parameters 135 </a>■<a href="#bookmark151"> Covariance of</a> <a href="#bookmark151">delegate return types 136</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark152"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">A small risk of incompatibility 138</font></a></p>
<p><a name="bookmark153"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark154">5.4 &nbsp;&nbsp;&nbsp;Inline delegate actions with anonymous methods 138</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark155">Starting simply: acting on a parameter 139 </a>■<a href="#bookmark156"> Returning</a> <a href="#bookmark156">values from anonymous methods 141</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark157"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Ignoring delegate</a> <a href="#bookmark157">parameters 143</a></font></p>
<p><a name="bookmark158"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark159">5.5 &nbsp;&nbsp;&nbsp;Capturing variables in anonymous methods 144</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark160">Defining closures and different types of variables 145</a> <a href="#bookmark161">Examining the behavior of captured variables 146 </a>■<a href="#bookmark162"> What’s the</a> <a href="#bookmark162">point of captured variables ? &nbsp;&nbsp;&nbsp;147 &nbsp;&nbsp;&nbsp;</a>■<a href="#bookmark163"> &nbsp;&nbsp;&nbsp;The &nbsp;&nbsp;&nbsp;extended &nbsp;&nbsp;&nbsp;lifetime of</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark163">captured variables 148 </a>■<a href="#bookmark164"> Local variable instantiations 149</a> <a href="#bookmark165">Mixtures of shared and distinct variables 151 </a>■<a href="#bookmark166"> Captured variable</a> <a href="#bookmark166">guidelines and summary 153</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark167">5.6 &nbsp;&nbsp;&nbsp;Summary 154</a></font></p>
<p><a name="bookmark168"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a href="#bookmark8">Implementing iterators the easy way 156</a></font></p>
<p><a name="bookmark169"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark170">6.1 C# 1: the pain of handwritten iterators 157</a></font></p>
<p><a name="bookmark171"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark172">6.2 C# 2: simple iterators with yield statements &nbsp;&nbsp;&nbsp;160</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark173">Introducing iterator blocks and yield return 160 </a>■<a href="#bookmark174"> Visualizing an</a> <a href="#bookmark174">iterator’s workflow 162 </a>■<a href="#bookmark175"> Advanced iterator execution flow 164</a> <a href="#bookmark176">Quirks in the implementation 167</a></font></p>
<p><a name="bookmark177"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark178">6.3 &nbsp;&nbsp;&nbsp;Real-life iterator examples 169</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark179">Iterating over the dates in a timetable 169 </a>■<a href="#bookmark180"> Iterating over lines in</a> <a href="#bookmark180">a file 170 </a>■<a href="#bookmark181"> Filtering items lazily using an iterator block and a</a> <a href="#bookmark181">predicate 173</a></font></p>
<p><a name="bookmark182"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark183">6.4 &nbsp;&nbsp;&nbsp;Pseudo-synchronous code with the Concurrency and</a></font></p>
<p><a name="bookmark184"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">Coordination Runtime 175</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark185">6.5 &nbsp;&nbsp;&nbsp;Summary 177</a></font></p>
<p><a name="bookmark186"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a href="#bookmark9">Concluding C# 2: the final features &nbsp;&nbsp;&nbsp;179</a></font></p>
<p><a name="bookmark187"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark188">7.1 &nbsp;&nbsp;&nbsp;Partial types 180</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark189">Creating a type with multiple files 181 </a>■<a href="#bookmark190"> Uses of partial</a> <a href="#bookmark190">types 183 </a>■<a href="#bookmark191"> Partial methods</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">C# 3 only! 184</font></a></p>
<p><a name="bookmark192"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark193">7.2 &nbsp;&nbsp;&nbsp;Static classes 186</a></font></p>
<p><a name="bookmark194"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark195">7.3 &nbsp;&nbsp;&nbsp;Separate getter/setter property access 189</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark196">7.4 &nbsp;&nbsp;&nbsp;Namespace aliases &nbsp;&nbsp;&nbsp;190</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark197">Qualifying namespace aliases 191 </a>■<a href="#bookmark198"> The global namespace</a> <a href="#bookmark198">alias 192 </a>■<a href="#bookmark199"> Extern aliases 192</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark200">7.5 &nbsp;&nbsp;&nbsp;Pragma directives &nbsp;&nbsp;&nbsp;194</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark201">Warning pragmas &nbsp;&nbsp;&nbsp;194 </a>■<a href="#bookmark202"> &nbsp;&nbsp;&nbsp;Checksum pragmas 195</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark203">7.6 &nbsp;&nbsp;&nbsp;Fixed-size buffers in unsafe code &nbsp;&nbsp;&nbsp;196</a></font></p>
<p><a name="bookmark204"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark205">7.7 &nbsp;&nbsp;&nbsp;Exposing internal members to selected assemblies 198</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark206">Friend assemblies in the simple case 198</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark207"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Why use</a> <a href="#bookmark207">InternalsVisibleTo? &nbsp;&nbsp;&nbsp;199</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;</a>■<a href="#bookmark208"> &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">InternalsVisibleTo &nbsp;&nbsp;&nbsp;and &nbsp;&nbsp;&nbsp;signed</font></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark208">assemblies 199</a></font></p>
<p><a name="bookmark209"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark210">7.8 &nbsp;&nbsp;&nbsp;Summary 200</a></font></p>
<p><a name="bookmark211"></a><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;"><a href="#bookmark11">Part</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;">3 C# 3: revolutionizing</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">how</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">we</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">code</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;">...........</font><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;">201</font></a></p>
<p><a name="bookmark212"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a href="#bookmark12">Cutting fluff with a smart compiler 203</a></font></p>
<p><a name="bookmark213"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark214">8.1 Automatically implemented properties &nbsp;&nbsp;&nbsp;204</a></font></p>
<p><a name="bookmark215"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark216">8.2 Implicit typing of local variables 207</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark217">Using var to declare a local variable 207</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark218"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Restrictions on</a> <a href="#bookmark218">implicit typing 208</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark219"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Pros and cons of implicit typing 209</a> <a href="#bookmark220">Recommendations 211</a></font></p>
<p><a name="bookmark221"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark222">8.3 &nbsp;&nbsp;&nbsp;Simplified initialization 211</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark223">Defining our sample types 212</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark224"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Setting simple properties 213</a> <a href="#bookmark225">Setting properties on embedded objects 214</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark226"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Collection</a> <a href="#bookmark226">initializers 215</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark227"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Uses of initialization features 218</font></a></p>
<p><a name="bookmark228"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark229">8.4 &nbsp;&nbsp;&nbsp;Implicitly typed arrays 219</a></font></p>
<p><a name="bookmark230"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark231">8.5 &nbsp;&nbsp;&nbsp;Anonymous types 220</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark232">First encounters of the anonymous kind 220</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark233"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Members of</a> <a href="#bookmark233">anonymous types 222</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark234"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Projection initializers 223</a> <a href="#bookmark235">What’s the point? 225</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark236">8.6 &nbsp;&nbsp;&nbsp;Summary 226</a></font></p>
<p><a name="bookmark237"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a href="#bookmark13">Lambda expressions and expression trees 227</a></font></p>
<p><a name="bookmark238"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark239">9.1 &nbsp;&nbsp;&nbsp;Lambda expressions as delegates 229</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark240">Preliminaries: introducing the Func&lt;... &gt;&nbsp;delegate types 229</a> <a href="#bookmark241">First transformation to a lambda expression 230</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark242"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Using a single</a> <a href="#bookmark242">expression as the body 231</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark243"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Implicitly typed parameter lists 231</a> <a href="#bookmark244">Shortcut for a single parameter 232</a></font></p>
<p><a name="bookmark245"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark246">9.2 &nbsp;&nbsp;&nbsp;Simple examples using List&lt;T&gt; and events 233</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark247">Filtering, sorting, and actions on lists 233</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark248"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Logging in an</a> <a href="#bookmark248">event handler 235</a></font></p>
<p><a name="bookmark249"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark250">9.3 &nbsp;&nbsp;&nbsp;Expression trees 236</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark251">Building expression trees programmatically 236</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark252"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Compiling</a> <a href="#bookmark252">expression trees into delegates &nbsp;&nbsp;&nbsp;238</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark253"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Converting C# lambda</font></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark253">expressions to expression trees 239</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark254"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Expression trees at the heart</a> <a href="#bookmark254">of LINQ 242</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark255"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Expression trees beyond LINQ 244</font></a></p>
<p><a name="bookmark256"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark257">9.4 &nbsp;&nbsp;&nbsp;Changes to type inference and overload resolution 246</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark258">Reasons for change: streamlining generic method calls 246</a> <a href="#bookmark259">Inferred return types of anonymous functions 247 </a>■<a href="#bookmark260"> Two-phase</a> <a href="#bookmark260">type inference 248</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark261"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Picking the right overloaded method 252</a> <a href="#bookmark262">Wrapping up type inference and overload resolution 254</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark263">9.5 &nbsp;&nbsp;&nbsp;Summary 254</a></font></p>
<p><a name="bookmark264"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Extension methods 256</font></p>
<p><a name="bookmark265"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark266">10.1 &nbsp;&nbsp;&nbsp;Life before extension methods 257</a></font></p>
<p><a name="bookmark267"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark268">10.2 &nbsp;&nbsp;&nbsp;Extension method syntax 259</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark269">Declaring extension methods 259 </a>■<a href="#bookmark270"> Calling extension</a> <a href="#bookmark270">methods 261 </a>■<a href="#bookmark271"> Extension method discovery 262</a> <a href="#bookmark272">Calling a method on a null reference 263</a></font></p>
<p><a name="bookmark273"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark274">10.3 &nbsp;&nbsp;&nbsp;Extension methods in .NET 3.5 265</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark275">First steps with Enumerable 265</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark276"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Filtering with Where and</a> <a href="#bookmark276">chaining method calls together 267 </a>■<a href="#bookmark277"> Interlude: haven’t we seen</a> <a href="#bookmark277">the Where method before ? &nbsp;&nbsp;&nbsp;269 &nbsp;&nbsp;&nbsp;</a>■<a href="#bookmark278"> Projections using the Select method</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark278">and anonymous types 269</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark279"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Sorting using the OrderBy</a> <a href="#bookmark279">method 270 </a>■<a href="#bookmark280"> Business examples involving chaining 272</a></font></p>
<p><a name="bookmark281"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark282">10.4 &nbsp;&nbsp;&nbsp;Usage ideas and guidelines 273</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark283">“Extending the world” and making interfaces richer 274</a> <a href="#bookmark284">Fluent interfaces 274 </a>■<a href="#bookmark285"> Using extension methods sensibly 276</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark286">10.5 &nbsp;&nbsp;&nbsp;Summary 277</a></font></p>
<p><a name="bookmark287"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a href="#bookmark15">Query expressions and LINQ to Objects 279</a></font></p>
<p><a name="bookmark288"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark289">11.1 &nbsp;&nbsp;&nbsp;Introducing LINQ 280</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark290">Fundamental concepts in LINQ 280</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark291"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Defining the sample</a> <a href="#bookmark291">data model 285</a></font></p>
<p><a name="bookmark292"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark293">11.2 &nbsp;&nbsp;&nbsp;Simple beginnings: selecting elements 285</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark294">Starting with a source and ending with a selection 286</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark295"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Compiler</a> <a href="#bookmark295">translations as the basis of query expressions 287 </a>■<a href="#bookmark296"> Range</a> <a href="#bookmark296">variables and nontrivial projections 290 </a>■<a href="#bookmark297"> Cast</a>, OfType, and explicitly typed range variables 292</font></p>
<p><a name="bookmark298"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark299">11.3 &nbsp;&nbsp;&nbsp;Filtering and ordering a sequence 294</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark300">Filtering using a </a>where clause 294 ■<a href="#bookmark301"> Degenerate query</a> <a href="#bookmark301">expressions 295 </a>■<a href="#bookmark302"> Ordering using an </a>orderby clause 296</font></p>
<p><a name="bookmark303"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark304">11.4 &nbsp;&nbsp;&nbsp;Let clauses and transparent identifiers 298</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark305">Introducing an intermediate computation with </a>let 298 <a href="#bookmark306">Transparent identifiers 299</a></font></p>
<p><a name="bookmark307"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark308">11.5 &nbsp;&nbsp;&nbsp;Joins 301</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark309">Inner joins using j</a>oin clauses 301 ■<a href="#bookmark310"> Group joins with j</a>oin ... into clauses 305 ■<a href="#bookmark311"> Cross joins and flattening sequences using multiple</a> from clauses 308</font></p>
<p><a name="bookmark312"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark313">11.6 &nbsp;&nbsp;&nbsp;Groupings and continuations 311</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark314">Grouping with the </a>group ... by clause 311 ■<a href="#bookmark315"> Query</a> <a href="#bookmark315">continuations 314</a></font></p>
<p><a name="bookmark316"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark317">11.7 &nbsp;&nbsp;&nbsp;Choosing between query expressions and dot</a></font></p>
<p><a name="bookmark318"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">notation 317</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark319">Operations that require dot notation 317 </a>■<a href="#bookmark320"> Query expressions</a> <a href="#bookmark320">where dot notation may be simpler 318 </a>■<a href="#bookmark321"> Where query</a> <a href="#bookmark321">expressions shine 319</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark322">11.8 &nbsp;&nbsp;&nbsp;Summary 320</a></font></p>
<p><a name="bookmark323"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">LINQ beyond collections 321</font></p>
<p><a name="bookmark324"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark325">12.1 &nbsp;&nbsp;&nbsp;Querying a database with LINQ to SQL 322</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark326">Getting started: the database and model 323 <sup></a>■</sup><a href="#bookmark327"> Initial</a> <a href="#bookmark327">queries 325 </a>■<a href="#bookmark328"> Queries involving joins 327</a></font></p>
<p><a name="bookmark329"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark330">12.2 &nbsp;&nbsp;&nbsp;Translations using IQueryable and IQueryProvider 329</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark331">IntroducingIQueryable&lt;T&gt; and related interfaces &nbsp;&nbsp;&nbsp;330 </a>■<a href="#bookmark332"> Faking</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark332">it: interface implementations to log calls 331 <sup></a>■</sup><a href="#bookmark333"> Gluing expressions</a> <a href="#bookmark333">together: the Queryable extension methods 334 </a>■<a href="#bookmark334"> The fake query</a> <a href="#bookmark334">provider in action 335 </a>■<a href="#bookmark335"> Wrapping up </a>IQueryable 337</font></p>
<p><a name="bookmark336"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark337">12.3 &nbsp;&nbsp;&nbsp;LINQ-friendly APIs and LINQ to XML 337</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark338">Core types in LINQ to XML 338 </a>■<a href="#bookmark339"> Declarative construction 340</a> <a href="#bookmark340">Queries on single nodes 342 <sup></a>■</sup><a href="#bookmark341"> Flattened query operators 344</a> <a href="#bookmark342">Working in harmony with LINQ 345</a></font></p>
<p><a name="bookmark343"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark344">12.4 &nbsp;&nbsp;&nbsp;Replacing LINQ to Objects with Parallel LINQ 346</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark345">Plotting the Mandelbrot set with a single thread &nbsp;&nbsp;&nbsp;346</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark346">Introducing ParallelEnumerable, ParallelQuery, and</a> <a href="#bookmark346">AsParallel 347 </a>■<a href="#bookmark347"> Tweaking parallel queries 349</a></font></p>
<p><a name="bookmark348"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark349">12.5 &nbsp;&nbsp;&nbsp;Inverting the query model with LINQ to Rx 350</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark350">IObservable&lt;T&gt; and IObserver&lt;T&gt; 351 </a>■<a href="#bookmark351"> Starting simply</a> <a href="#bookmark351">(again) 353 </a>■<a href="#bookmark352"> Querying observables 354 </a>■<a href="#bookmark353"> What’s the</a> <a href="#bookmark353">point? 356</a></font></p>
<p><a name="bookmark354"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark355">12.6 &nbsp;&nbsp;&nbsp;Extending LINQ to Objects 357</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark356">Design and implementation guidelines 357 </a>■<a href="#bookmark357"> Sample extension:</a> <a href="#bookmark357">selecting a random element 359</a></font></p>
<p><a name="bookmark358"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">12.7<a href="#bookmark359"> &nbsp;&nbsp;&nbsp;Summary 360</a></font></p>
<p><a name="bookmark360"></a><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;"><a href="#bookmark18">Part</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;">4 C# 4: playing</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">nicely</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">with</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;"> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">others</font><font style="font-size:large;font-family:Arial Narrow, sans-serif;font-weight:bold;">................</font><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;">363</font></a></p>
<p><a name="bookmark361"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Minor &nbsp;&nbsp;&nbsp;changes to simplify code 365</font></p>
<p><a name="bookmark362"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark363">13.1 &nbsp;&nbsp;&nbsp;Optional parameters and named arguments 366</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark364">Optional parameters 366 </a>■<a href="#bookmark365"> Named arguments 372</a> <a href="#bookmark366">Putting the two together 376</a></font></p>
<p><a name="bookmark367"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark368">13.2 &nbsp;&nbsp;&nbsp;Improvements for COM interoperability 380</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark369">The horrors of automating Word before C# 4 &nbsp;&nbsp;&nbsp;380</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;<sup></a>■</sup><a href="#bookmark370"> &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">The &nbsp;&nbsp;&nbsp;revenge</font></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark370">of optional parameters and named arguments 381</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark371"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">When is a</a> <a href="#bookmark371">ref parameter not a ref parameter? 382 </a>■<a href="#bookmark372"> Calling named</a> <a href="#bookmark372">indexers 383</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark373"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Linking primary interop assemblies 385</font></a></p>
<p><a name="bookmark374"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark375">13.3 &nbsp;&nbsp;&nbsp;Generic variance for interfaces and delegates 387</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark376">Types of variance: covariance and contravariance 387 </a>■<a href="#bookmark377"> &nbsp;&nbsp;&nbsp;Using</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark377">variance in interfaces 389 </a>■<a href="#bookmark378"> Using variance in delegates 392</a> <a href="#bookmark379">Complex situations 392 </a>■<a href="#bookmark380"> Restrictions and notes 394</a></font></p>
<p><a name="bookmark381"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark382">13.4 &nbsp;&nbsp;&nbsp;Teeny tiny changes to locking and field-like events 398</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark383">Robust locking 398 </a>■<a href="#bookmark384"> Changes to field-like events &nbsp;&nbsp;&nbsp;399</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark385">13.5 &nbsp;&nbsp;&nbsp;Summary 400</a></font></p>
<p><a name="bookmark386"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a href="#bookmark20">Dynamic binding in a static language 401</a></font></p>
<p><a name="bookmark387"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark388">14.1 &nbsp;&nbsp;&nbsp;What? When? Why? How? 403</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark389">What is dynamic typing? 403 </a>■<a href="#bookmark390"> When is dynamic typing useful,</a> <a href="#bookmark390">and why? 404 </a>■<a href="#bookmark391"> How does C# 4 provide dynamic typing? 405</a></font></p>
<p><a name="bookmark392"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark393">14.2 &nbsp;&nbsp;&nbsp;The five-minute guide to dynamic 406</a></font></p>
<p><a name="bookmark394"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark395">14.3 &nbsp;&nbsp;&nbsp;Examples of dynamic typing 408</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark396">COM in general, and Microsoft Office in particular &nbsp;&nbsp;&nbsp;408</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark397">Dynamic languages such as IronPython 410 </a>■<a href="#bookmark398"> Dynamic typing</a> <a href="#bookmark398">in purely managed code 415</a></font></p>
<p><a name="bookmark399"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark400">14.4 &nbsp;&nbsp;&nbsp;Looking behind the scenes 421</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark401">Introducing the Dynamic Language Runtime 421</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark402"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">DLR core</a> <a href="#bookmark402">concepts 422</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark403"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">How the C# compiler handles dynamic 426</a> <a href="#bookmark404">The C# compiler gets even smarter 430</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark405"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Restrictions on dynamic</a> <a href="#bookmark405">code 432</a></font></p>
<p><a name="bookmark406"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark407">14.5 &nbsp;&nbsp;&nbsp;Implementing dynamic behavior 435</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark408">Using ExpandoObject 435</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <sup></a>■</sup><a href="#bookmark409"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Using DynamicObject 440</a> <a href="#bookmark410">Implementing IDynamicMetaObjectProvider 446</a></font></p>
<p><a name="bookmark411"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">14.6<a href="#bookmark412"> &nbsp;&nbsp;&nbsp;Summary 450</a></font></p>
<p><a name="bookmark413"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a href="#bookmark21">Letting your code speak more clearly with Code Contracts 452</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark414">15.1 &nbsp;&nbsp;&nbsp;Life before Code Contracts 454</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark415">15.2 &nbsp;&nbsp;&nbsp;Introducing Code Contracts 455</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark416">Preconditions 456</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark417"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Postconditions 458</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark418"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Invariants 459</a> <a href="#bookmark419">Assertions and assumptions 461</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark420"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Legacy contracts 462</font></a></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">15.3 &nbsp;&nbsp;&nbsp;<a href="#bookmark421">Rewriting binaries with </a>ccrewrite and ccrefgen 464</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark422">Simple rewriting 464</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark423"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Contract inheritance 466</a> <a href="#bookmark424">Contract reference assemblies 469</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark425"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Failure behavior 470</font></a></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark426">15.4 &nbsp;&nbsp;&nbsp;Static checking 472</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark427">Getting started with static checking 473</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark428"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Implicit</a> <a href="#bookmark428">obligations 475</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark429"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Selective checking 478</font></a></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">15.5 &nbsp;&nbsp;&nbsp;<a href="#bookmark430">Documenting contracts with </a>ccdocgen 480</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark431">15.6 &nbsp;&nbsp;&nbsp;Practical contracts 482</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark432">Philosophy: what’s in a contract? 483</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>■<a href="#bookmark433"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">How do I get</a> <a href="#bookmark433">started ? &nbsp;&nbsp;&nbsp;484</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;</a>■<a href="#bookmark434"> &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Options, &nbsp;&nbsp;&nbsp;options &nbsp;&nbsp;&nbsp;everywhere &nbsp;&nbsp;&nbsp;485</font></a></p>
<p><a name="bookmark435"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark436">15.7 &nbsp;&nbsp;&nbsp;Summary 488</a> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Whither now? 490</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark437">16.1 &nbsp;&nbsp;&nbsp;C#—mixing tradition and modernity 490</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark438">16.2 &nbsp;&nbsp;&nbsp;Computer science and .NET 491</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark439">16.3 &nbsp;&nbsp;&nbsp;The world of computing 492</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><a href="#bookmark440">16.4 &nbsp;&nbsp;&nbsp;Farewell 493</a></font></p>
<p><font style="font-size:small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark441">appendix A &nbsp;&nbsp;&nbsp;LINQ standard query operators 495</a></font></p>
<p><font style="font-size:small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark442">appendix B &nbsp;&nbsp;&nbsp;Generic collections in .NET 508</a></font></p>
<p><font style="font-size:small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark443">appendix C &nbsp;&nbsp;&nbsp;Version summaries 521</a></font></p>
<p><font style="font-size:small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark444">index 529</a></font></p>
<p><a name="bookmark445"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">foreword</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two kinds of pianists.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are some pianists who play, not because they enjoy it, but because their parents force them to take lessons. Then there are those who play the piano because it pleases them to create music. They don’t need to be forced; on the contrary, they sometimes don’t know when to stop.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of the latter kind, there are some who play the piano as a hobby. Then there are those who play for a living. That requires a whole new level of dedication, skill, and talent. They may have some degree of freedom about what genre of music they play and the stylistic choices they make when playing it, but fundamentally those choices are driven by the needs of the employer or the tastes of the audience.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of the latter kind, there are some who do it primarily for the money. Then there are those professionals who would want to play the piano in public even if they weren’t being paid. They enjoy using their skills and talents to make music for others. That they can have fun and get paid for it is so much the better.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of the latter kind, there are some who are self-taught, who play by ear, who might have great talent and ability but can’t communicate that intuitive understanding to others except through the music itself. Then there are those who have formal training in both theory and practice. They can explain what techniques the composer used to achieve the intended emotional effect, and use that knowledge to shape their interpretation of the piece.</font></p>
<p><a name="bookmark24"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Of the latter kind, there are some who have never looked inside their pianos. Then there are those who are fascinated by the clever escapements that lift the damper felts a fraction of a second before the hammers strike the strings. They own key levelers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">and capstan wrenches. They take delight and pride in being able to understand the mechanisms of an instrument that has 5-10,000 moving parts.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of the latter kind, there are some who are content to master their craft and exercise their talents for the pleasure and profit it brings. Then there are those who are not just artists, theorists, and technicians; somehow they find the time to pass that knowledge on to others as mentors.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I have no idea if Jon Skeet is any kind of pianist. But from my email conversations with him as one of the C# team’s Most Valuable Professionals over the years, from reading his blog, and from reading every word of this book at least three times, it has become clear to me that Jon is that latter kind of software developer: enthusiastic, knowledgeable, talented, curious and analytical—a teacher of others.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# is a highly pragmatic and rapidly evolving language. Through the addition of query comprehensions, richer type inference, a compact syntax for anonymous functions, and so on, I hope that we have enabled a whole new style of programming while still staying true to the statically typed, component-oriented approach that has made C# a success.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Many of these new stylistic elements have the paradoxical quality of feeling very <a href="http://www.manning.com/C%23inDepthSecondEdition">old (lambda expressions go back to the foundations of computer science in the first</a> half of the twentieth century) and yet at the same time feeling new and unfamiliar to developers used to a more modern object-oriented approach.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Jon gets all that. This book is ideal for professional developers who have a need to understand the what and how of the latest revision to C#. But it is also for those developers whose understanding is enriched by exploring the why of the language’s design principles.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Being able to take advantage of all that new power will require new ways of think<a href="http://www.manning.com/C%23inDepthSecondEdition">ing about data, functions, and the relationship between them. It’s not unlike trying to</a> play jazz after years of classical training—or vice versa. Either way, I’m looking forward to finding out what sorts of functional compositions the next generation of C# programmers come up with. Happy composing, and thanks for choosing the key of C# to do it in.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">E</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-variant:small-caps;">ric </font><font style="font-size:x-small;font-family:Times New Roman, serif;">L</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-variant:small-caps;">ippert </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Senior Software Engineer, Microsoft</font></p>
<p><a name="bookmark446"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">preface</font></p>
<p><a name="bookmark25"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It feels like a very long time since I wrote the preface to the first edition, but it’s actually only been about two and a half years. In that time, there have been many changes both for myself and in the landscape of technology.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In my personal life, I’m now very proud to be a software engineer at Google—with the one downside that I don’t spend as much time working in C# as I used to. I’ve found a new addiction in the form of Stack Overflow, the developer question-and-answer forum. My youngest sons who were barely two years old when the first edition came out are now about to start school. I’ve had the privilege of giving talks about C# in London, Oslo, Copenhagen, and various other places, with more to come. It’s all been a lot of fun, although occasionally somewhat hectic.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The technological world has been no less shaken up. I’m writing this on a net-book—a word which barely had any meaning when I was writing the first edition. The smartest of smart phones was pretty primitive by today’s standards, and my current laptop would have served as an outrageously overpowered desktop machine. The developments in software have been less mind-blowing in my opinion, although many of the projects which are now becoming mainstream (such as Parallel Extensions) were in their early stages back then. Silverlight had only just made the leap to being a fully managed language, and ASP.NET MVC was still very young, and wouldn’t have its 1.0 release for some time. Of course, C# itself has changed as well—otherwise there’d be little reason to bring out a second edition.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Despite all this change, the focus of this book has stayed the same. I remain committed to helping people form a more intimate connection with C#. As ever more frameworks pop up—and as we have to learn them ever more quickly—it’s vital to</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">have a firm foundation to build on. We should at least be secure in saying, “this is a generic method call, this is a property access, this is a lambda expression being converted into a delegate,” and so on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I believe the general standard of language knowledge is improving, in fact. I’ve been pleasantly surprised to see how well LINQ seems to be understood by many developers, although to some it’s clearly still a black box of magic. Admittedly these observations are mostly via Stack Overflow, which is obviously a biased, self-selecting subset of all developers—but even so, I think there’s reason for optimism. I hope the first edition of this book has played some small part in that improvement, and that this edition will too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I keep meaning to learn a new language, properly. I’ve dabbled with F# and Python. I’ve promised myself that I’ll learn Erlang and Haskell. I keep meaning to see what all the fuss is about with Ruby... but C# pulls me back, every time. It’s not perfect, but it usually allows me to express myself clearly and concisely, and those are probably the most important attributes a language can have. One day I’ll manage to stray far enough away to start genuinely thinking in a different language—but until that time, I hope I can convey some of my passion for C# to you in this book.</font></p>
<p><a name="bookmark447"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">acknowledgments</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You might expect that writing the second edition of a book is easier than writing the first: just add another few chapters, make some modifications to the existing ones, and you’re done, right? If that sounds plausible, think about writing code for a new project compared with trying to modify an existing application. Now imagine doing it without a compiler or unit tests. Fortunately, although there are precious few ways of really testing the quality of a book, I have been lucky enough to have a great set of people supporting me and keeping the book on the straight and narrow.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Most importantly, my family have put up with me spending evenings writing, rewriting, editing, indexing, and generally not being with them as much as I’d like. My sons don’t seem to have been put off computing by this though, and my oldest son, Tom, is nearly old enough to start programming. It’ll be wonderful for him to have some idea of what I do all day at work. My children are generally in bed when I’m writing, though, so it’s mostly my wife Holly who has dealt with the worst of this. Despite our many commitments, my family is of utmost importance to me, and I’m immensely grateful that they have supported me in this and many other endeavors.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The formal peer reviewers are listed later on, but I’d like to add a note of personal thanks to all those who ordered early access copies of this second edition, finding typos and suggesting changes... and also constantly asking when the book was coming out. The very fact that I had readers who were eager to get their hands on the finished book was a huge source of encouragement.</font></p>
<p><a name="bookmark26"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I always get on well with the team at Manning, and it’s been a pleasure to work with some familiar friends from the first edition as well as newcomers. Mike Stephens and Jeff Bleiel have guided the whole process smoothly, as we decided what to change from the first edition and what to keep. They’ve generally put the whole thing into the right shape. Benjamin Berg and Katie Tennant provided expert copyediting and proofreading, respectively, never once expressing irritation with my Englishness, pickiness, or general bewilderment. The production team has worked its magic in the background, as ever, but I’m grateful to them nonetheless: Dottie Marsico, Janet Vail, Marija Tudor, and Mary Piergies. Finally, I’d like to thank the publisher, Marjan Bace, for allowing me a second edition and exploring some interesting future options.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Peer review is immensely important, not only for getting the technical details of the book right, but also the balance and tone. Sometimes the comments we received have merely shaped the overall book; in other cases I’ve made very specific changes in response. Either way, all feedback has been welcome. So thanks to the following reviewers for making the book better for all of us: Michael Caro, Austin Ziegler, Dave Corun, Amos Bannister, Lester Lobo, Marc Gravel, Nikander Bruggeman, Margriet Bruggeman, Joe Albahari, Tyson S. Maxwell, Horaci Macias, Eric Lippert, Kirill Osen-kov, Stuart Caborn, Sean Reilly, Aleksy Nudelman, Keith Hill, Josh Heyer, and Jared Parsons.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In the first edition of the book I thanked the C# team, but this time I have wider thanks to give to Softies. I’m always amazed at how generous the various software engineers and project managers have been when I’ve pestered them with specific questions or sections to review. Some of these folks may not even have realized they were helping with the book, but they certainly were: Todd Apley, Mike Barnett, Chris Burrows, Wes Dyer, Manuel Fahndrich, Neal Gafter, Eric Lippert, Francesco Logozzo, Erik Meijer, Sam Ng, Kirill Osenkov, Alexandra Rusina, Chris Sells, Mads Torgersen, Stephen Toub, and Jeffrey Van Gogh.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Out of that list, I’d like to call Eric Lippert out for special attention, as the tech reviewer for the book once again and for writing the foreword. Since the first edition I’ve had many more conversations with Eric, and finally met up with him a couple of times, both of which have been delightful. I’m still utterly in awe of both his knowledge and the meticulous but readable way in which he shares it with the world both in his blog and on Stack Overflow. I couldn’t have asked for a better reviewer, and I look forward to bugging Eric more in the future about anything and everything related to C#.</font></p>
<p><a name="bookmark448"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">about this book</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is a book about C# from version 2 onwards—it’s as simple as that. I barely cover C# 1, and only cover the .NET Framework libraries and Common Language Runtime (CLR) when they’re related to the language. This is a deliberate decision, and the result is quite a different book from most of the C# and .NET books I’ve seen.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">By assuming a reasonable amount of knowledge of C# 1, I avoid spending hundreds of pages covering material that I think most people already understand. This gives me much more room to expand on the details of C# 2, 3, and 4, which is what I hope you’re reading the book for.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I believe that many developers would be less frustrated with their work if they had a deeper connection with the language they’re writing in. I know it sounds geeky in the extreme to talk about having a “relationship” with a programming language, but that’s the best way I can describe it. This book is my attempt to help you achieve that sort of understanding, or deepen it further. It won’t be enough on its own—it should be a companion to your coding, guiding you and suggesting some interesting avenues to explore, as well as explaining why your code behaves the way it does.</font></p>
<p><a name="bookmark449"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Who should read this book?</font></p>
<p><a name="bookmark27"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve been very pleasantly surprised at the community reaction to the first edition of this book. I’ve seen it recommended in various places, especially on Stack Overflow (where I admit my presence might encourage a little bias). It’s usually recommended for those who wish to really know what’s going on in their code... but occasionally it’s suggested as a learning tool for beginners too. On its own, I think that’s a little bit unfortunate. You could probably struggle through, looking up C# 1 concepts as and when you needed to—but you’d be much better off reading this book in conjunction with another which starts from scratch.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Without wishing to dissuade you from buying this book if you haven’t already, there are plenty of other good C# books on the market—and they actually work well as companions to this one. I’ve seen numerous reports of readers who have started off with a book which makes fewer assumptions, and then gradually added </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">C# in Depth</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to the mix. I’m happy to recommend </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">C# 4.0 in a Nutshell</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (O’Reilly, 2010) as one possible choice here: it not only covers C# from scratch, but also digs into the core of the .NET Framework.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m not going to claim that reading this book will make you a fabulous coder. There’s so much more to software engineering than knowing the syntax of the language you happen to be using. I give some words of guidance (rather more in this second edition than in the first), but ultimately there’s a lot more gut instinct in development than most of us would like to admit. What I will claim is that if you read and understand this book, you should feel comfortable with C#, and free to follow your instincts without too much apprehension. It’s not about being able to write code that no one else will understand because it uses unknown corners of the language: it’s about being confident that you know the options available to you, and know which path the C# idioms are encouraging you to follow.</font></p>
<p><a name="bookmark450"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Roadmap</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The book’s structure is simple. There are four parts and three appendixes. The first part serves as an introduction, including a refresher on topics in C# 1 that are important for understanding C# 2 and 3, and that are often misunderstood. The second part covers the new features in C# 2. The third part covers the new features in C# 3. I’ll leave it as an exercise to the reader to guess what the fourth part contains.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are occasions where organizing the material this way means we come back to a topic a couple of times—in particular delegates are improved in C# 2 and then again in C# 3—but there’s method in my madness. I anticipate that a number of readers will be using different versions for different projects: for example, you may be using C# 3 at work, but experimenting with C# 4 at home. That means that it’s useful to clarify what is in which version. It also provides a feeling of context and evolution— it shows how the language has developed over time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 1 sets the scene by taking a simple piece of C# 1 code and evolving it, seeing how later versions allow the source to become more readable and powerful. We look at the historical context in which C# has grown, and the technical context in which it operates as part of a complete platform: C# as a language builds on framework libraries and a powerful runtime to turn abstraction into reality.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 2 looks back at C# 1, and three specific aspects: delegates, the type system characteristics, and the differences between value types and reference types. These topics are often understood “just well enough” by C# 1 developers, but as C# has evolved and developed them significantly, a solid grounding is required in order to make the most of the new features.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 3 tackles the biggest feature of C# 2, and potentially the hardest to grasp: generics. Methods and types can be written generically, with type parameters standing in for real types which are specified in the calling code. Initially it’s as confusing as this description makes it sound, but once you understand generics you’ll wonder how you survived without them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’ve ever wanted to represent a null integer, chapter 4 is for you. It introduces nullable types, a feature built on generics and taking advantage of support in the language, runtime, and framework.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 5 shows the improvements to delegates in C# 2. You may have only used delegates for handling events such as button clicks before now. C# 2 makes it easier to create delegates, and library support makes them more useful for situations other than events.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In chapter 6 we examine iterators, and the easy way to implement them in C# 2. Few developers use iterator blocks, but as LINQ to Objects is built on iterators, they’ll become more and more important. The lazy nature of their execution is also a key part of LINQ.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 7 shows a number of smaller features introduced in C# 2, each making life a little more pleasant. The language designers have smoothed over a few rough places in C# 1, allowing more flexible interaction with code generators, better support for utility classes, more granular access to properties, and more.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 8 once again looks at a few relatively simple features—but this time in C# 3. Almost all the new syntax is geared toward the common goal of LINQ but the building blocks are also useful in their own right. With anonymous types, automatically implemented properties, implicitly typed local variables, and greatly enhanced initialization support, C# 3 gives a far richer language with which your code can express its behavior.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 9 looks at the first major topic of C# 3—lambda expressions. Not content with the reasonably concise syntax we saw in chapter 5, the language designers have made delegates even easier to create than in C# 2. Lambdas are capable of more—they can be converted into expression trees: a powerful way of representing code as data.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In chapter 10 we examine extension methods, which provide a way of fooling the compiler into believing that methods declared in one type actually belong to another. At first glance this appears to be a readability nightmare, but with careful consideration it can be an extremely powerful feature—and one which is vital to LINQ.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 11 combines the previous three chapters in the form of query expressions, a concise but powerful way of querying data. Initially we concentrate on LINQ to Objects, but see how the query expression pattern is applied in a way which allows other data providers to plug in seamlessly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 12 is a quick tour of various different uses of LINQ. First we see the benefits of query expressions combined with expression trees: showing how LINQ to SQL is able to convert what appears to be normal C# into SQL statements. We then move on to see how libraries can be designed to mesh well with LINQ, taking LINQ to XML as an example. Parallel LINQ and Reactive Extensions show two alternative approaches to in-process querying, and we close the chapter with a discussion of how you can extend LINQ to Objects with your own LINQ operators.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our coverage of C# 4 begins in chapter 13, where we look at named arguments and optional parameters, COM interop improvements, and generic variance. In some ways these are very separate features, but named arguments and optional parameters contribute to COM interop as well as the more specific abilities which are only available when working with COM objects.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 14 describes the single biggest feature in C# 4: dynamic typing. The ability to bind members dynamically at execution time instead of statically at compile time is a huge departure for C#, but it is applied selectively: only code which involves a dynamic value will be executed dynamically.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 15 is about one potential future of C# code, rather than a new feature of the language itself. We look at Code Contracts, a new set of libraries and tools from Microsoft which allow you to express much more detail about what your methods need and what they’re willing to guarantee than the type system itself can. It’s early days, but it’s possible that in a few years, you wouldn’t dream of writing new code without specifying its contracts.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We wind down in chapter 16 by thinking about where we’ve come from, the current state of the industry, and what the future might hold.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The appendixes are all reference material really. In appendix A, I cover the LINQ standard query operators, with some examples. Appendix B looks at the core generic collection classes and interfaces, including the new concurrent collections in .NET 4. Appendix C provides a brief look at the different versions of .NET, including the different flavors such as the Compact Framework and Silverlight.</font></p>
<p><a name="bookmark451"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Terminology and typography</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Most of the terminology of the book is explained as it goes along, but there are a few definitions that are worth highlighting here. I use C# 1, C# 2, C# 3, and C# 4 in a reasonably obvious manner—but you may see other books and websites referring to C# 1.0, C# 2.0, C# 3.0, and C# 4.0. The extra “.0” seems redundant to me, which is why I’ve omitted it—I hope the meaning is clear.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve appropriated a pair of terms from a C# book by Mark Michaelis. To avoid the confusion between runtime being an execution environment (as in “the Common Language Runtime”) and a point in time (as in “overriding occurs at runtime”), Mark uses execution time for the latter concept, usually in comparison with compile time. This seems to me to be a thoroughly sensible idea, and one that I hope catches on in the wider community. I’m doing my bit by following his example in this book.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I frequently refer to the language specification or just the specification—unless I indicate otherwise, this means the C# language specification. However, multiple versions of the specification are available, partly due to different versions of the language itself and partly due to the standardization process. Any section numbers provided are from the C# 4.0 language specification from Microsoft.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This book contains numerous pieces of code, which appear in a fixed-width font like this; output from the listings appears in the same way. Code annotations accompany some listings, and at other times particular sections of the code are highlighted in bold. Almost all of the code appears in snippet form, allowing it to stay compact but still runnable—within the right environment. That environment is Snippy, a custom tool that’s introduced in section 1.7. Snippy is available for download, along with all of the code from the book (in the form of snippets, full Visual Studio solutions, or more often both) from the book’s website at csharpindepth.com.</font></p>
<p><a name="bookmark452"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Source code downloads</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The source code for all of the examples from the book is available from the publisher’s website at <a href="http://www.manning.com/CSharpinDepthSecondEdition">www.manning.com/CSharpinDepthSecondEdition</a> and from csharpindepth.com.</font></p>
<p><a name="bookmark453"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Author Online and</font><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;"> the C# in Depth </font><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">website</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Purchase of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">C# in Depth, Second Edition</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> includes free access to a private web forum run by Manning Publications where you can make comments about the book, ask technical questions, and receive help from the author and other users. To access the forum and subscribe to it, point your web browser to <a href="http://www.manning.com/CSharpinDepthSecondEdition">www.manning.com/CSharpinDepth</a> <a href="http://www.manning.com/CSharpinDepthSecondEdition">SecondEdition</a>. This page provides information on how to get on the forum once you are registered, what kind of help is available, and the rules of conduct on the forum.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Author Online forum and the archives of previous discussions will be accessible from the publisher’s website as long as the book is in print.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In addition to Manning’s own website, I have set up a companion website for the book at csharpindepth.com, containing information that didn’t quite fit into the book, downloadable source code for all the listings in the book, and links to other resources.</font></p>
<p><a name="bookmark454"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">About the author</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m not a typical C# developer, I think it’s fair to say. For the last two years, almost all of my time working with C# has been for fun—effectively as a somewhat obsessive hobby. At work, I’ve been writing server-side Java in the Mobile team in Google Lon-don—and I can safely claim that few things help you to appreciate new language features than having to code in a language which doesn’t have them, but is similar enough to remind you of their absence.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve tried to keep in touch with what other developers find hard about C# by keeping a careful eye on Stack Overflow, posting oddities to my blog, and occasionally talking about C# and related topics just about anywhere that will provide people to listen to me. In short, C# is still coursing through my veins as strongly as ever.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For all these oddities—and despite my ever-surprising micro-celebrity status due to Stack Overflow—I’m a very ordinary developer in many other ways. I write plenty of code which makes me grimace when I come back to it. My unit tests don’t always come first...and sometimes they don’t even exist. I make off-by-one errors every so often. The type inference section of the C# specification still confuses me, and there are some uses of Java wildcards which make me want to have a little lie down. I’m a deeply flawed programmer.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s the way it should be. For the next few hundred pages, I’ll try to pretend otherwise: I’ll espouse best practices as if I always followed them myself, and frown on dirty shortcuts as if I’d never dream of taking them. Don’t believe a word of it. The truth of the matter is, I’m probably just like you. I happen to know a bit more about how C# works, that’s all...and even that state of affairs will only last until you’ve finished the book.</font></p>
<p><a name="bookmark455"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">About the cover illustration</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The caption on the illustration on the cover of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">C# in Depth, Second Edition</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is a &quot;Musician.” The illustration is taken from a collection of costumes of the Ottoman Empire published on January 1, 1802, by William Miller of Old Bond Street, London. The title page is missing from the collection and we have been unable to track it down to date. The book’s table of contents identifies the figures in both English and French, and each illustration bears the names of two artists who worked on it, both of whom would no doubt be surprised to find their art gracing the front cover of a computer programming book...two hundred years later.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The collection was purchased by a Manning editor at an antiquarian flea market in the “Garage” on West 26th Street in Manhattan. The seller was an American based in Ankara, Turkey, and the transaction took place just as he was packing up his stand for the day. The Manning editor didn’t have on his person the substantial amount of cash that was required for the purchase and a credit card and check were both politely turned down. With the seller flying back to Ankara that evening the situation was getting hopeless. What was the solution? It turned out to be nothing more than an old-fashioned verbal agreement sealed with a handshake. The seller simply proposed that the money be transferred to him by wire and the editor walked out with the bank information on a piece of paper and the portfolio of images under his arm. Needless to say, we transferred the funds the next day, and we remain grateful and impressed by this unknown person’s trust in one of us. It recalls something that might have happened a long time ago.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We at Manning celebrate the inventiveness, the initiative, and, yes, the fun of the computer business with book covers based on the rich diversity of regional life of two centuries ago, brought back to life by the pictures from this collection.</font></p>
<p><a name="bookmark456"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark457"></a>Part 1</font></p>
<p><a name="bookmark458"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Preparing for the journey</font></p>
<p><a name="bookmark28"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><sub>E</sub></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">very reader will come to this book with a different set of expectations and a different level of experience. Are you an expert looking to fill some holes, however small, in your present knowledge? Perhaps you consider yourself an average developer, with a bit of experience in using generics and lambda expressions, but a desire to know how they work better. Maybe you’re reasonably confident with C# 2 and 3 but have no C# 4 experience.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As an author, I can’t make every reader the same—and I wouldn’t want to even if I could. But I hope that all readers have two things in common: the desire for a deeper relationship with C# as a language, and at least a basic knowledge of C# 1. If you can bring those elements to the party, I’ll provide the rest.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The potentially huge range of skill levels is the main reason why this part of the book exists. You may already know what to expect from later versions of C#— or it could all be brand new to you. You could have a rock-solid understanding of C# 1, or you might be rusty on some of the details—some of which will become increasingly important as you learn C# 2, 3, and 4. By the end of part 1, I won’t have leveled the playing field entirely, but you should be able to approach the rest of the book with confidence and an idea of what’s coming later.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For the first two chapters, we’ll be looking both forward and back. One of the key themes of the book is evolution. Before introducing any feature into the lan-</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">guage, the C# design team carefully considers that feature in the context of what’s already present and the general aims of the future. This brings a feeling of consistency to the language even in the midst of change. To understand how and why the language is evolving, we need to see where we’ve come from and where we’re going.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 1 presents a bird’s-eye view of the rest of the book, taking a brief look at some of the biggest features of C# 2, 3, and 4. I’ll show a progression of code from C# 1 onward, applying new features one by one until the code is almost unrecognizable from its humble beginnings. We’ll also look at some of the terminology I’ll be using in the rest of the book, as well as the format for the sample code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 2 is heavily focused on C# 1. If you’re an expert in C# 1, you can skip this chapter, but it does tackle some of the areas of C# 1 that tend to be misunderstood. Rather than try to explain the whole of the language, the chapter concentrates on features that are fundamental to the later versions of C#. From this solid base, we can move on and look at C# 2 in part 2 of the book.</font></p>
<p><a name="bookmark2"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark459"></a>The changing face ofC# development</font></p>
<p><a name="bookmark460"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">■</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> &nbsp;&nbsp;&nbsp;An evolving example</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;The composition of .NET</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Using the code in this book</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;The C# language specification</font></p>
<p><a name="bookmark461"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark462"></a><a name="bookmark463"></a>Do yo<a name="bookmark464"></a>u know what I really li<a name="bookmark465"></a>ke about dynamic languages such as Python, Ruby, and Groovy? They suck away fluff from your code, leaving just the essence of it—the bits that really </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> something. Tedious formality gives way to features such as generators, lambda expressions, and list comprehensions.</font></p>
<p><a name="bookmark466"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The interesting thing is that few of the features that tend to give<a name="bookmark467"></a> dynamic languages their lightwe<a name="bookmark468"></a>ight feel have anything to do with being dyna<a name="bookmark469"></a>mic. Some do, of course—duck typing, and some of the magic used in Active Record, for example— but statically typed languages don't </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be clumsy and heavyweight.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Enter C#. In some ways, C# 1 could be seen as a nicer version of the Java language circa 2001. The similarities were all too clear, but C# had a few extras: properties as a first-class feature in the language, delegates and events, foreach loops,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">using statements, explicit method overriding, operator overloading, and custom value types, to name a few. Obviously language preference is a personal issue, but C# 1 definitely felt like a step up from Java when I first started using it.</font></p>
<p><a name="bookmark470"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Since then, things have only gotten better. Each new version of C# has added significant features to reduce developer angst, but always in a carefully considered way, and with little backward incompatibility. Even before C# 4 gained the ability to use dynamic typing where it’<a name="bookmark471"></a>s genuinely useful, many features traditionally associated with dynamic (and functional) languages had made it into C#, leading to code that’s easier to write and maintain.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this book, I’ll take you through those changes one by one, in enough detail to make you feel comfortable with some of the miracles the C# compiler is now prepared to perform on your behalf. All that comes later, though—in this chapter I’m going to whizz through as many features as I can, barely taking a breath. I’ll define what I mean when I talk about C# as a language compared with .NET as a platform, and give a few important caveats about what you should take from the rest of the book. Then we can dive into the details.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We won’t be looking at </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the changes to C# in this single chapter—but we’re going to see generics, properties with different access modifiers, nullable types, anonymous methods, automatically implemented properties, enhanced collection initializers, enhanced object initializers, lambda expressions, extension methods, implicit typing, LINQ query expressions, named arguments, optional parameters, simpler COM interop, and dynamic typing. These will carry us from C# 1 all the way up to the latest release, C# 4. Obviously that’s a lot to get through, so let’s get started.</font></p>
<p><a name="bookmark31"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark472"></a>1.1 &nbsp;&nbsp;&nbsp;Starting with a simple data type</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For this chapter, I’m going to let the C# compiler do amazing things without telling you how, and barely mentioning the what or the why. This is the only time that I won’t explain how things work, or try to go one step at a time. Quite the opposite, in fact— the plan is to impress rather than educate. If you read this entire section without getting at least a little excited about what C# can do, maybe this book isn’t for you. With any luck, though, you’ll be eager to get to the details of how these magic tricks work— to slow down the sleight of hand until it’s obvious what’s going on—and that’s what the rest of the book is for.</font></p>
<p><a name="bookmark473"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The example I’m using is contrived—it’s designed to pack as many new features into as short a piece of code as possible. It’s also cliched—but at least that makes it familiar. Yes,<a name="bookmark474"></a> it’s a product/name/price example, the e-commerce virtual child of “hello, world.” We’ll look at how various tasks can be achieved, and how as we move forward in versions of C#, we can accomplish them more simply and elegantly than before.</font></p>
<p><a name="bookmark32"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark475"></a>1.1.1 &nbsp;&nbsp;&nbsp;The Product type in C# 1</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll start off with a type representing a product, and then manipul<a name="bookmark476"></a>ate it. We’re not looking for anything particularly impressive yet—just encapsulation of a couple of</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">properties. To make life simpler for demonstration purposes, this is also where we create a list of predefined products. Listing 1.1 shows the type as it might be written in C# 1. We’ll then move on to see how the code might be rewritten for each later version. This is the pattern we’ll follow for each of the other pieces of code. Given that I’m writing this in 2010, it’s likely that you’re already familiar with code that uses some of the features I’m going to introduce—but it’s worth looking back so we can see how far the language has come.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.1 The Product type (C# 1)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System.Collections; public class Product {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public string Name { get { return name; } } decimal price;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public decimal Price { get { return price; } } public Product(string name, decimal price)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">this.name = name; this.price = price;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static ArrayList GetSampleProducts()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ArrayList list = new ArrayList(); list.Add(new Product(&quot;West Side Story&quot;, 9.99m)); list.Add(new Product(&quot;Assassins&quot;, 14.99m)); list.Add(new Product(&quot;Frogs&quot;, 13.99m)); list.Add(new Product(&quot;Sweeney Todd&quot;, 10.99m)); return list;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override string ToString()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return string.Format(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;name, &nbsp;&nbsp;&nbsp;price);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark477"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark478"></a>Nothing in listing 1.1 should be hard to understand—it’s just C# 1 code, after all. There are three limitations that it demonstrates, though:</font></p>
<p><a name="bookmark479"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;An ArrayList has no compile-time information about what’s in it. We could’ve accidentally added a string to the list created in GetSampleProducts and the compiler wouldn’t have batted an eyelid.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;We’ve provided public “getter” properties, which means that if we wanted matching “setters,” t<a name="bookmark480"></a>hey’d have to be public, too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;There’s a lot of fluff involved in creating the properties and variables—code that complicates the simple task of encapsulating a string and a decimal.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s see what C# 2 can do to improve matters.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our first set of changes (shown in listing 1.2) tackles the first two items listed previously, including the most important change in C# 2: generics. The parts that are new are listed in bold.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.2 Strongly typed collections and private setters (C# 2)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class Product {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string name; public string Name</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get { return name; } private set { name = value; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">decimal price; public decimal Price</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get { return price; } private set { price = value; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Product(string name, decimal price)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Name = name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Price = price;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">List&lt;Product&gt;</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> GetSampleProducts()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; list = new List&lt;Product&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">list.Add(new Product(&quot;West Side Story&quot;, 9.99m)); list.Add(new Product(&quot;Assassins&quot;, 14.99m)); list.Add(new Product(&quot;Frogs&quot;, 13.99m)); list.Add(new Product(&quot;Sweeney Todd&quot;, 10.99m)); return list;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override string ToString()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return string.Format(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;name, &nbsp;&nbsp;&nbsp;price);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark481"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We now have properties with priva<a name="bookmark482"></a>te setters (which we use in the constructor), and it doesn’t take a genius to guess that List&lt;Product&gt; is telling the compiler that the list contains products. Attempting to add a different type to the list would result in a compiler error, and also we won’t need to cast the results when we fetch them from the list. The changes in C# 2 leave only one of the original three difficulties unanswered— and C# 3 helps out there.</font></p>
<p><a name="bookmark34"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark483"></a>1.1.3 Automatically implemented properties in C# 3</font></p>
<p><a name="bookmark484"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark485"></a>We’re starting off with some fairly tame f<a name="bookmark486"></a>eatures from C# 3. The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">automatically implemented properties</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and simplified initialization shown in the following listing are relatively trivial compared with lambda expressions and the like, but they can make code a lot simpler.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.3 Automatically implemented properties and simpler initialization (C# 3)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System.Collections.Generic; class Product {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public string Name { get; private set; } public decimal Price { get; private set; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Product(string name, decimal price)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Name = name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Price = price;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Product() {}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static List&lt;Product&gt; GetSampleProducts()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new List&lt;Product&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Product { Name=&quot;West Side Story&quot;, Price = 9.99m }, new Product { Name=&quot;Assassins&quot;, Price=14.99m }, new Product { Name=&quot;Frogs&quot;, Price=13.99m }, new Product { Name=&quot;Sweeney Todd&quot;, Price=10.99m}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override string ToString()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return string.Format(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;Name, Price);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark487"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark488"></a><a name="bookmark489"></a>The properties now don’t have any code (or visible variables!) associated with them, and we’re building the hard-coded list in a very different way. With no name and price variables to access, we’re forced to use the properties everywhere in the class, improving consistency. We now have a private parameterless constructor for the sake of the new property-based initialization. In this example, we could’ve actually removed the public constructor completely, but then no outside code could’ve created other product instances.</font></p>
<p><a name="bookmark35"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark490"></a>1.1.4 Named arguments in C# 4</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For C# 4, we’ll go back to the original code whe<a name="bookmark491"></a>n it comes<a name="bookmark492"></a> to the properties and constructor. One reason for this might be to make it immutable: although a type with only private setters can’t be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">publicly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> mutated, it can be clearer if it’s not privately mutable either.<sup><a name="footnote1"></a><a href="#bookmark493">1</a></sup> There’s no shortcut for read-only prop<a name="bookmark494"></a>erties, unfortunately... but C# 4 lets us specify argument names for the constructor call, as shown in listing 1.4, which gives us the clarity of C# 3 initializers without the mutability.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.4 Named arguments for clear initialization code (C# 4)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System.Collections.Generic; public class Product {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">readonly string name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public string Name { get { return name; } } readonly decimal price;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public decimal Price { get { return price; } } public Product(string name, decimal price)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">this.name = name; this.price = price;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static List&lt;Product&gt; GetSampleProducts()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new List&lt;Product&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Product(name: &quot;West Side Story&quot;, price: 9.99m), new Product(name: &quot;Assassins&quot;, price: 14.99m), new Product(name: &quot;Frogs&quot;, price: 13.99m), new Product(name: &quot;Sweeney Todd&quot;, price: 10.99m)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override string ToString()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return string.Format(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;name, &nbsp;&nbsp;&nbsp;price);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The benefits of this are relatively minimal i<a name="bookmark495"></a>n this particular example, but when a method or c<a name="bookmark496"></a>onstructor has several parameters, it can make the meaning of the code much clearer—<a name="bookmark497"></a>particularly if they’re of the same type, or if you’re passing in null for some arguments. You can choose when to use this feature, of course, only specifying the names for arguments when it makes the code easier to understa<a name="bookmark498"></a>nd.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 1.1 shows a summary of how our Product type has evolved so far. I’ll include a similar diagram after each task, so you can see the pattern of how the evolution of C# improves the code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far, the changes are relatively minimal. In fact, the addition of generics (the List&lt;Product&gt; syntax) is probably the most important part of C# 2, but we’ve only seen part of its usefulness so far. There’s nothing to get the heart racing yet, but we’ve only just started. Our next task is to print out the list of products in alphabetical order.</font></p><img src="images/2.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 1.1 Evolution of the </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Product </font><font style="font-size:x-small;font-family:Times New Roman, serif;">type, showing greater encapsulation, stronger</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">typing, and ease of</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">initialization over time</font></p>
<p><a name="bookmark37"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark499"></a><a name="bookmark500"></a><a name="bookmark501"></a>1.2 Sorting and filtering</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this section, we’re not going to change the Product type at all—instead, we’re going to take the sample products and sort them by name, and then find just the expensive ones. Neither of these tasks is exactly </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">difficult,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> but we’ll see how much simpler they become over time.</font></p>
<p><a name="bookmark38"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark502"></a>1.2.1 Sorting products by name</font></p>
<p><a name="bookmark503"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The easiest way to display a list in a particular order is to sort the list and then run through it, displaying items. In .NET 1.1, this involved using ArrayList.Sort, and in our case providing an IComparer implementation. We could’ve made the Product type implement IComparable, but we could only define one sort order that way, and it’s not a stretch to imagine that we might want to sort by price at some stage as well as by name. The following listing implements IComparer, then sorts the list and displays it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.5 Sorting an ArrayList using IComparer (C# 1)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class ProductNameComparer : IComparer {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int Compare(object x, object y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Product first = (Product)x;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Product second = (Product)y;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return first.Name.CompareTo(second.Name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ArrayList products = Product.GetSampleProducts(); products.Sort(new ProductNameComparer()); foreach (Product product in products)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (product);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first thing to spot in listing 1.5 is that we’ve had to introduce an extra type to help us with the sorting. That’s not a disaster, but it’s a lot of code if we only want to sort by name in one place. Next, we see the casts in the Compare method. Casts are a way of telling the compiler that we know more information than it does—and that usually means there’s a chance we’re wrong. If the ArrayList we returned from Get-SampleProducts </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">did</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> contain a string, that’s where the code would go bang—where the comparison tries to cast the string to a Product.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We also have a cast in the code that displays the sorted list. It’s not obvious, because the compiler puts it in automatically, but the foreach loop implicitly casts each element of the list to Product. Again, that cast could fail at execution time, and once more generics come to the rescue in C# 2. Listing 1.6 shows the earlier code with the use of generics as the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> change.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.6 Sorting a List&lt;Product&gt; using IComparer&lt;Product&gt; (C# 2)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class ProductNameComparer : IComparer&lt;Product&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int Compare(Product x, Product y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return x.Name.CompareTo(y.Name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; products = Product.GetSampleProducts();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">products.Sort(new ProductNameComparer()); foreach (Product product in products)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(product);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The code for the comparer in listing 1.6 is simpler because we’re given products to start with. No casting is necessary. Similarly, the invisible cast in the foreach loop is effectively gone now. The compiler still has to consider the conversion from the source type of the sequence to the target type of the variable, but it knows that in this case both types are Product, so it doesn’t need to emit any code for the conversion.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s an improvement, but it’d be nice if we could sort the products by simply specifying the comparison to make, without needing to implement an i<a name="bookmark504"></a>nterface to do so. The following listing shows how to do<a name="bookmark505"></a> precisely this, telling the Sort method how to compare two products using a delegate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.7 Sorting a List&lt;Product&gt; using Comparison&lt;Product&gt; (C# 2)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; products = Product.GetSampleProducts(); products.Sort(delegate(Product x, Product y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ return x.Name.CompareTo(y.Name); }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (Product product in products)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(product);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Behold the lack of the ProductNameComparer type. The statement in bold actually creates a delegate instance, which we provide to the Sort method in order to per<a name="bookmark506"></a>form the comparisons. We’ll learn more about this feature </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">(anonymous methods</font><font style="font-size:x-small;font-family:Times New Roman, serif;">) in chapter 5. We’ve now fixed all the things we didn’t like about the C# 1 version. That doesn’t mean that C# 3 can’t do better, though. First we’ll replace the anonymous method with an even more compact way of creating a delegate instance, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.8 Sorting using Comparison&lt;Product&gt; from a lambda expression (C# 3)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; products = Product.GetSampleProducts(); products.Sort((x, y) =&gt; x.Name.CompareTo(y.Name));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (Product product in products)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(product);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark507"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve gained even more strange syntax (a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lambda expression),</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which still creates a Comparison&lt;Product&gt; delegate<a name="bookmark508"></a> just as listing 1.7 did, but this time with less fuss. We haven’t had to use the delegate keyword to introduce it, or even specify the types of the parameters. There’s more, though: with C# 3 we can easily print the names out in order without modifying the original list of products. The next listing shows this using the OrderBy method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.9 Ordering a List&lt;Product&gt; using an extension method (C# 3)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; products = Product.GetSampleProducts(); foreach (Product product in products.OrderBy(p =&gt; p.Name))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (product);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We appear to be calling an OrderBy method on the list, but if you look in MSDN, you’ll see that it doesn’t even exist in List&lt;Product&gt;. We’re able to call it due to the presence of an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extension method,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which we’ll see in more detail in chapter 10. We’re not actually sorting the list “in place” anymore, just retrieving the contents of the list in a particular order. Sometimes you’ll need to change the actual list; sometimes an ordering without any other side effects is better. The important point is that it’s much more compact and readable (once you understand the syntax, of course). We wanted the list ordered by name, and that’s exactly what the code says. It doesn’t say to sort by comparing the name of one product with the name of another, like the C# 2 code did, or to sort by using an instance of another type that knows how to compare one product with another. It just says to order by name. This simplicity of expression is one of the key benefits of C# 3. When the individual pieces of data querying and manipulation are so simple, larger transformations can remain compact and readable in one piece of code. That in turn encourages a more “data-centric” way of looking at the world.</font></p><img src="images/3.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 1.2 Features involved in making sorting easier in C# 2 and 3</font></p>
<p><a name="bookmark509"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen more of the power of C# 2 and 3 in this section, with a lot of (as yet) unexplained syntax, but even without understanding the details<a name="bookmark510"></a> we can see the progress toward clearer, simpler code. Figure 1.2 shows that evolution.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s it for sorting.<sup><a name="footnote2"></a><a href="#bookmark511">2</a></sup> Let’s do a different form of data manipulation now—querying.</font></p>
<p><a name="bookmark39"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark512"></a>1.2.2 Querying collections</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our next task is to find all the elements of the list that match a certain criterion—in particular, those with a price greater than $10. The following listing shows how in C# 1, we need to loop around, testing each element and printing it out where appropriate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.10 Looping, testing, printing out (C# 1)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ArrayList products = Product.GetSampleProducts(); foreach (Product product in products)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (product.Price &gt;&nbsp;10m)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(product);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Okay, this is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> difficult code to understand. But it’<a name="bookmark513"></a>s worth bearing in mind how intertwined the three tasks are—looping with foreach, testing the criterion with if, then displaying the product with Console.WriteLine. The dependency is obvious because of the nesting. The following listing demonstrates how C# 2 lets us flatten things out a bit.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.11 Separating testing from printing (C# 2)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; products = Product.GetSampleProducts();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Predicate&lt;Product&gt; test = delegate(Product p) { return p.Price &gt;&nbsp;10m; }; List&lt;Product&gt;matches = products.FindAll(test);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Action&lt;Product&gt; print = Console.WriteLine; matches.ForEach(print);</font></p>
<p><a name="bookmark514"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The test variable is initialized using the anonymous method feature we saw in the previous section; the print variable initialization uses another new C# 2 feature called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">method group conversions</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that makes it easier to create delegates from existing methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m not going to claim that this code is simpler than the C# 1 code—but it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a lot more powerful.<sup><a name="footnote3"></a><a href="#bookmark515">3</a></sup> In particular, it makes it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> easy to c<a name="bookmark516"></a>hange the condi<a name="bookmark517"></a>tion we’re testing for and the action we take on each of the matches independently. The delegate variables involved (test and print) could be passed into a method—that same method could end up testing radically different conditions and taking radically different actions. Of course, we could’ve put all the testing and printing into one statement, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.12 Separating testing from printing redux (C# 2)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; products = Product.GetSampleProducts(); products.FindAll(delegate(Product p) { return p.Price &gt;&nbsp;10;}) .ForEach(Console.WriteLine);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In some ways that's better, but the delegate(Product p) is getting <a name="bookmark518"></a>in the way, as are the braces. They’re adding noise to the code, which hurts readability. I still prefer the C# 1 version, in the case where we only ever want to use the same test and perform the same action. (It may sound obvious, but it’s worth remembering that there’s nothing stopping us from using the C# 1 code with a later compiler version. You wouldn’t use a bulldozer to plant tulip bulbs, which is the kind of overkill we’re using here.) The next listing shows how C# 3 improves matters dramatically by removing a lot of the fluff surrounding the actual </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">logic</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the delegate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.13 Testing with a lambda expression (C# 3)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; products = Product.GetSampleProducts(); foreach (Product product in products.Where(p =&gt; p.Price &gt;&nbsp;10))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(product);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark519"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The combination of the lambda expression putting the test in just the right place and a well-named method means we can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">almost</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> read the code out loud and understand i<a name="bookmark520"></a>t without even thinking. We still have the flexibility of C# 2—the argument to Where could come from a variable, and we could use an Action&lt;Product&gt; instead of the hard-coded Console.WriteLine call if we wanted to.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This task has emphasized what we already knew from sorting—anonymous methods make writing a del<a name="bookmark521"></a>egate simple, and lambda expressions are even more concise. In both cases, that brevity means that we can include the query or sort operation i<a name="bookmark522"></a>nside the first part of the foreach loop without losing clarity. Figure 1.3 summarizes the changes we’ve just seen. C# 4 doesn't offer us anything to simplify this task any further.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, now that we’ve displayed the filtered list, let’s consider a change to our initial assumptions about the data. What happens if we don’t always know the price for a product? How can we cope with that within our Product class?</font></p><img src="images/4.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 1.3 Anonymous methods and lambda expressions aid separation of concerns and readability for C# 2 and 3.</font></p>
<p><a name="bookmark41"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark523"></a>1.3 Handling an absence of data</font></p>
<p><a name="bookmark524"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re going to look at two different forms of missing data. First we’ll deal with the scenario where we genuinely don’t have the information, and the<a name="bookmark525"></a>n see how we can actively </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">remove</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> information from method calls, using default values instead.</font></p>
<p><a name="bookmark42"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark526"></a>1.3.1 Representing an unknown price</font></p>
<p><a name="bookmark527"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark528"></a><a name="bookmark529"></a>I’m not going to present much code this time, but I’m sure <a name="bookmark530"></a>it’ll be a familiar problem to you, especially if you’ve done a lot of work with databases. Let’s imagine our list of products contains not just products on sale right now bu<a name="bookmark531"></a>t ones that aren’t avail<a name="bookmark532"></a>able yet. In some cases,<a name="bookmark533"></a> we may not know the price. If decimal were a reference type, we could just use null to represent the unknown price—but as it’s a value type, we can’t. How would you represent this in C# 1? There are three common alternatives:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Create a reference type wrapper<a name="bookmark534"></a> around decimal.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Maintain a separat<a name="bookmark535"></a>e Boolean flag indicating whether the price is known.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Use a “magic value” (decimal .MinValue, for example) to represent the unknown price.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I hope you’ll agree that none of these holds much appeal. Time for a little magic: we can solve the problem with the addition of a single extra character in the variable and property de<a name="bookmark536"></a>clarations. .NET 2.0 makes matters a lot simpler by intr<a name="bookmark537"></a>oducing the Nullable&lt;T&gt; structure, and C# 2 provides some additional syntactic sugar that lets us change the property declaration to this block of code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">decimal? price; public decimal? Price {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get { return price; } private set { price = value; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark538"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The constructor parameter changes to decimal? as well, and then we can pass in null as the argument, or say Price = null; within the class. That’s a lot more expressive than any of the other solutions. The rest of the code just works as-is—a product with an unknown price will be considered to be less expensiv<a name="bookmark539"></a>e than $10, due to the way nullable values are handled in “greater-than” comparisons. <a name="bookmark540"></a>To check whether a price is known, we can compare it with null or use the HasValue property—so to show all the products with unknown prices in C# 3, we’d write the code in listing 1.14.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.14 Displaying products with an unknown price (C# 3)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; products = Product.GetSampleProducts();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (Product product in products.Where(p =&gt; p.Price == null))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(product.Name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark541"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The C# 2 code would be similar to listing 1.12 but would use return p.Price == null; as the body for the anonymous method. C# 3 doesn’t offer any changes here, but C# 4 has a feature that’s at least tangentially related.</font></p>
<p><a name="bookmark43"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark542"></a>1.3.2 Optional parameters and default values</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Sometimes you just don’t want to tell a method everything it needs to know—if you almost always use the same value for a particular parameter, for example. Traditionally the soluti<a name="bookmark543"></a>on has been to overload the method in question, but C# introduces </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">optional parameters</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to make this simpler. In our C# 4 version of the Product type, we have a constructor that takes the name and the price. We can make the price a nullable decimal just as in C# 2 and 3, but now let’s suppose that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">most</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of our products didn’t have prices. It would be nice to be able to initialize a product like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Product p = new Product(&quot;Unreleased product&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Prior to C# 4, we would’ve had to introduce a new overload in the Product constructor for this purpose. C# 4 allows us to declare a default value (in this case null) for the price parameter:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Product(string name, decimal? price = null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">this.name = name; this.price = price;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark544"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You always have to specify a constant value when you declare an optional parameter. It doesn’t have to be null; that just happens to be the default we want in this situation. This is applicable to any type of parameter, although for reference types other than strings you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> lim<a name="bookmark545"></a>ited to null as the only constant value available. Figure 1.4 summarizes the evolution we’ve seen across different versions of C#.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far the features have been useful, but perhaps nothing to write home about. Next we’ll look at something rather more exciting: LINQ.</font></p><img src="images/5.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 1.4 Options for working with “missing” data</font></p>
<p><a name="bookmark45"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark546"></a>1.4 Intr<a name="bookmark547"></a>oducing <a name="bookmark548"></a>LINQ</font></p>
<p><a name="bookmark549"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark550"></a><a name="bookmark551"></a><a name="bookmark552"></a>LINQ (Language Integrated Query) is what C# 3 is all about at its heart. As its name suggests, LINQ is all about queries—<a name="bookmark553"></a>the aim is to make it easy to write q<a name="bookmark554"></a>ueries against multiple data sources with consistent syntax and features, in a readable and compos-able fashion.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Whereas the features in C# 2 are arguably more about fixing annoyances in C# 1 than setting the world on fire, almost everything in C# 3 builds toward LINQ—and the result is rather special. I’ve seen features in other languages tha<a name="bookmark555"></a>t tackle </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">some</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the same areas as LINQ, but nothing quite so well-rounded and flexible.</font></p>
<p><a name="bookmark46"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark556"></a>1.4.1 Query expressions and in-process queries</font></p>
<p><a name="bookmark557"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’ve see<a name="bookmark558"></a>n any LINQ before, you’re probably aware of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">query expressions</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that allow a declarative style for creating queries on various data sources. The reason none of the examples so far have use<a name="bookmark559"></a>d them is because they’ve all actually been simpler </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">without</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> using the extra syntax. That’s not to say we couldn’t use it anyway, of course—listing 1.15, for example, is equivalent to listing 1.13.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.15 First steps with query expressions: filtering a collection</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; products = Product.GetSampleProducts(); var filtered = from Product p in products where p.Price &gt;&nbsp;10 select p;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (Product product in filtered)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(product);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark560"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark561"></a>Personally, I find the earlier listing easier to read—the only benefit to the query expression version is that the whe<a name="bookmark562"></a>r<a name="bookmark563"></a>e clause is simpler. I’ve snuck in one extra feature here</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">—implicitly typed local variables,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> whic<a name="bookmark564"></a>h are declared using the var contextual keyword. These allow the compiler to infer the type of a variable from the value that it’s initially assigned—in this case, the type of filtered is IEnumerable&lt;Product&gt;. I’ll use var fairly extensively for the rest of the examples in this chapter; it’s particularly useful in books, where space in listings is at a premium.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But if query expressions are no good, why does everyone make such a fuss about them, and about LINQ in general? The first answer is that though query expressions aren’t particularly beneficial for simple tasks, they’re </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> good for more complicated situations that would be hard to read if written out in the equivalent method calls (and fiendish in C# 1 or 2). Let’s make things a little harder by introducing another type—Supplier.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Each supplier has a Name (string) and a SupplierID (int). I’ve also added SupplierID as a property in Product and adapted the sample data appropriately. Admittedly that’s not a very object-oriented way of giving each product a supplier—it’s much closer to how the data would be represented in a database. It makes this particular feature easier to demonstrate for now, but we’ll see in chapter 12 that LINQ allows us to use a more natural model, too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now let’s look at the code (listing 1.16) to join the sample products with the sample suppliers (obviously based on the supplier ID), apply the same price filter as before to the products, sort by supplier name and then product name, and print out the name of both the supplier and the product for each match. That was a mouthful (fingerful?), and in earlier versions of C# it would’ve been a nightmare to implement. In LINQ, it’s almost trivial.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.16 Joining, filtering, ordering, and projecting (C# 3)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Product&gt; products = Product.GetSampleProducts();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Supplier&gt; suppliers = Supplier.GetSampleSuppliers(); var filtered = from p in products join s in suppliers</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">on p.SupplierID equals s.SupplierID where p.Price &gt;&nbsp;10 orderby s.Name, p.Name</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select new { SupplierName = s.Name, ProductName = p.Name }; foreach (var v in filtered)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Supplier={0}; Product={1}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">v.SupplierName, v.ProductName);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark565"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The more astute among you will have noticed that it looks remarkably like SQL. Indeed, the reaction of many people on first hearing about LINQ (but before examining it closely) is to reject it as merely trying to put SQL into the language for the sake of talking to databases. Fortunately, LINQ has borrowed the syntax <a name="bookmark566"></a>and some ideas from SQL, but as we’ve seen, you needn’t be anywhere near a database in order to use it—none of the code we’ve run so far has touche<a name="bookmark567"></a>d a database at all. Indeed, we could be getting data from any number of sources: XML, for example.</font></p>
<p><a name="bookmark47"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark568"></a>1.4.2 Querying XML</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Suppose that instead of hard-coding our suppliers and products, we’d used the following XML file:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;?xml version=&quot;1.0&quot;?&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Data&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Products&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Product Name=&quot;West Side Story&quot; Price=&quot;9.99&quot; SupplierID=&quot;1&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Product Name=&quot;Assassins&quot; Price=&quot;14.99&quot; SupplierID=&quot;2&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Product Name=&quot;Frogs&quot; Price=&quot;13.99&quot; SupplierID=&quot;1&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Product Name=&quot;Sweeney Todd&quot; Price=&quot;10.99&quot; SupplierID=&quot;3&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/Products&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Suppliers&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Supplier Name=&quot;Solely Sondheim&quot; SupplierID=&quot;1&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Supplier Name=&quot;CD-by-CD-by-Sondheim&quot; SupplierID=&quot;2&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Supplier Name=&quot;Barbershop CDs&quot; SupplierID=&quot;3&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/Suppliers&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/Data&gt;</font></p>
<p><a name="bookmark569"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The file is simple enough, but what’s the best way of extracting the data from it? How do we query it? Join on it? Surely it’s going to be somewhat harder than listing<a name="bookmark570"></a> 1.16, right? The following listing shows how much work we have to do in LINQ to XML.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.17 Complex processing of an XML file with LINQ to XML (C# 3)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XDocument doc = XDocument.Load(&quot;data.xml&quot;); var filtered = from p in doc.Descendants(&quot;Product&quot;) join s in doc.Descendants(&quot;Supplier&quot;) on (int)p.Attribute(&quot;SupplierID&quot;) equals (int)s.Attribute(&quot;SupplierID&quot;) where (decimal)p.Attribute(&quot;Price&quot;) &gt;&nbsp;10 orderby (string)s.Attribute(&quot;Name&quot;),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(string)p.Attribute(&quot;Name&quot;) select new {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SupplierName = (string)s.Attribute(&quot;Name&quot;),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ProductName = (string)p.Attribute(&quot;Name&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var v in filtered)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Supplier={0}; Product={1}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">v.SupplierName, v.ProductName);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s not quite as straightforward, because we n<a name="bookmark571"></a>eed to tell the system how it should understand the data (in terms of what attributes should be used as what types)—but it’s not far off. In particular, there’s an obvious relationship between each part of the two listings. If it weren’t for the line length limitations of books, you’d see an exact line-by-line correspondence between the two queries.</font></p>
<p><a name="bookmark572"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Impressed yet? Not quite convinced? Let’s put the data where it’s much more likely to be—in a database.</font></p>
<p><a name="bookmark48"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark573"></a>1.4.3 LINQ to SQL</font></p>
<p><a name="bookmark574"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s some work (much of which can be automated) to let LINQ to SQL know about what to expect in what table, but it’s all fairly straightforward. We'll skip straight to the querying code, which is shown in the following listing. If you want to see the details of</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">LinqDemoDataContext, they're all in the downloadable source code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.18 Applying a query expression to a SQL database (C# 3)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using (LinqDemoDataContext db = new LinqDemoDataContext()) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var filtered = from p in db.Products join s in db.Suppliers</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">on p.SupplierID equals s.SupplierID where p.Price &gt;&nbsp;10 orderby s.Name, p.Name select new {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SupplierName = s.Name,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ProductName = p.Name</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var v in filtered)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Supplier={0}; Product={1}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">v.SupplierName, v.ProductName);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">By now, this should be looking incredibly familiar. Everything below the join line is cut and pasted directly from listing 1.16 with no changes. That’s impressive enough, but if you’re performance-conscious, you may be wondering why we’d want to pull down all the data from the database and then apply these .NET queries and orderings. Why not get the database to do it? That’s what it’s good at, isn’t it? Well, indeed—and that’s exactly what LINQ to SQL does. The code in listing 1.18 issues a database request, which is basically the query translat<a name="bookmark575"></a>ed into SQL. Even though we’ve </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">expressed </font><font style="font-size:x-small;font-family:Times New Roman, serif;">the query in C# code, it’s been </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">executed</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as SQL.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll see later that there’s a more relation-oriented way of approaching this kind of join when the schema and the entities know about the relationship between suppliers and products. The result is the same, though, and it shows just how similar LINQ to Objects (the in-memory LIN<a name="bookmark576"></a>Q operating on collections) and LINQ to SQL can be.</font></p>
<p><a name="bookmark577"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">LINQ is extr<a name="bookmark578"></a>emely flexible—you can write your own provider to talk to a web service, or translate a query into your own specific representation. In chapter 13, we’ll look at how broad the term </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">LINQ</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> really is, and how it can go beyond what you might consider in terms of querying collections.</font></p>
<p><a name="bookmark50"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark579"></a>1.5 COM and dynamic typing</font></p>
<p><a name="bookmark580"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark581"></a>The final features I want to demo<a name="bookmark582"></a>nstrate are specific to C# 4. Where LINQ was the major focus of C# 3, interoperability is the biggest theme in C# 4. This includes working wit<a name="bookmark583"></a>h both the old tec<a name="bookmark584"></a>hnology of COM and also t<a name="bookmark585"></a>he brave new world of dynamic languages executing on the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Dynamic Language Runtime (DLR).</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> We’ll start by exporting our product list to an Excel spreadsheet.</font></p>
<p><a name="bookmark51"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark586"></a>1.5.1 Simplifying COM interoperability</font></p>
<p><a name="bookmark587"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are various ways of making data available to Excel, but using COM to control it gives the most power and flexibility. <a name="bookmark588"></a>Unfortunately, previous incarnations of C# made it quite difficult to work with COM; VB had much better support. C# 4 largely rectifies that situation. The following listing shows some code to save our data to a new spreadsheet.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.19 Saving data to Excel using COM (C# 4)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var app = new Application { Visible = false };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Workbook workbook = app.Workbooks.Add();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Worksheet worksheet = app.ActiveSheet; int row = 1;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var product in Product.GetSampleProducts()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Where(p =&gt; p.Price != null))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">worksheet.Cells[row, 1].Value = product.Name; worksheet.Cells[row, 2].Value = product.Price; row++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">workbook.SaveAs(Filename: &nbsp;&nbsp;&nbsp;&quot;demo.xls&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FileFormat: XlFileFormat.xlWorkbookNormal); app.Application.Quit();</font></p>
<p><a name="bookmark589"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Though this may not be quite as nice as we’d like, it’s a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lot</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> better than it would’ve been using earlier versions of C#. In fact, you already know about some of the C# 4 features we can see here—but there are a couple of other ones that aren’t so obvious. Here's the full list:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The SaveAs call uses named arguments.</font></p>
<p><a name="bookmark590"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark591"></a><a name="bookmark592"></a>■ &nbsp;&nbsp;&nbsp;Various calls omit arguments for optional<a name="bookmark593"></a> parameters—in particular, SaveAs would normally have an extra 10 arguments!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;C# 4 can embed the relevant parts of the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Prim<a name="bookmark594"></a>ary Interop Assembly (PIA)</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> into the calling code—so you no longer need to deploy the PIA separately.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;In C# 3, the assignment to worksheet would fail without a cast, as the type of the ActiveSheet property is represented as object. W<a name="bookmark595"></a>hen using the embedded PIA feature, the type of ActiveSheet becomes dynamic, which leads to a whole other feature.</font></p>
<p><a name="bookmark596"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark597"></a>Additionally, C# 4 supports named indexers when working with COM—a feature not demonstrated in this example.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve already mentioned our final feature: dynamic typing in C# using the new dynamic type.</font></p>
<p><a name="bookmark52"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark598"></a>1.5.2 Interoperating with a dynamic language</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Dynamic typing is such a big topic that it has its own (rather long) chapter, near the end of the book. I’m just going to show you one small example of what it can do. Let’s suppose our products are<a name="bookmark599"></a>n’t stored in a database, or in XML,<a name="bookmark600"></a> or in memory. They’re accessible via a web service of sorts, but you only have Python code to access it—and that code uses the dynamic nature of Python to build results without declaring a type with all the properties you need to access. Instead, it’ll let you ask for any property, and try to work out what you mean at execution time. In a language like Python, there’s nothing unusual about that. But how c<a name="bookmark601"></a>an we access our results from C#?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The answer comes in the form of dynamic—a new type,<sup><a name="footnote4"></a><a href="#bookmark602">4</a></sup> which the C# compiler allows you to use dynamically. If an expression is of type dynamic, you can call methods on it, access properties, pass it around as a method argument, and so on—and most of the normal binding process happens at execution time instead of compile time. You can implicitly convert a value from dynamic to any other type (which is why our worksheet cast worked in listing 1.19) and all kinds of other fun stuff.</font></p>
<p><a name="bookmark603"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark604"></a>This ability can be useful even within pure C# code, with no interop involved, but it’s likely to prove more useful when working with dynamic languages. Listing 1.20 shows how we can get our list of products from IronPython and print them out. This includes all the setup code to run the Python code in the same process as well.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 1.20 Running IronPython and extracting properties dynamically (C# 4)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ScriptEngine engine = Python.CreateEngine();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ScriptScope scope = engine.ExecuteFile(&quot;FindProducts.py&quot;); dynamic products = scope.GetVariable(&quot;products&quot;); foreach (dynamic product in products)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;product.ProductName, &nbsp;&nbsp;&nbsp;product.Price);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Both products and product are declared to be dynamic, so the compiler is happy to let us iterate over the list of products and print out the properties, even though it doesn’t know whether it’ll work. If we’d made a typo, using product.Name instead of product.ProductName, for example, that would only show up at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is completely contrary to the rest of C#, which is statically typed. But dynamic typing only comes into play when expression<a name="bookmark605"></a>s with a type of dynamic are involved: most C# code is likely to remain statically typed throughout.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Are you dizzy yet? Relax—I’ll be going a lot more sl<a name="bookmark606"></a>owly for the rest of the book. In particular, I’ll be explaining some of the corner cases, going into more detail about </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">why</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> various features were introduced, and giving some guidance as to when it’s appropriate to use them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far I’ve been showing you features of C#. Some of these are also library features. Some of them are also runtime features. I’m going to say this sort of thing a lot, so let’s clear up what I mean.</font></p>
<p><a name="bookmark54"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark607"></a>1.6 Dissecting the .NET platform</font></p>
<p><a name="bookmark608"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When it was originally introduced, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">.<a name="bookmark609"></a>NET</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> was used as a catchall term f<a name="bookmark610"></a>or a vast range of techno<a name="bookmark611"></a>logies coming from Microsoft. For instance, Windows Live ID was called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">.NET Passport,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> despite there being no clear relationship between that and what we currently know as .NET. Fortunately, things have calmed down somewhat since then. In this section we’ll look at the various parts of .NET.</font></p>
<p><a name="bookmark612"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In several places in this book, I’ll refer <a name="bookmark613"></a>to three different kinds of features: features of C# as a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">language,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> features of the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">ru<a name="bookmark614"></a>ntime</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that provides the “engine” if you will, and features of the .NET </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">framework libraries.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> In particular, this book is heavily focused on the language of C#, for the most part explaining runtime and framework features only when they relate to features of C# itself. This only makes sense if there’s a clear distinction between the three. Often features will overlap, but it’s important to understand the principle of the matter.</font></p>
<p><a name="bookmark55"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark615"></a>1.6.1 &nbsp;&nbsp;&nbsp;C#, the language</font></p>
<p><a name="bookmark616"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The language of C# is defined by its specification, which describes the format of C# source code, including both syntax and behavior. It does </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> describe the platform that the compiler output will run on, beyond a few key points at which the tw<a name="bookmark617"></a>o interact. For instance, the C# language<a name="bookmark618"></a> requires a type called System.IDisposable, which contains a method called Dispose. These are required in order to define the using statement. Like<a name="bookmark619"></a>wise, the platform n<a name="bookmark620"></a>eeds to be able to support (in <a name="bookmark621"></a>one form or other) both value types and reference types, along with garbage collection.</font></p>
<p><a name="bookmark622"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark623"></a>I<a name="bookmark624"></a>n theory, any platform that supports the required features could have a C# compiler targeting it. For example, a C# com<a name="bookmark625"></a>pile<a name="bookmark626"></a>r<a name="bookmark627"></a> could legitimately produce output in a form other than the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Intermediate Language</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (IL), which is the typical output at the time of this writing. A runtime could interpre<a name="bookmark628"></a>t the output<a name="bookmark629"></a> of a C# compiler, or convert it all to native code in one step rather than JIT-compiling it. Though these options <a name="bookmark630"></a>are relatively unco<a name="bookmark631"></a>mmon, they d<a name="bookmark632"></a>o exist in the wild: for example, the Micro Framework uses a<a name="bookmark633"></a>n interpreter, as can Mono. At the other end of the spectrum, NGen and Mon<a name="bookmark634"></a>oTouch (<a href="http://monotouch.net/">http://monotouch.net/</a>)—a platform for building applications for the iPhone<sup><a name="footnote5"></a><a href="#bookmark635">5</a></sup>—use ahead-of-time compilation.</font></p>
<p><a name="bookmark56"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark636"></a>1.6.2 &nbsp;&nbsp;&nbsp;Runtime</font></p>
<p><a name="bookmark637"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The runtime aspect of the .NET platform is the relatively small amount of code that’s responsible for making su<a name="bookmark638"></a>re that<a name="bookmark639"></a> programs written in IL execute according to the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Common Language Infrastructure (CLI</font><font style="font-size:x-small;font-family:Times New Roman, serif;">) specification,<a name="bookmark640"></a> partitions I to III. The runtime part of the CLI is called the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Common Lan<a name="bookmark641"></a>guage Runtime</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">(CLR</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> ). When I refer to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">the CLR</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in the rest of the book, I mean Microsoft’s implementation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Some elements of language n<a name="bookmark642"></a>ever appear at the runtime level, but others cross the divide. For instance, enumerators aren’t defined at a runtime level, an<a name="bookmark643"></a>d neither is an<a name="bookmark644"></a>y particular meaning attached to the IDisposable interface—but arrays and delegates are important to the runtime.</font></p>
<p><a name="bookmark57"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark645"></a><a name="bookmark646"></a>1.6.3 &nbsp;&nbsp;&nbsp;Framework libraries</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Libraries provide code that’s available to our programs.<a name="bookmark647"></a> The framework libraries in .NET are largely built as IL themselves, with native code used only where necessary. This is a mark of the strength of the runtime: your own code isn’t expected to be a second-class citizen—it can provide the same kind of power and performance as the libraries it utilizes. The amount of code in the library is much greater than that of the runtime, in the same way that there’s much more to a car than the engine.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The framework libraries are partially stan<a name="bookmark648"></a>dardized.<a name="bookmark649"></a> Partition I<a name="bookmark650"></a>V of the CLI specification provides a number of different profiles </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">(compact</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">kernel)</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and libraries. Partition IV comes in two parts—a general textual description of the libraries, including which libraries are required within which profiles, and another part containing the details of the libraries themselves in XML for<a name="bookmark651"></a>mat. This is the same form of documentation produced when you use XML comments within C#.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s much within .NET that’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> within the base libraries. If you write a program that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> uses libraries from the specification, and only uses them correctly, you should find that your code works flawlessly on any implementation—Mono, .NET, or anything else. In practice, alm<a name="bookmark652"></a>ost any progr<a name="bookmark653"></a>am of any size will use libr<a name="bookmark654"></a>aries that aren’t standardized—Windows Forms or ASP.NET, for instance.<a name="bookmark655"></a> The Mono project has its own libraries that aren’t part of .NET as well, such as GTK#, in addition to implementing many of the nonstandardized libraries.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The term </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">.NET</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> refers to the combination of the <a name="bookmark656"></a>runtim<a name="bookmark657"></a>e and libraries provided by Microsoft, and it al<a name="bookmark658"></a>so includes compilers for <a name="bookmark659"></a>C# and VB.NET. It can be seen as a <a name="bookmark660"></a>whole </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">development platform</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> built on top of Windows. Each aspect of .NET is versioned separately, which can be a source of confusion. Appendix C gives a quick rundown of which version of what came out when and with which features.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If that’s all clear, I have one last bit of housekeeping to go through before we really start diving into C#.</font></p>
<p><a name="bookmark59"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark661"></a><a name="bookmark662"></a>1.7 Making your code super awesome</font></p>
<p><a name="bookmark663"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I apologize for the misleading title. This section (in it<a name="bookmark664"></a>self) will </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> make your code super awesome. It won’t even make it refreshingly minty. It will help you to make the most of this book though—and that's why I wanted to make sure you actually read it. There’s more of this sort of thing in the front matter (the bit before page 1) but I know that many readers skip over that, heading straight for the meat of the book. I can understand that, so I’ll make this as quick as possible.</font></p>
<p><a name="bookmark60"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark665"></a>1.7.1 Presenting full programs as snippets</font></p>
<p><a name="bookmark666"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark667"></a>One of the challenges when writing a book about a computer language (other than scripting languages) is that <a name="bookmark668"></a>complete programs—ones that the reader can compile and run with no source code other than what’s presented—get long pretty quickly. I wanted to <a name="bookmark669"></a>get around this, to provide you with code that you could easily type in and ex<a name="bookmark670"></a>periment with. I believe that actually </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">trying</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> something is a much better way of learning about it than just reading.</font></p>
<p><a name="bookmark671"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">With the right assembly references and the right using directives, you can accomplish a lot with a fairly short amount of C# code—but the killer is the fluff involved in writing those using directives, then declaring a class, then declaring a Main method before you’ve even written the first line of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">useful</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> code. My examples are mostly in the form of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">snippets</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which ignore the fluff that gets in the way of simple programs, concentrating on the important part. The snippets can be run directly in a small tool I’ve built called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Snippy.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If a snippet doesn't contain an ellipsis <a name="bookmark672"></a>(...) then all of the code should be considered to be the body of the Main method of a program. If there </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> an ellipsis, then <a name="bookmark673"></a>everything before it is treated as declarations of methods and nested types, and everything after the ellipsis goes in the Main method. So for example, consider this snippet:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static string Reverse(string input)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">char[] chars = input.ToCharArray();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Array.Reverse(chars); return new string(chars);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark674"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(Reverse(&quot;dlrow olleH&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is expanded by Snippy into the following:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System; public class Snippet {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static string Reverse(string input)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">char[] chars = input.ToCharArray();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Array.Reverse(chars); return new string(chars);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[STAThread] static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(Reverse(&quot;dlrow olleH&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In reality, Snippy includes far more using directives, but the expanded version was already getting long. Note that the containing class will always be called Snippet, and any types declared within the snippet will be nested within that class.</font></p>
<p><a name="bookmark675"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark676"></a>There are more details about how to use Snippy on the book’s website (<a href="http://mng.bz/Lh82">http://</a> <a href="http://mng.bz/Lh82">mng.bz/Lh82</a>), along with all the examples as both snippets and expanded versions in Visual Studio solutions. Additionally, there’s suppor<a name="bookmark677"></a>t for LINQPad (<a href="http://www.linqpad.net">http://www.</a> <a href="http://www.linqpad.net">linqpad.net</a>)—a similar tool developed by Joe Albahari, with particularly helpful features for exploring LINQ.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Next, let’s look at what’s wrong with the code we’ve just seen.</font></p>
<p><a name="bookmark61"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark678"></a>1.7.2 Didactic code isn’t production code</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’d be lovely if you could take all the examples from this book and use them directly in your own applications with no further thought involved... but I strongly suggest you don’t. Most examples are given to demonstrate a specific point—and that’s usually the limit of the intent. For example, most snippets don’t include argument validation, access modifiers, unit tests, or documentation. They may also simply fail when used outside their intended context. For example, let’s consider the body of the method previously shown for reversing a string. I use this code several times in the course of the book.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">char[] chars = input.ToCharArray();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Array.Reverse(chars); return new string(chars);</font></p>
<p><a name="bookmark679"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Leaving aside argu<a name="bookmark680"></a>ment validation, this succeeds in reversing the sequence of UTF-16 code points within a string—but in some cases that’s not good enough. For example, if a single displayed glyph is composed of an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">e</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> followed by a combining character representing an acute accent, you don’t want to switch the sequence of the code points: the accent will end up on the wrong char<a name="bookmark681"></a>acter. Or suppose your string co<a name="bookmark682"></a>ntains a character outside the basic multilingual plane, formed from a surrogate pai<a name="bookmark683"></a>r—reordering the code points will lead to a string which is effectively invalid UTF-16. Fixing these problems would lead to much more complicated code, distracting from the point it’s meant to be demonstrating.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You’re welcome to use the code from the book, but please bear this section in mind if you do so—it’d be much better to take inspiration from it than to copy it verbatim and assume it’ll work according to your particular requirements.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Finally, there’s another book you should really download in order to make the absolute most of this one.</font></p>
<p><a name="bookmark62"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark684"></a>1.7.3 Your new best friend: the language specification</font></p>
<p><a name="bookmark685"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve tried<a name="bookmark686"></a> extremely hard to be accurate in this book, but I’d be amazed if there were no errors at all—indeed you’ll find a list of any known errors on the book’s website (<a href="http://mng.bz/m1Hh">http://mng.bz/m1Hh</a>). If you think you’ve found a mistake, I’d be grateful if you could email me (<a href="mailto:skeet@pobox.com">skeet@pobox.com</a>) or add a note on the author forum (<a href="http://mng.bz/gi4q">http://</a> <a href="http://mng.bz/gi4q">mng.bz/gi4q</a>). But you may not want to wait for me to get back to you—or you may have a question that simply isn’t covered in the<a name="bookmark687"></a> book. Ultimately, the definitive source for the intended behavior of C# is the language specification.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two important forms of the spec—the international stan<a name="bookmark688"></a>dard from ECMA, and the Microsoft specification. At the time of this writing, the ECMA specification only covers C# 2, despite being the fourth edition. It’s unclear whether or when this will be updated, but the Microsoft version is complete and freely available. This book’s website has links to all the available versions of both specification flavors (<a href="http://mng.bz/8s38">http:/</a> <a href="http://mng.bz/8s38">/mng.bz/8s38</a>). When I refer to sections of the specification within this book, I’ll use numbering from the Microsoft C# 4 specification, even when I’m talking about earlier versions of the language. I strongly recommend that you download this version and have it on hand whenever you find yourself eager to check out a weird corner case.</font></p>
<p><a name="bookmark689"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One of my aims is to make the spec </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">mostly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> redundant for developers—to provide a more developer-oriented form covering everything you’re likely to see in everyday code, without the huge level of detail required by compiler authors. Having said that, it’s extremely readable as specifications go, and you shouldn’t be daunted by it. If you find the spec interesting, there’s already an annotated version available for <a name="bookmark690"></a>C# 3 (<a href="http://mng.bz/0y9c">http://mng.bz/0y9c</a>), which contains fascinating comments from the C# team and other contributors; an updated version for C# 4 is in the works.</font></p>
<p><a name="bookmark63"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark691"></a>1.8 Summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this chapter, I’ve shown (but not explained) some of the features that are tackled in depth in the rest of the book. There are plenty more that haven’t been shown here, and many of the features we’ve seen so far have further “subfeatures” associated with them. Hopefully what you’ve seen here has whetted your appetite for the rest of the book.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although features have taken up most of the chapter, we’ve also looked at some areas that should help you get the most out of the book. I’ve clarified what I mean when I refer to the language, runtime, or libraries, and also explained how code will be laid out in the book.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s one more area we need to cover before we dive into the features of C# 2, and that’s C# 1. Obviously, as an author I have no idea how knowledgeable you are about C# 1, but I </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have some understanding of which areas of C# often cause conceptual problems. Some of these areas are critical to getting the most out of the later versions of C#, so in the next chapter I’ll go over them in some detail.</font></p>
<p><a name="bookmark65"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark3"></a>Core foundations: building on C# 1</font></p>
<p><a name="bookmark692"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">■</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> &nbsp;&nbsp;&nbsp;Delegates</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Type system characteristics</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Value/reference types</font></p>
<p><a name="bookmark693"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This isn’t a refresher on the whole of C# 1. Let’s get that out of the way immediately. I couldn’t do justice to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">any</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> topic in C# if I had to cover the whole of the first version in a single chapter. I’ve written this book assuming that my readers are at least reasonably competent in C# 1. What counts as “reasonably competent” is, of course, somewhat subjective, but I’ll assume you’d </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">at least</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be happy to walk into an interview for a junior C# developer role and answer technical questions appropriate to that job. My expectation is that many readers will have more experience, but that’s the level of knowledge I’m assuming.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this chapter we’re going to focus on three areas of C# 1 that are particularly important in order to understand the features of later versions. This should raise the “lowest common denominator” a little, so that I can make slightly greater assumptions later on in the book. Given that it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a lowest common denominator, you may find you already have a perfect understanding of all the concepts in this</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">chapter. If you believe that’s the case without even reading the chapter, then feel free to skip it. You can always come back later if it turns out something isn’t as simple as you thought. You might want to at least look at the summary at the end of each section, which highlights the important points—if any of those sound unfamiliar, it’s worth reading that section in detail.</font></p>
<p><a name="bookmark694"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll start off by looking at delegates, then think about how the C# type system compares with some other possibilities, and finally look at the differences between value types and reference types. With each topic I’ll describe the ideas and behavior, as well as take the opportunity to define terms so that I can use them later on. After we’ve looked at how C# 1 works, I’ll show you a quick preview of how many of the new features in later versions relate to the topics examined in this chapter.</font></p>
<p><a name="bookmark67"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark695"></a>2.1 &nbsp;&nbsp;&nbsp;Delegates</font></p>
<p><a name="bookmark696"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark697"></a>I’m sure you already have an instinctive idea about the co<a name="bookmark698"></a>ncept of a delegate, even though it can be hard to articulate. If you’re familiar with <a name="bookmark699"></a>C and had to describe delegates to another C programmer, the term </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">functi<a name="bookmark700"></a>on pointer</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> would no doubt cro<a name="bookmark701"></a>p up. Essentially, delegates provide a level of indirection: instead of specifying behavior to be executed immediately, it can somehow be “contained” in an object. That object can then be used like any other, and one operation you can perform with it is to execute the encapsulated<a name="bookmark702"></a> action. Alternatively, you can think of a delegate type as a singlemethod interface, and a delegate instance as an object implementing that interface.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If that’s just gobbledygook to you, maybe an example will help. It’s slightly morbid, but it does capture what delegates are all about. Consider your will—your last will and testament. It’s a set of instructions—“pay the bills, make a donation to charity, leave the rest of my estate to the cat,” for instance. You write it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">before</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> your death, and leave it in an appropriately safe place. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">After</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> your death, your attorney will (you hope!) act on those instructions.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A delegate in C# acts like your will does in the real world—as a sequence of actions to be executed at the appropriate time. Delegates are typically used when the code that wants to execute the actions doesn’t know the details of what those actions should be. For instance, the only reason why the Thread class knows what to run in a new thread when you start it is b<a name="bookmark703"></a>ecause you provide the constructor with a ThreadStart or ParameterizedThreadStart delegate instance.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll start our tour of delegates with the four absolute basics, without which none of the rest would make sense.</font></p>
<p><a name="bookmark68"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark704"></a>2.1.1 &nbsp;&nbsp;&nbsp;A recipe for simple delegates</font></p>
<p><a name="bookmark705"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In order for delegates to do anything, four things need to happen:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">■</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">delegate type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> needs to be declared.</font></p>
<p><a name="bookmark706"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark707"></a>■ &nbsp;&nbsp;&nbsp;There must be a <a name="bookmark708"></a>method containing the code to execute.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;A </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">delegate instance</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> must be created.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The delegate instance must be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">invoked.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s take each step of this recipe in turn.</font></p>
<p><a name="bookmark709"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">DECLARING THE DELEGATE TYPE</font></p>
<p><a name="bookmark710"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark711"></a>A </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">delegate type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is effectively a list of parameter types and a return type. It specifies what kind of action can be represented by instances of the type. For instance, consider a delegate type declared like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate void StringProcessor(string input);</font></p>
<p><a name="bookmark712"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The code says that if we want to create an instance of StringProcessor, we’re going to need a method with one parameter (a string) and a void return type (the method doesn’t return anything). It’s important to understan<a name="bookmark713"></a>d that StringProcessor really is a type, deriving<a name="bookmark714"></a> from System.MulticastDelegate, which in turn derives from System.Delegate. It has methods, you can create instances of it, pass around references to instances, the whole works. There are obviously a few “special features,” but if you’re ever stuck wondering what’ll happen in a particular situation, first think about what would happen if you were just using a normal reference type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">SOURCE OF CONFUSION: THE AMBIGUOUS TERM </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">DELEGATE</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Delegates can be misunderstood because the word </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">delegate</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is often used to describe both a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">delegate type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">delegate instance.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> The distinction between these two is exactly the same as between any other type and instances of that type—the string type itself is different from a particular sequence of characters, for example. I’ve used the terms </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">delegate type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">delegate instance</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> throughout this chapter to try to keep clear exactly what I’m talking about at any point.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll use the StringProcessor delegate type when we consider the next ingredient. FINDING AN APPROPRIATE METHOD FOR THE DELEGATE INSTANCE’S ACTION</font></p>
<p><a name="bookmark715"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Our next ingredient is to find (or write, of course) a method that does what we want and has the same signature as the delegate type we’re using. The idea is to make sure that when we try to invoke a delegate instance, the parameters we use will all match up and we’ll be able to use the return value (if any) in the way we expect—just like a normal method call.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now consider these five method signatures as candidates to be used for a StringProcessor instance:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void PrintString(string x) void PrintInteger(int x)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void PrintTwoStrings(string x, string y) int GetStringLength(string x) void PrintObject(object x)</font></p>
<p><a name="bookmark716"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark717"></a>The first method has everything right, so we can use it to create a delegate inst<a name="bookmark718"></a>ance. The second method has one parameter, but it’s not string, so it’s incompatible with StringProcessor. The third method has the correct first parameter type, but it has another parameter as well, so it’s still incompatible.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The fourth method has the right parameter list but a nonvoid return type. (If our delegate type had a return type, the return type of the method would have to match</font></p>
<p><a name="bookmark719"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">that, too.) The fifth method is interesting—any time we invoke a StringProcessor instance, we could call the PrintObject method with the same arguments, because string derives from object. It would make sense to be able to use it for an instance of StringProcessor, but C# 1 limits the delegate to have </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the same parameter types.<sup><a name="footnote6"></a><a href="#bookmark720">6</a></sup> C# 2 changes this situation—see chapter 5 for more details. In some ways, the fourth method is similar, as you could always ignore the unwanted return value. But void and nonvoid return types are currently always deemed to be incompatible. This is partly because other aspects of the system (particularly the JIT) need to know whether a value will be left on the stack as a return value when a method is executed.<sup><a name="footnote7"></a><a href="#bookmark721">7</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s assume we have a method body for the compatible signature (PrintString) and move on to our next ingredient—the delegate instance itself.</font></p>
<p><a name="bookmark722"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">CREATING A DELEGATE INSTANCE</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we have a delegate type and a method with the right signature, we can create an instance of that delegate type, specifying that this method be executed when the delegate instance is inv<a name="bookmark723"></a>oked. No official terminology has been defined for this, but for this book I’ll call it the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">action</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the delegate instance. The exact form of the expression used to create the delegate instance depends on whether the action uses an instance method or a static method. Suppose PrintString is a static method in a type called StaticMethods and an instance method in a type called InstanceMethods. Here are two examples of creating an instance of StringProcessor:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StringProcessor proc1, proc2;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">proc1 = new StringProcessor(StaticMethods.PrintString);</font></p>
<p><a name="bookmark724"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">InstanceMethods instance = new InstanceMethods(); proc2 = new StringProcessor(instance.PrintString);</font></p>
<p><a name="bookmark725"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When the action is a static m<a name="bookmark726"></a>ethod, you only need to specify the type name. When the action is an instance method, you need an instance of the type (or a derived type)— ju<a name="bookmark727"></a>st as if you were calling the method in the normal way. This object is called the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">target </font><font style="font-size:x-small;font-family:Times New Roman, serif;">of the action, and when the delegate instance is invoked, the method will be called on that object. If the action is <a name="bookmark728"></a>within the same class (as it often is, particularly when you’<a name="bookmark729"></a>re writing event handlers in UI code), you don’t need to qualify it either way—the this reference is used implicitly for instance methods.<sup><a name="footnote8"></a><a href="#bookmark730">8</a></sup> Again, these rules actjust as if you were calling the method directly.</font></p>
<p><a name="bookmark731"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark732"></a>UTTER GARBAGE! (OR NOT, AS THE CASE MAY BE...) It’s worth being aware that a delegate instance will prevent its target from being garbage collected, if the delegate instance itself can’t be collected. This can result in apparent memory leaks, particularly when a “short-lived” object subscribes to an event</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">in a “long-lived” object, using itself as the target. The long-lived object indirectly holds a reference to the short-lived one, prolonging its lifetime.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s not much point in creating a delegate instance if it doesn’t get invoked at some point. Let’s look at our last step—the invocation.</font></p>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">INVO<a name="bookmark733"></a>KING A DELEGATE INSTANCE</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is the really easy bit<sup><a name="footnote9"></a><a href="#bookmark734">9</a></sup>—it’s just<a name="bookmark735"></a> a case of calling a method on the delegate instance. The method itself is c<a name="bookmark736"></a>alled </font><font style="font-size:x-small;font-family:Courier New, monospace;">Invoke</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, an<a name="bookmark737"></a>d it’s always present in a delegate type with the same list of parameters and return type that the delegate type declaration specifies. So in our case, there’s a method like this:</font></p>
<p><a name="bookmark738"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Invoke(string input)</font></p>
<p><a name="bookmark739"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Calling </font><font style="font-size:x-small;font-family:Courier New, monospace;">Invoke </font><font style="font-size:x-small;font-family:Times New Roman, serif;">will execute the action of the delegate instance, passing on whatever arguments you’ve specified in the call to </font><font style="font-size:x-small;font-family:Courier New, monospace;">Invoke</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and (if the return type isn’t </font><font style="font-size:x-small;font-family:Courier New, monospace;">void</font><font style="font-size:x-small;font-family:Times New Roman, serif;">) returning the return value of the action.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As simple as this is, C# makes it even easier—if you have a variable<sup><a name="footnote10"></a><a href="#bookmark740">10</a></sup> whose type is a delegate type, you can treat it as if it were a method itself. It’s easiest to see this happening as a chain of events occurring at different times, as shown in figure 2.1.</font></p><div><img src="images/6.png"/>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">Figure 2.1 Processing a call to a delegate instance that uses the C# shorthand syntax</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, that’s simple too. All our ingredients are in place, so we can preheat our CLR to 200°C, stir everything together, and see what happens.</font></p>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;font-variant:small-caps;">A complete example and some motivation</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s easiest to see all this in action in a complete example—finally, something we can actually run! As there are lots of bits and pieces going on, I’ve included the whole source code this time rather than using snippets.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s nothing mind-blowing in the following listing, so don’t expect to be amazed—it’s just useful to have concrete code to discuss.</font></p>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">Listing 2.1 Using delegates in a variety of simple ways</font></p>
<p><a name="bookmark733"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a name="bookmark738"></a>using System;</font></p>
<p><a name="bookmark735"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a name="bookmark736"></a><a name="bookmark737"></a><a name="bookmark739"></a>delegate void StringProcessor(string input); class Person</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Person(string name) { this.name = name; } public void Say(string message)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0} says: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;name, &nbsp;&nbsp;&nbsp;message);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Background {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static void Note(string note)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;({0})&quot;, note);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class SimpleDelegateUse {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person jon = new Person(&quot;Jon&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person tom = new Person(&quot;Tom&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StringProcessor jonsVoice, tomsVoice, background; jonsVoice = new StringProcessor(jon.Say); tomsVoice = new StringProcessor(tom.Say); background = new StringProcessor(Background.Note);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">jonsVoice(&quot;Hello, son.&quot;); tomsVoice.Invoke(&quot;Hello, Daddy!&quot;); background(&quot;An airplane flies past.&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark741"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">To start with, we declare the delegate type O. Next, we create two methods (© and ©)</font></p>
<p><a name="bookmark742"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">that are both compatible with the <a name="bookmark743"></a>delegate type. We have one instance method (Person.Say) and one static method (Background.Note) so that we can see how they’re used differently when we create the delegate instances Q. We’ve cr<a name="bookmark744"></a>eated two insta<a name="bookmark745"></a>nces of the Person class so that we can see the difference that the target of a delegate makes. When jonsVoice is invoked ©, it calls the Say method on the Person object with the name </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Jon</font><font style="font-size:x-small;font-family:Times New Roman, serif;">; likewise, when tomsVoice is invoked, it uses the object with the name </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Tom</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. I’ve included both the ways we’ve seen of invoking delegate instances— calling Invoke explicitly and using the C# shorthand—just for interest’s sake. Normally you’d just use the shorthand. The output for listing 2.1 is fairly obvious:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Jon says: Hello, son.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Tom says: Hello, Daddy!</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(An airplane flies past.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Frankly, there’s an awful lot of code in listing 2.1 to display three lines of output. Even if we wanted to use the Person class and the Background class, there’s no real need to use delegates here. So what’s the point? Why can’t we just call methods directly? The answer lies in our original example of an attorney executing a will—just because you want something to happen, that doesn’t mean you’re always there at the right<a name="bookmark746"></a> time and place to make it happen yourself. Sometimes you need to give instructions—to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">delegate</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> responsibility, as it were.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I should stress that back in the world of software, this isn’t a matter of objects leaving dying wishes. Often the object that first creates a delegate instance is still alive and</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">well when the delegate instance is invoked. Instead, it’s about specifying some code to be executed at a particular time, when you may not be able to (or may not want to) change the code that’s running at that point. If I want something to happen when a button is clicked, I don’t want to have to change the code of the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">button</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—I just want to tell the button to call one of my <a name="bookmark747"></a>methods that’ll take the appropriate action. It’s <a name="bookmark748"></a>a matter of adding a level of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">indirection</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> —as so much of object-oriented programming is. As we’ve seen, this adds complexity (look at how many lines of code it took to produce so little output!) but also flexibility.</font></p>
<p><a name="bookmark749"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark750"></a>Now that we understand more about simple delegates, we’ll take a brief look at combining delegates together to execute a whole bunch of actions instead of just one.</font></p>
<p><a name="bookmark69"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark751"></a>2.1.2 Combining and removing delegates</font></p>
<p><a name="bookmark752"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark753"></a>So far, all the delegate instances we’ve looked at have had a single action. The truth is a bit more complicated: <a name="bookmark754"></a>a delegate instance actually <a name="bookmark755"></a>has a list of actions associated with it. This<a name="bookmark756"></a> is called the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">invocation list</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the delegate instance. The static Combine and Remove methods of the System.Delegate type are responsible for creating new delegate instances by respectively splicing together the invocation lists of two delegate instances or removing the invocation list of one delegate instance from another.</font></p>
<p><a name="bookmark757"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark758"></a><a name="bookmark759"></a><a name="bookmark760"></a>DELEGATES ARE IMMUTABLE Once you’ve created a delegate instance, nothing about it can be changed. This makes it safe to pass around references to delegate instances and combine them with others without worrying about consistency, thread safety, or anyone trying to change their actions. This is the same as with strings, which are also immutable. I mention this because Delegate.Combine is just like String.Concat—they both combine existing instances together to form a new one without changing the original objects at all. In the case of delegate instances, the original invocation<a name="bookmark761"></a> lists are concatenated together. Note that if you ever try to combine null with a delegate instance, the null is treated as if it were a delegate instance with an empty invocation list.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You’ll rarely see an explicit call to Delegate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Combine in C# code—usually the + and += operators are used. Figure 2.2 shows the translation process, where x and y are both variables of the same (or compatible) delegate types. All of this is done by the C# compiler.</font></p><div><img src="images/7.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 2.2 The transform<a name="bookmark762"></a>ation process used for the C# shorthand syntax for combining delegate instances</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see, it’s a straightforward transformation, but it does make the code a lot neater. Just as you can combine delegate instances, you can remove one from another with the Delegate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Remove method, and C# uses the shorthand of the - and -= operators in the obvious way. Delegate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Remove(source, value) creates a new delegate</font></p>
<p><a name="bookmark763"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">whose invocation list is the one from source, with the list from value having been removed. If the resul<a name="bookmark764"></a>t would have an empty invocation list, null is returned.</font></p>
<p><a name="bookmark765"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When a delegate instance is invoked, all its actions are executed in order. If the delegate’s signature has a nonvoid return type, the value returned by Invoke is the value returned by the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">last</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> action executed. It’s rare to see a nonvoid delegate instance with more than one action in its invocation list, because it means the return values of all the other actions are never seen unless t<a name="bookmark766"></a>he invoking code explicitly executes one at a time using Delegate.GetInvocationList to fetch the list of ac<a name="bookmark767"></a>tions.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If any of the actions in the invocation list throws an exception, that prevents any of the subsequent actions from being executed. For example, if a delegate instance with an invocation list [a, b, c] is invoked, and action b throws an exception, then the exception will be propagated immediately and action c won’t be executed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Combining and removing delegate instances is particularly useful when it comes to events. Now that we understand what combining and removing involves, we can sensibly talk about events.</font></p>
<p><a name="bookmark70"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark768"></a><a name="bookmark769"></a>2.1.3 A brief diversion into events</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You probably have an instinctive idea about the overall </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">point</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of events—particularly if you’ve written any UIs. The idea is that an event allows code to react when something happens—saving a file when the appropriate button is clicked, for example. In this case, the event is the clicking of the button, and the action is the saving of the file. Understanding the reason for the concept isn’t the same as understanding how C# defines events in language terms, though.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Developers often confuse events and delegate instances, or events and fields declared with delegate types. The difference is important: </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">events aren’t fields.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <a name="bookmark770"></a>The reason f<a name="bookmark771"></a>or the confusion is that yet again, C# provides a shorthand, in the form of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">field-like events.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> We’ll come to those in a minute, but first let’s consider what events consist of as far as the C# compiler is concerned.</font></p>
<p><a name="bookmark772"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s helpful to think of events as being similar to properties. To start with, both of them are declared to be of a certain type, which in the case of an event is forced to be a delegate type. When you use properties, it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">looks</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> like you’re fetching or assigning values directly to fields, but you’re </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">actually</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> calling methods (getters and setters). The property implementation can do what it likes within those methods—it just happens that most properties are implemented with simple fields backing them, sometimes with some validation in the setter and sometimes with some thread safety thrown in for good measure.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Likewise, when you subscribe to or unsubscribe from an event, it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">looks</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> like you’re using a field whose type is a delegate type, with the += and -= operators. Again, though, you’re actually calling methods (add and remove).<sup><a name="footnote11"></a><a href="#bookmark773">11</a></sup> That’s all you can do with an event—subscribe to it (add an event handler) or unsubscribe from it (remove an event handler). It’s up to the event methods to do something useful—such as taking notice of the event handlers you’re trying to add and remove, and making them available elsewhere within the class.</font></p>
<p><a name="bookmark774"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The reason for having events in the first place is much like th<a name="bookmark775"></a>e reason for having properties—they add a layer of encapsulation, implementing the publish/subscribe pattern (see <a href="http://mng.bz/otVt">http://mng.bz/otVt</a>). Just as you don’t want other code to be able to set field values without the owner at least having the option of validating the new value, you often don’t want code outside a class to be able to arbitrarily change (or call) the handlers for an event. Of course, a class </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> add methods to give extra access—for instance, to reset the list of handlers for an event, or to raise<a name="bookmark776"></a> the event (in other words, call its event handlers). For example, BackgroundWorker.OnProgressChanged just calls the ProgressChanged event handlers. But if you only expose the event itself, code outside the class <a name="bookmark777"></a></font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> has the ability to add and remove handlers.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Field-like events</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> make the implementation of all of this much simpler to look at—a single declaration and you’re done. The compiler turns the declaration into both an event with default add/remove implementations, and a private field of the same type. Code inside the class sees the field; code outside the class only sees the event. This makes it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">look</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as if you can invoke an event—but what you actually do to call the event handlers is invoke the delegate instance stored in the field.</font></p>
<p><a name="bookmark778"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The details of events are outside the scope of this chapter—events themselves haven’t changed much<sup><a name="footnote12"></a><a href="#bookmark779">12</a></sup> in later versions of C#—but I wanted to draw attention to the difference between delegate instances and events now, to prevent confusion later on.</font></p>
<p><a name="bookmark71"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark780"></a>2.1.4 Summary of delegates</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, to summarize what we’ve covered on delegates:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Delegates encapsulate behavior with a particular return type and set of parameters, similar to a single-method interface.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The type signature described by a delegate type declaration determines which methods can be used to create delegate instances, and the signature for invocation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Creating a delegate instance requires a method and (for instance methods) a target to call the method on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Delegate instances are immutable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Delegate instances each contain an invocation list—a list of actions.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Delegate instances can be combined together and removed from each other.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Events aren’t delegate instances—they’re just add/remove method pairs (think property getters/setters).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Delegates are one specific feature of C# and .NET—a detail, in the grand scheme of things. Both of the other “reminder” sections in this chapter deal with much broader topics. First, we’ll consider what it means to talk about C# being a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">statically typed</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> language and the implications that has.</font></p>
<p><a name="bookmark781"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Type system characteristics</font></p><div>
<p><a name="bookmark73"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">2.2</font></p></div><br clear="all"/>
<p><a name="bookmark782"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Almost every programming language has a type system of some kind. Over time, these have been classified as strong/weak, safe/unsafe, static/dynamic, and no doubt some more esoteric variations. It’s obviously important to understand the type system with which one is working, and it’s reasonable to expect that knowing the categories into which a language falls would give a lot of information to help on that front. But because the terms are used by different people to mean somewhat different things, miscommunication is almost inevitable. I’ll try to say </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> what I mean by each term to avoid confusion as much as possible.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One important thing to note is that this section is only appl<a name="bookmark783"></a>icable to “safe” code— which means all C# code that isn’t explicitly within an unsafe context. As you might judge from the name, code within an unsafe context can do various things that safe code can’t, and that may violate some aspects of normal type safety—although the type system is still safe in many other ways. Most developers are unlikely ever to need to write unsafe code, and the characteristics of the type system are far simpler to describe and understand when only safe code is considered.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This section shows what restrictions are and aren’t enforced in C# 1 while defining some terms to describe that behavior. We’ll then see a few things we can’t do with C# 1—first from the point of view of what we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> tell the compiler, and then from the point of view of what we wish we didn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to tell the compiler.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s start off with what C# 1 does, and what terminology is usually used to describe that kind of behavior.</font></p>
<p><a name="bookmark784"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C#’s place in the world of type systems</font></p><div>
<p><a name="bookmark74"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">2.2.1</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s easiest to begin by making a statement, and then clarify what it actually means and what the alternatives might be:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">C# 1 ’s type system is static, explicit, and safe.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You might have expected the word </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">strong</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to appear in the list, and I had half a mind to include it. But though most people can reasonably agree on whether a la<a name="bookmark785"></a>nguage has the listed characteristics, deciding whether a language is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">strongly typed</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> can cause heated debate because the definitions vary so wildly. Some meanings (those preventing any conversions, explicit or implicit) would clearly rule C# out—whereas others are quite close to (or even the same as) </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">statically typed</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which would include C# 1. Most of the articles and books I’ve read that describe C# as a strongly typed language are effectively using it to mean statically typed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s take the terms in the definition one at a time and shed some light on them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">STATIC TYPING VERSUS DYNAMI<a name="bookmark786"></a>C TYPING</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 1 is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">statically typed</font><font style="font-size:x-small;font-family:Times New Roman, serif;">: each variable<sup><a name="footnote13"></a><a href="#bookmark787">13</a></sup> is of a particular type, and that type is known at compile time. Only operations that are known for that type are allowed, and this is enforced by the compiler. Consider this example of enforcement:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object o = &quot;hello&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(o.Length);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As developers looking at the code, we obviously know that the value of o refers to a string, and that the string type has a Length property, but the compiler only thinks of o as being of type obj ect. If we want to get to the Length property, we have to tell the compiler that the value of o actually refers to a string:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object o = &quot;hello&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(((string)o).Length);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler is then able to find the Length property o<a name="bookmark788"></a>f System.String. It uses this to validate that the call is correct, emit the appropriate IL, and also work out the type of the lar<a name="bookmark789"></a>ger expression. The compile-time type of an expression is also known as its static type—so we might say, “The static type of o is System.Object,” for example.</font></p>
<p><a name="bookmark790"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark791"></a>WHY IS IT CALLED </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">STATIC</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> TYPING? The word </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">static</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is used to describe this kind of typing because the analysis of what operations are available is performed using </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">unchanging</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> data: the compile-time types of expressions. Suppose a variable is declared to be of type Stream: the type of the variable doesn’t change even if the value of the variable varies between a reference to a Memory-Stream, a FileStream, or no stream at all (with a null reference). Even within static type systems, there can be some dynamic behavior of course: the actual </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">implementation</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> executed by a virtual method call will depend on the value it’s called on. Although the idea of unchanging information is also the motivation behind the static modifier, it’s generally simpler to think of a static member as one belonging to the type itself rather than any particular instance of the type. For most practical purposes, you can think of the two uses of the word as unrelated.</font></p>
<p><a name="bookmark792"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The alternative to static typing is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">dynamic typing,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which can take a variety of guises. The essence of dynamic typing is that variables just have values—they aren’t restricted to particular types, so the compiler can’t perform the same sort of checks. Instead, the execution environment attempts to understand any given expression in an appropriate manner for the value involved. For example, if C# 1 </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">were</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> dynamically typed, we could do this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">o = &quot;hello&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(o.Length); o = new string[] {&quot;hi&quot;, &quot;there&quot;};</font></p>
<p><a name="bookmark793"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(o.Length);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This would invoke two completely unrelated Length properties—String.Length and Array.Length—by examining the types dynamically at execution time. Like many areas of defining type systems, there are different levels of dynamic typing. Some languages allow you to specify types where you want to—possibly still<a name="bookmark794"></a> treating them dynamically apart from assignment—but let you use untyped variables elsewhere.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although I’ve specified C# 1 repeatedly in this description, C# was entirely statically typed up to and including C# 3. We'll see later that C# 4 introduces some dynamic typing, although the vast majority of code in most C# 4 applications will still use static typing.</font></p>
<p><a name="bookmark795"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark796"></a>EXPLICIT TYPING VERSUS IMPLICIT TYPING</font></p>
<p><a name="bookmark797"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The distinction between </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">explicit typing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">implicit typing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is only relevant in statically typed languages. With explicit typing, the type of every variable must be explicitly stated in the declaration. Implicit typing allows the compiler to infer the type of the variable based on its use. For example, the language could dictate that the type of the variable is the type of the expression used to assign the initial v<a name="bookmark798"></a>alue.</font></p>
<p><a name="bookmark799"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Consider a hypothetical language that uses the keyword var to indicate type infer-ence.<sup><a name="footnote14"></a><a href="#bookmark800">14</a></sup> Table 2.1 shows how code in such a language could be written in C# 1. The code in the left column is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> allowed in C# 1, but the code in the right column is the equivalent valid code.</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Invalid C# 1—implicit typing</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Valid C# 1—explicit typing</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var s = &quot;hello&quot;; var x = s.Length; var twiceX = x * 2;</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string s = &quot;hello&quot;; int x = s.Length; int twiceX = x * 2;</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table 2.1 An example showing the differences between implicit and explicit typing</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Hopefully it’s clear why this is only relevant for statically typed situations: <a name="bookmark801"></a>for both implicit and explicit typing, the type of the variable is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">known</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> at compile time, even if it’s not explicitly stated. In a dynamic context, the variable doesn’t even </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a compile-time type to state or infer.</font></p>
<p><a name="bookmark802"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">TYPE-SAFE VERSUS TYPE-UNSAFE</font></p>
<p><a name="bookmark803"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The easiest way of describing a type-sa<a name="bookmark804"></a>fe syste<a name="bookmark805"></a>m is to describe its opposite. Some languages (I’m thinking particularly of C and C++) allow you to do some really devious things. They’re potentially powerful in the right situations, but with great power comes a free box of donuts, or however the expression goes—and the right situations are relatively rare. Some of these devious things can shoot you in the foot if you get them wrong. Abusing the type system is one of them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With the right voodoo rituals, you can persuade these languages to treat a value of one type as if it were a value of a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">completely</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> different type without applying any conversions. I don’t just mean calling a method that happens to have the same name, as in our dynamic typing example earlier. I mean code that looks at the raw bytes within a value and interprets them in the “wrong” way. The following listing gives a simple C example of what I mean.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 2.2 Demonstrating a type-unsafe system with C code</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">#include &lt;stdio.h&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int main(int argc, char**argv)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">char *first_arg = argv[1];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int *first_arg_as_int = (int *)first_arg;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">printf (&quot;%d&quot;, *first_arg_as_int);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark806"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark807"></a>If you compile listing 2.2 and run it with a sim<a name="bookmark808"></a>ple argument of &quot;hello&quot;, you’ll see a value of 1819043176—at least on a little-endian architecture with a co<a name="bookmark809"></a>mpiler treating int as 32 bits and char as 8 bits, and where text is represented in ASCII or UTF-8. The code is treating the char pointer as an int pointer, so dereferencing it returns the first 4 bytes of text, treating them as a number.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In fact, this tiny example is tame compared with other potential abuses—casting between completely unrelated structs can easily result in total mayhem. It’s not that this happens in real life very often, but some elements of the C typing system often require you to tell the compiler what to do, leaving it no option but to trust you even at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Fortunately, none of this occurs in C#. Yes, there are plenty of conversions available, but you can’t pretend that data for one particular type of object is actually data for a different type. You can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">try</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> by adding a cast to give the compiler this extra (and incorrect) information, but if the compile<a name="bookmark810"></a>r spots that it’s actually </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">impossible</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for that cast to work, it’ll trigger a compilation error—and if it’s theoreti<a name="bookmark811"></a>cally allowed but actually incorrect at execution time, the CLR will throw an exception.</font></p>
<p><a name="bookmark812"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we know a little about how C# 1 fits into the bigger picture of type systems, I’d like to mention a few downsides of its choices. That’s not to say the choices are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">wrong</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—just limiting in some ways. Often language designers have to choose between different paths that add different limitations or have other undesirable consequences. I’ll start with the case where you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">want</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to tell the compiler more information, but there’s no way of doing so.</font></p>
<p><a name="bookmark75"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark813"></a>2.2.2 When is C# 1’s type system not rich enough?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two common situations where you might want to expose more information to the caller of a method, or perhaps force the caller to limit what it provides in its arguments. The first involves collections, and the second involves inheritance and overriding methods or implementing interfaces. We’ll examine each in turn.</font></p>
<p><a name="bookmark814"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">COLLECTIONS, STRONG AND WEAK</font></p>
<p><a name="bookmark815"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark816"></a>Having avoided the terms </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">strong</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">weak</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for the C# type system in general, I’ll use them when talking about collections. They’re used almost everywhere in this context, with little room for ambiguity. Broadly speaking, three kinds of collection types are built into .NET 1.1:</font></p>
<p><a name="bookmark817"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Arrays—strongly typed—which are built into both the language and the runtime</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The weakly typed collections in the<a name="bookmark818"></a> System.Collections namespace</font></p>
<p><a name="bookmark819"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The strongly typed collections in the System.Collections.Specialized namespace</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Arrays are strongly typed,<sup><a name="footnote15"></a><a href="#bookmark820">15</a></sup> so at compile time you can’t set a<a name="bookmark821"></a>n element of a string[ <a name="bookmark822"></a>] to be a FileStream, for instance. But<a name="bookmark823"></a> reference type arrays also support </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">covariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which provides an implicit conversion from one type of array to another, so long<a name="bookmark824"></a> as there’s a conversion between the element types. Checks occur at execution time to make sure that the wrong type of reference isn’t actually stored, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 2.3 Demonstration of the covariance of arrays, and execution time checking</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string[] strings = new string[5];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object[] objects = strings; &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">Applies covariant conversion</font></p>
<p><a name="bookmark825"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">objects[0] = new Button(); &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">Attempts to store a Button reference</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you run listing 2.3, you’ll see that an ArrayTypeMismatchException is thrown </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. This is because the conversion from string [ ] to object [] </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">returns the original reference—both strings and objects refer to the same array. The array itself knows it’s a string array, and will reject attempts to store references to nonstrings. Array covariance is occasionally useful, but comes at the cost of some of the type safety being implemented at execution time instead of compile time.</font></p>
<p><a name="bookmark826"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s <a name="bookmark827"></a>compare this wi<a name="bookmark828"></a>th the situation that the weakly typed collections such as ArrayList and Hashtable put us in. The API of these collections uses object as the type of keys and values. When you write a method that takes an ArrayList, for example, there’s no way of making sure at compile time that the caller will pass in a list of strings. You can document it, and the type safety of the runtime will enforce it if yo<a name="bookmark829"></a>u cast each element of the list to string, but you don’t get compile-time ty<a name="bookmark830"></a>pe safety. Likewise, if you return an ArrayList, you can indicate in the documentation that it’ll just contain strings, but callers will have to trust that you’re telling the truth, and will have to insert casts when they access the elements of the list.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Finally, consider the strongly typed collections such as StringCollection. These provide a strongly typed API, so you can be confident that when you receive a StringCollection as a parameter or return value, it’ll only contain strings, and you don’t need to cast when fetching elements of the c<a name="bookmark831"></a>ollection. It sounds ideal, but there are two problems. First, it implements IList, so you can still </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">try</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to add</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">nonstrings to it (although you’ll fail at execution time). Second, it only deals with strings. There are other specialized c<a name="bookmark832"></a>ollections, but all told they don’t cover much ground. There’s the CollectionBase type, which can be used to build your own strongly typed collections, but that means creating a new collection type for each element type, which is also not ideal.</font></p>
<p><a name="bookmark833"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve seen the problem with collections, let’s consider the issue that can occur when overriding methods and implementing interfaces. It’s related to the idea of covariance, which we’ve already seen with arrays.</font></p>
<p><a name="bookmark834"></a><font style="font-size:x-small;font-family:Times New Roman, serif;font-variant:small-caps;">lack of cov<a name="bookmark835"></a>ariant return types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ICloneable is one of the simplest interfaces in the framework. It has a single method, Clone, which should return a copy of the object that the method is called on. Now, leaving aside the issue of whether this should be a deep or shallow copy, let’s look at the signature of the Clone method:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object Clone()</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s a straightforward signature, certainly—but as I said, the method should return a copy of the object it’s called on. That means it needs to return an object of the same type—or at least a compatible one (where that meaning will vary depending on the type). It would make sense to be able to override the method with a signature that gives a more accurate description of what the method actually returns. For example, in a Person class it’d be nice to be able to implement ICloneable with</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Person Clone()</font></p>
<p><a name="bookmark836"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">That wouldn’t break anything—code exp<a name="bookmark837"></a>ecting any old object would s<a name="bookmark838"></a>till work fine. This feature is called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">return t<a name="bookmark839"></a>ype covariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> but, unfortunately, interface implementation and method overriding don’t support it. Instead, the normal workaround for interfaces is to use </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">explicit interface implementation</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to achieve the desired effect:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Person Clone()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">[Implementation goes here]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object ICloneable.Clone()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return Clone();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Any code that calls Clone () on an expression with a static type of Person will call the top method; if the type of the expression is just ICloneable, it’ll call the bottom method. This works but is really ugly. The mirror image of this situation also occurs with parameters, where if you had an interface or virtual method with a signature of, say, void Process (string x), then it’d seem logical to be able to implement or override <a name="bookmark840"></a>the method with a less demanding <a name="bookmark841"></a>signature, such as void Process (object x). This is called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">parameter type contravariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—and is just as unsupported as return type covariance, <a name="bookmark842"></a>with the same workaround for interfaces and normal overloading for virtual methods. It’s not a showstopper, but it’s irritating.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, C# 1 developers put up with all of these issues for a long time—and Java developers had a similar situation for far longer. Though co<a name="bookmark843"></a>mpile-time type safety is a great feature in general, I can’t remember seeing many bugs where people </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">actually</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> put the wrong type of element in a collection. I can live with the workaroun<a name="bookmark844"></a>d for the lack of covariance and contravariance. But there’s such a thing as elegance and making your cod<a name="bookmark845"></a>e clearly express what you mean, preferably </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">without</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> needing explanatory comments. Even if bugs don’t actually strike, enforcing the documented contract that a collection </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">must</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> only contain strings (for example) can be expensive and fragile in the face of mutable collections. This is the sort of contract you really want the type system itself to enforce.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll see later that C# 2 isn’t flawless either, but it makes large improvements. There are more changes in C# 4, but even so, return type covariance and parameter contravariance are missing.<sup><a name="footnote16"></a><a href="#bookmark846">16</a></sup></font></p>
<p><a name="bookmark76"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark847"></a>2.2.3 &nbsp;&nbsp;&nbsp;Summary of type system characteristics</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this section we’ve learned some of the differences between type systems, and in particular which characteristics apply to C# 1:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;C# &nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;is &nbsp;&nbsp;&nbsp;statically typed—the compiler knows what members to let you &nbsp;&nbsp;&nbsp;use.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;C# &nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;is &nbsp;&nbsp;&nbsp;explicit—you have to state the type of every variable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;C# &nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;is &nbsp;&nbsp;&nbsp;safe—you can’t treat one type as if it were another without &nbsp;&nbsp;&nbsp;the &nbsp;&nbsp;&nbsp;availability &nbsp;&nbsp;&nbsp;of a &nbsp;&nbsp;&nbsp;genuine conversion.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Static typing still doesn’t allow a single collection to be a strongly typed “list of strings” or “list of integers” without a lot of code duplication for different element types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Method overriding and interface implementation don’t allow covariance or contravariance.</font></p>
<p><a name="bookmark848"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark849"></a>Our next section covers one of the most fundamental aspects of C#’s type system beyond its high-level characteristics—the differences between structs and classes.</font></p>
<p><a name="bookmark78"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark850"></a>2.3 &nbsp;&nbsp;&nbsp;Value types and reference types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It would be hard to overstate how important the subject of this section is. Everything you do in .NET will deal with either a value type or a reference type—and yet it’s curiously possible to develop for a long time with only a vague idea of what the difference is. Worse yet, there are plenty of myths to confuse things further. The unfortunate fact is that it’s easy to make a short but incorrect statement that’s close enough to the truth to be plausible but inaccurate enough to be misleading—but it’s relatively tricky to come up with a concise but accurate description.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This section isn’t a complete breakdown of how types are handled, marshalling between application domains, interoperability with native code, and the like. Instead, it’s a brief look at the absolute basics of the topic (as applied to C# 1) that are crucial to understand in order to come to grips with later versions of C#.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll start off by seeing how the fundamental differences between value types and reference types appear naturally in the real world as well as in .NET.</font></p>
<p><a name="bookmark79"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark851"></a>2.3.1 &nbsp;&nbsp;&nbsp;Values and references in the real world</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Suppose you’re reading something fantastic, and want a<a name="bookmark852"></a> friend to read it too. Let’s further suppose that it’s a <a name="bookmark853"></a>document in the public domain, just to avoid any accusations of supporting copyright violation. What do you need to give your friend so that he can read it too? It depends entirely on what you’re reading.</font></p>
<p><a name="bookmark854"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">First we’ll<a name="bookmark855"></a> deal with the case where you have real paper in your hands. To give your friend a copy, you’d need to photocopy all the pages and then give it to him. At that point, he has his own complete copy of the document. In this situation, we’re dealing with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">value type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> behavior. All the information is directly in your hands—you don’t need to go anywhere else to get it. Your copy of the information is also independent of your friend’s after you’ve made the copy. You could add some notes to your pages, and his pages wouldn’t be changed at all.</font></p>
<p><a name="bookmark856"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Compare that with the situation where you’re reading a web page. This time, all you have to give your friend is the URL of the web page. This is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reference type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> behavior, with the URL taking the place of the reference. In order to actually read t<a name="bookmark857"></a>he document, you have to navigate the reference by putting the URL in your browser and asking it to load the page. On the other hand, if the web page changes for some reason (imagine it’s a wiki page and you’ve added your notes to the page), both you and your friend will see that change the next time each of you loads the page.</font></p>
<p><a name="bookmark858"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The differences we’ve seen in the real world form the heart of the distinction between value types and reference types in C# and .NET. Most types in .NET are reference types, and you’re likely to create </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">far</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> more reference t<a name="bookmark859"></a>han value types. The most common cases to know are that cl<a name="bookmark860"></a>asses (declared using class) are reference types, and structures (declared using struct) are value types. The other situations are as follows:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Array types are reference types, even if the element type is a value type (so int[] is still a <a name="bookmark861"></a>reference type, even <a name="bookmark862"></a>though int is a value type).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Enumerations<a name="bookmark863"></a> (declared using enum) are<a name="bookmark864"></a> value types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Delegate types<a name="bookmark865"></a> (declared using delegate)<a name="bookmark866"></a> are reference types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Interface types (declared using interface) are reference types, but they can be implemented by value types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we have a basic idea of what reference types and value types are about, we’ll look at a few of the most important details.</font></p>
<p><a name="bookmark80"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark867"></a>2.3.2 &nbsp;&nbsp;&nbsp;Value and reference type fundamentals</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The key concept to grasp when <a name="bookmark868"></a>it comes to value types and reference types is what the value of a particular expression is. To keep things concrete, I’ll use variables as the</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">most common examples of expressions—but the same thing applies to properties, method calls, indexers, and other expressions.</font></p>
<p><a name="bookmark869"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">As we discussed in section 2.2.1, most expressions have a static type associated with them. The value of a value type expression is the value, plain and simple. For instance, the value of t<a name="bookmark870"></a>he expression “2+3” i<a name="bookmark871"></a>s 5. The value of a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reference</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type expression, though, is a reference. It’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> t<a name="bookmark872"></a>he object that the reference refers to. So, the value of the expression String. Empty is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> an empty string—it’s a reference to an empty string. In everyday discussions and even in documentation, we tend to blur this distinction. For instance, we might describe String.Concat as returnin<a name="bookmark873"></a>g “a string that’s the concatenation of all the parameters.” Using precise terminology here would be time consuming and distracting, and there’s no problem so long as everyone involved understands that only a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reference</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is returned.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To demonstrate this further, consider a Point type that stores two integers, x and y. It could have a constructor that takes the two values. Now, this type could be implemented as either a struct or a class. Figure 2.3 shows the result of executing the following lines of code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Point p1 = new Point(10, 20);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Point p2 = p1;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The left side of figure 2.3 indicates the values involved when Point is a class (a reference type), and the right side shows the situation when Point is a struct (a value type).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In both cases, p1 and p2 have the same value after the assignment. But in the case where Point is a reference type, that value is a reference: both p1 and p2 refer to the same object. When Point is a value type, the value of p1 is the whole of the data for a point—the x and y values. Assigning the value of p1 to p2 copies all of that data.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The values of variables are<a name="bookmark874"></a> stored wherever they’re declared. Local variable values are always stored on the stack,<sup>12</sup> and instance variable values are always stored wherever the ins<a name="bookmark875"></a>tance itself is stored. Reference type instances (objects) are always stored on the heap, as are static variables.</font></p><div><img src="images/8.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup>12</sup> This is only totally true for C# 1. We’ll see later that local variables can end up on the heap in certain situations in later versions.</font></p></div><br clear="all"/><div>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 2.3 Comparing value type and reference type behaviors, particularly with regard to assignment</font></p></div><br clear="all"/>
<p><a name="bookmark876"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Ano<a name="bookmark877"></a>ther difference between the two kinds of type is that value types can’t be derived from. One consequence of this is that the value doesn’t need any extra information about what type that value </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">actually</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is. Compare that with reference types, where each object contains a block of data at the start identifying the actual type of the object, along with some other information. You can <a name="bookmark878"></a>never change the type of an object— when you perform a simple cast, the runtime just takes a reference, checks whether the object it refers to is a valid object of <a name="bookmark879"></a>the desired type, and returns the original reference if it’s valid or throws an exception otherwise. The reference itself doesn’t know the type of the object—so the same reference value can be used for multiple variables of different types. For instance, consider the following code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Stream stream = new MemoryStream();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MemoryStream memoryStream = (MemoryStream) stream;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first line creates a new MemoryStream object and sets the value of the stream variable to be a reference to that new object. The second line checks whether the value of stream refers to a MemoryStream (or derived type) object and sets the value of memory-Stream to be the same as stream.</font></p>
<p><a name="bookmark880"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Once you understand these basic points, you can apply them when thinking about some of the falsehoods that are often stated about value types and reference types.</font></p>
<p><a name="bookmark81"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark881"></a>2.3.3 Dispelling myths</font></p>
<p><a name="bookmark882"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Various myths do the rounds on a regular basis. I’m sure the misinformation is almost always passed on with no malice and with no idea of the inaccuracies involved, but it’s unhelpful nonetheless. In this section I’ll tackle the most prominent myths, explaining the true situation as I go.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">MYTH #1: “STRUCTS ARE LIGHTWEIGHT CLASSES”</font></p>
<p><a name="bookmark883"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This myth comes in a variety of forms. Some people believe that value types can’t or shouldn’t have methods or other significant behavior—they should be used <a name="bookmark884"></a>as simple data transfer types, with just public fields or simple properties. The DateTime type is a good counterexample to this: it makes sense for it to be a value type, in terms of being a fundamental unit like a number or a character, and it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> makes sense for it to be able to perform calculations <a name="bookmark885"></a>to do with its value. Looking at things from the other direction, data transfer types should often be reference types <a name="bookmark886"></a>anyway—the decision should be based on the desired value or reference type semantics, not the simplicity of the type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Other pe<a name="bookmark887"></a>ople believe that value types are “lighter” than reference types in terms of performance. The truth is that in </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">some</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> cases value types are more performant—they don’t require garbage collection unless they're boxed, don’t have the type identification overhead, and don’t require dereferencing, for example. But in other ways reference types are more performant—parameter passing, assigning values to variables, returning values, and similar operations only require 4 or <a name="bookmark888"></a>8 bytes to be copied (depending on whether you’re running the 32-bit or 64-bit CLR) rather than copying </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the data. Imagine if ArrayList were somehow a “pure” value type, and passing an</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ArrayList expression to a method involved copying all its data! In almost all ca<a name="bookmark889"></a>ses, performance isn’t really determined by this sort of decision anyway. Bottlenecks are almost never where you think they’ll be, and before you make a design decision based on performance, you should measure the different options.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth noting that the combination of the two beliefs doesn’t work either: it doesn’t <a name="bookmark890"></a>matter how many methods a type has (whether it's a class or a struct)—the memory taken per instance isn’t affected. (There’s a cost in terms of the memory taken up for the code itself, but that’s incurred once rather than for each instance.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">MYTH #2: “REFERENCE TYPES LIVE ON THE HEAP; VALUE TYPES LIVE ON THE STACK”</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This one is often caused by laziness on the part of the person repeating it. <a name="bookmark891"></a>The first part is correct—an instance of a reference type is always created o<a name="bookmark892"></a>n the heap. It’s the second part that causes problems. As I’ve already noted, a variable’s value lives wherever it’s declared—so if you have a class with an instance variable of type int, that variable’s value for any given object will always be where the rest of the data for the object is—on the heap. Only local variables (variables declared within methods) <a name="bookmark893"></a>and method parameters live<a name="bookmark894"></a> on the stack. In C# 2 and later, even some local variables don’t really live on the stack, as we’ll see when we look at anonymous methods in chapter 5.</font></p>
<p><a name="bookmark895"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">ARE THESE<a name="bookmark896"></a> CONCEPTS RELEVANT NOW? It’s arguable that if you’re writing managed code, you should let the runtime worry about how memory is best used. Indeed, the language specification makes no guarantees about what lives where; a future runtime may be able to create some objects on the stack if it knows it could get away with it, or the C# compiler could generate code that hardly uses the stack at all.</font></p>
<p><a name="bookmark897"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The next myth is usually just a terminology issue.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">MYTH #3: “OBJECTS ARE PASSED BY REFERENCE IN C# BY DEFAULT”</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is probably the most widely propagated myth. Again, the people who make this claim often (though n<a name="bookmark898"></a>ot always) know how C# actually behaves, but they don’t know what “pass by reference” really means. Unfortunately, this is confusing for people who </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> know what it mean<a name="bookmark899"></a>s. The formal definition of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">pa<a name="bookmark900"></a>ss by reference</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is relatively complicated, involving </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">l-values</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and similar computer science terminology, but the important thing is that if you pass a variable by reference, the method you’re calling can change the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">value of the caller’s variable</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> by changing its parameter value. Now remember that the value of a reference type variable is the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reference,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> not the object itself. You can change the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">contents</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the object that a parameter refers to without the parameter itself being passed by reference. For instance, the following method changes the contents of the StringBuilder object in question, but the caller’s expression will still refer to the same object as before:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void AppendHello(StringBuilder builder)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">builder.Append(&quot;hello&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When this method is called, the parameter value (a reference to a StringBuilder) is passed by value. If I were to change the value of the builder variable within the method—for example, with the statement builder = null;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">—that</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> change wouldn’t be seen by the caller, contrary to the myth.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s interesting to note<a name="bookmark901"></a> that not only is the “by reference” bit of the myth inaccurate, but so is the “objects are passed” bit. Objects themselves are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">never</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> passed, either by reference or by value. When a reference type is involved, either the variable is passed by reference or the value of the argument (the reference) is passed by val<a name="bookmark902"></a>ue. Aside from anything else, this answers the question of what happens when null is used as a by-value argument—if objects were being passed around, that would cause issues, as there wouldn’t be an object to pass! Instead, the null reference is passed by value in the same way as any other reference would be.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If this quick explanation has left you bewildered, you might want to look at the article on my main C# website (<a href="http://mng.bz/otVt">http://mng.bz/otVt</a>), which goes into much more detail.</font></p>
<p><a name="bookmark903"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark904"></a>These myths aren’t the only ones around. Boxing and unboxing come in for their fair share of misunderstanding, which I’ll try to clear up next.</font></p>
<p><a name="bookmark82"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark905"></a>2.3.4 Boxing and unboxing</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Sometimes, you just don’t want a value type value. You want a reference. There are any number of reasons why this can happen, and fortunately C# and .NET provide a mechanism called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">boxing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that lets you create an object from a value type value and use a reference to that new object. Before we leap straight into an example, let’s start off by reviewing two important facts:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The value of a reference type variable is always a reference.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The value of a value type variable is always a value of that type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Given those two facts, the following three lines of code don’t seem to make much sense at first glance:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int i = 5; object o = i; int j = (int) o;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We have two variables: i is a value type variable, and o is a reference type variable. How does it make sense to assign the value of i to o? The value of o has to be a reference, and the number 5 isn’t a reference—it’s an integer value. What’s actually happening is boxing: the runtime creates an object (on the heap—it’s a normal object) that contains the value (5).<a name="bookmark906"></a> The value of o is then a reference to that new object. The value in the object is a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">copy</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the original value—changing the value of i won't change the value in the box at all.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The third line performs the reverse operation— </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">unboxing</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. We have to tell the compiler which type to unbox the object as, and if we use the wrong type (if it’s a box<a name="bookmark907"></a>ed uint or long, for example, or not a boxed value at all), an InvalidCastException is thrown. Again, unboxing copies the value that was in the box: after the assignment, there's no further association between j and the object.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s it, really—boxing and unboxing in a nutshell. The only remaining problem is knowing when boxing and unboxing occur. Unboxing is usually obvious, because the cast is present in the code. Boxing can be mor<a name="bookmark908"></a>e subtle.<a name="bookmark909"></a> We’ve seen the s<a name="bookmark910"></a>imple version, but it can also occur if you call the ToString, Equals, or GetHashCode methods on the value of a type that doesn’t override them,<sup><a name="footnote17"></a><a href="#bookmark911">17</a></sup> or if you use the value as an interface expression—assigning it to a variable whose type is an interface type or passing it as the value for a parameter with an interface type. For example, the statement IComparable x = 5; would box the number 5.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth being aware of boxing and unboxing because of the potential performance penalty involved. A single box or unbox operation is cheap, but if you perform hundreds of thousands of them, you not only have the cost of the o<a name="bookmark912"></a>peration itself, but you’re also creating a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lot</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <a name="bookmark913"></a>of objects, which gives the garbage collector more work to do. Again, this performance hit isn’t usually an issue, but it’s worth being aware of so you can measure the effect if you’re concerned.</font></p>
<p><a name="bookmark83"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark914"></a>2.3.5 Summary of value types and reference types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this section we’ve looked at the differences between value types and reference types, as well as some of the myths surrounding them. Here are the key points:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The value of a reference type expression (a variable, for example) is a reference, not an object.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;References are like URLs—they’re small pieces of data that let you access the real information.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The value of a value type expression is the actual data.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;There are times when value types are more efficient than &nbsp;&nbsp;&nbsp;reference &nbsp;&nbsp;&nbsp;types, &nbsp;&nbsp;&nbsp;and</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">vice versa.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Reference type objects are always on the heap, but value &nbsp;&nbsp;&nbsp;type values &nbsp;&nbsp;&nbsp;can be on</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">either the stack or the heap, depending on context.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;When a reference type is used as a method parameter, by default the argument is passed </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">by value</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—but the value itself is a reference.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Value type values are boxed when reference type behavior is needed; unboxing is the reverse process.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve had a look at all the bits of C# 1 that you need to be comfortable with, it’s time to take a quick look forward and see where each of the features will be enhanced by the later versions.</font></p>
<p><a name="bookmark85"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark915"></a>2.4 Beyond C# 1: new features on a solid base</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The three topics covered in this chapter are all vital to all versions of C#. Almost all the new features relate to at least one of them, and they change the balance of how</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">the language is used. Before we wrap up the chapter, let’s explore how the new features relate to the old ones. I’m not going to give many details (for some reason the publisher didn’t want a single 600-page section), but it’s helpful to have an idea of where these areas are going before we get to the nitty-gritty. We’ll look at them in the same order as we covered them earlier, starting with delegates.</font></p>
<p><a name="bookmark916"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Features related to delegates</font></p>
<p><a name="bookmark917"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Delegates of all kinds get a boost in C# 2, and then they’re given even more special treatment in C# 3. Most of the features aren’t new to the CLR, but are clever compiler tricks to make delegates work more smoothly within the language. The changes affect not just the syntax we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use, but the appearance and feeling of idiomatic C# code. Over time, C# is gaining a more functional approach.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 1 has pretty clumsy syntax when it comes to creating a delegate instance. For one thing, even if you need to accomplish something straightforward, you have to write a whole separate method dedicated to that job in order to create a delegate instance for it. C# 2 fixes this with anonymous methods, and introduces a simpler syntax for the cases where you still want to use a normal method to provide the actio<a name="bookmark918"></a>n for the del<a name="bookmark919"></a>egate. You can also create delegate instances using methods with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">compatible</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> sig-natures—the method signature no longer has to be exactly the same as the delegate’s declaration.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The following listing demonstrates all these improvements.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 2.4 Improvements in delegate instantiation brought in by C# 2</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void HandleDemoEvent(object sender, EventArgs e)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Handled by HandleDemoEvent&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">EventHandler handler;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">handler = new EventHandler(HandleDemoEvent); handler(null, EventArgs.Empty);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">handler = HandleDemoEvent; handler(null, EventArgs.Empty);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">handler = delegate(object sender, EventArgs e)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Handled anonymously&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">handler(null, EventArgs.Empty); handler = delegate {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Handled anonymously again&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">handler(null, EventArgs.Empty);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MouseEventHandler mouseHandler = HandleDemoEvent; mouseHandler(null, new MouseEventArgs(MouseButtons.None,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">0, 0, 0, 0));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first part of the main code </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is just C# 1 code, kept for comparison. The remaining delegates<a name="bookmark920"></a> all use new features of C# 2. Method group conversions </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">make event subscription code read a lot more pleasantly—lines such as saveButton.Click += SaveDocumen<a name="bookmark921"></a>t; are straightforward, with no extra fluff to distract the eye. The anonymous method syntax </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">G </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is a little cumbersome, but does allow the action to be clear at the point of creation, rather than being another method to look at before you understand what’s going on. A shortcut is available when using anonymous methods </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, but this form can only be used when you don’t need the parameters. Anonymous methods have other powerful features as well, but we’ll see those later.</font></p>
<p><a name="bookmark922"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark923"></a><a name="bookmark924"></a>The final delegate instance created </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is an instance of MouseEventHandler rather than just EventHandler—but the HandleDemoEvent method can sti<a name="bookmark925"></a>ll be used due to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">contravariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, w<a name="bookmark926"></a>hich specifies parameter compatibility. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Covariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> specifies return type com<a name="bookmark927"></a>patibility. We’ll be looking at both of these in more detail in chapter 5. Event handlers are probably the biggest beneficiaries of this, as suddenly the Microsoft guideline to make all delegate types used in events follow the same convention makes a lot more sense. In C# 1, it didn’t matter whether two different event handlers looked quite similar—you had to have a method with an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> matching signature in order to create a delegate instance. In C# 2, you may find yourself able to use the same method to handle many different kinds of events, particularly if the purpose of the method is fairly event independent, such as logging.</font></p>
<p><a name="bookmark928"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 3 provides special syntax for instantiating delegate types, using </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lamb<a name="bookmark929"></a>da expressions.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> To demonstrate these, we’ll use a new delegate type. As part of the CLR gaining generics in .NET 2.0, generic delegate types beca<a name="bookmark930"></a>me available and were used in a number of API calls in generic collections. But .NET 3.<a name="bookmark931"></a>5 takes things a step further, introducing a group of generic delegate types called Func that all take a number of parameters of specified types and return a value of another specified type. The following listing gives an example of the use of a Func delegate type as well as lambda expressions.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 2.5 Lambda expressions, which are like improved anonymous methods</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;int,int,string&gt; func = (x, y) =&gt; (x * y).ToString(); Console.WriteLine(func(5, 20));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Func&lt;int,int,string&gt; is a delegate type that takes two integers and returns a string. The lambda expression in listing 2.5 specifies that the delegate instance (held in func) should multiply the two integers together and call ToString(). The syntax is much more straightforward than that of anonymous methods, and there are other benefits in terms of the amount of type inference the compiler is prepared to perform for you. Lambda expressions are absolutely crucial to LINQ, and you should get ready to make them a core part of your language toolkit. They’re not restricted to working with LINQ, though—any use of anonymous methods from C# 2 can use lambda expressions in C# 3, and that will almost always lead to shorter code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To summarize, the new features related to delegates are as follows:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Generics (generic delegate types)</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 2</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Delegate instance creation expressions</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 2</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Anonymous methods</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 2</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Delegate covariance/contravariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 2</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Lambda expression</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 3</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Additionally C# 4 allows </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">generic</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> covariance and contravariance for delegates, which goes beyond what we’ve just seen. Indeed, generics form one of the principle enhancements to the type system, which we’ll look at next.</font></p>
<p><a name="bookmark87"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark932"></a>2.4.2 Features related to the type system</font></p>
<p><a name="bookmark933"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark934"></a>The primary new feature in C# 2 regarding the type system is the inclusion of generics. It largely addresses the issues I raised in section 2.2.2 about strongly typed collections, although generic types are useful in a number of other situations, too. As a feature, it’s elegant, it solves a real problem, and despite a few wrinkles it generally works well. We’ve seen examples of this in quite a few places already, and it’s described fully in the next chapter, so I won’t go into any more details here. It’ll be a brief reprieve, though—generics form probably the most important feature in C# 2 with respect to the type system, and you’ll see generic types throughout th<a name="bookmark935"></a>e rest of the book.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C<a name="bookmark936"></a># 2 doesn't tackle the issues of return type covariance and parameter contravari-ance for overriding members or implementing interfaces. But it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> improve the situation for delegate instance creation in certain situations, as we saw in section 2.4.1.</font></p>
<p><a name="bookmark937"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark938"></a>C# 3 introduces a wealth of new concepts in the type sy<a name="bookmark939"></a>stem, most notably </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">anonymous types, implicitly typed local variables,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extension methods.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Anonymous types themselves are mostly present for the sake of LINQ, where it’s useful to be able to effectively create a data transfer type with a bunch of read-only properties without having to actually write the code for them. There’s nothing to stop them from being used outside LINQ, though, which makes life easier for demonstrations. Listing 2.6 shows both features in action.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 2.6 Demonstration of anonymous types and implicit typing</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var jon = new { Name = &quot;Jon&quot;, Age = 31 }; var tom = new { Name = &quot;Tom&quot;, Age = 4 };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;{0} is {1}&quot;, jon.Name, jon.Age);</font></p>
<p><a name="bookmark940"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;{0} is {1}&quot;, tom.Name, tom.Age);</font></p>
<p><a name="bookmark941"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The first t<a name="bookmark942"></a>wo lines each show implicit typing (the use of var) and anonymous object initializers (the new {...} bit), which create instances of anonymous types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two things worth noting at this stage, long before we get into the details—points that have <a name="bookmark943"></a>caused people to worry needlessly before. The first is that C# 3 is still statically typed. The C# compiler has &nbsp;&nbsp;&nbsp;declared jon &nbsp;&nbsp;&nbsp;and &nbsp;&nbsp;&nbsp;tom &nbsp;&nbsp;&nbsp;to &nbsp;&nbsp;&nbsp;be of a particular type, just as normal, and when we use the &nbsp;&nbsp;&nbsp;properties &nbsp;&nbsp;&nbsp;of the objects &nbsp;&nbsp;&nbsp;they’re nor</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">mal properties—no dynamic lookup is going on. It’s just that we (as source code</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">authors) couldn’t tell the compiler what type to use in the variable declaration because the compiler will be generating the type itself. The properties are also statically typed—here the Age property is of type int, and the Name property of type string.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The second point is that we haven’t created two different anonymous types here. The variables j<a name="bookmark944"></a>on and tom both have the same type because the compiler uses the property names, types, and order to work out that it can generate just one type and use it for both statements. This is done on a per-assembly basis, and makes life a lot simpler in terms of being able to assign the value of one variable to another (for example, jon = tom; w<a name="bookmark945"></a>ould be permitted in the previous code) and similar operations.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Extension methods are also there for the sake of LINQ but can be useful outside it. Think of all the times you’v<a name="bookmark946"></a>e wished that a <a name="bookmark947"></a>framework type had a certain method, and you’ve had to write a static utility method to implement it. For instance, to create a new string by reversing an existing one, you might write a static StringUtil .Reverse method. Well, the extension method feature effectively lets you call that static method as if it existed on the string type itself, so you could write</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string x = &quot;dlrow olleH&quot;.Reverse();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Exte<a name="bookmark948"></a>nsion methods also let y<a name="bookmark949"></a>ou appear to add methods with implementations to inter-faces—and that’<a name="bookmark950"></a>s what LINQ relies on heavily, allowing calls to all kinds of methods on IE<a name="bookmark951"></a>numerable&lt;T&gt; that have never previously existed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C#<a name="bookmark952"></a> 4 ha<a name="bookmark953"></a>s two features r<a name="bookmark954"></a>ela<a name="bookmark955"></a>ted to the type system. A relatively minor feature is covariance and <a name="bookmark956"></a>contravariance <a name="bookmark957"></a>for generic delegates and interfaces. This has been present in the CLR since .NET 2.0 came out,<a name="bookmark958"></a> but only with the introduction of C# 4 (and updates to the generic types in the BCL) has it become usable for C# developers. A far bigger feature—although one <a name="bookmark959"></a>many coders may never need—is dynamic typing in C#.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Remember the introduction I gave to static typing, where I tried to use the Length property of an array and a string via the same variable? Well in C# 4, it works—when you want it to. The following listing shows the same code except for the variable declaration, but working as valid C# 4 code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 2.7 Dynamic typing in C# 4</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">dynamic </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">o = &quot;hello&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(o.Length);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">o = new string[] {&quot;hi&quot;, &quot;there&quot;};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(o.Length);</font></p>
<p><a name="bookmark960"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">By declaring<a name="bookmark961"></a> the variable o as having a static type of dynamic (yes, you read that right), the<a name="bookmark962"></a> compiler handles almost everything to do with o differently, leaving all the binding decisions (such as what Length means) until execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Obviously we’re going to look at dynamic typing in greater depth, but I want to stress now that C# 4 is still a statically typed language for the most part. Unless you’re using the dynamic type (which acts as a static type denoting a dynamic value), everything works exactly the same way as before. Most C# developers will only rarely need dynamic typing, and for the rest of the time they can ignore it. When dynamic typing</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> handy, it can be really slick—and of course it lets you play nicel<a name="bookmark963"></a>y with code written in dynamic languages running on the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Dynamic Language Runtime (DLP).</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> I’d just advise you not to s<a name="bookmark964"></a>tart using C# as a primarily dynamic language. If that’s what you want, use IronPython or something similar; languages which are designed to su<a name="bookmark965"></a>pport dynamic typing from the ground up are likely to have fewer unexpected gotchas.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here’s the quick-view list of these features, along with which version of C# they’re introduced in:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Generics</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 2</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Limited delegate covariance/contravariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 2</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Anonymous types</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 3</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Implicit typing</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 3</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Extension methods</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 3</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Limited</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> generic </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">covariance/contravariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 4</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Dynamic typing</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 4</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">After that fairly diverse set of features on the type system in general, let’s look at the features added to one specific part of typing in .NET—value types.</font></p>
<p><a name="bookmark88"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark966"></a>2.4.3 Features related to value types</font></p>
<p><a name="bookmark967"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are only tw<a name="bookmark968"></a>o features to talk about here, both introduced in C# 2. The first goes back to generics yet again, and in particular collections. One common complaint about using value types in collections with .NET 1.1 was that due to all of the “general-purpose” APIs being specified in terms of the object type, every operation that added a struct value to a collection would involve boxing it, and when retrieving it you’d have to unbox it. While boxing is pretty cheap for an individual call, it can cause a significant performance hit when it’s used every time with frequently accessed collections. It also takes more memory than it needs to, due to the per-object overhead. Generics fix both the speed and memory deficiencies by using the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">real</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type involved rather than just a general-purpose object. As an example, it wou<a name="bookmark969"></a>ld’ve been madness to read a file and store each byte as an element in an ArrayList in .NET 1.1—but in .NET 2.0 it wouldn’t be crazy to do the same with a List&lt;byte&gt;.</font></p>
<p><a name="bookmark970"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark971"></a>The second feature addresses another common cause o<a name="bookmark972"></a>f complaint, pa<a name="bookmark973"></a>rticularly when talking to databases—the fact that you can’t assign null to a value type variable. There’s no such concept as an int value of null, for instance, even though a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">database </font><font style="font-size:x-small;font-family:Times New Roman, serif;">integer field may well be nullable. At that point it can be hard to model the database table within a statically typed class without ugliness of some form or another. Nullable types are part of .NET 2.0, and C# 2 includes extra syntax to make them easy to use. The following listing gives a brief example of this.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 2.8 Demonstration of a variety of nullable type features</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int? x = null; x = 5;</font></p><div>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null;</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (x != null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int y = x.Value; Console.WriteLine(y);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int z = x ?? 10;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 2.8 shows a number of the features of nullable types and the shorthand that C# provides for working with them. We’ll get around to the details of each feature in chapter 4, but the important point is how much easier and cleaner all of this is than any of the alternative workarounds that have been used in the past.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The list of enhancements is smaller this time, but they’re important features in terms of both performance and elegance of expression:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Generics</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 2</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Nullable types</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—C# 2</font></p>
<p><a name="bookmark90"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark974"></a>2.5 Summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This chapter has mostly been a revision exercise for C# 1. The aim wasn’t to cover any one topic in its entirety, but merely to get everyone on the same page so that I can describe the later features without worrying about the ground that I’m building on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All of the topics we’ve covered are core to C# <a name="bookmark975"></a>and .NET, but I’ve seen a lot of misunderstandings around them within community discussions. Although this chapter hasn’t gone into much depth about any one point, it’ll hopefully have cleared up any confusion that would’ve made the rest of the book harder to understand.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The three core topics we’ve briefly covered in this chapter have all been significantly enhanced since C# 1, and some features touch on more than one topic. In particular, generics has an impact on almost every area we’ve covered in this chapter—it’s probably the most widely used and important feature in C# 2. Now that we’ve finished all our preparations, we can start looking at it properly in the next chapter.</font></p>
<p><a name="bookmark976"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Part 2</font></p>
<p><a name="bookmark91"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark977"></a>C# 2: solving the issues of C# 1</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">i part 1 we took a quick look at a few of the features of C# 2. Now it’s time to</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">do the job properly. We’ll see how C# 2 fixes various problems that developers ran into when using C# 1, and how C# 2 makes existing features more useful by streamlining them. This is no mean feat, and life with C# 2 is much more pleasant than with C# 1.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The new features in C# 2 have a certain amount of independence. That’s not to say they’re not related at all; many of the features are based on—or at least interact with—the massive contribution that generics make to the language. But the different topics we’ll look at in the next five chapters don’t combine into one “super feature.”</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first four chapters of this part cover the biggest new features. We’ll look at the following:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Generics</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—The most important new feature in C# 2 (and indeed in the CLR for .NET 2.0), generics allow type and method parameterization in terms of the types they interact with.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Nullable types</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Value types such as int and DateTime don’t have any concept of “no value present”; nullable types allow you to represent the absence of a meaningful value.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Delegates</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Although delegates haven’t changed at the CLR level, C# 2 makes them a lot easier to work with. In addition to a few simple shortcuts, the introduction of anonymous methods begins the movement toward a more functional style of programming—a trend that continues in C# 3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Iterators</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Though using iterators has always been simple in C# with the foreach statement, it’s a pain to implement them in C# 1. The C# 2 compiler is happy to build a state machine for you behind the scenes, hiding a lot of the complexity involved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Having covered the major, complex new features of C# 2 with a chapter dedicated to each one, chapter 7 rounds off our coverage by introducing several simpler features. Simpler doesn’t necessarily mean less useful: partial types in particular are crucial for better designer support in versions of Visual Studio from 2005 onward. The same feature is beneficial for other generated code, too. Likewise many C# developers take the ability to write a property with a public getter and a private setter for granted these days—but it was only introduced in C# 2.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When the first edition of this book was published, many developers still hadn’t used C# 2 at all. My impression in 2010 is that it’s rare to find someone who’s currently using C#, but hasn’t at least dabbled with C# 2 and probably 3. The topics covered here are fundamental to how C# 3 and 4 work; in particular, attempting to learn about LINQ without understanding generics and iterators would be tricky. If you’ve been using C# 2 and upward for a while, you may find a lot of this part covers familiar ground—but I suspect you’ll still benefit from a deeper knowledge of the details presented.</font></p>
<p><a name="bookmark5"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark978"></a><a name="bookmark979"></a>Parameterized typing with generics</font></p>
<p><a name="bookmark980"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">■</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> &nbsp;&nbsp;&nbsp;Understanding generic types and methods</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Type inference for generic methods</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Type constraints</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Reflection and generics</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;CLR behavior</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Limitations of generics</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Comparisons with other languages</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">True<sup><a name="footnote18"></a><a href="#bookmark981">18</a></sup> story: The other day my wife and I did our weekly grocery shopping. Just before we left, she asked me if I had the list. I confirmed that I </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">did</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have the list, and off we went. It was only when we got to the grocery store that our mistake made itself obvious. My wife had been asking about the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">shopping</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> list whereas I’d actually brought the list of neat features in C# 2. When we asked an assistant whether we could buy any anonymous methods, we received a strange look.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If only we could’ve expressed ourselves more clearly! If only she’d had some way of saying that she wanted me to bring the list of items we wanted to buy! If only we’d had generics...</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For most developers, generics will be the most important new feature of C# 2. They enhance performance, make your code more expressive, and move a lot of safety from execution time to compile time. Essentially, they allow you to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">parameterize</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> types and methods. Just as normal method calls often have parameters to tell them what </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">values</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to use, generic types and methods have type parameters to tell them what </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">types</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to use. It all sounds confusing to start with—and if you’re completely new to generics, you can expect a certain amount of head scratching—but once you’ve got the basic idea, you’ll come to love them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this chapter we’ll be looking at how to use generic types and methods that others have provided (whether in the framework or as third-party libraries), and how to write your own. Along the way, we’ll look at how generics work with the reflection calls in the API, as well as a bit of detail around how the CLR handles generics. To conclude the chapter, I’ll present some of the most frequently encountered limitations of generics, along with possible workarounds, and compare generics in C# with similar features in other languages.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First, though, we need to understand the problems that caused generics to be devised in the first place.</font></p>
<p><a name="bookmark94"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark982"></a>3.1 Why generics are necessary</font></p>
<p><a name="bookmark983"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark984"></a>If you still have any C# 1 c<a name="bookmark985"></a>ode available, look at it and count the casts—particularly i<a name="bookmark986"></a>n code that uses collectio<a name="bookmark987"></a>ns extensively. Don’t forget that almost every use of foreach contains an implicit cast. When you use types that are designed to work with many different types of data, that naturally leads to casting, quietly telling the compiler not to worry, that everything’s fine, just treat the expr<a name="bookmark988"></a>ession over there as if it had </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">this</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> particular type. Using almost any API that has obj ect as either a parameter type or a return type will probably involve casts at some point. Having a single-class hierarchy with object as the root makes some things more straightforward, but the object type in itself is extremely dull, and in order to do anything genuinely useful with an object you almost always need to cast it.</font></p>
<p><a name="bookmark989"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Casts are bad, m’kay? Not bad in an “almost never do this” kind of way (like mutable structs and nonprivate fields) but bad in a “necessary evil” kind of way. They’re an indication that you ought to give the compiler more information somehow, and that you’re choosing to ask the compiler to trust you at compile time and generate a check to run at execution time, to keep you honest.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now, if you need to tell the compiler the information somewhere, chances are that anyone </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reading</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> your code is also going to need the same information. They can see it where you’re casting, of course, but that’s not terribly useful. The ideal place to keep such information is usually at the point of declaring a variable or method. This is even more important if you’re providing a type or method that other people will call</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">without access to your code.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Generics allow library providers to prevent their users from compiling code that calls the libr<a name="bookmark990"></a>ary with bad arguments. In C# 1, we had to rely on manually written documentation —which can easily become incomplete or inaccurate, as duplicate information so often is. When the extra information can be declared in code as part of a method or type declaration, everyone can work mo<a name="bookmark991"></a>re productively. The compiler can do more checking; the IDE can present IntelliSense options based on the extra information (for instance, offering the members of string as the next step when you access an elem<a name="bookmark992"></a>ent within a list of strings); callers of methods can be more confident of correctness in terms of arguments passed in and values returned; and anyone maintaining your code can better understand what was running through your head when you originally wrote it.</font></p>
<p><a name="bookmark993"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark994"></a>WILL GENERICS REDUCE YOUR BUG COUNT? Every description of generics I’ve read (including my own) emphasizes the importance of compile-time type checking over execution-time type checking. I’ll let you in on a secret: I can’t remember ever fixing a bug in released code that was directly due to the lack of type checking. In other words, the casts we put in C# 1 code always worked, in my experience. <a name="bookmark995"></a>Those casts were like warning signs, forcing us to think about the type safety explicitly rather than it flowing naturally in the code we write. Although generics may not radically re<a name="bookmark996"></a>duce the number of type safety bugs you encounter, the greater readability afforded can reduce the number of bugs across the board. Code that’s simp<a name="bookmark997"></a>le to understand is simple to get right. Likewise code which has to be robust in the face of malicious callers is much simpler to write correctly when the type system can provide appropriate guarantees.</font></p>
<p><a name="bookmark998"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">All of this would be enough to make generics worthwhile—but there are performance improvements, too. First, as the compiler can perfor<a name="bookmark999"></a>m more enforcement, that leaves less to be checked at execution time. Second, the <a name="bookmark1000"></a>JIT can treat v<a name="bookmark1001"></a>alue types in a particularly clever way that manages to eliminate boxing and unboxing in many situations. In some cases, t<a name="bookmark1002"></a>his can make a huge difference to performance in terms of both speed and memory consumption.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Many of the benefits of generics may strike you as being similar to the be<a name="bookmark1003"></a>nefits of statically typed languages over dynamic ones: better <a name="bookmark1004"></a>compile-time checking, more information expressed directly in the code, more IDE support, better performance. The reason for this is fairly simple: when you’re using a general API (for example, ArrayList) that can’t differentiate between the different types, you effectively </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in a dynamic situation in terms of access to that API. The reverse isn’t generally true, by the way—the benefits that dynamic languages provide rarely apply to the choice between generic/nongeneric APIs. When you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> reasonably use generics, the decision to do so is usually a no-brainer.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, those are the goodies awaiting us in C# 2—now it’s time to actually start using generics.</font></p>
<p><a name="bookmark1005"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Simple generics for everyday use</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The topic of generics has a lot of dark corners if you want to know </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">everything</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> about it. The C# language specification goes into a great deal of detail in order to make sure that the behavior is specified in pretty much every conceivable case. But we don’t need to understand most of those corner cases in order to be productive. (The same is true in other areas, in fac<a name="bookmark1006"></a>t. For example, you don’t need to know all the exact rules about definite assignment—you just fix the code appropriately when the compiler complains.)</font></p><div>
<p><a name="bookmark96"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">3.2</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This section will cover most of what you’ll need in your day-to-day use of generics, both consuming generic APIs that other people have created and creating your own. If you get stuck while reading this chapter but want to keep making progress, I suggest you concentrate on what you need to know in order to use generic types and methods within the framework and other libraries; writing your own generic types and methods crops up a lot less often than using the framework ones.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll start by looking <a name="bookmark1007"></a>at one of the collection classes introduced in .NET 2.0— Dictionary&lt;TKey,TValue&gt;.</font></p>
<p><a name="bookmark1008"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Learning by examp<a name="bookmark1009"></a>le: a generic dictionary</font></p><div>
<p><a name="bookmark97"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">3.2.1</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Using generic types can be straightforward if you don’t happen to hit some of the limitations and start wondering what’s wrong. You don’t need to know any of the terminology to have a pretty go<a name="bookmark1010"></a>od guess as to what t<a name="bookmark1011"></a>he code will do when reading it, and with a bit of trial and error you can experiment your way to writing your own working code, too. (One of the benefits of generics is that more checking is done at compile time, so you’re more likely to have working code by the time it all compiles—this makes the experimentation simpler.) Of course, the aim of this chapter is to give you the knowledge so that you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">won’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be using guesswork—you’ll know what’s going on at every stage.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For now, let’s look at some code that’s straightforward even if the syntax is unfamiliar. Listing 3.1 uses a Dict<a name="bookmark1012"></a>ionary&lt;TKey,TValue&gt; (roughly the generic equivalent of the nongeneric Hashtable class) to count the frequencies of words in a given piece of text.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.1 Using a Dictionary&lt;TKey,TValue&gt; to count words in text</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static Dictionary&lt;string,int&gt; CountWords(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dictionary&lt;string,int&gt; frequencies; frequencies = new Dictionary&lt;string,int&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string[] words = Regex.Split(text, @&quot;\W+&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (string word in words)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (frequencies.ContainsKey(word))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">frequencies[word]++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">else {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">frequencies[word] = 1;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return frequencies;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string text = @&quot;Do you like green eggs and ham?</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">I do not like them, Sam-I-am.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">I do not like green eggs and ham.&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dictionary&lt;string,int&gt; frequencies = CountWords(text); foreach (KeyValuePair&lt;string,int&gt; entry in frequencies)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string word = entry.Key; int frequency = entry.Value;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;word, &nbsp;&nbsp;&nbsp;frequency);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1013"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The CountWords method first creates an empty map from string to int </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">o</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. This will effe<a name="bookmark1014"></a>ctively count how often each word is used within the given text. We then use a regular expression </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">C</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to split the text into words. It’s crude—we end up with an empty string due to the period at the end of the text, and I haven’t worried about the fact that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> are counted separately. These issues are easily fixable, but I wanted to keep the code as simple as possible for this example. For each word, we check whether it’s already in the map. If it is, we increment the existing count; otherwise, we give the word an initial count of 1 </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Note how the incrementing code doesn’t need to do a cast to int in order to perform the addition: the value we retrieve is known to be an int at comp<a name="bookmark1015"></a>ile time. The step incrementing the count is actually performing a get on the indexer for the map, then incrementing, then performing a set on the indexer. Some developers may find it easier to keep this explicit, using frequencies[word] = frequencies[word] + 1; instead.</font></p>
<p><a name="bookmark1016"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The final part of the listing is famili<a name="bookmark1017"></a>ar: enumerating through a Hashtable gives a similar (nongeneric) DictionaryEntry with Key and Value properties for each entry </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. But in C# 1 we would’ve needed to cast both the word and the frequency, as the key and value would’ve bee<a name="bookmark1018"></a>n returned as just object. That also means that the frequency would’ve been boxed. Admittedly we don’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to put the word and the frequency into variables—we could’ve just had a single call to Console.WriteLine and passed entry.Key and entry.Value as arguments. I just have the variables here to ram home the point that no casting is necessary.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve seen an example, let’s look at what it means to talk about Dictionary&lt;TKey, TValue&gt; in the first place. What are TKey and TValue, and why do they have angle brackets round them?</font></p>
<p><a name="bookmark98"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1019"></a>3.2.2 Generic types and type parameters</font></p>
<p><a name="bookmark1020"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1021"></a><a name="bookmark1022"></a><a name="bookmark1023"></a>There are two forms of generics in C#: </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">generic types</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (including classes, interfaces, delegates, and structures—there are no generic enums) and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">generic methods</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Both are essentially a way of expressing an API (whether it’s for a single generic method or a whole generic type) such that in some places where you’d expect to see a normal type, you see a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">type parameter</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> instead.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A type par<a name="bookmark1024"></a>ameter is a placeholder for a real type. Typ<a name="bookmark1025"></a>e parameters appear in angle brackets within a generic declaration, using commas to separate them. So in Dictionary&lt;TKey,TValue&gt; the type parameters are TKey and TValue. When you use a generic type or<a name="bookmark1026"></a> method, you specify the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">real</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> types you want to use. These are called the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">type arguments</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—for example, in listing 3.1 the type arguments were string (for TKey) and int (for TValue).</font></p>
<p><a name="bookmark1027"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">JARGON ALERT! A lot of detailed terminology is involved in generics. I’ve included it for reference—and because occasionally it makes it easier to talk about topics in a precise manner. It could be useful if you ever need to consult the language specification, but you’re unlikely to need to use this terminology in day-to-day life. Just grin and bear it for the moment. A lot of this terminology is defined in section 4.4 of the C# 4 specification—look there for further details.</font></p>
<p><a name="bookmark1028"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The form where none of the ty<a name="bookmark1029"></a>pe parameters have been provided with type arguments is called an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">unbound generic type</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. When type arguments are specified, t<a name="bookmark1030"></a>he type is said to be a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">constructed type</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Unbound generic types are effectively blueprints for constructed types, in a way similar to how types (generic <a name="bookmark1031"></a>or not) can be regarded as blueprints for objects. It’s a sort of extra layer of abstraction. Figure 3.1 shows this graphically.</font></p><img src="images/9.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 3.1 Unbound generic types act as blueprints for constructed types, which then act as blueprints for actual objects, just as nongeneric types do.</font></p>
<p><a name="bookmark1032"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1033"></a>As a further complication, types can be open or closed. An </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">open type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is one that still involves a type parameter (for example, as one of the type arguments, or as the array element type), whereas a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">closed type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is one that isn’t open; every aspect of the type is known precisely. All code actually </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">executes</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in the context of a closed constructed type. The only time you see an unboun<a name="bookmark1034"></a>d generic type appear within C# code (other than as a declaration) is within the typeof operator, which we’ll meet in section 3.4.4.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The idea of a type parameter “receiving” information and a type argument “providing” the informa<a name="bookmark1035"></a>tion—the dash<a name="bookmark1036"></a>ed lines in figure 3.1—is exactly the same as with method parameters and arguments, although type arguments have to be types rather than just arbitrary values. The type argument has to be known at compile time, but it can be (or involve) a type parameter from the relevant context.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can think of a closed ty<a name="bookmark1037"></a>pe as having the API of the open type, but with the type parameters being substituted with their corresponding type arguments.<sup><a name="footnote19"></a><a href="#bookmark1038">19</a></sup> Table 3.1 shows some public method and property declarations from the open type Dictionary &lt;TKey, TValue&gt; and the equivalent member in the closed type we built from it— Dictionary&lt;string,int&gt;.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table 3.1 Examples of how method signatures in generic types contain placeholders, which are replaced when the type arguments are specified</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Method signature in generic type</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Method signature after type parameter substitution</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Add(TKey key, TValue value) TValue this[TKey key] { get; set; } bool ContainsValue(TValue value) bool ContainsKey(TKey key)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Add(string key, int value) int this[string key] { get; set; } bool ContainsValue(int value) bool ContainsKey(string key)</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One important thing to note is that none of the methods in table 3.1 are actually generic methods. They’re just “normal” methods within a generic type, and they happen to use the type parameters declared as part of the type. We’ll look at generic methods in the next section.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that you know what TKey and TValue mean, and what the angle brackets are for, we can see what the declarations in table 3.1 would look like within the class declaration. Here’s what the code for Dictionary&lt;TKey,TValue&gt; might look like— although the actual method implementations are all missing, and there are more members in reality:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">namespace System.Collections.Generic {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class Dictionary&lt;TKey,TValue&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">: IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Dictionary() { ... } &nbsp;&nbsp;&nbsp;&lt;|_</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void &nbsp;&nbsp;&nbsp;Add(TKey key, TValue value) &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public TValue this[TKey key]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get { ... } set { ... }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public bool &nbsp;&nbsp;&nbsp;ContainsValue(TValue value) &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public bool &nbsp;&nbsp;&nbsp;ContainsKey(TKey key) { ... &nbsp;&nbsp;&nbsp;}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[... other members ...]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how Dictionary&lt;TKey,T<a name="bookmark1039"></a>Value&gt; implements the generic interface IEnumerable &lt;KeyValuePair&lt;TKey,TValue&gt;&gt; (and many other interfaces in real life). Whatever type arguments you specify for the class are applied to the interface where the same type parameters are used—so in our example, Dictionary&lt;string,int&gt; implements IEnumerable&lt;KeyValuePair&lt;string,int&gt;&gt;. That’s actually sort of a doubly generic interface—it’s the IEnumerable&lt;T&gt; interface, with the structure KeyValue-Pair&lt;string,int&gt; as the type argument. It’s because it implements that interface that listing 3.1 was able to enumerate the keys and valu<a name="bookmark1040"></a>es in the way that it did.</font></p>
<p><a name="bookmark1041"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s also worth pointing out that the constructor doesn’t list the type parameters in angle brackets. The type parameters belong to the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> rather than to the particular constructor, so that’s where they’re declared. Members only declare type parameters when they’re introducing new ones—and only methods can do that.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">PRONOUNCING GENERICS If you ever need to describe a generic type to a colleague, it’s conventional to use “of” to introduce the type parame<a name="bookmark1042"></a>ters or arguments—so List&lt;T&gt; is pronounced “list of T,” for example. In VB, this is part of the language: the type itself would be written as List(Of T). When there are multiple type parameters, I find it makes sense to separate them with a word appropriate to the meaning of the overall type—so I’d talk about a “dictionary of string </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">to</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> int” in order to emphasize the mapping aspect, but a “tuple of string </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">and</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> int.”</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Generic types can effectively be overloaded on the number of type parameters—so you could define MyType, MyType&lt;T&gt;, MyType&lt;T,U&gt;, MyType&lt;T,U,V&gt;, and so forth, all within the same namespace. The names of the type parameters aren’t used when considering this—just how many there are. These types are unrelated except in name— there’s no default conversion from one to another, for instance. The same is true for generic methods: two methods can be exactly the same in signature other than the number of type parameters. Although this may sound like a<a name="bookmark1043"></a> recipe for disaster, it can be useful if you want to take advantage of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">generic type inference,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> where the compiler can work out some of the type arguments for you; we'll come back to that in section 3.3.2.</font></p>
<p><a name="bookmark1044"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1045"></a>NAMING CONVENTIONS FOR TYPE PARAMETERS Although you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have a type with type parameters T, U, and V, it wouldn’t give much indication of what they actually meant, or how they should be used. Compare this with Dictionary &lt;TKey, TValue&gt;, where it’s obvious that TKey represents the type of the keys and TValue represents the type of the values. Where you have a single type parameter and its meaning is clear, T is conventionally used (List&lt;T&gt; is a good example of this). Multiple type parameters should usually be named according to meaning, using the prefix T to indicate a type parameter. Every so often, you may run into a type with multiple single-letter type parameters (SynchronizedKeyedCollection&lt;K,T&gt;, for example), but you should try to avoid creating the same situation yourself.</font></p>
<p><a name="bookmark1046"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we have an idea of what generic types do, let’s look at generic methods.</font></p>
<p><a name="bookmark99"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1047"></a>3.2.3 Generic methods and reading generic declarations</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve mentioned generic methods a few times, but we haven’t actually met one yet. You may find the overall idea of generic methods more confusing than generic types— they’re somehow less natural for the brain—but it’s the same basic principle. We’re used to the parameters and return value of a method having firmly specified types, and we’ve seen how a generic type can use its type parameters in method declarations. Generic methods go one step further: even if you know exactly which constructed type you’re dealing with, an individual method can have type parameters, too. Don’t worry if you’re still none the wiser—the concept is likely to click at some point after you’ve seen enough examples.</font></p>
<p><a name="bookmark1048"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Diction<a name="bookmark1049"></a>ary&lt;TKey, TValue&gt; doesn’t have any generic methods, but its close neighbor List&lt;T&gt; does. As you can imagine, List&lt;T&gt; is just a list of items of whatever type is specified—so Li<a name="bookmark1050"></a>st&lt;string&gt; is a list of strings, for instance. Remembering that T is the type parameter for the whole </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">class,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> let’s dissect a generic method declaration. Figure 3.2 shows what the different parts of the declaration of the ConvertAll method</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">3</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">mean.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When you look at a generic declaration—whether it’s for a generic type or a generic method—it can be daunting trying to work out what it means, particularly if you have to deal with generic types of generic types, as we did when we looked at the</font></p><div>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup>3</sup> I’ve renamed the parameter from converter to conv so that it fits on one line, but everything else is as documented.</font></p></div><br clear="all"/><img src="images/10.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 3.2 The anatomy of a generic method declaration</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">interface implemented by the dictionary. The key is to not panic—just take things calmly, and pick an example situation. Use a different type for each type parameter, and apply them all consistently.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this case, let’s start by replacing the type parameter of the type containing the method (the &lt;T&gt; part of List&lt;T&gt;). We’ll stick with the concept of a list of strings, and replace T with string everywhere in the method declaration:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt;(Converter&lt;string,TOutput&gt; conv)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That looks a bit better, but we’ve still got TOutput to deal with. We can tell that it’s a method’s type parameter (apologies for the confusing terminology) because it’s in angle brackets directly after the name of the method. So, let’s try to use another familiar type—Guid—as the type argument for TOutput. Again we replace the type parameter with the type argument everywhere. We can now think of the method as if it were nongeneric, removing the type parameter part of the declaration:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Guid&gt; ConvertAll(Converter&lt;string,Guid&gt; conv)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now everything is expressed in terms of a concrete type, so it’s easier to think about. Even though the real method is generic, we’re just treating it as if it weren’t for the sake of understanding it better. Going through the elements of this declaration from left to right:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The method returns a List&lt;Guid&gt;.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The method’s name is ConvertAll.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The method has a single parameter: a Converter&lt;string,Guid&gt; called conv.</font></p>
<p><a name="bookmark1051"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now wejust need to know what Converter&lt;string,Guid&gt; is and we’re all <a name="bookmark1052"></a>done. Not surprisingly, Converter&lt;string,Guid&gt; is a constructed </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">generic delegate type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (the unbound type is Converter&lt;TInput, TOutput&gt;), which is used to convert a string to a GUID.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, we have a method that can operate on a list of strings, using a converter to produce a list of GUIDs. Now that we understand the method’s signature, it’s easier to understand the documentation, which confirms that this method does the obvious thing and creates a new List&lt;Guid&gt;, converts each element in the original list into the target type adding it to the new list, and then returns that list. Thinking about the signature in concrete terms gives us a clearer mental model, and makes it simpler to think about what we might expect the method to do. Although this technique may sound somewhat simplistic, I find it useful for complicated methods even now. Some of the LINQ method signatures with four type parameters are fearsome beasts, but putting it into concrete terms tames them significantly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just to prove I haven’t been leading you down the garden path, let’s take a look at this method in action. Listing 3.2 shows the conversion of a list of integers into a list of floating-point numbers, where each element of the second list is the square root of the corresponding element in the first list. After the conversion, we print out the results.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.2 The List&lt;T&gt;.ConvertAll&lt;TOutput&gt; method in action</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static double TakeSquareRoot(int x)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return Math.Sqrt(x);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;int&gt; integers = new List&lt;int&gt;(); integers.Add(1); integers.Add(2); integers.Add(3); integers.Add(4);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Converter&lt;int,double&gt; converter = TakeSquareRoot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;double&gt; doubles;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">doubles = integers.ConvertAll&lt;double&gt;(converter); foreach (double d in doubles)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(d);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The creation and population of the list </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is st<a name="bookmark1053"></a>raightforward enough—it’s just a stro<a name="bookmark1054"></a>ngly typed list of integers. </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">uses a feature of delegates (method group conversions), which is new to C# 2 and which we’ll discuss in more detail in section 5.2. Although I don’t like using a feature before describing it fully, the line would’ve been too long to fit on the page with the C# 1 delegate syntax. It does what you expect it to, though. At </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">G </font><font style="font-size:x-small;font-family:Times New Roman, serif;">we call the generic method, specifying the type argument for the method in the same way as we’ve seen for generic types. This is one situation where we could’ve used type inference to avoid explicitly specifying the type argument, but I wanted to take it one step at a time. Writing out the list that has been returned is simple, and when you run the code you’ll see it print 1, 1.414..., 1.732..., and 2, as expected.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, what’s the point of all of this? We could’ve just used a foreach loop to go through the integers and printed out the square root immediately, of course, but it’s not uncommon to want to convert a list of one type to a list of another by performing some logic on it. The code to do it manually is still simple, but it’s easier to read a version that just does it in a single method call. That’s often the way with generic methods—they often do things that previously you’d have happily done “longhand” but that are simpler with a <a name="bookmark1055"></a>method call. Before generics, there could’ve been a similar operation to ConvertAll on ArrayList converting from object to object, but it would’ve been a lot less satisfactory. Anonymous methods (see section 5.4) also help here—if we hadn’t wanted to introduce an extra method, we could’ve just specified the conversion “inline.” LINQ and lambda expressions take this pattern much further, as we’ll see in part 3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note that generic methods can be part of nongeneric types as well. Listing 3.3 shows a generic method being declared and used within a normal nongeneric class.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.3 Implementing a generic method in a nongeneric type</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static List&lt;T&gt; MakeList&lt;T&gt;(T first, T second)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;T&gt; list = new List&lt;T&gt;(); list.Add(first); list.Add(second); return list;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;string&gt; list = MakeList&lt;string&gt;(&quot;Line 1&quot;, &quot;Line 2&quot;); foreach (string x in list)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (x);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The MakeList&lt;T&gt; generic method only needs one type parameter (T). All it does is build a list containing the two parameters. It’s worth noting that we can use T as a type argument when we create the List&lt;T&gt; in the method, though. Just as when we were looking at generic declarations, think of the implementation as (roughly speaking) replacing all of the places where it says T with string. When we call the method, we use the same syntax we’ve seen before to specify the type arguments.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All okay so far? You should now have the hang of simple generics. There’s a bit more complexity to come, I’m afraid, but if you’re happy with the fundamental idea of generics, you’ve jumped the biggest hurdle. Don’t worry if it’s still a bit hazy—particularly when it comes to the open/closed/unbound/constructed terminology—but now would be a good time to do some experimentation so you can see gen<a name="bookmark1056"></a>erics in action before we go any further. If you haven’t used the generic collections before, you might want to quickly look at appendix B, which describes what’s available. The collection types give you a simple starting point for playing with generics, as well as being widely used in almost every nontrivial .NET program.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One thing you may find when you experiment is that it’s hard to go only part of the way. Once you make one part of an API generic, you often find that you need to rework other code, either making that generic too or putting in the casts required by the new, more strongly typed method calls. An alternative can be to have a strongly typed implementation, using generic classes under the covers, but leaving a weakly typed API for the moment. As time goes on, you’ll become more confident about when it’s appropriate to use generics.</font></p>
<p><a name="bookmark101"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;"><a name="bookmark1057"></a>3.3 </font><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Beyond the basics</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Though the relatively simple uses of generics we’ve seen can get you a long way, there are some more features available that can help you further. We’ll start by examining </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">type constraints</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which give you more control over which type arguments can be specified. They’re useful when creating your own generic types and methods, and you’ll need to understand them in order to know what options are available when using the framework, too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll then examine </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">type inference</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—a handy compiler trick that means that when you’re using generic methods, you don’t always have to explicitly state the type arguments. You don’t have to use it, but it can make your code a lot easier to read when used appropriately. We’ll see in part 3 that the C# compiler is gradually being allowed to infer a lot more information from your code, while still keeping the language safe and statically typed.<sup><a name="footnote20"></a><a href="#bookmark1058">20</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The last part of this section deals with obtaining the default value of a type parameter and what comparisons are available when you’re writing generic code. We’ll wrap up with an example demonstrating most of the features we’ve covered, as well as being a useful class in itself.</font></p>
<p><a name="bookmark1059"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Although this section delves a bit deeper into generics, there’s nothing </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">really</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> hard about it. There’s plenty to remember, but all the features serve a purpose, and you’ll be grateful for them when you need them. Let’s get started.</font></p>
<p><a name="bookmark102"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1060"></a>3.3.1 Type constraints</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far, all th<a name="bookmark1061"></a>e type parameters we’ve seen can be applied to any type at all—they’re </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">unconstrained.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> We can have a List&lt;int&gt;, a Dictionary&lt;object,FileMode&gt;, anything. That’s fine when we’re dealing with collections that don’t have to interact with what they store—but not all uses of generics are like that. Often you want to call methods on instances of the type parameter, or create new instances, or make sure you only accept reference types (or only accept value types). In other words, you want to specify rules to say which type arguments are considered valid for your generic type or method. In C# 2, you do this with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">constraints</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><a name="bookmark1062"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Four kinds of constraints are available, and the general syntax is the same for all of them. Constraints come at the end of the de<a name="bookmark1063"></a>claration of a generic method or type, and are introduced by the contextual keyword where. They can be combined together in sensible ways, as we’ll see later. First, though, we’ll explore each kind of constraint in turn.</font></p>
<p><a name="bookmark1064"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">REFERENCE TYPE CONSTRAINTS</font></p>
<p><a name="bookmark1065"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The first kind of constraint, which is expressed as T : class and which must be the first constraint specified for that type parameter, simply ensures that the type argument used is a reference type. This can be any class, interface, array, or delegate—or another type parameter that’s already known to be a reference type. For example, consider the following declaration:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">struct RefSample&lt;T&gt; where T : class</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Valid closed types include</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;RefSample&lt;IDisposable&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;RefSample&lt;string&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;RefSample&lt;int[]&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;RefSample&lt;Guid&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;RefSample&lt;int&gt;</font></p>
<p><a name="bookmark1066"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I deliberately made RefSample a struct (and therefor<a name="bookmark1067"></a>e a value type) to emphasize the difference between the constrained type parameter and the type itself. RefSample &lt;string&gt; is still a value type with value semantics everywhere—it just happens to use the string type wherever T is specified in the code.</font></p>
<p><a name="bookmark1068"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1069"></a>When a ty<a name="bookmark1070"></a>pe parameter is constrained this way, you can compare references (including null) with == and !=, but be aware that unless there are any other constraints, only references will be compared, even if the type in question overloads those operators (as string does, for example). With a conversion type c<a name="bookmark1071"></a>onstraint (described later), you can end up with “compiler guaranteed” overloads of == and !=, in which case those overloads are used—but that’s relatively rare.</font></p>
<p><a name="bookmark1072"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">VALUE TYPE CONSTRAINTS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This cons<a name="bookmark1073"></a>traint, expressed as T : &nbsp;&nbsp;&nbsp;struct, ensures that the type argument used is a</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">value type, including enums. It excludes nullable types (as described in chapter 4), though. Let’s look at an example declaration:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class ValSample&lt;T&gt; where T : struct</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Valid closed types include</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;ValSample&lt;int&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;ValSample&lt;FileMode&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Invalid closed types include</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;ValSample&lt;object&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;ValSample&lt;StringBuilder&gt;</font></p>
<p><a name="bookmark1074"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This time ValSample is a ref<a name="bookmark1075"></a>erence type, despite T b<a name="bookmark1076"></a>eing constrained to be a value type. Note that System.Enum and System.ValueType are both reference types in themselves, so they aren’t allowed as valid type arguments for ValSample. When a type parameter is constrained to be a value type, comparisons using == and != are prohibited.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I rarely find myself using value or reference type constraints, although we’ll see in the next chapter that nullable value types rely on value type constraints. The remaining two constraints are likely to prove more useful to you when writing your own generic types.</font></p>
<p><a name="bookmark1077"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1078"></a>CONSTRUCTOR TYPE CONSTRAINTS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The third kind of constraint is expressed as T : new () and must be the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">last</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> constraint for any particular type pa<a name="bookmark1079"></a>rameter. It simply checks that the type argument used has a parameterless<a name="bookmark1080"></a> constructor, which can be used to create an instance. This applies to any value type; any nonstatic, nonabstract class without any explicitly declared constructors; and any nonabstract class with an explicit public parameterless constructor.</font></p>
<p><a name="bookmark1081"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1082"></a><a name="bookmark1083"></a>C# VERSU<a name="bookmark1084"></a>S CLI STANDARDS There’s a discrepancy between the C# and CLI standards when it comes to value types and constructors. The C# specification states that all value types have a default parameterless constructor, and it uses the same syntax to call both explicitly declared constructors and the parame-terless one, relying on the compiler to do the right thing underneath. The CLI specification has no such requirement, but provides a special instruction to create a default value without specifying any parameters. You can see this discrepancy at work when you use reflection to find the constructors of a value type—you won’t see a parameterless one.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Again, let’s look at a quick example, this time for a method. Just to show how it’s useful, I’ll give the implementation of the method, too:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public T CreateInstance&lt;T&gt;() where T : new()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new T();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This method just returns a new instance of whatever type you specify, provided that it has a parameterless constructor. So calls to CreateInstance&lt;int&gt;() and Create-Instance&lt;object&gt;() are okay, but CreateInstance&lt;string&gt;() isn’t, because string doesn’t have a parameterless constructor.</font></p>
<p><a name="bookmark1085"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s no way of constraining type parameters to force other constructor signa-tures—for instance, you can’t specify that there has to be a constructor taking a single string parameter. It can be frustrating, but that’s unfortunately just the way it is. We’ll look at this issue in more detail when we consider the various restrictions of .NET generics in section 3.5.</font></p>
<p><a name="bookmark1086"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Constructor type constraints can be useful when you need to use factory-like patterns, where one object will create another one as and when it needs to. Factories often need to produce objects that are compatible with a certain interface, of course—and that’s where our last type of constraint comes in.</font></p>
<p><a name="bookmark1087"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">CONVERSION TYPE CONSTRAINTS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The final (and most complicated) kind of constr<a name="bookmark1088"></a>aint lets you speci<a name="bookmark1089"></a>fy another <a name="bookmark1090"></a>type that the <a name="bookmark1091"></a>type argument must be implicitly convertible to via an identity, reference, or boxing conversion. You can specify that one t<a name="bookmark1092"></a>ype argument be convertible to another, too—this is called a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">type parameter constraint</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and makes it harder to understand the declaration, but can be handy every so often. Table 3.2 shows some examples of generic type declarations with conversion type constraints, along with valid and invalid examples of corresponding constructed types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The third constraint of T : IComparable&lt;T&gt; is just one example of using a generic type as the constraint. Other variations such as T : List&lt;U&gt; (where U is another type parameter) and T : IList&lt;string&gt; are also fine. You can specify multiple interfaces, but only one class. For instance, this is fine (if hard to satisfy):</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Sample&lt;T&gt; where T : Stream,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;string&gt;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IComparable&lt;int&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table 3.2 Examples of conversion type constraints</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Declaration</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Constructed type examples</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">class Sample&lt;T&gt; where T : Stream</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Valid:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Sample&lt;Stream&gt; (identity conversion) </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Invalid:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Sample&lt;string&gt;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">struct Sample&lt;T&gt; where T : IDisposable</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Valid:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Sample&lt;SqlConnection&gt; (reference conversion)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Invalid:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Sample&lt;StringBuilder&gt;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">class Sample&lt;T&gt; where T : IComparable&lt;T&gt;</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Valid:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Sample&lt;int&gt; (boxing conversion) </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Invalid:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Sample&lt;FileInfo&gt;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">class Sample&lt;T,U&gt; where T : U</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Valid:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Sample&lt;Stream,IDisposable&gt; (reference conversion)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Invalid:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Sample&lt;string,IDisposable&gt;</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But this isn’t:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">class Sample&lt;T&gt; where T : Stream,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ArrayList,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IComparable&lt;int&gt;</font></p>
<p><a name="bookmark1093"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">No type can derive directly from more than one class anyway, so such a constraint would usually either be impossible (like this one) or part of it would be redundant (specifying that the type had to derive from both Stream and MemoryStream, for example). One more set of restrictions: the type you specify can’t be a value type, a sealed class (such as string), or any of the following “special” types:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;System.Object</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;System.Enum</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;System.ValueType</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;System.Delegate</font></p>
<p><a name="bookmark1094"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1095"></a>WORKING AROUND THE LACK OF ENUM AND DELEGATE CONSTRAINTS The inability to specify the preceding types in conversion type constraints sounds like it’s due to a CLR restriction—but it’s not. It may have been historically (at some point while generics were still being designed), but if you construct the appropriate code in IL, it works fine. The CLI specification even lists these as examples and explains what would be valid and what wouldn’t. This is frustrating, and there are plenty of generic methods that would be useful when restricted to delegates or enums. I have an open source project called Unconstrained Melody (<a href="http://mng.bz/s9Ca">http://mng.bz/s9Ca</a>), which performs some hackery to build a class library that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have these constraints on various utility methods. Although the C# compiler won’t let you declare such constraints, it’s happy to apply them when you call the methods in the library. Perhaps in a future version of C#, the prohibition will be lifted.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Conversion type constraints are probably the most useful kind, as they mean you can use members of the specified type on instances of the type parameter. One particularly <a name="bookmark1096"></a>handy example of this is T : IComparable&lt;T&gt;, so that you know you can compare two instances of T meaningfully and directly. We’ll see an example of this (as well as discuss other forms of comparison) in section 3.3.3.</font></p>
<p><a name="bookmark1097"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">COMBINING CONSTRAINTS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve mentioned the possibility of having multiple constraints, and we’ve seen them in action for conversion type constraints, but we haven’t seen the different kinds being combined together. Obviously no type can be both a reference type and a value type, so that combination is forbidden. Likewise, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">every</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> value type has a parameterless constructor, so you can’t specify the construction constraint when you already have a value type constraint (although you can still use new T() within methods if T is constrained to be a value type). If you have multiple conversion type constraints and one of them is a class, that has to come before the interfaces—and you can’t specify the same interface more than once. Different type parameters can have different constraints, and they’re each introduced with a separate where.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s see some valid and invalid examples:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Valid</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class &nbsp;&nbsp;&nbsp;Sample&lt;T&gt; where T &nbsp;&nbsp;&nbsp;: &nbsp;&nbsp;&nbsp;class, IDisposable, new()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class &nbsp;&nbsp;&nbsp;Sample&lt;T&gt; where T &nbsp;&nbsp;&nbsp;: &nbsp;&nbsp;&nbsp;struct, IDisposable</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class &nbsp;&nbsp;&nbsp;Sample&lt;T,U&gt; where &nbsp;&nbsp;&nbsp;T &nbsp;&nbsp;&nbsp;: class where U : struct, &nbsp;&nbsp;&nbsp;T</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Sample&lt;T,U&gt; where T : Stream where U : IDisposable</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Invalid</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class &nbsp;&nbsp;&nbsp;Sample&lt;T&gt; where T &nbsp;&nbsp;&nbsp;: &nbsp;&nbsp;&nbsp;class, struct</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class &nbsp;&nbsp;&nbsp;Sample&lt;T&gt; where T &nbsp;&nbsp;&nbsp;: &nbsp;&nbsp;&nbsp;Stream, class</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class &nbsp;&nbsp;&nbsp;Sample&lt;T&gt; where T &nbsp;&nbsp;&nbsp;: &nbsp;&nbsp;&nbsp;new(), Stream</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class &nbsp;&nbsp;&nbsp;Sample&lt;T&gt; where T &nbsp;&nbsp;&nbsp;: &nbsp;&nbsp;&nbsp;IDisposable, Stream</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Sample&lt;T&gt; where T : XmlReader, IComparable, IComparable class &nbsp;&nbsp;&nbsp;Sample&lt;T,U&gt; where &nbsp;&nbsp;&nbsp;T &nbsp;&nbsp;&nbsp;: struct where U : class, &nbsp;&nbsp;&nbsp;T</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class &nbsp;&nbsp;&nbsp;Sample&lt;T,U&gt; where &nbsp;&nbsp;&nbsp;T &nbsp;&nbsp;&nbsp;: Stream, U : IDisposable</font></p>
<p><a name="bookmark1098"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I included the last example on each list because it’s so easy to try the invalid one instead of the valid version, and the compiler error isn’t at all helpful. Just remember that each list of type parameter constraints needs its own introductory where. The third valid example is interesting—if U is a value type, how can it derive from T, which is a reference type? The answer is that T could be an object or an interface that U implements. It’s a pretty nasty constraint, though.</font></p>
<p><a name="bookmark1099"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1100"></a>SPECIFICATION TERMINOLOGY The specification categorizes constraints slightly differently—into </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">primary</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> constraints, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">secondary</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> constraints, and constructor constraints. A primary constraint is a reference type constraint, a value type constraint, or a conversion type constraint using a class. A secondary constraint is a conversion type constraint using an interface or another type parameter. I don’t find these particularly useful categories, but they make it easier to define the grammar of constraints: the primary constraint is optional but you can only have one; you can have as many secondary constraints as you like; the constructor constraint is optional (unless you have a value type constraint, in which case it’s forbidden).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that you have all the knowledge you need to read generic type declarations, let’s look at the type argument inference that I mentioned earlier. In listing 3.2 we explicitly stated the type arguments to List&lt;T&gt;.ConvertAll, and we did the same in listing 3.3 for our own MakeList method—but let’s now ask the compiler to work them out when it can, making it simpler to call generic methods.</font></p>
<p><a name="bookmark103"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1101"></a><a name="bookmark1102"></a><a name="bookmark1103"></a>3.3.2 Type inference for type arguments of generic methods</font></p>
<p><a name="bookmark1104"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Specifying type arguments when you’re calling a generic method can often seem pretty redundant. Usually it’s obvious what the type arguments should be, based on the method arguments themselves. To make life easier, from C# 2 onward, the compiler is allowed to be smart in tightly defined ways, so you can call the method without explicitly stating the type arguments.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before we go any further,<a name="bookmark1105"></a> I should stress that this is only true for generic </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">methods.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> It doesn’t apply to generic </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">types.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Now that we’ve cleared that up, let’s look at the relevant lines from listing 3.3, and see how things can be simplified. Here are the lines declaring and invoking the method:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static List&lt;T&gt; MakeList&lt;T&gt;(T first, T second)</font></p>
<p><a name="bookmark1106"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;string&gt; list = MakeList&lt;string&gt;(&quot;Line 1&quot;, &quot;Line 2&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">No<a name="bookmark1107"></a>w look at the arguments we’ve specified—they’re both strings. Each of the parameters in the method is declared to be of type T. Even if we didn’t have the &lt;string&gt; part of the method invocation expression, it would be fairly obvious that we meant to call the method using string as the type argument for T. The compiler allows you to omit it, leaving this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;string&gt; list = MakeList(&quot;Line 1&quot;, &quot;Line 2&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s a<a name="bookmark1108"></a> bit neater, isn’t it? At least, it’s shorter. That doesn’t always mean it’s more readable, of course—in some cases it’ll be harder for the reader to work out what type arguments you’re trying to use, even if the compiler can do it easily. I recommend that you judge each case on its merits. My personal preference is to let the compiler infer the type arguments in </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">most</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> cases where it works.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how the compiler definitely knows that we’re using string as the type argument, because the assignment to list <a name="bookmark1109"></a>works too, and that still </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> specify the type argument (and has to). The assignment has no influence on the type parameter inference process, though. It just means that if the compiler works out what type arguments it thinks you want to use but gets it wrong, you’re still likely to get a compiletime error.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">How could the compiler get it wrong? Suppose we actually wanted to use object as the type argument. Our method parameters are still valid, but the compiler thinks we actually meant to use string, as they’re both strings. Changing one of the parameters to explicitly be cast to object makes type inference fail, as one of the method arguments would suggest that T should be string, and the other suggests that T should be object. The compiler </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> look at this and say that setting T to object would satisfy <a name="bookmark1110"></a>everything but setting T to string wouldn’t, but the specification only gives a limited number of steps to follow. This area is already fairly complicated in C# 2, and C# 3 takes things even further. I won’t try to give all of the nuts and bolts of the C# 2 rules here, but the basic steps are as follows:</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;For each method argument (the bits in normal parentheses, not angle brackets) , try to infer some of the type arguments of the generic method, using some fairly simple techniques.</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">2</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;Check that all the results from the first step are consistent—in other words, if one argument implied one type argument for a particular type parameter, and another implied a different type argument for the same type parameter, then inference fails for the method call.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">3 &nbsp;&nbsp;&nbsp;Check that all the type parameters needed for the generic method have been inferred. You can’t let the compiler infer some while you specify others explic-itly—it’s all or nothing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To avoid learning all the rules (and I wouldn’t recommend it unless you’re particularly interested in the fine details), there’s one simple thing to do: try it to see what happens. If you think the compiler </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">might</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be able to infer all the type arguments, try calling the method without specifying any. If it fails, stick the type arguments in explicitly. You lose nothing more than the time it takes to compile the code once, and you don’t need to have all the extra language-lawyer garbage in your head.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Type inference can be combined with the idea of overloading type names based on the number of type parameters to make it easier to use generic types. We’ll see an example of this in a while, when we put everything together.</font></p>
<p><a name="bookmark104"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1111"></a>3.3.3 Implementing generics</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although you’re likely to spend more time using generic types and methods than writing them yourself, there are a few things you should know for those occasions when you’re providing the implementation. Most of the time you can just pretend T (or whatever your type parameter is called) is the name of a type and get on with writing code as if you weren’t using generics at all. There are a few extra things you should know, though.</font></p>
<p><a name="bookmark1112"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">DEFAULT VALUE EXPRESSIONS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When you know exactly what type you’re <a name="bookmark1113"></a>working with, you know its default value— the value an otherwise uninitialized field would have, for instance. When you don’t know what type you’re referring to, you can’t specify that default value directly. You can’t use null because it might not be a reference type. You can’t use 0 because it might not be a numeric type. Though it’s fairly rare to need the default value, it can be useful on occasion. Dictionary&lt;TKey,TValue&gt; provides a good example—it has a TryGetValue method that works a bit like the TryParse methods on the numeric types: it uses an output parameter for the value you’re trying to fetch, and a Boolean return value to indicate whether it succeeded. This means that the method </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">has</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to have</font></p>
<p><a name="bookmark1114"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1115"></a>some value of type<a name="bookmark1116"></a> TValue to popul<a name="bookmark1117"></a>ate the output parameter with. (Remember that output parameters must be assigned before the method returns normally.)</font></p>
<p><a name="bookmark1118"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1119"></a><a name="bookmark1120"></a><a name="bookmark1121"></a><a name="bookmark1122"></a>THE TRYXXX PATTERN A few patterns in .<a name="bookmark1123"></a>NET are easily identifiable by the names of the methods involved—BeginXXX and EndXXX suggest an asynchronous operation, for example. The TryXXX pattern is one that has had its use expanded between .NET 1.1 and 2.0. It’s designed for situations that might normally be considered to be errors (in that the method can’t perform its primary duty) but where failure could well occur without indicating a serious issue, and shouldn’t be deemed exceptional. For instance, users often fail to type in numbers correctly, so being able to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">try</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to parse some text without having to catch an exception and swallow it is useful. Not only does it improve performance in the failure case, but more importantly, it saves exceptions for genuine error cases where something is wrong in the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">system</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (however widely you wish to interpret that). It’s a useful pattern to have up your sleeve as a library designer, when applied appropriately.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 2 provides the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">default value <a name="bookmark1124"></a>expression</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to cater for just this need. The specificatio<a name="bookmark1125"></a>n doesn’t refer to it as an operator, but you can think of it as being similar to the typeof operator, just returning a different value. The following listing shows this in a generic method, and also gives an example of type inference and a conversion type constraint in action.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.4 Comparing a given value to the default in a generic way</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static int CompareToDefault&lt;T&gt;(T value) where T : IComparable&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return value.CompareTo(default(T));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(CompareToDefault(&quot;x&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(CompareToDefault(10));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(CompareToDefault(0));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(CompareToDefault(-10));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(CompareToDefault(DateTime.MinValue));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.4 shows a generic method being used with three different types: string, int, and DateTime. The CompareToDefault met<a name="bookmark1126"></a>hod dictates that it can only be used with types implementing the IComparable&lt;T&gt; interface, which allows us to call CompareTo (T) on the value passed in. The other value we use for the comparison is the default value for the type. As string <a name="bookmark1127"></a>is a reference type, the default value is null— and the documentation fo<a name="bookmark1128"></a>r CompareTo states that for reference types, everything should be greater than null so the first result is 1. The next three lines show comparisons with the default value of int, demonstrating that the d<a name="bookmark1129"></a>efault value is 0. The output of t<a name="bookmark1130"></a>he last line is 0, showing that DateTime.MinValue is the default value for DateTime.</font></p>
<p><a name="bookmark1131"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, the method in listing 3.4 will fail if you pass it null as the argument— the line calling CompareTo will throw NullReferenceException in the normal way. Don’t worry about it for the moment—there’s an alternative using IComparer&lt;T&gt;, as we’ll see soon.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">DIRECT COMPARISONS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although listing 3.4 showed how a comparison is possible, we don’t always want to constrain our types to implement IComparable&lt;T&gt; or its sister interface, IEquat-able&lt;T&gt;, which provides a strongly typed Equals(T) method to complement the Equals(object) method that all types have. Without the extra information these interfaces give us access to, there’s little we can do in terms of comparisons, other than calling Equals (object), which will result in boxing the value we want to compare with when it’s a value type. (In fact, there are a couple of types to help us in some situations—we’ll come to them in a minute.)</font></p>
<p><a name="bookmark1132"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1133"></a>W<a name="bookmark1134"></a>hen a type parameter is unconstrained (no constraints are applied to it), you can use == and != operators, but </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to compare a value of that type with null. You can’t compare two values of type T with each other. When the type argument is a reference type, the normal reference comparison will be used. In the case where the type argument provided for T is a non-nullable value type, a comparison with null will alwa<a name="bookmark1135"></a>ys decide that they’re unequal (so the comparison c<a name="bookmark1136"></a>an be removed by the JIT compiler). When the type argument is a nullable value type, the comparison will behave in the natural way, making the comparison against the null value of the type.<sup><a name="footnote21"></a><a href="#bookmark1137">21</a></sup> (Don’t worry if this last bit doesn’t make sense yet—it will when you’ve read the next chapter. Some features are too intertwined to allow me to describe either of them completely without referring to the other, unfortunately.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When a type parameter is constrained to be a value <a name="bookmark1138"></a>type, == and != can’t be used with it at all. When it’s constrained to be a reference type, the kind of comparison performed depends on </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> what the type parameter is constrained to be. If it’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">just</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a reference type, simple reference comparisons are pe<a name="bookmark1139"></a>rformed. If it’s further constrained to derive from a particular type that overloads the == and != operators, those overloads are used. Beware, though—extra overloads that happen to be made available by the type argument specified by the caller are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> used. The next listing demonstrates this with a simple reference type constraint and a type argument of string.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.5 Comparisons using == and != using reference comparisons</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static bool AreReferencesEqual&lt;T&gt;(T first, T second) where T : class</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return first == second;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">} string name = &quot;Jon&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string intro1 = &quot;My name is &quot;&nbsp;+ name; string intro2 = &quot;My name is &quot;&nbsp;+ name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(intro1 == intro2); Console.WriteLine(AreReferencesEqual(intro1, intro2));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even though string overloads == (as demonstrated by Q printing True), this overload isn’t used by the comparison at O. Basically, when AreReferencesEqual&lt;T&gt; is compiled, the compiler doesn’t know what overloads will be available—it’s as if the parameters passed in were of type object.</font></p>
<p><a name="bookmark1140"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1141"></a>This isn’t just specific to operat<a name="bookmark1142"></a>ors—when the compiler encounters a generic type, it resolves all the method overloads when compiling the unbound generic type, rather than reconsidering each possible method call for more specific overloads at execution time. For instance, a statement of Console.WriteLine(default(T)); will always resolve to a call to Console.WriteLine(object value)—it doesn’t call Console. WriteLine (string va<a name="bookmark1143"></a>lue) when T happens to be string. This is similar to the normal situation of overloads being chosen at compile time rather than execution time, but readers familiar with templates in C++ may be surprised nonetheless.<sup><a name="footnote22"></a><a href="#bookmark1144">22</a></sup></font></p>
<p><a name="bookmark1145"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Two classes that <a name="bookmark1146"></a>are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extremely</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> usef<a name="bookmark1147"></a>ul when it comes to comparing values are EqualityComparer&lt;T&gt; and Comparer&lt;T&gt;, both in th<a name="bookmark1148"></a>e System.Collecti<a name="bookmark1149"></a>ons.Generic namespace. They implement IEqualityComparer&lt;T&gt; and IComparer&lt;T&gt; respectively, and the Default property returns an implementation that generally does the right thing for the appropriate type.</font></p>
<p><a name="bookmark1150"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">THE GENERIC COMPARISON INTERFACES There are four main generic interfaces for comparisons. Two of them—I<a name="bookmark1151"></a>Comparer&lt;T&gt; and IComparable&lt;T&gt;— are about comparing values for </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">ordering</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (is one value less than, equal to, or greater than the other?), and the other two—IEquali<a name="bookmark1152"></a>tyComparer&lt;T&gt; and IEquatable&lt;T&gt;—are for comparing two items for </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">equality</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> according to some criteria, and finding the hash of an item (in a manner compatible with the same notion of equality).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Splitting the four another way, IComparer&lt;T&gt; and IEqualityComparer&lt;T&gt; are implemented by types that are capable of comparing two different values, whereas an instance of IComparable&lt;T&gt; and IEquatable&lt;T&gt; is capable of comparing </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">itself</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> with another value.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">See the documentation f<a name="bookmark1153"></a>or more details, but consider using these (and similar types such as StringComparer) when performing comparisons. We’ll use Equality-Comparer&lt;T&gt; in our next example.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">FULL COMpARISON EXAMpLE: REpRESENTING A pAIR OF VALUES</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To finish off our section on implementing generics—and, indeed, medium-level generics—h<a name="bookmark1154"></a>ere’s a complete example. It implements a useful generic type—a Pair&lt;T1,T2&gt;, which just holds two values together, like a key/value pair, but with no expectations as to the relationship between the two values.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">.NET 4 AND TUPLES .NET 4 provides a lot of this functionality out of the box—and for many different numbers of type parameters, too. Look for Tuple&lt;T1&gt;, Tuple&lt;T1,T2&gt;, and so on in the System namespace.</font></p>
<p><a name="bookmark1155"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1156"></a>In addition to providing properties to access the values themselves, we’ll override Equals and GetHashCode to allow instances of our type to play nicely when used as keys in a dictionary. The following listing gives the complete code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.6 Generic class representing a pair of values</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System.Collections.Generic;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public sealed class Pair&lt;T1, T2&gt; : IEquatable&lt;Pair&lt;T1, T2&gt;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static readonly IEqualityComparer&lt;T1&gt; FirstComparer = EqualityComparer&lt;T1&gt;.Default; private static readonly IEqualityComparer&lt;T2&gt; SecondComparer = EqualityComparer&lt;T2&gt;.Default;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private readonly T1 first; private readonly T2 second;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Pair(T1 first, T2 second)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">this.first = first; this.second = second;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public T1 First { get { return first; } } public T2 Second { get { return second; } } public bool Equals(Pair&lt;T1, T2&gt; other)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return other != null &amp;&amp;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FirstComparer.Equals(this.First, other.First) &amp;&amp;&nbsp;SecondComparer.Equals(this.Second, other.Second);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override bool Equals(object o)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return Equals(o as Pair&lt;T1, T2&gt;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override int GetHashCode()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return FirstComparer.GetHashCode(first) * 37 + SecondComparer.GetHashCode(second);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.6 is straightforward. The constituent values are stored in appropriately typed member variables, and access is<a name="bookmark1157"></a> provided by simple read-only properties. We implement IEquatable&lt;Pair&lt;T1, T2&gt;&gt; to give a strongly typed API that’ll avoid unnecessary execution-time checks. The equality and hash-code computations both use the default</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">equality comparer for the two type parameters—these handle nulls for us automatically, which makes the code somewhat simpler.<sup><a name="footnote23"></a><a href="#bookmark1158">23</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The static variables used to store the equality comparers for T1 and T2 are mostly there for the sake of formatting the code onto the printed page, but they’ll also be useful as a reference point in the next section.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If we wanted to support sorting, we could implement IComparer&lt;Pair&lt;T1,T2&gt;&gt;, perhaps ordering by the first component and then the second. This kind of type is a good candidate for bearing in mind what functionality you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">might</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> want, but not actually implement until you need it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we have our Pair class, how do we construct an instance of it? At the moment, you’d need to use something like this:</font></p>
<p><a name="bookmark1159"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Pair&lt;int,string&gt; pair = new Pair&lt;int,string&gt;(10, &quot;value&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s not terribly nice. It would be good to use type inference, but that only works for generic methods, and we don’t have any of those. If we put a generic method in the generic type, we’d still need to specify the type<a name="bookmark1160"></a> arguments for the type to start with. The solution is to use a nongeneric helper class with a generic method in it, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.7 Using a nongeneric type with a generic method to enable type inference</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static class Pair {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static Pair&lt;T1,T2&gt; Of&lt;T1,T2&gt;(T1 first, T2 second)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new Pair&lt;T1,T2&gt;(first, second);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1161"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">If you're reading this book for the first time, ignore the fact that the class is declared to be static—we’ll come to that in chapter 7. The important point is that we have a nongeneric class with a generic method. That means we can turn our earlier example into the far-more-pleasant</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Pair&lt;int,string&gt; pair = Pair.Of(10, &quot;value&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In C# 3 we could even dispense with the explicit typing of the pair variable, but let’s not get ahead of ourselves. This use of nongeneric helper classes (or </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">partially</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> generic helper classes, if you have two or more type parameters and want to infer some of them but leave others explicit) is a useful trick.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve finished looking at our intermediate features now. I realize it can all seem complicated at first sight, but don’t be put off: the benefits far outweigh the added complexity. Over time, they become second nature. Now that you have the Pair class as an example, it might be worth looking over your own code base to see whether there are some patterns that you keep reimplementing solely to use different types.</font></p>
<p><a name="bookmark1162"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">With any large topic there’s always more to learn. The next section will take you through the most important advanced topics in generics. If you’re feeling overwhelmed by now, you might want to skip to the relative comfort of section 3.5, where we explore some of the limitations of generics. It’s worth understanding the topics in the next section </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">eventually</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, but if everything so far has been new to you, it wouldn’t hurt to skip it for the moment.</font></p>
<p><a name="bookmark106"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1163"></a>3.4 Advanced generics</font></p>
<p><a name="bookmark1164"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You may expect me to claim that in the rest of this chapter we’ll cover every aspect of generics that we haven’t looked at so far. But there are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">so many</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> little nooks and crannies involving generics, that’s simply not possible—or at least, I certainly wouldn’t want to even read about all the de<a name="bookmark1165"></a>tails, let alone write about them. Fortunately, the nice people at Microsoft and ECMA have written all the details in the language specification, so if you ever want to check some obscure situation that isn’t covered here, that should be your nex<a name="bookmark1166"></a>t port of call. Unfortunately I can’t point to one particular area of the specification that covers generics: they pop up almost everywhere. Arguably if your code ends up in a corner case so complicated that you need to consult the specification to work out what it should do, you should refactor it into a more obvious form anyway; you don’t want each maintenance engineer from now until eternity to have to read the gory details.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">My aim with this section is to cover everything you’re </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">likely</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to want to know about generics. I’ll talk more about the CLR and framework side of things than the particular syntax of the C# 2 language, although of course it’s all relevant when developing in C#. We’ll start by considering static members of generic types, including type initialization. From there, it’s a natural step to wonder how all this is implemented under the covers—although we’ll keep it fairly light on detail, concentrating on the important effects of the implementation decisions. We’ll look at what happens when you enumerate a generic collection using foreach in C# 2, and round off the section by seeing how reflection in the .NET Framework is affected by generics.</font></p>
<p><a name="bookmark107"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1167"></a>3.4.1 Static fields and static constructors</font></p>
<p><a name="bookmark1168"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Just as instance fields belong to an instance, static fields belong to the type they’re declared in. If you declare a static field x in class SomeClass, there’s exactly one Some-Class. x field, no matter how many instances of SomeClass you create, and no matter how many types derive from SomeClass.</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup><a name="footnote24"></a><a href="#bookmark1169">24</a></font><font style="font-size:small;font-family:Times New Roman, serif;"></sup> That’s the familiar scenario from C# 1—so how does it map across to generics?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The answer is that each </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">closed</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type has its own set of static fields. We saw this in listing 3.6 when we stored the default equality comparers for T1 and T2 in static fields, but let’s look at it in more detail with another example. Listing 3.8 creates a generic type including a static field. We set the field’s value for different closed types, and then print out the values to show that they’re separate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.8 Proof that different closed types have different static fields</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class TypeWithField&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static string field; public static void PrintField()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(field + &quot;: &nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;+ &nbsp;&nbsp;&nbsp;typeof(T).Name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TypeWithField&lt;int&gt;.field = &quot;First&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TypeWithField&lt;string&gt;.field = &quot;Second&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TypeWithField&lt;DateTime&gt;.field = &quot;Third&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TypeWithField&lt;int&gt;.PrintField();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TypeWithField&lt;string&gt;.PrintField();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TypeWithField&lt;DateTime&gt;.PrintField();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We set the value of each field to a different value, and print out each field along with the name of the type argument used for that closed type. Here’s the output from listing 3.8:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">First: Int32 Second: String Third: DateTime</font></p>
<p><a name="bookmark1170"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1171"></a>So the basic rule is “one stat<a name="bookmark1172"></a>ic field per closed type.” The same applies for static initializers and static constructors. But it’s possible to have one generic type nested within another, and types with multiple generic parameters. This </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">sounds</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a lot more complicated, but it works as you probably think it should. The following listing shows this in action, this time using static constructors to show just how many types there are.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.9 Static constructors with nested generic types</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class Outer&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class Inner&lt;U,V&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static Inner()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Outer&lt;{0}&gt;.Inner&lt;{1},{2}&gt;&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">typeof(T).Name,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">typeof(U).Name,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">typeof(V).Name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;int&gt;.Inner&lt;string,DateTime&gt;.DummyMethod();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;string&gt;.Inner&lt;int,int&gt;.DummyMethod();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;object&gt;.Inner&lt;string,object&gt;.DummyMethod();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;string&gt;.Inner&lt;string,object&gt;.DummyMethod();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;object&gt;.Inner&lt;object,string&gt;.DummyMethod();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;string&gt;.Inner&lt;int,int&gt;.DummyMethod();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first call to DummyMethod() for any type will cause the type to be initialized, at which point the static constructor prints out some diagnostics. Each different list of type arguments counts as a different closed type, so the output of listing 3.9 looks like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;Int32&gt;.Inner&lt;String,DateTime&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;String&gt;.Inner&lt;Int32,Int32&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;Object&gt;.Inner&lt;String,Object&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;String&gt;.Inner&lt;String,Object&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Outer&lt;Object&gt;.Inner&lt;Object,String&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just as with nongeneric types, the static constructor for any closed type is only executed once, which is why the last line of listing 3.9 doesn’t create a sixth line of output—the static constructor for Outer&lt;string&gt;.Inner&lt;int,int&gt; executed earlier, producing the second line of output. To clear up any doubts, if we had a nongeneric PlainInner class inside Outer, there still would’ve been one possible Outer&lt;T&gt;.PlainInner type per closed Outer type, so Outer&lt;int&gt;.PlainInner would be separate from Outer&lt;long&gt;.PlainInner, with a separate set of static fields as seen earlier.</font></p>
<p><a name="bookmark1173"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve seen what constitutes a different type, we should think about what the effects of that might be in terms of the amount of native code generated. And no, it’s not as bad as you might think...</font></p>
<p><a name="bookmark108"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1174"></a>3.4.2 How the JIT compiler handles generics</font></p>
<p><a name="bookmark1175"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Given that we have all of these differen<a name="bookmark1176"></a>t closed types, the JIT’s job is to convert the IL of the generic type into native code so it can actually be run. In some ways,<a name="bookmark1177"></a> we shou<a name="bookmark1178"></a>ldn’t<a name="bookmark1179"></a> care exactly how it does that—beyond keeping a close eye on memory and CPU time, we wouldn’t see much difference if the JIT took the simplest possible approach and generated native code for each closed type separately, as if each one had nothing to do with any other type. But the JIT authors are clever enough that it’s worth seeing just what they’ve done.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s start with a simple situation first, with a single type parameter—we’ll use List&lt;T&gt; for the sake of convenience. The JIT creates different code for each closed type with a type argument that’s a value type—int, long, Guid, and the like. But it shares the native code generated for all the closed types that use a reference type as the type argu<a name="bookmark1180"></a>ment, such as string, Stream, and StringBuilder. It can do this because all references are the same size (the size varies between a 32-bit CLR and a 64-bit CLR, but within any one CLR all references are the same size). An array of references will always be the same size whatever the references happen to be. The space required on the s<a name="bookmark1181"></a>tack for a reference will always be the same. It can use the same register optimizations whatever type is being used—the List&lt;Reason&gt; goes on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Each of the types still has it<a name="bookmark1182"></a>s own static fields, as described in section 3.4.1, but the executable code itself is reused. Of course, the JIT still does all of this lazily—it won’t generate the code for List&lt;int&gt; before it needs to, and it’ll cache that code for all future uses of List&lt;int&gt;. In theory, it’s possible to share code for at least </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">some</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> value types. <a name="bookmark1183"></a>The JIT would have to be careful, not just due to size, but also for garbage collection reasons—it has to be able to quickly identify areas of a struct value that are live references. But value types that are the same size and have the same in-memory footprint as far as the GC is concerned </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> share code. At the time of this writing, that’s been of sufficiently low priority that it hasn’t been implemented, and it may well stay that way.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This level of detail is primarily of academic interest, but it does have a slight performance impact in terms of more code being JIT compiled. The performance </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">benefits </font><font style="font-size:x-small;font-family:Times New Roman, serif;">of generics can be huge, though, and again that comes down to having the opportunity to JIT to different code for different types. Co<a name="bookmark1184"></a>nsider a List&lt;byte&gt;, for<a name="bookmark1185"></a> instance. In .NET 1.1, adding individual bytes to an ArrayList would’ve meant boxing each one of them, and storing a reference to each boxed value. Using List&lt;byte&gt; has no such impact—List&lt;T&gt; has a member of type T[] to replace the object[] within ArrayList, and that array is of the appropriate type, taking the appropriate space. So List&lt;byte&gt; has a straight byte [] within it used to store the elements of the array. (In many ways, this makes a List&lt;byte&gt; behave like a MemoryStream.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 3.3 shows an ArrayList and a List&lt;byte&gt;, each with the same six values. The arrays themselves have more than six elements, to allow for growth. Both List&lt;T&gt; and ArrayList have a buffer, and they create a larger buffer when they need to.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The difference in efficiency here is incredible. Let’s look at the ArrayList first, considering a 32-bit CLR.<sup><a name="footnote25"></a><a href="#bookmark1186">25</a></sup> Each of the boxed bytes will take up 8 bytes of object overhead, plus 4 bytes (1 byte, rounded up to a word boundary) for the data itself. On top of that, you have all the references themselves, each of which takes up 4 bytes. So for each byte of useful data, we’re paying at least 16 bytes—and then there’s the extra unused space for references in the buffer.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Compare this with the List&lt;byte&gt;. Each byte in the list takes up a single byte within the elements array. There’s still wasted space in the buffer, waiting to be used potentially by new items—but at least we’re only wasting a single byte per unused element there.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We don’t just gain space, but execution speed, too. We don’t need the time taken to allocate the box, the type checking involved in unboxing the bytes in order to get at them, or the garbage collection of the boxes when they’re no longer referenced.</font></p><img src="images/11.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 3.3 Visual demonstration of why </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;T&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">takes up a lot less space than </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ArrayList </font><font style="font-size:x-small;font-family:Times New Roman, serif;">when storing value types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We don’t have to go down to the CLR level to find things happening transparently on our behalf, though. C# has always made life easier with syntactic shortcuts, and our next section looks at a familiar example but with a generic twist: iterating with</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">foreach.</font></p>
<p><a name="bookmark1187"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Generic iteration</font></p><div>
<p><a name="bookmark109"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">3.4.3</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One of the most common operations you’ll want to perform on a collection is to iterate thr<a name="bookmark1188"></a>ough all its elements. The simplest way of doing that is usually to use the foreach statement. In C# 1, this <a name="bookmark1189"></a>relied on the collection either implementing t<a name="bookmark1190"></a>he System.Collections.IEnumerable interface or havi<a name="bookmark1191"></a>ng a similar GetEnumer<a name="bookmark1192"></a>ator() method that returned a type with a suitable MoveNext() method and Current property. The Current property didn’t have to be of type object—and that was the whole point of having the<a name="bookmark1193"></a>se extra rules, <a name="bookmark1194"></a>which look odd on first sight. Yes, even in C# 1 yo<a name="bookmark1195"></a>u could avoid boxing and unboxing during iteration if you had a custom iteration type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 2 makes this somewhat easier, as the rules for the foreach statement have been extended to also use the System.Collections.Generic.IEnumerable&lt;T&gt; interface along with its partner, IEnumerator&lt;T&gt;. These are simply the generic equivalents of the old iteration interfaces, and they’re used in preference to the nongeneric versions. This means that if you iterate through a generic collection of value type ele-ments—List&lt;int&gt;, for example—then no boxing is performed at all. If the old interface had been used instead, then although we wouldn’t have incurred the boxing cost while </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">storing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the elements of the list, we’d still have ended up boxing them when we retrieved them using foreach!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All of this is done for you under the covers—all you need to do is use the fo<a name="bookmark1196"></a>reach statement in the normal way, using an appropriate type for the iteration variable, and all will be well. That’s not the end of the story, though. In the relatively rare situation when you need to implement iteration over one of your own types, you’ll find that IEnumerable&lt;T&gt; extends the old IEnumerable interface, which means you have to implement two different methods:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerator&lt;T&gt; GetEnumerator();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerator GetEnumerator();</font></p>
<p><a name="bookmark1197"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Ca<a name="bookmark1198"></a>n you see the problem? The methods differ only in return type, and the overloading rules of C# prevent you from writing two such methods normally. If you think back to section 2.2.2, we saw a similar situation—and we can use the sam<a name="bookmark1199"></a>e workaround. If you implement IEnumerable using explicit interface implementation, you can implement IEnumerable&lt;T&gt; with a “normal” method. Fortunately, because IEnumerator&lt;T&gt; extends IEnumerator, you can use the same return value for both methods, and implement the nongeneric method by just calling the generic version. Of course, now you need to implement IEnumerator&lt;T&gt; and you quickly run into similar problems, this time with the Current property.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The following listing gives a full example, implementing an enumerable class that always just enumerates to the integers 0 to 9.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.10 A full generic iterator—of the numbers 0 to 9</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class CountingEnumerable: IEnumerable&lt;int&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IEnumerator&lt;int&gt; GetEnumerator()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new CountingEnumerator();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerator IEnumerable.GetEnumerator()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return GetEnumerator();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class CountingEnumerator : IEnumerator&lt;int&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int current = -1; public bool MoveNext()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">current++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return current &lt;&nbsp;10;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int Current { get { return current; } } object IEnumerator.Current { get { return Current; } } public void Reset()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void Dispose() {}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CountingEnumerable counter = new CountingEnumerable(); foreach (int x in counter)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(x);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Clearly this isn’t useful in terms of the result, but it shows the little hoops you have to go through in order to implement generic iteration appropriately—at least if you’re doing it all longhand. (And that’s without making an effort to throw exceptions if Current is accessed at an inappropriate time.) If you think that listing 3.10 looks like a lot of work just to print out the numbers 0 to 9, I can’t help but agree with you—and there’d be even more code if we wanted to iterate over anything useful. Fortunately we’ll see in chapter 6 that C# 2 takes a large amount of the work away from iterators in many cases. I’ve shown the full version so you can appreciate the slight wrinkles that have been introduced by the design decision for IEnumerable&lt;T&gt; to extend IEnumer-able. I’m not suggesting it was the wrong decision, though; it means that you can pass any IEnumerable&lt;T&gt; into a method written in C# 1 with an IEnumerable parameter. That’s not as important now as it was back in 2005, but it’s still a useful transition path.</font></p>
<p><a name="bookmark1200"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1201"></a><a name="bookmark1202"></a>We only need the trick of using explicit interface implementation twice—once for IEnumerable.GetEnumerator </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and once at IEnumerator.Current </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Both of these call their generic equivalents (</font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">respectively). Another addition to IEnumerator&lt;T&gt; is th<a name="bookmark1203"></a>at it extends IDisposable, so you have to<a name="bookmark1204"></a> provide a Dispose method. The foreach stat<a name="bookmark1205"></a>ement in C# 1 already called Dispose on an iterator if it implemented IDisposable, but in C# 2 no execution-time testing is required—if the compiler finds that you’ve implemented IEnumerable&lt;<a name="bookmark1206"></a>T&gt;, it creates an unconditional call to Dispose at the end of the loop (in a finally block). Many iterators won’t actually need to dispose of anything, but it’s nice to know that when it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> required, the most common way of working through an iterator (the foreach statemen<a name="bookmark1207"></a>t </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">) handles the calling side automatically. This is most commonly used to release resources when you’ve finished iterating—for example, you might have an iterator that reads lines from a file, and needs to close the file handle when the calling code has finished looping.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll now go from compile-time efficiency to execution-time flexibility: our final advanced topic is reflection. Even in .NET 1.0/1.1, reflection could be tricky, but generic types and methods introduce an extra level of complexity. The framework provides everything we need (with a bit of helpful syntax from C# 2 as a language), and although the additional considerations can be daunting, it’s not too bad if you take it one step at a time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Reflection is used by different people for all sorts of things. You might use it for execution-time introspection of objects to perform a simple form of data binding. You might use it to inspect a directory full of assemblies to find im<a name="bookmark1208"></a>plementations of a plugin interface. You might write a file for an Inversion of Control framework (see <a href="http://mng.bz/xc3J">http://</a> <a href="http://mng.bz/xc3J">mng.bz/xc3J</a>) to load and dynamically configure your application’s components. As the uses of reflection are so diverse, I won’t focus on any particular one, but will give you more general guidance<a name="bookmark1209"></a> on performing common tasks. We’ll start by looking at the extensions to the typeof operator.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">USING TYPEOF WITH GENERIC TYPES</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Reflection is all about examining objects and their types. As such, one of the most important things you need to be able to do is obtain a reference to a particular System.Type object, which allows access to all the information about that type. C# uses the typeof operator to obtain such a reference for types known at compile time, and this has been extended to encompass generic types.</font></p>
<p><a name="bookmark1210"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two ways of using typeof with generic ty<a name="bookmark1211"></a>pes—one retrieves the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">generic type definition</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (in ot<a name="bookmark1212"></a>her words, the unbound generic type ) and one retrieves a particular constructed type. To obtain the generic type definition—the type with none of the type arguments specified—you simply take the name of the type as it would’ve been declared and remove the type parameter names, keeping any commas. To retrieve constructed types, you specify the type arguments in the same way as you would to declare a variable of the generic type. Listing 3.11 gives an example of both uses. It uses a generic method so we can revisit how typeof can be used with a type parameter, which we previously saw in listing 3.8.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.11 Using the typeof operator with type parameters</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void DemonstrateTypeof&lt;X&gt;()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(X));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(List&lt;&gt;)); Console.WriteLine(typeof(Dictionary&lt;,&gt;));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(List&lt;X&gt;)); Console.WriteLine(typeof(Dictionary&lt;string,X&gt;));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(List&lt;long&gt;)); Console.WriteLine(typeof(Dictionary&lt;long,Guid&gt;));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DemonstrateTypeof&lt;int&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Most of listing 3.11 works as you might naturally expect, but it’s worth pointing out two things. First, look at the syntax f<a name="bookmark1213"></a>or obtaining the gene<a name="bookmark1214"></a>ric type definition of Dictionary&lt;TKey,TValue&gt;. The comma in the angle brackets is required to tell the compiler to look for the type with two type parameters: remember that there can be</font></p>
<p><a name="bookmark1215"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">several gene<a name="bookmark1216"></a>ric types with the same name, as long as they vary by the number of type parameters they have. Similarly, you’d retrieve the generic type definition for MyClass&lt;T1,T2,T3,T4&gt; using typeof(MyClass&lt;<sub>///</sub>&gt;). The number of type parameters is specified in <a name="bookmark1217"></a>IL (a<a name="bookmark1218"></a>nd in full type names as far as the framework is concerned) by putting a back tick after the first part of the type n<a name="bookmark1219"></a>ame and then the number. The type parameters are then indicated in square brackets instead of the angle brackets we’re used to. For instance, the second line printed ends with List'1[T], showing that there’s one type parameter, and the third line includes Dictionary'2 [TKey, TValue].</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Second, note that wherever the method’s type parameter (X) is used, the actual value of the type argument is used at execution time. So line O prints List'1 [System. Int32] rather t<a name="bookmark1220"></a>han List' 1 [X], which you mi<a name="bookmark1221"></a>gh<a name="bookmark1222"></a>t have expected.<sup><a name="footnote26"></a><a href="#bookmark1223">26</a></sup> In other words, a type that’s open at compile time may be closed at execution time. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">This is very confusing. You should be aware of it in case you don’t get <a name="bookmark1224"></a>the results you expect, but otherwise, don’t worry</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. To retrieve a truly open constructed type at execution time, y<a name="bookmark1225"></a>ou need to work a bit harder. See the MSDN documentation for Type.IsGenericType for a suitably convoluted example (<a href="http://mng.bz/9W6O">http://mng.bz/9W6O</a>).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For reference, here’s the output of listing 3.11:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Int32</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Collections.Generic.List'1[T]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Collections.Generic.Dictionary'2[TKey,TValue]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Collections.Generic.List'1[System.Int32]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Collections.Generic.Dictionary'2[System.String,System.Int32]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Collections.Generic.List'1[System.Int64]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Collections.Generic.Dictionary'2[System.Int64,System.Guid]</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Having retrieved an object representing a generic type, there are many next steps you can take. All the previously available ones (finding the members of the type, creating an instance, and so on) are still present—although some aren’t applicable for generic type definitions—and there are new ones as well that let you inquire about the generic nature of the type.</font></p>
<p><a name="bookmark1226"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">METHODS AND PROPERTIES OF SYSTEM.TYPE</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are far too many new methods and properties to look at them all i<a name="bookmark1227"></a>n detail, but there are t<a name="bookmark1228"></a>wo particularly important ones: GetGenericTypeDefinition and Make-GenericType. They’re effectively opposites—the first acts on a constructed type, retrieving the generic type definition; the second acts on a generic type definition and returns a constructed type. Arguably it would’ve been clearer if this <a name="bookmark1229"></a>method had been called ConstructType, MakeConstructedType, or some other name with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">construct</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> or </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">constructed</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in it, but we’re stuck with what we’ve got.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just like normal types, there’s only one Type object for any particular type—so calling MakeGenericType twice with the same types as arguments will return the same reference twice. Similarly, calling GetGenericTypeDefinition on two types constructed</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">from the same generic type definition will give the same result for both calls, even if the constructed types are different (such as List&lt;int&gt; and List&lt;string&gt;).</font></p>
<p><a name="bookmark1230"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Another method—this <a name="bookmark1231"></a>time one that already existed in .NET 1.1—that’s worth exploring is Type.GetType(string), and its related Assem<a name="bookmark1232"></a>bly.GetType(string) method, both of which provide a dynamic equivalent to typeof. You might expect to be able to feed each line of the output of listing 3.11 to the GetType method called on an appropriate assembly, but u<a name="bookmark1233"></a>nfortunately life isn’t quite that straightforward. It’s fine for closed constructed types—the type arguments just go in square brackets. For generic type definitions, though, you need to remove the square brackets entirely— otherwise GetType thinks you mean an array type. Listing 3.12 shows all of these methods in action.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.12 Various ways of retrieving generic and constructed Type objects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string listTypeName = &quot;System.Collections.Generic.List'1&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Type defByName = Type.GetType(listTypeName);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Type closedByName = Type.GetType(listTypeName + &quot;[System.String]&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Type closedByMethod = defByName.MakeGenericType(typeof(string));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Type closedByTypeof = typeof(List&lt;string&gt;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(closedByMethod == closedByName); Console.WriteLine(closedByName == closedByTypeof);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Type defByTypeof = typeof(List&lt;&gt;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Type defByMethod = closedByName.GetGenericTypeDefinition();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(defByMethod == defByName);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(defByName == defByTypeof);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The output of listing 3.12 is just True four times, validating that however you obtain a reference to a particular type object, only one such object is involved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As I mentioned earli<a name="bookmark1234"></a>er, there are many new meth<a name="bookmark1235"></a>ods and properties on Type, such as GetGenericArguments, IsGenericTypeDefinition, and IsGenericType. Again, the documentation for IsGenericType is probably the best starting point for further exploration.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">REFLECTING GENERIC<a name="bookmark1236"></a> METHODS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Generic methods have a similar (though smaller) set of additional properties and methods. The following listing gives a brief demonstration of this, calling a generic method by reflection.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.13 Retrieving and invoking a generic method with reflection</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static void PrintTypeParameter&lt;T&gt;()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(T));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Type type = typeof(Snippet);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MethodInfo definition = type.GetMethod(&quot;PrintTypeParameter&quot;); MethodInfo constructed;</font></p>
<p><a name="bookmark1237"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a name="bookmark1238"></a>constructed = definition.MakeGenericMethod(typeof(string)); constructed.Invoke(null, null);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First we retrieve the generic method definition, and then we make a constructed generic method using MakeGenericMethod. As with types, we could go the other way if we wanted to—but unlike Type.GetType, there’s no way of specifying a constructed method in the GetMethod call. The framework also has a problem if there are methods that are overloaded purely by number of type parameters—there are no methods in Type that allow you to<a name="bookmark1239"></a> specify the number of type parameters, so instead you’d have to call Type.GetMethods and find the right<a name="bookmark1240"></a> one by loo<a name="bookmark1241"></a>king through </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">After retrieving the constructed method, we invoke it. The arguments in this example are both null, as we’re invoking a static method that doesn’t have any normal parameters. The output is System.String, as we’d expect. Note that the methods retrieved from generic type definitions can’t be invoked directly—instead, you must get the method from a constructed type. This applies to both generic and nongeneric methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">SAVED BY C# 4 If all of t<a name="bookmark1242"></a>his looks messy to you, I agree. Fortunately, in many cases C#’s dynamic t<a name="bookmark1243"></a>yping can come to the rescue, taking a lot of the work out of generic reflection. It doesn’t help in all situations, so it’s worth being aware of the general flow of the preceding code, but where it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> apply it’s great.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll look at dynamic typing in detail in chapter 14.</font></p>
<p><a name="bookmark1244"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Again,<a name="bookmark1245"></a> more methods and properties are available on MethodInfo, and IsGeneric-Method is a good starting point in MSDN (<a href="http://mng.bz/PDmC">http://mng.bz/PDmC</a>). Hopefully the information in this section will have been enough to get you going, though—and to point out some of the added complexities you might not have otherwise anticipated when first starting to access generic types and methods with reflection.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s all we’re going to cover in the way of advanced features. Just to reiterate, this isn’t meant to be a complete guide by any means—but most developers are unlikely to need to know the more obscure areas. I hope for your sake that you fall into this camp, as specifications tend to get harder to read the deeper you go into them. Remember that unless you’re developing alone and just for yourself, you’re unlikely to be the only one to work on your code. If you need features that are more complex than the ones demonstrated here, you almost certainly shouldn’t assume that anyone reading your code will understand it without help. On the other hand, if you find that your co-workers don’t know about some of the topics we’ve covered so far, please feel free to direct them to the nearest bookshop...</font></p>
<p><a name="bookmark1246"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Our final main section of the chapter looks at some of the limitations of generics in C# and considers similar features in other languages.</font></p>
<p><a name="bookmark112"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;"><a name="bookmark1247"></a>3.5 </font><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Limitations of generics in<a name="bookmark1248"></a> C# and other languages</font></p>
<p><a name="bookmark1249"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s no dou<a name="bookmark1250"></a>bt that generics co<a name="bookmark1251"></a>ntribute a great deal to C# in terms of expressiveness, type safety, and perform<a name="bookmark1252"></a>ance. The feature has been carefully <a name="bookmark1253"></a>designed to cope with most of the tasks that C++ programmers typically used templates for, but without some of the accompanying disadvantages. But this isn’t to say limitations don’t exist.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are some problems that C++ templates so<a name="bookmark1254"></a>lve with ease but that C# generics can’t help with. Similarly, though generics in Java are generally less powerful than in C#, there are some concepts that can be expressed in Java but that don’t have a C# equivalent. This section will take you through some of the most commonly encountered weaknesses, and I’ll briefly compare the C#/.NET implementation of generics with C++ templates and Java generics.</font></p>
<p><a name="bookmark1255"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s important to stress that pointing out these snags doesn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">imply</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that they should’ve been avoided in the first plac<a name="bookmark1256"></a>e. In particular, I’m in <a name="bookmark1257"></a>no way saying that I could’<a name="bookmark1258"></a>ve done a better job! The language and platform designers have had to balance power with complexity (and the small matter of achieving both design and implementation within a reasonable time scale). Most likely, you won’t encounter problems, and if you do, you’ll be able to work around them with the guidance given here.</font></p>
<p><a name="bookmark1259"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll start with the answer to a question that almost everyone raises sooner or later: why can’t I convert a List&lt;string&gt; to a List&lt;object&gt;?</font></p>
<p><a name="bookmark113"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1260"></a>3.5.1 Lack of generic variance</font></p>
<p><a name="bookmark1261"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1262"></a><a name="bookmark1263"></a>In section<a name="bookmark1264"></a> 2.2.2, we looked at the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">covariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of arrays—the fact that an array of a reference type can be viewed as an array of its base type, or an array of any of the interfaces it implements. There are actually t<a name="bookmark1265"></a>wo forms of this idea, called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">covariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">contr<a name="bookmark1266"></a>avariance,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> or collectively just </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">var<a name="bookmark1267"></a>iance.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Generics don’t support this—they’re </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">invariant. </font><font style="font-size:x-small;font-family:Times New Roman, serif;">This is for the sake of type safety, as we’ll see, but it can be annoying.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One thing I'd like to make clear to start with: C# 4 improves the generic variance situation somewhat. Many of the restrictions listed here </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> still apply though, and this section serves as a useful introduction to the idea of variance. We’ll see how C# 4 helps in chapter 13, but many of the clearest examples of generic variance rely on other new features from C# 3, including LINQ. Variance is also quite a complicated topic in itself, so it’s worth waiting until you’re comfortable with the rest of C# 2 and 3 before you tackle it. For the sake of readability, I’m not going to point out every place in this section that’s slightly different in C# 4... it’ll all become clear in chapter 13.</font></p>
<p><a name="bookmark1268"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">WHY DON’T GENERICS SUPPORT COVARIANCE?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s suppose we have two classes, Turtle and Cat, both of which derive from an abstract Animal class. In the code that follows, the array code (on the left) is valid C# 2; the generic code (on the right) isn’t:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Valid (at compile time) &nbsp;&nbsp;&nbsp;Invalid</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Animal[] animals = new Cat[5]; &nbsp;&nbsp;&nbsp;List&lt;Animal&gt; animals = new &nbsp;&nbsp;&nbsp;List&lt;Cat&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">animals[0] = new Turtle(); &nbsp;&nbsp;&nbsp;animals.Add(new Turtle());</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler has no problem with the second line in either case, but the first line on the right causes the following error:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">error CS0029: Cannot implicitly convert type</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">'System.Collections.Generic.List&lt;Cat&gt;' to 'System.Collections.Generic.List&lt;Animal&gt;'</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This was a deliberate choice on the part of the framework and language designers. The obvious question to ask is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">why</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> this is prohibited—and the answer lies on the second line. There’s nothing about the second line that should raise any suspicion. After all, List&lt;Animal&gt; effectively has a method with the signature void Add(Animal value)—you should be able to put a Turtle into any list of animals, for instance. But the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">actual</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> object referred to by animals is a Cat[] (in the code on the left) or a List&lt;Cat&gt; (on the right), both of which require that only references to instances of Cat (or further subclasses) are stored in them. Although the array version will compile, it’ll fail at execution time. This was deemed by the designers of generics to be worse than failing at compile time, which is reasonable—the whole point of static typing is to find out about errors before the code ever gets run.</font></p>
<p><a name="bookmark1269"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">SO WHY ARE ARRAYS COVARIANT? Having answered the question about why generics are invariant, the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">next</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> obvious step is to question why arrays are covariant. According to the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Common Language Infrastructure Annotated Standard </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(Miller and Ragsdale, Addison-Wesley Professional, 2003), for the first edition the designers wanted to reach as broad an audience as possible, which included being able to run code compiled from Java source. In other words,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">.NET has covariant arrays because Java has covariant arrays—despite this being a known wart in Java.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, that’s why things are the way they are—but why should you care, and how can you get around the restriction?</font></p>
<p><a name="bookmark1270"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">WHERE COVARIANCE WOULD BE USEFUL</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The example I’ve given with a list is clearly problematic. We can add items to the list, which is where we lose the type safety in this case. Now an add operation is an example of a value being used as an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">input</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> into the API: the caller is supplying the value. What would happen if we limited ourselves to getting values out?<a name="bookmark1271"></a> The obvious example of this is IEnumerator&lt;T&gt; and (by association) IEnumerable&lt;T&gt;. In fact, these are almost the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">canonical</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> example for generic covariance. Together they describe a sequence of values—all we know about the values we see is that each one will be compatible with T, such that you can always write</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T currentValue = iterator.Current;</font></p>
<p><a name="bookmark1272"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1273"></a>This uses the normal idea of compatibility—it would be fine for an IEnumerator &lt;Animal&gt; to yield references to instances of Cat or Turtle, for example. There’s no way we can push values that are inappropriate for the actual sequence type, so we’d like to be able to treat an IEnumerator&lt;Cat&gt; as an IEnumerator&lt;Animal&gt;. Let me give an example of where that might be useful.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Suppose we take the customary shape example for inheritance, but using an interface (IShape). Now consider another interface, IDrawing, to represent a drawing made up of shapes. We’re going to have two concrete types of drawing—a Mondrian-Drawing (made of rectangles) and a SeuratDrawing (made of circles).<sup><a name="footnote27"></a><a href="#bookmark1274">27</a></sup> Figure 3.4 shows the class hierarchies involved.</font></p><img src="images/12.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Both drawing types need to implement the IDrawing interface, so they need to expose a property with this signature:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;IShape&gt; Shapes { get; }</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But each drawing type would probably find it easier to maintain a more strongly typed list internally. For example, a Seurat drawing may include a field of type List&lt;Circle&gt;. It’s useful for it to have this rather than a List&lt;IShape&gt; so that if it needs to manipulate the circles in a circle-specific way, it can do so without casting. If we had a List&lt;ISha<a name="bookmark1275"></a>pe&gt;, we could either return it directly or at least wrap it in a ReadOnly-Collection&lt;IShape&gt; to prevent callers from messing with it via casting—the property implementation would be cheap and simple either way. But we can’t do that when our types don’t match up... we can’t convert from an IEnumerable&lt;Circle&gt; to an IEnumerable&lt;Shape&gt;. So what </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> we do?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are a few options here. We could</font></p>
<p><a name="bookmark1276"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Change the field type to List&lt;IShape&gt; and just live with the casts. This isn’t pleasant, and defeats a lot of the point of using generics.</font></p>
<p><a name="bookmark1277"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Use the new features provided by C# 2 for implementing iterators, as we’ll see in chapter 6. This is a reasonable solution for this particular case, but </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> this case (when we’re dealing with IEnumerable&lt;T&gt;).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Make each Shapes property i<a name="bookmark1278"></a>mplementation create a new copy of the list, possibly using List&lt;T&gt;.ConvertAll for simplicity. Creating an independent copy of a collection is often the right thing to do in an API anyway, but it does cause a lot of copying, which can be unnecessarily inefficient in many cases.</font></p>
<p><a name="bookmark1279"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Make IDrawing generic, indicating the type of shapes in the drawing. Thus MondrianDrawing would implement IDrawing&lt;Rectangle&gt; and SeuratDrawing would implement IDrawing&lt;Circle&gt;. This is only viable when you own the interface.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Create a helper class to adapt one kind of IEnumerable&lt;T&gt; into another: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class EnumerableWrapper&lt;TOriginal, TWrapper&gt; : IEnumerable&lt;TWrapper&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">where TOriginal : TWrapper</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Again, as this particular situation (IEnumerable&lt;T&gt;) is special, we could get away with just a utility method. In fact, .NET 3.5 ships with two useful methods</font></p>
<p><a name="bookmark1280"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">like this: Enumerable.Cast&lt;T&gt; and Enumerable.OfType&lt;T&gt;. They’re part of LINQ, and we’ll look at them in chapter 11. Although this is a special case, it’s probably the most common form of generic covariance you’ll come across.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When you run into covariance issues, you may need to consider all of these options and anything else you can think of. It depends heavily on the exact nature of the situation. Unfortunately, covariance isn’t the only problem we have to deal with. There’s also the matter of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">contravariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which is like covariance in reverse.</font></p>
<p><a name="bookmark1281"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">WHERE CONTRAVA<a name="bookmark1282"></a>RIANCE WOULD BE USEFUL</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Contravariance feels slightly less intuitive than covariance, but it does make sense. With covariance, we were trying to convert from SomeType&lt;Circle&gt; to Some-Type&lt;IShape&gt; (using IEnumerable&lt;T&gt; for SomeType in our example). Contravariance is about converting the other way—from SomeType&lt;IShape&gt; to SomeType&lt;Circle&gt;. How can that be safe? Well, covari<a name="bookmark1283"></a>ance is safe when SomeType only describes operations that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">return</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the type parameter—and contravariance is safe when SomeType only describes operations that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">accept</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the type parameter.<sup><a name="footnote28"></a><a href="#bookmark1284">28</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The simplest exa<a name="bookmark1285"></a>mple of a type that only uses its type parameter in an input position is IComparer&lt;T&gt;, which is commonly used to sort collections. Let’s expand our IShape interface (which has been empty so far) to include an Area property. It’s now easy to write an implementation of IComparer&lt;IShape&gt; that compares any two shapes by area. We’d then </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">like</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be able to write the following code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IComparer&lt;IShape&gt; areaComparer = new AreaComparer();</font></p>
<p><a name="bookmark1286"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Circle&gt; circles = new List&lt;Circle&gt;(); circles.Add(new Circle(Point.Empty, 20)); circles.Add(new Circle(Point.Empty, 10));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">INVALID^, circles . Sort (areaComparer) ;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That won’t work, though, because the Sort method on List&lt;Circle&gt; effectively takes an IComparer&lt;Circle&gt;. The fact that our AreaComparer can compare </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">any</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> shape rather than just circles doesn’t impress the compiler at all. It considers IComparer &lt;Circle&gt; and IComparer&lt;IShape&gt; to be completely different types. Maddening, isn’t it? It would be nice if the Sort method had this signature instead:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Sort&lt;S&gt;(IComparer&lt;S&gt; comparer) where T : S</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Unfor<a name="bookmark1287"></a>tunately, not only is that not the signature of Sort, but it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be—the constraint is invalid, because it’s a constraint on T instead of S. We want a conversion type constraint but in the other direction, constraining the S to be somewhere </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">up</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the inheritance tree of T instead of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">down</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Given that this isn’t possible, what </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> we do? There are fewer opti<a name="bookmark1288"></a>ons this time. First, you could revisit the idea of creating a generic helper class as shown in listing 3.14.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 3.14 Working around the lack of contravariance with a helper</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class ComparisonHelper&lt;TBase, TDerived&gt; : IComparer&lt;TDerived&gt; where TDerived : TBase</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private readonly IComparer&lt;TBase&gt; comparer; public ComparisonHelper(IComparer&lt;TBase&gt; comparer)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">this.comparer = comparer;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int Compare(TDerived x, TDerived y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return comparer.Compare(x, y);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1289"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Again, this is the adapter pattern at work, this time varying in the type of items to compare. We just remember the original comparer providing the real logic to compare items of the base type Q and then call it when we’r<a name="bookmark1290"></a>e asked to compare items of the derived type G. The fact that we don’t have any casts involved (not<a name="bookmark1291"></a> even hidden ones) should give us some confidence: this helper is com<a name="bookmark1292"></a>pletely type-safe. We’re able to call the base comparer due to an implicit conversion being available from TDerived to TBase, which we required with a type constraint O.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The secon<a name="bookmark1293"></a>d option is to make the area comparison class generic, with a conversion type constraint, so it can compare any two values of the same type, as long as that type implements IShape. For the sake of simplicity in the situation where you really don’t need this functionality, you could keep the nongeneric class by just making it derive from the generic one:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class AreaComparer&lt;T&gt; : IComparer&lt;IShape&gt; where T : IShape class AreaComparer : AreaComparer&lt;IShape&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, you can only do this when you’re able to change the comparison class. This can be an effective solution, but it still feels unnatural—why should you have to construct the comparer in various ways for different types, when it’s not going to behave any differently? Why should you have to derive from the class to simplify things when you’re not actually specializing the behavior?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note that the various options for both covariance and contravariance use more generics and constraints to<a name="bookmark1294"></a> express the interface in a more general manner, or to provide generic helper classes. I know that adding a constraint makes it sound </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">less</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> general, but the generality is added by first making the type or method generic. When you run into a problem like this, adding a level of genericity somew<a name="bookmark1295"></a>here with an appropriate constraint should be the first option to consider.<a name="bookmark1296"></a> Generic </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">methods</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (rather than generic types) are often helpful here, as type inference can make the lack of variance invisible to the naked eye. This is particularly true in C# 3, which has stronger type inference capabilities than C# 2.</font></p>
<p><a name="bookmark1297"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This limitation is a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> common cause of questions on C# discussion sites. The remaining issues are either relatively academic or affect only a moderate subset of the development community. The next one mostly affects those who do a lot of calculations (usually scientific or financial) in their work.</font></p>
<p><a name="bookmark114"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1298"></a>3.5.2 Lack of operator constraints or a “numeric” constraint</font></p>
<p><a name="bookmark1299"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1300"></a>C# isn’t without its dow<a name="bookmark1301"></a>nsides when it comes to heavily mathematical code. The need to explicitly use the Math class for every operation beyond the simplest arithmetic and the lack of C-style typedefs to allow the data representation used<a name="bookmark1302"></a> throughout<a name="bookmark1303"></a> a program to be easily changed have always been raised by the scientific community as barriers to C#’s adoption. Generics weren’t likely to fully solve either of those issues, but there’s a common problem that stops generics from helping as much as they could have. Consider this (illegal) generic method:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public T FindMean&lt;T&gt;(IEnumerable&lt;T&gt; data)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T sum = default(T);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int count = 0;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (T datum in data)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">sum += datum; count++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return sum / count;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Obviously that could never work for </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> types of data—wh<a name="bookmark1304"></a>at could it mean to add one Exception to another, for instance? Clearly a constraint of some kind is called for... something that can express what we need to be able to do: add two instances of T together, and divide a T by an integer. If that were available, even if it were limited to built-in types, we could write generic algorithms that wouldn’t care whether they were working on an int, a long, a double, a decimal, and so forth. Limiting it to the built-in types would’ve been disappointing but better than nothing. The ideal solution would have to al<a name="bookmark1305"></a>so allow user-defined types to act in a numeric capacity—so you could define a Complex type to handle complex numbers, for instance.<sup><a name="footnote29"></a><a href="#bookmark1306">29</a></sup> That complex number could then store each of its components in a generic way as well, so you could have a Complex&lt;float&gt;, a Complex&lt;double&gt;, and so on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Two related solutions present themselves. One would be simply to allow constraints on operators, so you could write a set of constraints such as</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">where T : T operator+ (T, T), T operator/ (T, int)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This would require that T have the operati<a name="bookmark1307"></a>ons we need in the earlier code. The other solution would be to define a few operators and perhaps conversions that must be supported in order for a type to meet the extra constraint—we could make it the “numeric constraint” written where T : numeric.</font></p>
<p><a name="bookmark1308"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One problem with both of these options is that they can’t be expressed as normal interfaces, because operator overloading is performed with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">static</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> members, which can’t be used to implement interfaces. I find the idea of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">static interfaces</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> appealing: interfaces that only declare stati<a name="bookmark1309"></a>c members, including methods, operators, and constructors. Such static interfaces would only be useful within type constraints, but they’d present a type-safe generic way of accessing static members. This is just blue sky thinking, though (see <a href="http://mng.bz/3Rk3">http://mng.bz/3Rk3</a>)—I don't know of any plans to include this in a future version of C#.</font></p>
<p><a name="bookmark1310"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1311"></a>The two neatest workarounds for <a name="bookmark1312"></a>this problem to date require later versions of .NET: one designed by Marc Gravell (<a href="http://mng.bz/9m8i">http://mng.bz/9m8i</a>) uses expression trees (which <a name="bookmark1313"></a>we’ll meet in chapter 9) to build dynamic methods; the other is to use the dynamic features of C# 4. We’ll see an example of the latter in chapter 14. But, as you can tell by the descriptions, both of these are dynamic—you have to wait until execution time to see whether your code will work with a particular type. There are a few workarounds that still use static typing, bu<a name="bookmark1314"></a>t they have other disadvantages (surprisingly enough, they can sometimes be slower than the dynamic code).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The two limitations we’ve looked at so far have been quite practical—they’ve been issues you may well run into during actual development. But if you’re generally curious like I am, you may also be asking yourself about other limitations that don’t necessarily slow down development but are intellectual curiosities. In particular, just why are generics limited to types and methods?</font></p>
<p><a name="bookmark115"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1315"></a>3.5.3 Lack of generic properties, indexers, and other member types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen generic types (classes, structs, delegates, and interfaces) and we’ve seen generic methods. The<a name="bookmark1316"></a>re are plenty of other members that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be parameterized. But there are no generic properties, indexers, operators, constructors, finalizers, or events. First let’s be clear about what we mean here: clearly an indexer can have a return type that’s a type parameter—List&lt;T&gt; is an obvious example. KeyValue-Pair&lt;TKey,TValue&gt; provides similar examples for properties. What you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have is an indexer or property (or any of the other members in that list) with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extra</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type parameters. Leaving the possible syntax of declaration aside for the minute, let’s look at how these members might have to be called:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SomeClass&lt;string&gt; instance = new SomeClass&lt;string&gt;&lt;Guid&gt;(&quot;x&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int x = instance.SomeProperty&lt;int&gt;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">byte y = instance.SomeIndexer&lt;byte&gt;[&quot;key&quot;];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">instance.Click&lt;byte&gt; += ByteHandler;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">instance = instance +&lt;int&gt; instance;</font></p>
<p><a name="bookmark1317"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I hope you’ll agree that all of those look somewhat silly. Finalizers can’t even be called explicitly from C# code, which is why there isn’t a line for them. The fact that we can’t do any of these isn’t going to cause significant problems anywhere, as far as I can see—it’s just worth being aware of this as an academic limitation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The one exception to this is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">possibly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the constructor. A static generic method in the class is<a name="bookmark1318"></a> a good workaround for this, though, and the syntax with two lists of type arguments is horrific.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">These are by no means the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> limitations of C# generics, but I believe they’re the ones that you’re most likely to run up against, either in your daily work, in community conversations, or when idly considering the feature as a whole. In our next two sections, we’ll see how some aspects of these aren’t issues in the two languages whose features are most commonly compared with C#’s generics: C++ (with templates) and Java (with generics as of Java 5). We’ll tackle C++ first.</font></p>
<p><a name="bookmark116"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1319"></a><a name="bookmark1320"></a><a name="bookmark1321"></a>3.5.4 Comparison with</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> C++ </font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">templates</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C++ templates are a bit like macros taken to an extreme level. They’re incredibly powerful, but have costs associated with them both in terms of code bloat and ease of understanding.</font></p>
<p><a name="bookmark1322"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When a template is used in C++, the code is compiled for that particular set of template arguments, as if the template arguments were in the source code. This means that there’s not as much need for constraints, as the compiler will check whether you’re allowed to do everything you want to with the type anyway while it’s compiling the code for this particular set of template arguments. The C++ standards committee has recognized that constraints are still useful, though. They’ve been postponed from C++0x (the next version of C++)<a name="bookmark1323"></a> but may yet see the light of day some time in the future, under the name of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">concepts.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The C++ compiler is smart enough to compile the code only once for any given set of template arguments, but it isn’t able to share code in the way that the CLR does with reference types. That lack of sharing does have its benefits, though—it allows type-specific optimizations, such as inlining method calls for some type parameters but not others, from the same template. It also means that overload resolution can be performed separately for each set of type parameters, rather than just once based solely on the limited knowledge the C# com<a name="bookmark1324"></a>piler has due to any constraints present.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Don’t forget that with normal C++ there’s only one compilation involved, rather than the “compile to IL” then “JIT compile to native code” model of .NET. A program using a standard template in 10 different ways will include the code 10 times in a C++ program. A similar program in C# using a generic type from the framework in 10 differ<a name="bookmark1325"></a>ent ways won’t include the code for the generic type at all—it’ll refer to it, and the JIT will compile as many different versions as required (as described in section 3.4.2) at execution time.</font></p>
<p><a name="bookmark1326"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One significant feature that C++ templates have ove<a name="bookmark1327"></a>r C# generics is that th<a name="bookmark1328"></a>e template arguments don’t have to be type names. Variable names, function names, and constant expressions can be used as well. A common example of this is a buffer type that has the size of the buffer as one of the template arguments—so a buffer &lt;int,20&gt; will always be a buffer of 20 integers, and a buffer&lt;double,35&gt; will al<a name="bookmark1329"></a>ways be a buffer of 35 doubles. This ability is crucial to template metaprogramming (see <a href="http://mng.bz/c1G0">http://mng.bz/c1G0</a>)—an advanced C++ technique the very idea of which scares me, but that can be powerful in the hands of experts.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C++ templates are more flexible in other ways, too. They don’t suffer from the problem described in section 3.5.2, and there are a few other restrictions that don’t exist in C++: you can derive a class from one of its type parameters, and you can specialize a template for a particular set of type arguments. The latter ability allows the template author to write general code to be used when there’s no more knowledge available but specific (often highly optimized) code for particular types.</font></p>
<p><a name="bookmark1330"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1331"></a>The same variance issues of .NET generics exist in C++ templates as well—an example given by Bjarne Stroustrup<sup><a name="footnote30"></a><a href="#bookmark1332">30</a></sup> is that there are no implicit conversions between vector&lt;shape*&gt; and vector&lt;circle*&gt; with similar reasoning—in this case, it might allow you to put a square peg in a round hole.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For further details of C++ templates, I recommend Stroustrup’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">The C++ Programming Language</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (Addison-Wesley, 1991). It’s not always the easiest book to follow, but the templates chapter is fairly clear (once you get your mind around C++ terminology and syntax). For more comparisons with .NET generics, look at the blog post by the Visual C++ team on this topic (<a href="http://mng.bz/En13">http://mng.bz/En13</a>).</font></p>
<p><a name="bookmark1333"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1334"></a>The other obvious language to compare with C# in terms of generics is Java, which introduced the feature into the mainstream language for the 1.5 release,<sup><a name="footnote31"></a><a href="#bookmark1335">31</a></sup> several years after other projects had created Java-like languages which supported generics.</font></p>
<p><a name="bookmark117"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1336"></a>3.5.5 Comparison with Java generics</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Where C++ includes </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">more</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the template in the generated code than C# does, Java includes <a name="bookmark1337"></a></font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">less.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> In fact, the Java runtime doesn’t know about generics at all. The Java bytecode (roug<a name="bookmark1338"></a>hly equivalent terminology to IL) for a generic type includes some extra metadata to say that it’s generic, but after compilation the calling code doesn’t have much to indicate that generics were involved at all—and certainly an instance of a generic type only knows about the nongeneric side of itself. For example, an instance of HashSet&lt;T&gt; doesn’t know whether it was cr<a name="bookmark1339"></a>eated as a HashSet&lt;String&gt; or a HashSet&lt;Object&gt;. <a name="bookmark1340"></a>The compiler effectively adds casts where necessary and performs more sanity checking. Here’s an example—first the generic Java code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;(); strings.add(&quot;hello&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">String entry = strings.get(O); strings.add(new Object());</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">and now the equivalent nongeneric code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ArrayList strings = new ArrayList(); strings.add(&quot;hello&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">String entry = (String) strings.get(O); strings.add(new Object());</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">They would generate the same Java bytecode, except for the last line—which is valid in the nongeneric case but caught by<a name="bookmark1341"></a> the compiler as an error in the generic version. You can use a generic type as a raw type, which is equivalent to using java. lang .Object for each of the type arguments. This rewriting—and loss of information—is called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">type <a name="bookmark1342"></a><a name="bookmark1343"></a>erasure</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Java doesn’t have user-defined value types, but you can’t even use the built-in ones as type arguments. Instead, you have to use the boxed version—ArrayList&lt;Inte-ger&gt; for a list of integers, for example.</font></p>
<p><a name="bookmark1344"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You’ll be forgiven for thinking this is all a bit disappointing compared with generics in C#, but there are some nice features of Java generics, too:</font></p>
<p><a name="bookmark1345"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The virtual machine doesn’t know anything about generics, so you can use code compiled using generics on an older version, as long as you don’t use any classes or methods that aren’t present on the old version. Versioning in .NET is much stricter in general—for each assembly you reference, you can specify whether the version number has to match exactly. In addition, code built to run on the 2.0 CLR won’t run on .NET 1.1.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;You don’t need to learn a new set of classes to use Java generics—where a nongeneric developer would use ArrayList, a generic developer just uses Array-List&lt;T&gt;. Existing classes can reasonably easily be upgraded to generic versions.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The previous feature has been utilized quite effectively with the reflection system—java.lang.Class (the equivalent of System.Type) is generic, which allows compile-time type safety to be extended to cover many situations involving reflection. In some other situations it’s a pain, t<a name="bookmark1346"></a>hough.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Java has support for generic variance using wildcards. For instance, ArrayList&lt;? extends Base&gt; can be read as “this is an ArrayList of some type that derives from Base, but we don’t know which exact type.” When we discuss C# 4’s support for generic variance in chapter 13, we’ll revisit this with a short example.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">My personal opinion is that .NET generics are superior in almost every respect, although when I run into covariance/contravariance issues I often wish I had wildcards. C# 4’s limited generic variance improves this somewhat, but there are still times where the variance Java model works better. Java with ge<a name="bookmark1347"></a>nerics is still much better than Java without generics, but there are no performance benefits and the safety only applies at compile time.</font></p>
<p><a name="bookmark118"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;"><a name="bookmark1348"></a>3.6 </font><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Phew! It’s a good thing generics are simpler to use in reality than they are to describe. Although they </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> get complicated, they’re widely regarded as the most important addition to C# 2 and are incredibly useful. The worst thing about writing code using generics is that if you ever have to go back to C# 1, you’ll miss them terribly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this chapter I haven’t tried to cover every detail of what is and isn’t allowed when using generics—that’s the job of the language specification, and it makes for dry reading. Instead, I’ve aimed for a practical approach, providing the information you’ll need in everyday use, with a smattering of theory for the sake of academic interest.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen three main benefits to generics: compile-time type safety, performance, and code expressiveness. Being able to get the IDE and compiler to validate your code early is certainly a good thing, but it’s arguable that more is to be gained from tools providing intelligent options based on the types involved than the actual safety aspect.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Performance is improved most radically when it comes to value types, which no longer need to be boxed and unboxed when they’re used in strongly typed generic APIs, particularly the generic collection types provided in .NET 2.0. Performance with reference types is usually improved but only slightly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Your code is able to express its intention more clearly using generics—instead of a comment or a long variable name being required to describe exactly what types are involved, the details of the type itself can do the work. Comments and variable names can often become inaccurate over time, as they can be forgotten when the code is changed—but the type information is correct by definition.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Generics aren’t capable of doing </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">everything</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> we might sometimes like them to do, and we’ve studied some of their limitations in the chapter, but if you truly embrace C# 2 and the generic types within the .NET 2.0 Framework, you’ll come across good uses for them incredibly frequently in your code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This topic will come up time and time again in future chapters, as other new features build on this key one. Indeed, the subject of our next chapter would be very different without generics—we’re going to look at nullable types, as implemented by Nullable&lt;T&gt;.</font></p>
<p><a name="bookmark1349"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark1350"></a>Saying nothing with nullable types</font></p>
<p><a name="bookmark6"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1351"></a>This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Motivation for null values</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Framework and runtime support</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Language support in C# 2</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Patterns using nullable types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Nullity is a concept that has provoked debate over the years. Is a null reference a value, or the absence of a value? Is “nothing” a “something”? Should languages support the concept of nullity at all, or should it be represented in other patterns? In this chapter, I’ll try to stay more practical than philosophical. First we’ll look at why there’s a problem at all—why you can’t set a value type variable to null in C# 1 and what the traditional alternatives have been. After that, I’ll introduce you to our knight in shining armor—System.Nullable&lt;T&gt; —before we see how C# 2 makes working with nullable types simple and compact. Like generics, nullable types sometimes have some uses beyond what you might expect, and we’ll look at a few examples of these at the end of the chapter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, when is a value not a value? Let’s find out.</font></p>
<p><a name="bookmark121"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1352"></a>4.1 &nbsp;&nbsp;&nbsp;What do you do when you just don’t have a value?</font></p>
<p><a name="bookmark1353"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The C# and .NET designers don’t add features just for kicks. There has to be a real, significant problem to be fixed before they’ll go as far as changing C# as a language or .NET at the platform level. In th<a name="bookmark1354"></a>is case, the problem is best summed up in one of the most frequently asked questions in C# and .NET discussion groups:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">I need to set my DateTime<sup><a name="footnote32"></a><a href="#bookmark1355">32</a></sup> variable to null, but the compiler won't let me. What should I do?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s a question that comes up fairly naturally—an example might be in an e-commerce application where users are looking at their account history. If an order has been placed but not delivered, there may be a purchase date but no dispatch date—so how would you represent that in a type that’s meant to provide the order details?</font></p>
<p><a name="bookmark1356"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Before C# 2, the answer to the question was usually in two parts: first, why you couldn’t just use null in the first place, and second, which options were available. Nowadays the answer would usually explain nullable types instead—but it’s worth looking at the C# 1 options to understand where the problem comes from.</font></p>
<p><a name="bookmark122"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1357"></a>4.1.1 &nbsp;&nbsp;&nbsp;Why value type variables can’t be null</font></p>
<p><a name="bookmark1358"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1359"></a>As we saw in chapter 2, the value of a reference type variable is a reference, and the value of a value type variabl<a name="bookmark1360"></a>e is the real data itself. A non-null reference is a way of getting at an object, but null acts as a special value that mean<a name="bookmark1361"></a>s “I don’t refer to any object.” If you want to think of references as bein<a name="bookmark1362"></a>g like URLs, null is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">(very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> roughly speaking) the reference equivalent of about:blank. It’s represented as all zeroes in memory (which is why it’s the default value for all reference types—clearing a whole block of memory is cheap, so that’s the way objects are initialized), but it’s still basically stored in the same way as other references. There’s no extra bit hidden somewhere for each reference type variable. That means we can’t use the “all zeroes” value for a real reference, but that’s okay—our memory is going to run out long before we have that many live objects anyway.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The last sentence is the key to why null isn’t a valid </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">value</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type value, though. Let’s cons<a name="bookmark1363"></a>ider the byt<a name="bookmark1364"></a>e type as a familiar one that's easy to think about. The value of a variable of type byte is stored in a single byte—it may be padded for alignment purposes, but the value itself is conceptually only made up of one byte. We’ve </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">got</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be able to store the <a name="bookmark1365"></a>values 0-255 in that variable; otherwise it’s useless for reading arbitrary binary data. So, with the 256 normal values and one null value, we’d have to cope with a total of 257 values, and there’s no way of squeezing that many values into a single byte. Now, the designers could’ve decided that every value type would have an extra flag bit somewhere determining whether a value was null or contained real data, but the memory usage implications are horrible, not to mention the fact that we’d have to check the flag every time we wanted to use the value. So in a nutshell, with value types you often care about having the whole range of possible bit patterns available as real values, whereas with reference types we’re happy enough to lose one potential value in order to gain the benefits of making the null reference available.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s the usual situation—now why would you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">want</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be able to represent <a name="bookmark1366"></a>null for a value type a<a name="bookmark1367"></a>nyway? The most common reason is simply because databases typically support NULL as a value for every type (unless you specifically make the field non-nullable), so you can have nullable character data, nullable integers, nullable Bool-eans—the whole works. When you fetch data from a database, it’s generally not a good idea to lose information, so you want to be able to represent the nullity of whatever you read, somehow.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That just moves the question one step further on, though. Why do databases allow null values for dates, integers, and the like? Null values are typically used for unknown or missing values such as the dispatch date in our earlier e-commerce example. Nullity represents an absence of definite information, which can be important in many situations. Indeed, there doesn’t have to be a database involved for nullable value types to be useful: that’s just the scenario where developers typically encounter the problem first.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That brings us to options for representing null values in C# 1.</font></p>
<p><a name="bookmark123"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1368"></a><a name="bookmark1369"></a>4.1.2 Patterns for representing null values in C# 1</font></p>
<p><a name="bookmark1370"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are three basic patterns commonly used to get around the lack of nullable value types in C# 1. Each has its pros and cons—mostly cons—and all of them are fairly unsatisfying. But they’re worth knowing, partly to more fully appreciate the benefits of the integrated solution in C# 2.</font></p>
<p><a name="bookmark1371"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">PATTERN 1: THE MAGIC VALUE</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first pattern tends to be used as the solution for DateTime, because few people expect their databases to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">actually</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> contain dates in AD1. In other words, it goes against the line of reasoning I gave earlier, which assumes that every possible value needs to be availa<a name="bookmark1372"></a>ble for normal purposes. So, we s<a name="bookmark1373"></a>acrifice one value (typically DateTime. MinValue) to mean a null value. The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">semantic</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> meaning of that will vary from application to application—it may mean that the user hasn’t entered the value into a form yet, or that it’s not required for that record, for example.</font></p>
<p><a name="bookmark1374"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The good news is that using a magic value doesn’t waste any memory or require any new types. But it does rely on you picking an appropriate value that you’ll never actually want to use for real data. Also, it’s basically inelegant. It just doesn’t feel right. If you ever find yourself needing to go down this path, you should at least have a constant (or static read-only value for types that can’t be expressed as constants) representing the magic value—comparisons with DateTime.MinValue everywhere, for instance, don’t express the meaning of the magic value. Additionally, it’s easy to accidentally use the magic value as if it were a normal, meaningful one—neither the compiler nor the runtime will help you spot the error. Most of the other solutions presented here <a name="bookmark1375"></a>(including the one in C# 2) would result in either a compilation error or an exception at execution time, depending on the exact situation.</font></p>
<p><a name="bookmark1376"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The magic value <a name="bookmark1377"></a>pattern is deeply em<a name="bookmark1378"></a>bedded in c<a name="bookmark1379"></a>omputing in the form of IEEE-754 binary floating-point types such as float and double. These go further than the idea of a single value representing “this <a name="bookmark1380"></a>isn’t re<a name="bookmark1381"></a>ally a number”—there are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">many</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> bit patterns that ar<a name="bookmark1382"></a>e classified as “not a number” (NaN) as well as values for positive and negative infinity. I suspect few programmers (myself included) are as cautious around these values as we sh<a name="bookmark1383"></a>ould be, which is another indication of the pattern’s shortcomings.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A<a name="bookmark1384"></a>DO.NET has a variation on this pattern where the same magic value— DBNull.Value—is used for </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> null values, regardless of the type. In this case, an extra value and indeed an extra type have been introduced to indicate whe<a name="bookmark1385"></a>n a database has returned null. But it’s only applicable where compile-time type safety isn’t important (in other words, when you’re happy to use object and cast after testing for nullity), and again it doesn’t feel quite r<a name="bookmark1386"></a>ight. In fact, it’s a mixture of the magic value pattern and the reference type wrapper pattern, which we’ll look at next.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">PATTERN 2: A REFERENCE TYPE WRAPPER</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The second solution c<a name="bookmark1387"></a>an take two fo<a name="bookmark1388"></a>rms. The simpler one is to just use object as the variable type, boxing and unboxing values as necessary. The more complex (and more appealing) form is to have a reference type for each value type you need in a nullable form, co<a name="bookmark1389"></a>ntaining a single instance variable of that value type, and with implicit conversion operators to and from the value type. With generics, you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> do this in one generic type—but if you’re using C# 2 anyway, you might as well use the nullable types described in this chapter instead. If you’re stuck in C# 1, you have to create extra source <a name="bookmark1390"></a>code for each type you wish to <a name="bookmark1391"></a>wrap. This isn’t hard to put in the form of a template for automatic code generation, but it’s still a burden that’s best avoided if possible.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Both of these forms have the problem that though<a name="bookmark1392"></a> they allow you to use null directly, t<a name="bookmark1393"></a>hey </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> require objects to be created on the heap, which can lead to garb<a name="bookmark1394"></a>age collection pressure if<a name="bookmark1395"></a> you need to use this approach frequently, and adds memory use due to the overhead associated with objects. For the more complex solution, you could make the reference type mutable, which may reduce the number of instances you need to create but could also make for some unintuitive code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">pATTERN 3: AN EXTRA BOOLEAN FLAG</font></p>
<p><a name="bookmark1396"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The final pattern revolve<a name="bookmark1397"></a>s around having a normal value type value available, and another value—a Boolean flag—indicating whether the value is “real” or whether it should be disregarded. Again, there are two ways of implementing this solution. Either you could maintain two separate variables in the code that uses the value, or you could encapsulate the “value plus flag” into another value type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This latter solution is quite similar to the more complicated reference type idea described earlier, except that you avoid the garbage collection issue by using a value type, and indicate nullity within the encapsulated value rather than by virtue of a null reference. The downside of having to create a new one of these types for every value type you wish to handle is the same, though. Also, if the value is ever boxed for some reason, it’ll be boxed in the normal way whether it’s considered to be null or not.</font></p>
<p><a name="bookmark1398"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The last pattern (in the more encapsulated form) is effectively how nullable types work in C# 2. We’ll see that when the new features of the framework, CLR, and language are all combined, the solution is significantly neater than anything that was possible in C# 1. Our next section deals with just the support provided by the framework and the CLR: if C# 2 </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> supported generics, most of section 4.2 would still be relevant and the feature would still work and be useful. But C# 2 provides extra syntactic sugar to make it even better—that’s the subject of section 4.3.</font></p>
<p><a name="bookmark125"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1399"></a>4.2 System.Nullable&lt;T&gt;and System.Nullable</font></p>
<p><a name="bookmark1400"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The core structure at the heart of nullable types is the System.Nullable&lt;T&gt; struct. In addition, the System.Nullable static class provides utility methods that occasionally make nullable types easier to work with. (From now on I’ll leave out the namespace, to make life simpler.) We’ll look at both of these types in turn, and for this section I’ll avoid any extra features provided by the language, so you’ll be able to understand what’s going on in the IL code when we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> look at the shorthand provided by C# 2.</font></p>
<p><a name="bookmark126"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1401"></a>4.2.1 Introducing Nullable&lt;T&gt;</font></p>
<p><a name="bookmark1402"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1403"></a><a name="bookmark1404"></a><a name="bookmark1405"></a>As you can tell by its <a name="bookmark1406"></a>name, Nullable&lt;T&gt; is a generic type. The type parameter T has a value type constraint, so you can’t use Nullable&lt;Stream&gt;, for example. As I mentioned in section 3.3.1, this also means you can’t use another nullable type as the argument—so Nullable&lt;Nullable&lt;int&gt;&gt; is forbidden, even though Nullable&lt;T&gt; is a value type in every<a name="bookmark1407"></a> other way. The type of T for any particular nullable type is called the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">underlying type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of that nullable type. For example, the underlying type of Nullable&lt;int&gt; is int.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The most important parts of Nullable&lt;T&gt; are its properties, HasValue and Value. They do the obvious: Value represents the non-nullable value (the <a name="bookmark1408"></a></font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">real</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> one, if you will) when there is one, and throws an InvalidOperationException if (conceptually) there’s no real value. HasValue is simply a Boolean property indicating whether there’s a real value or whether the instance should be regarded as null. For now, I’ll talk about an “instance with a value” and an “instance without a value,” which mean instances where the HasValue property returns t<a name="bookmark1409"></a>rue or false, respectively.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">These properties are backed by simple fields in the obvious way. Figure 4.1 shows instances of Nullable&lt;int&gt; representing (from left to right) no value, 0, and 5. Rememb<a name="bookmark1410"></a>er that Nullable&lt;T&gt; is still a value type, so if you have a variable of type Nullable&lt;int&gt;, the variable’s value will directly contain a bool and an int—it won’t be a reference to a separate object.</font></p><div><img src="images/13.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 4.1 Sample values of Nullable&lt;int&gt;</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we know what we want the properties to achieve, let’s see how to create an instance of the<a name="bookmark1411"></a> type. Nullabl<a name="bookmark1412"></a>e&lt;T&gt; has two constructors: the default one</font></p>
<p><a name="bookmark1413"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">(creating an instance without a value) and one taking an instance of T as the value. Once an instance has been constructed, it’s immutable.</font></p>
<p><a name="bookmark1414"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1415"></a>VALUE TYPES AND MUTABILITY A type is said to be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">immutable</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> if it’s designed so that an instance can’t be change<a name="bookmark1416"></a>d after it’s been constructed. Immutable types often lead to a cleaner design than having to keep track of what </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">might</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be changing shared values—particularly among different t<a name="bookmark1417"></a>hreads.</font></p>
<p><a name="bookmark1418"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1419"></a>Immutability is particularly important for value types: they should almost always be immutable. <a name="bookmark1420"></a>If you need a way of basing one value on another, follow the lead of DateTime and TimeSpan—provide methods and operators that return a new value rather than modifying an existing one. This avoids all kinds of subtle bugs, including situations where you may </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">appear</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be changing something, but you’re actually just changing a copy. Just say “no” to mutable value types.<sup><a name="footnote33"></a><a href="#bookmark1421">33</a></sup></font></p>
<p><a name="bookmark1422"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1423"></a>Nullable&lt;T&gt; introduces a single new method, GetValueOrDefault, which has two overloads. Both return the value of the instance if there is one, or a default value otherwise. One overload doesn’t have any parameters (in which case the default value of the underlying type is used), and the other allows you to specify the default value to return if necessary.</font></p>
<p><a name="bookmark1424"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The other methods implemented by Nullable&lt;T&gt; all override existing methods (GetHashCode, ToString, and Equals). GetHashCode returns 0 if the instance doesn’t have a value, or the result of calling GetHashCode on the value if there is one. ToStrin<a name="bookmark1425"></a>g returns an empty string if there isn’t a value, or the result of calling ToString on the value if there is. Equals is slightly more complicated—we’ll come back to it when we’ve discussed boxing.</font></p>
<p><a name="bookmark1426"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Finally,<a name="bookmark1427"></a><a name="bookmark1428"></a> two conversions are p<a name="bookmark1429"></a>rovided by the framework. First, there’s an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">implicit </font><font style="font-size:x-small;font-family:Times New Roman, serif;">conversion from T to Nullable&lt;T&gt;. This always results<a name="bookmark1430"></a> in a<a name="bookmark1431"></a>n instance where HasValue returns true. Likewise, there’s an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">explicit</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> conversion from Nullable&lt;T&gt; to T, which behaves exactly the same as the Value property, including throwing an exception when there’s no real value to return.</font></p>
<p><a name="bookmark1432"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1433"></a>WRAPPING AND UNWRAPPING The C# specification names the process of converting an instance of T to an instance of Nullab<a name="bookmark1434"></a>le&lt;T&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">wrapping,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> with the obvious opposite process being called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">unwrapping</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. The specification actually defines these terms with reference to the constructor taking a parameter and the Value property, respectively. Indeed these calls are generated by the C# code, even when it otherwise </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">looks</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as if you’re using the conversions provided by the framework. The results are the same either way, though. For the rest of this chapter, I won’t distinguish between the two implementations available.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before we go any further, let’s see all this in action. Listing 4.1 shows everything you can do with Nullable&lt;T&gt; directly, leaving Equals aside for the moment.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 4.1 Using various members of Nullable&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Display(Nullable&lt;int&gt; x)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;HasValue: &nbsp;&nbsp;&nbsp;{0}&quot;, &nbsp;&nbsp;&nbsp;x.HasValue);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (x.HasValue)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Value: &nbsp;&nbsp;&nbsp;{0}&quot;, &nbsp;&nbsp;&nbsp;x.Value);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Explicit conversion: &nbsp;&nbsp;&nbsp;{0}&quot;, (int)x);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;GetValueOrDefault(): &nbsp;&nbsp;&nbsp;{0}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.GetValueOrDefault()); Console.WriteLine(&quot;GetValue0rDefault(10): &nbsp;&nbsp;&nbsp;{0}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.GetValue0rDefault(10));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;ToString(): \&quot;{0}\&quot;&quot;, x.ToString()); Console.WriteLine(&quot;GetHashCode(): &nbsp;&nbsp;&nbsp;{0}&quot;, &nbsp;&nbsp;&nbsp;x.GetHashCode());</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Nullable&lt;int&gt; x = 5; x = new Nullable&lt;int&gt;(5);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Instance with value:&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Display(x);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x = new Nullable&lt;int&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Instance without value:&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Display(x);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In listing 4.1, we first show the two different ways (in terms of C# source code) of wrapping a value of the underlying type, and then we use various different members on the instance. Next, we create an instance that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">doesn't</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have a value, and use the same members in the same order, just omitting the Value property and the explicit conversion to int since these would throw exceptions. The output of listing 4.1 is as follows:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Instance with value:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">HasValue: True Value: 5</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Explicit conversion: 5 GetValue0rDefault(): 5 GetValue0rDefault(10): 5 ToString(): &nbsp;&nbsp;&nbsp;&quot;5&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">GetHashCode(): 5</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Instance without value:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">HasValue: False GetValue0rDefault(): 0 GetValue0rDefault(10): 10 ToString(): &nbsp;&nbsp;&nbsp;&quot;&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">GetHashCode(): 0</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far, you could probably have predicted all of the results just by looking at the members provided by Nullable&lt;T&gt;. When it comes to boxing and unboxing, though, there’s special behavior to make nullable types behave how we’d really </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">like</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> them to</font></p>
<p><a name="bookmark1435"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1436"></a><a name="bookmark1437"></a>behave, rather than how they’d behave if we slavishly followed the normal boxing rules.</font></p>
<p><a name="bookmark127"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1438"></a>4.2.2 Boxing Nullable&lt;T&gt;and unboxing</font></p><div><img src="images/14.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 4.2 Results of boxing an instance without a value (top) or one with a value (bottom)</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s important to remember that Nullable &lt;T&gt; is a struct—a value type. This means that if you want to convert it to a reference type (obj ect is the most obvious example), you’ll need to box it. It’s only with <a name="bookmark1439"></a>respect to boxing and unboxing that the CLR itself has any special behavior regarding nullable types—the rest is standard generics, conversions, method calls, and so forth. In fact, the behavior was only changed shortly before the <a name="bookmark1440"></a>release of .NET 2.0, as the result of community requests.</font></p>
<p><a name="bookmark1441"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">An instance of Nullable&lt;T&gt; is boxed to either a null reference (if it doesn’t have a value) or a boxed value of T (if it does), as shown in figure 4.2. It never boxes to a “boxed nullable int”—there’s simply no such type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can unbox from a boxed value either to its normal type or to the corresp<a name="bookmark1442"></a>onding nullable type. Unboxing a null reference will throw a NullReferenceException if you unbox to the normal type, but will unbox to an instance without a value if you unbox to the appropriate nullable type. This behavior is shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 4.2 Boxing and unboxing behavior of nullable types</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Nullable&lt;int&gt; nullable = 5;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object boxed = nullable;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(boxed.GetType());</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int normal = (int)boxed;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(normal);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullable = (Nullable&lt;int&gt;)boxed;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(nullable);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullable = new Nullable&lt;int&gt;(); boxed = nullable;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(boxed == null);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullable = (Nullable&lt;int&gt;)boxed;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(nullable.HasValue);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The output of listing 4.2 shows that the type of the boxed value is printed as System. Int32 (not System.N<a name="bookmark1443"></a>ullable&lt;System. Int32&gt;). It then confirms that we can retrieve the value by unboxing to either just int or to Nullable&lt;int&gt;. Finally, the output demonstrates we can box from a nullable instance without a value to a null reference and successfully unbox again to another valueless nullable instance. If we’d tried unboxing the last value of boxed to<a name="bookmark1444"></a> a non-nullable int, the program would’ve blown up with a NullReferenceException.</font></p>
<p><a name="bookmark1445"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we understand the behavior of boxing and unboxing, we can begin to tackle the behavior of Nullable&lt;T&gt;.Equals.</font></p>
<p><a name="bookmark128"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1446"></a>4.2.3 &nbsp;&nbsp;&nbsp;Equality of Nullable&lt;T&gt; instances</font></p>
<p><a name="bookmark1447"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1448"></a>Nullable&lt;T&gt; overrides object.Equals(object) but doesn’t introduce any equality operators or provide an Equals(Nullable&lt;T&gt;) method. Since the framework has supplied the basic building block<a name="bookmark1449"></a>s, languages can add extra functionality on top, including making existing operators work as we’d expect them to. We’ll see the details of that in section 4.3.3, but the basic equality as defined by the vanilla Equals method follows these rules for a call to first.Equals (second):</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;If first has no value and second is null, they’re equal.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;If first has no value and second isn’t null, they aren’t equal.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;If first has a value and second is null, they aren’t equal.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Otherwise, they’re equal if first’s value is equal to second.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note that we don’t have to consider the case where second is another Nullable&lt;T&gt; because the rules of boxing prohibit that situation. The type of second is object, so in order to be a Nullable&lt;T&gt; it would have to be boxed, and as we’ve just seen, boxing a nullable instance creates a box of the non-nullable type or returns a null reference. Initially the first rule may appear to be breaking the contract for object.Equals (object), which insists that x.Equals(null) returns false—but that’s only when x is a non-null reference. Again, due to the boxing behavior, Nullable&lt;T&gt;’s implementation will never be called via a reference.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The rules are mostly consistent with the rules <a name="bookmark1450"></a>of equality elsewhere in .NET, so you can use nullable instances as keys for dictionaries and any other situations where you need equality. Just don’t expect it to differentiate between a non-nullable instance and a nullable instance with a value—it’s all been carefully set up so that those two cases </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> treated the same way as each other.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That covers the Nullable&lt;T&gt; structure itself, but it has a shadowy partner: the Nullable class.</font></p>
<p><a name="bookmark129"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1451"></a><a name="bookmark1452"></a>4.2.4 &nbsp;&nbsp;&nbsp;Support from the nongeneric Nullable class</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The System.Nullable&lt;T&gt; <a name="bookmark1453"></a>struct does almost everyth<a name="bookmark1454"></a>ing you want it to. But it gets help from the System.Nullable class. This is a static class—it only contains static methods, and you can’t create an instance of it.<sup><a name="footnote34"></a><a href="#bookmark1455">34</a></sup> In fact, everything it does could’ve been done equally well by other types, and if Microsoft had seen where it was going right from the beginning, it might not have even existed—which would’ve saved confusion over what the two types are there for, aside from anything else. But this accident of history has three methods to its name, and they’re still useful.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first two are comparison methods:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static int Compare&lt;T&gt;(Nullable&lt;T&gt; n1, &nbsp;&nbsp;&nbsp;Nullable&lt;T&gt; n2)</font></p>
<p><a name="bookmark1456"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static bool Equals&lt;T&gt;(Nullable&lt;T&gt; n1, &nbsp;&nbsp;&nbsp;Nullable&lt;T&gt; n2)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Compare uses Comparer&lt;T&gt;.Default to compare the t<a name="bookmark1457"></a>wo underlying values (if they exist), and Equals uses EqualityComparer&lt;T&gt;.Default. In the face of instances with no values, the results returned from each method comply with the .NET conventions of nulls comparing equal to each other and less than anything else.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Both of these methods could happily be part of Nullable&lt;T&gt; as static but nongeneric methods. The one small advantage of <a name="bookmark1458"></a>having them as generic &nbsp;&nbsp;&nbsp;methods &nbsp;&nbsp;&nbsp;in a nongeneric type is that generic type inference can &nbsp;&nbsp;&nbsp;be applied, so you’ll &nbsp;&nbsp;&nbsp;rarely &nbsp;&nbsp;&nbsp;need &nbsp;&nbsp;&nbsp;to</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">explicitly specify the type parameter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The final method of System.Nullable isn’t generic—indeed, it couldn’t be. Its signature is as follows:</font></p>
<p><a name="bookmark1459"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static Type GetUnderlyingType(Type nullableType)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If the parameter is a nullable type, the method returns its underlying type; otherwise it returns null. The reason this couldn’t be a generic method is that if you knew the underlying type to start with, you wouldn’t have to call it!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve now seen what the framework and the CLR provide to support nullable types—but C# 2 adds language features to make life a lot more pleasant.</font></p>
<p><a name="bookmark131"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1460"></a>4.3 C# 2’s syntactic sugar for nullable types</font></p>
<p><a name="bookmark1461"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The examples so far have shown nullable types doing their job, but they haven’t been particularly pretty to look at. Admittedly it makes it obvious that you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> using nullable types when you have to type Nullable&lt;&gt; around the name of the type you’re really interested in, but it makes the nullability more prominent than the underlying type, which is usually not a good idea.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In addition, the very name </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">nullable</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> suggests that we should be able to assign null to a variable of a nullable type, and we haven’t seen that—we’ve always used the default constructor of the type. In this section we’ll see how C# 2 deals with these issues and others.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before we get into the details of what C# 2 p<a name="bookmark1462"></a>rovides as a language, there’s one definition I can fi<a name="bookmark1463"></a>nally introduce. The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">null value</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of a nullable value type is the value where HasValue returns false—or an “instance without a value,” as I r<a name="bookmark1464"></a>eferred to it in section 4.2. I didn’t use it before because it’s specific to C#. The CLI specification doesn’t mention it, and the documentation for Nullable&lt;T&gt; itself doesn’t mention it. I’ve honored that difference by waiting until we’re specifically talking about C# 2 itself before introducing the term. The term also applies to reference types: the null value of a reference type is simply the null reference we’re familiar with from C# 1.</font></p>
<p><a name="bookmark1465"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">NUL<a name="bookmark1466"></a>LABLE TYpE <a name="bookmark1467"></a>VERSUS NULLABLE VALUE TYpE In the C# language specification, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">nullable type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is used to mean any type with a null value—so any reference type, or any Nullable&lt;T&gt;. You may have noticed t<a name="bookmark1468"></a>hat I’ve been using this term as if it were synonymous with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">nullable value type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (which obviously doesn’t include reference types). Although I’m usually a huge pedant when it comes to terminology, if I’d used “nullable value type” everywhere in this chapter it would’ve been horrible to read. You should also expect “nullable type” to be used ambiguously in the real world: it’s probably more common to use it when describing Nullable&lt;T&gt; than in the sense described in the specification.</font></p>
<p><a name="bookmark1469"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">With that out of the way, let’s see what features C# 2 gives us, starting by reducing the clutter in our code.</font></p>
<p><a name="bookmark132"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1470"></a>4.3.1 The ? modifier</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are some elements of syntax that may<a name="bookmark1471"></a> be unfamiliar at first but have an appropriate </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">feel</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to them. The conditional operator (a ? b : c) is one of them for me—it asks a question and then has two corresponding answers. In the same way, the ? modifier for nullable types just feels right to me.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s a shorthand way of specifying a nullable type, so instead of using Nullable &lt;byte&gt; we can use byte? throughout our code. The two are interchangeable and compile to exactly the same IL, so you can mix and match them if you want to—but on behalf of whoever reads your code next, I’d urge you to pick one way or the other and use it consistently. Listing 4.3 is exactly equivalent to listing 4.2 but uses the ? modifier, which is shown in bold.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 4.3 The same code as listing 4.2 but using the ? modifier</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int? nullable = 5;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object boxed = nullable;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(boxed.GetType());</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int normal = (int)boxed;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(normal);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullable = (int?)boxed;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(nullable);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullable = new int?(); boxed = nullable;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(boxed == null);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullable = (int?)boxed;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(nullable.HasValue);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I won’t go through what the code does or how it does it, because the result is exactly the same as listing 4.2. The two listings compile down to the same IL—they’re simply using different syntax, just as using int is interchangeable with System. Int32. The only changes are the ones in bold. Yo<a name="bookmark1472"></a>u can use the sh<a name="bookmark1473"></a>orthand version everywhere, including in method signatures, typeof expressions, casts, and the like.</font></p>
<p><a name="bookmark1474"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The reason I feel the modifier is well chosen is that it adds an air of uncertainty to the nature of the variable. Does the variable nullable in listing 4.3 have an integer value? Well, at any particular time it might, or it might be the null value. From now on, we’ll use the ? modifier in all the examples—it’s neater, and it’s arguably the idiomatic way to use nullable types in C#. But you may feel that it’s too easy to miss when reading the code, in which case there’s nothing to stop you from using the longer syntax. You may wish to compare the listings in this section and the previous one to see which you find more clear.</font></p>
<p><a name="bookmark1475"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Given that the C# 2 specification defines the null value, it would be odd if we couldn’t use the null literal we already have in the language in order to represent it. Fortunately we can...</font></p>
<p><a name="bookmark133"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1476"></a>4.3.2 Assigning and comparing with null</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A concise author could cover this whole section in a single sentence: “The C# compiler allows the use of null to represent the null value of a nullable type in both comparisons and assignments.” I prefer to show you what it means in real code, as well as think about </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">why</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the language has been given this feature.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may<a name="bookmark1477"></a> have felt uncomfortable every time we used the default constructor of Nullable&lt;T&gt;. It achieves the desired behavior, but it doesn’t express the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reason</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> why we want to do it—it doesn’t leave the ri<a name="bookmark1478"></a>ght impression with the reader. We want to give the same sort of feeling that using null does with reference types. If it seems odd to you that I’ve talked about feelings in both this section and the last one, just think about who writes code, and who reads it. Sure, the compiler has to understand the code, and it couldn’t care less about the subtle nuances of styl<a name="bookmark1479"></a>e—but few pieces of code used in production systems are written and then never read again. Anything you can do to get the reader into the mental process you were going through when you originally wrote the code is good—and using the familiar null literal helps to achieve that.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With that in mind, we’re going to change the example we’re using from one that just shows syntax and behavior to one that gives an impression of how nullable types might be used. We’ll consider modeling a Person class where you need to know the name, date of birth, and date of death of a person. We’ll only keep track of people who have definitely been born, but some of those people may still be alive—in which case our date of death is represented by null. Listing 4.4 shows some of the possible code. Although a real class would clearly have more operations available, we’re just looking at the calculation of age for this example.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 4.4 Part of a Person class including calculation of age</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Person {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime birth; DateTime? death; string name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public TimeSpan Age</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (death == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return DateTime.Now - birth;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">else {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return death.Value - birth;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Person(string name,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime birth,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime? death)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">this.birth = birth; this.death = death; this.name = name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1480"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person turing = new Person(&quot;Alan Turing&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new DateTime(1912, 6, 23), new DateTim<a name="bookmark1481"></a>e(1954, 6, 7));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person knuth = new Person(&quot;Donald Knuth&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new DateTime(1938, 1, 10), null);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 4.4 doesn’t produce any output, but the fact that it compiles might have surprised you before reading this chapter. Apart from the use of the ? modifier causing confusion, you might have found it odd that you could compare a DateTime? with null, or pass null as the argument for a DateTime? parameter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Hopefully by now the meaning is intuitive—when we compare the death variable with null, we’re asking whether its value is the null value or not. Likewise when we use null as a DateTime? instance, we’re really creating the null value for the type by calling the defa<a name="bookmark1482"></a>ult constructor. Indeed, you can see in the generated IL that the code the compiler spits out for listing 4.4 really does just call the death.HasValue property </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and creates a new instance of DateTime? </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">using the default constructor (represented in IL as the initobj instruction). The date of Alan Turing’s death </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">G </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is created by calling the normal DateTime constructor and then passing the result into the Nullable&lt;DateTime&gt; constructor that takes a parameter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I mention looking at the IL because that can be a useful way of finding out what your code is actually doing, p<a name="bookmark1483"></a>articularly if something compiles when you don’t expect it to. You can use the ildasm t<a name="bookmark1484"></a>ool that comes with the .NET SDK, or for a better user interface you can use Reflector (see <a href="http://mng.bz/pMXJ">http://mng.bz/p</a>MXJ), which has many other features (most notably decompilation to high-level languages such as C# as well as disassembly to IL).</font></p>
<p><a name="bookmark1485"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1486"></a><a name="bookmark1487"></a>We’ve seen how C# provides shorthand syntax for the concept of a null value, making the code more expressive once nullable types are understood in the first place. But one part of listing 4.4 took a bit more w<a name="bookmark1488"></a>ork than we might have hoped—the subtraction at ©. Why did we have to unwrap the value? Why couldn’t we just return death - birth directly? What would we want that expression to mean if death had been null (excluded in our code by our earlier test, of course)? These questions— and more—are answered in our next section.</font></p>
<p><a name="bookmark134"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1489"></a>4.3.3 Nullable conversions and operators</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen that we can compare instances of nullable types with null, but there are other comparisons that can be made and other operators that can be used in some cases. Likewise we’ve seen wrapping and unwrapping, but other conversions can be used with some types. This section explains what’s available. I’m afraid it’s pretty much impossible to make this kind of topic genuinely exciting, but carefully designed features like these are what make C# a pleasant language to work with in the long run. Don’t worry if not all of it sinks in the first time: just remember that the details are here if you need to refer to them in the middle of a coding session.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The executive summary is that if there’s an operator or conversion available on a non-nullable value type, and that operator or conversion only involves other non-nullable value types, then the nullable value type also has the same operator or conversion available, usually converting the non-nullable value types into their nullable equivalents. To give a more concrete example, there’s an implicit conversion from int to long, and that means there’s also an implicit conversion from int? to long? that behaves in the obvious manner.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Unfortunately, although that broad description gives the right general idea, the exact rules are slightly more complicated. Each one is simple, but there are quite a few of them. It’s worth knowing about them because otherwise you may end up staring at a compiler error or warning for a while, wondering why it believes you’re trying to make a conversion that you never intended in the first place. We’ll start with the conversions, and then look at operators.</font></p>
<p><a name="bookmark1490"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">CONVERSIONS INVOLVING NULLABLE TYPES</font></p>
<p><a name="bookmark1491"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">For completeness, let’s start with the conversions we already know about:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;An implicit conversion from the null literal to T?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;An implicit conversion from T to T?</font></p>
<p><a name="bookmark1492"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;An explicit conversion from T? to T</font></p>
<p><a name="bookmark1493"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now consider the predefined and user-defined conversions available on types. For instance, there’s a predefined conversion from int to long. For any conversion like this, from one non-nullable value type (S) to another (T), the following conversions are also available:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;S? to T? (explicit or implicit depending on original conversion)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;S to T? (explicit or implicit depending on original conversion)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;S? to T (always explicit)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To carry our example forward, this means that you can convert implicitly from int? to long? and from int to long? as well as explicitly from int? to long. The conversions behave in the natural way, with null values of S? converting to null values of T?, and non-null values using the original conversion. As <a name="bookmark1494"></a>before, the explicit conversion from S? to T will throw an InvalidOpera<a name="bookmark1495"></a>tionException when converting from a null value of S?. For us<a name="bookmark1496"></a>er-defined conv<a name="bookmark1497"></a>ersions, these extra conversions involving nullable types are known as </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lifted conversions.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far, so relatively simple. Now let’s consider the operators, where things are slightly more tricky.</font></p>
<p><a name="bookmark1498"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">OPERATORS INVOLVING NULLABLE TYP<a name="bookmark1499"></a>ES</font></p>
<p><a name="bookmark1500"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">C# allows the following operators to be overloaded:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Unary: + ++ &nbsp;&nbsp;&nbsp;- -- &nbsp;&nbsp;&nbsp;! &nbsp;&nbsp;&nbsp;~ &nbsp;&nbsp;&nbsp;true &nbsp;&nbsp;&nbsp;false</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1501">■ &nbsp;&nbsp;&nbsp;Binary: + - * / % &nbsp;&nbsp;&nbsp;&amp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;<sup>A</sup> &nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1502">■ &nbsp;&nbsp;&nbsp;Equality:<sup><a name="footnote35"></a><a href="#bookmark1503">35</a></sup> == &nbsp;&nbsp;&nbsp;! =</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1504">■ &nbsp;&nbsp;&nbsp;Relational: &lt;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&lt;= &nbsp;&nbsp;&nbsp;&gt;=</a></font></p>
<p><a name="bookmark1505"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1506"></a>When these operators are overloaded for a non-nullable value type T, the nullable type T? has the same ope<a name="bookmark1507"></a>rators, with slightly different operand and <a name="bookmark1508"></a>result types. These are called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lifted operators</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> whether they’re p<a name="bookmark1509"></a>redefined operators such as addition on numeric types, or user-defi<a name="bookmark1510"></a>ned operators such as adding a TimeSpan to a DateTime. There are a few restrictions as to when they apply:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The true and false operators are never lifted. They’re incredibly rare in the first place, though, so it’s no great loss.</font></p>
<p><a name="bookmark1511"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Only operator<a name="bookmark1512"></a>s with non-nullable value types for the operands are lifted.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;For the unary and binary operators (other than equality and relational operators), the return<a name="bookmark1513"></a> type has to be a non-nu<a name="bookmark1514"></a>llable value type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;For t<a name="bookmark1515"></a>he equ<a name="bookmark1516"></a>ality and relational operators, the return type has to be bool.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The &amp;&nbsp;and | operators on bool? have separately defined behavior, which we’ll see in section 4.3.6.</font></p>
<p><a name="bookmark1517"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">For all the operators, the operand types become their nullable equivalents. For the unary and binary operators, the return type also becomes nullable, and a null value is returned if any of the operands is a null value. The equality and relational operators keep their non-nullable Boolean return types. For equality, two null values are considered equal, and a null value and any non-null value are considered different, which is consistent with the behavior we saw in section 4.2.3. The relational operators always return false if either operand is a null value. When none of the operands is a null value, the operator of the non-nullable type is invoked in the obvious way.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All these rules sound more complicated than they really are—for the most part, everything works as you probably expect it to. It’s easiest to see what happens with a</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression &nbsp;&nbsp;&nbsp;Lifted &nbsp;&nbsp;&nbsp;operator &nbsp;&nbsp;&nbsp;Result</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-nullInt</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int? -(int? x)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-five</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int? -(int? x)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-5</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">five + nullInt</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int? +(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">five + five</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int? +(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">10</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullInt == nullInt</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool ==(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">five == five</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool ==(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">five == nullInt</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool ==(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">five == four</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool ==(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">four &lt;&nbsp;five</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool &lt;(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullInt &lt;&nbsp;five</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool &lt;(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">five &lt;&nbsp;nullInt</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool &lt;(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullInt &lt;&nbsp;nullInt</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool &lt;(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullInt &lt;= nullInt</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool &lt;=(int? x, int? y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table 4.1 Examples of lifted operators applied to nullable integers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">few examples, and as int has so many predefined operators (and integers can be so easily expressed), it’s the natural demonstration type. Table 4.1 shows a number of expressions, the lifted operator signature, and the result. It’s assumed that there are variables four, five, and nullInt, each with type int? and with the obvious values.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Possibly the most surprising line of the table is the bottom one—that a null value isn’t deemed less than or equal to another null value, even though they </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> deemed to be equal to each other (as per the fifth row)! Very odd—but unlikely to cause problems in real life, in my experience.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One aspect of lifted operators and nullable conversion that has caused some confusion is unintended comparisons with null when using a non-nullable value type. The code that follows is legal, but not useful:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int i = 5; if (i == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><a name="bookmark1518"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Never going to happen&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1519"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The C# compiler raises warnings on this code, but you may consider it surprising that it’s allowed at all. What’s happening is that the compiler sees the int expression on the left side of the ==, sees null on the right side, and knows that there’s an implicit conversion to int? from each of them. Because a comparison between two int? values is perfectly valid, the code doesn’t generate an error—just the warning. As a further complication, this </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">isn’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> allowed in the case where instead of int, we’re dealing with a generic type parameter that has been c<a name="bookmark1520"></a>onstrained to be a value type—the rules on generics prohibit the comparison with null in that situation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Either way, there’ll be an error or a warning, so as long as you look closely at warnings, you shouldn’t end up with deficient code due to this quirk—and hopefully pointing it out to you now may save you from getting a headache trying to work out exactly what’s going on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now we can answer the question at the end of the previous section—why we used death.Value - birth in listing 4.4 instead of just death - birth. Applying the previous rules, we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have used the latter expression, but the result would’ve bee<a name="bookmark1521"></a>n a TimeSpan? instead of a TimeSpan. <a name="bookmark1522"></a>This would’ve left us with the options of casting the result to TimeSpan, using its Value property, or changing the Age property to return a TimeSpan?—which just pushes the issue onto the caller. It’s still a bit ugly, but we’ll see a nicer implementation of the Age property in section 4.3.6.</font></p>
<p><a name="bookmark1523"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In the list of restrictions regarding operator lifting, I mentioned that bool? works slightly differently than the other types. Our next section explains this and pulls back the lens to see the bigger picture of why all these operators work the way they do.</font></p>
<p><a name="bookmark135"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1524"></a>4.3.4 Nullable logic</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I vividly remember my early electronics lessons at school. They always seemed to revolve around either working out the voltage across different parts of a circuit using the V=IR formula, or applying </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">truth tables</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—the reference charts for explaining the difference between NAND gates and NOR gates and so on. The idea is simple—a truth table maps out every possible combination of inputs into whatever piece of logic you’re interested in <a name="bookmark1525"></a>and tells you the output.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The truth tables we drew for simple, two-input logic gates always had four rows— each input had two possible values, which means there were four possible combinations. Boolean logic is si<a name="bookmark1526"></a>mple like that—but what happens when you have a tristate logical type? Well, bool? is just such a type—the value can be true, false, or null. That means that our truth tables now need nine rows for our binary operator<a name="bookmark1527"></a>s, as there are n<a name="bookmark1528"></a>ine combinations. The specification only highlights the logical AND and inclusive OR <a name="bookmark1529"></a>operators (&amp; and |, res<a name="bookmark1530"></a>pectively) because the other operators—unary logical negation (!) and exclusive OR (<sup>A</sup>)—follow the<a name="bookmark1531"></a> same rules as other lifted operators. There are no conditional logical operators (the short-circuiting &amp;&amp;&nbsp;and || operators) defined for bool?, which makes life simpler.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For the sake of completeness, table 4.2 gives the truth table for all four valid bool? logical operators.</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">y</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">y</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;8</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x | y</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">y</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">&lt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">!x</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table 4.2 Truth table for the logical operators AND, inclusive OR, exclusive OR, and logical negation, applied to the bool? type</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For those who find reasoning about rules easier to understand than lookin<a name="bookmark1532"></a>g up values in tables, the idea is that a null bool? value is in some senses a “maybe.” If you imagine that each null entry in the input side of the table is a variable instead, then you’ll always get a null value on the output side of the table if the result depends on the value of that variable. For instance, looking at the third line of the table, the expression true &amp;&nbsp;y will only be true if y is true, but the expression true | y will always be true whatever the value of y is, so the nullable results are null and true, respectively.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When considering the lifted operators and partic<a name="bookmark1533"></a>ularly how nullable logic works, the language designers h<a name="bookmark1534"></a>ad t<a name="bookmark1535"></a>wo slightly contradictory sets of existing behavior—C# 1 null references and SQL NULL values. In many cases, these don’t conflict at all—C# 1 had no concept of applying logical operators to null references, so there was no problem in using the SQL-like results given earlier. The definitions we’ve seen may surprise some SQL developers, though, when it comes to comparisons. In standard SQL, the result of comparing two values (in terms of equality or greater than/less than) is always unknown if either value is NULL. The result in C# 2 is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">never</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> null, and in particular two null values are considered to be equal to each other.</font></p>
<p><a name="bookmark1536"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">REMINDER: THIS IS C# SPECIFIC! It’s worth remembering that the lifted operators and conversions, along with the bool? logic described in this sec<a name="bookmark1537"></a>tion, are all provided by the C# compiler and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> by the CLR or the framework itself. If you use ildasm on code that evaluates any of these nullable operators, you’ll find that the compiler has created all the appropriate IL to test for null va<a name="bookmark1538"></a>lues and dealt with them accordingly. This means that different languages can behave differently on these matters—definitely something to look out for if you need to port code between different .NET-based languages.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Another familiar operator is now available with nullable value types, and it behaves exactly as you’d expect it to if you consider your existing knowledge of null references and just tweak it to be in terms of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">null values.</font></p>
<p><a name="bookmark136"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1539"></a><a name="bookmark1540"></a>4.3.5 Using the as operator with nullable types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Prior to C# 2, the as operator was only available for reference types. As of C# 2, it can now be applied to nullable value types as well. The result is a value of that nullable type—either the null value if the original reference was the wrong type or null, or a meaningful value otherwise. Here’s a short example:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void PrintValueAsInt32(object o)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int? nullable = o as int?;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(nullable.HasValue ?</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">nullable.Value.ToString() : &nbsp;&nbsp;&nbsp;&quot;null&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintValueAsInt32(5); PrintValueAsInt32(&quot;some string&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This allows you to safely convert from an arbitrary reference to a value i<a name="bookmark1541"></a>n a single step—although y<a name="bookmark1542"></a>ou’d normally check. In C# 1, you’d have had to use the is operator followed by a cast, which is inelegant: it’s asking the CLR to perform the same type check twice, effectively.</font></p>
<p><a name="bookmark1543"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1544"></a>SURPRISING PERFORMANCE TRAP I’d always assumed that doing one check would be faster than two, but it appears that’s not the case—at least with the versions of .NET I’ve tested with. When writing a quick benchmark that summed all the integers within an array of type object [] where only a third of the values were actually boxed integers, using is and then a cast ended up being </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">20 times faster</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> than using the as operator. The details are beyond the scope of this book, and as always you should test performance with your actual code and data before deciding the best course of action for your specific situation—but it’s worth being aware of.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We now know enough to use nullable types and predict how they’ll behave, but C# 2 has a sort of “bonus track” when it comes to syntax enhancements: the null coalescing operator.</font></p>
<p><a name="bookmark137"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1545"></a><a name="bookmark1546"></a>4.3.6 The null coalescing operator</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Aside from the ? modifier, all of the rest of the C# compiler’s tricks relating to nullable types so far have worked with the existing syntax. But C# 2 introduces a new operator that can occasionally make cod<a name="bookmark1547"></a>e shorte<a name="bookmark1548"></a>r and sweeter. It’s called the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">null coalescing operator</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and appears in code as ?? between its two operands. It’s like the conditional operator but specially tweaked for nulls.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s a binary operator that evaluates first ?? second by going through the following steps (roughly speaking):</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;Evaluate first.</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">2</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;If the result is non-n<a name="bookmark1549"></a>ull, that’s the result of the whole expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">3 &nbsp;&nbsp;&nbsp;Otherwise, evaluate second; the result then becomes the result of the whole expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I say “roughly speaking” because the formal rules in the specification have to deal with situations involving conversions between the types of first and second. As ever, these aren’t important in most uses of the operator, and I don’t intend to go through them—consult section 7.13 of the specification if you need the details.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Importantly, if the type of the second operand is the underlying type of the first operand (and therefore non-nullable), then the overall result is that underlying type. For example, this code is perfectly valid:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int? a = 5; int b = 10; int c = a ?? b;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how we’re assigning directly to c even though its type is the non-nullable int type. We can only do this because b is non-nullable, so we know that we’ll get a</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">non-nullable result eventually. Obviously that’s a pretty simplistic example; let’s find a more practical use for this by revisiting the Age property from listing 4.4. As a reminder, here’s how it was implemented back then, along with the relevant variable declarations:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime birth;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime? death;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public TimeSpan Age {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (death == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return DateTime.Now - birth;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">else</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return death.Value - birth;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1550"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how both branches of the if statement subtract the value of birth from some non-null DateTime value. The value we’re interested in is the latest time the person was alive—the time of the person’s death if he or she has already died, or now otherwise. To make progress in little steps, let’s try just using the normal conditional operator first:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime lastAlive = (death == null ? DateTime.Now : death.Value); return lastAlive - birth;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s progress of a sort, but arguably the conditional operator has actually made it harder to read rather than easier, even though the new code is shorter. The conditional operator is often like that—how much you use it is a matter of personal preference, although it’s worth consulting the rest of your team before using it extensively. Let’s see how the null coalescing operator improves things. We want to use the value of death if it’s non-null, and DateTime.Now otherwise. We can change the implementation to</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime lastAlive = death ?? DateTime.Now; return lastAlive - birth;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how the type of the result is DateTime rather than DateTime? because we’ve used DateTime.Now as the second operand. We </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> shorten the whole thing to one expression:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return (death ?? DateTime.Now) - birth;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But this is more obscure—in particular, in the two-line version the name of the last-Alive variable helps the reader to see why we’re applying the null coalescing operator. I hope you agree that the two-line version is simpler and more readable than either the original version using the if statement or the version using the normal conditional operator from C# 1. Of course, it relies on the reader understanding what the null coalescing operator does. In my experience, this is one of the least well-known aspects of C# 2, but it’s useful enough to make it worth trying to enlighten your coworkers rather than avoiding it.</font></p>
<p><a name="bookmark1551"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two further aspects that increase the operator’s useful<a name="bookmark1552"></a>ness. First, it doesn’t just apply to nullable value types—it works with reference types too; you just can’t use a non-nullabl<a name="bookmark1553"></a>e value type for the first operand, as that would be pointless. Also, it’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">right associative,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which means an expression of the form first ?? second ?? third is evaluated as first ?? (second ?? third)—and so it continues for more operands. You can have any number of expressions, and they’ll be evaluated in order, stopping with the first non-null result. If all of the expressions evaluate to null, the result will be null too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As a concrete example of this, suppose you have an online ordering system (who doesn’t these days?) with the concepts of a billing address, contact address, and shipping address. The business rule<a name="bookmark1554"></a>s declare that any user </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">must</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have a billing address, but the contact address is optional. The shipping address for a particular order is also optional, defaulting to the billing address. These optional addresses are easily represented as null references in the code. To work out whom to contact in the case of a problem with a shipment, the code in C# 1 might look something like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Address contact = user.ContactAddress; if (contact == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">contact = order.ShippingAddress; if (contact == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">contact = user.BillingAddress;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Using the conditional operator in this case is even more horrible. But using the null coalescing operator makes the code very straightforward:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Address contact = user.ContactAddress ??</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">order.ShippingAddress ?? user.BillingAddress;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If the business rules changed to use the shipping address by default instead of the user’s contact address, the change here would be extremely obvious. It wouldn’t be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">particularly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> taxing with the if/else version, but I know I’d have to stop and think twice, and verify the code mentally. I’d also be relying on unit tests, so there’d be little chance of actually getting it wrong, but I’d prefer not to think about things like this unless I absolutely have to.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">EVERYTHING IN MODERATION Just in case you may be thinking that my code is littered with uses of the null c<a name="bookmark1555"></a>oalescing operator, it’s really not. I tend to consider it when I see defaulting mechanisms involving nulls and possibly the conditional operator, but it doesn’t come up often. When its use is natural, though, it can be a powerful tool in the battle for readability.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen how nullable types can be used for ordinary properties of objects—cases where we naturally might not have a value for some particular aspect that’s still best expressed with a value type. Those are the more obvious uses for nullable types and indeed the most common ones. A few patterns aren’t as obvious but can still be powerful when you’re used to them. We’ll explore two of these patterns in our next section. This is more for the sake of interest than as part of learning about the behavior of nullable types themselves—you now have all the tools you need to use them in your own code. If you’re interested in quirky ideas and perhaps trying something new, read on...</font></p>
<p><a name="bookmark139"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1556"></a>4.4 Novel uses of nullable types</font></p>
<p><a name="bookmark1557"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Before nullable types became a reality, I saw lots of people effectively asking for them, usually related to database access. That’s not the only use they can be put to, though. The patterns presented in this section <a name="bookmark1558"></a>are unconventional but can make code simpler. If you only ever stick to normal idioms of C#, that’s fine—this section might not be for you, and I have a lot of sympathy for that point of view. I usually prefer simple code over code that’s clever—but if a whole </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">pattern</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> provides benefits when it’s known, that sometimes makes the pattern worth learning. Whether you use these techniques is entirely up to you—but you may find that they suggest other ideas to use elsewhere in your code. Without further ado, let’s start with an alternative to the TryXXX pattern mentioned in section 3.3.3.</font></p>
<p><a name="bookmark140"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1559"></a><a name="bookmark1560"></a>4.4.1 Trying an operation without using output parameters</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The pattern o<a name="bookmark1561"></a>f using a return value to say whether an operation worked, and an output parameter to return the real result, is becoming increasingly common in the .NET Framework. I have no issues with the aims—the idea that some methods are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">likely</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to fail to perform their primary purpose in non-exceptional circumstances is common sense. My one problem with it is that I’m not a huge fan o<a name="bookmark1562"></a>f output p<a name="bookmark1563"></a>arameters. There’s something slightly clumsy about the syntax of declaring a variable on one line, then immediately using it as an output parameter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Methods returning reference types have often used a pattern of returning null on failure and non-null on success. It <a name="bookmark1564"></a>doesn’t work so well when null is a valid return value in the success case. Hashtable is an example of both of these statements, in a slightly ambivalent way. You see, null is a theoretically valid val<a name="bookmark1565"></a>ue in a Hashtable, but in my experience most </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">uses</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of Hashtable never use null values, which makes it perfectly acceptable to have code that assumes that a null value means a missing key. One common scenario is to have each value of the Hashtable as a list: the first time an item is added for a particular key, a new list is created and the item added to it. Thereafter, adding another item for the same key involves adding the item to the existing list. Here’s the code in C# 1:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ArrayList list = hash[key]; if (list == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">list = new ArrayList();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">hash[key] = list;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">list.Add(newItem);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Hopefully you’d use variable names more specific to your situation, but I’m sure you get the idea and may well have used the pattern yourself.<sup><a name="footnote36"></a><a href="#bookmark1566">36</a></sup> With nullable types, this pattern can be extended to value types—and in fact, it’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">safer</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> with value types, because if the natural result type is a value type, then a null value could </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be returned as a result of failure. Nullable types add that extra Boolean piece of information in a nice general way with language support—so why not use them?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To demonstrate this pattern in practice and in a con<a name="bookmark1567"></a>text other than dictionary lookups, I’ll use the classic exa<a name="bookmark1568"></a>mple of the TryXXX pattern—parsing an integer. The implementation of the TryParse method in listing 4.5 shows the version of the pattern using an output parameter, but then we see the use of the version using nullable types in the main part at the bottom.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 4.5 An alternative implementation of the TryXXX pattern</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static int? TryParse(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int ret;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (int.TryParse(text, out ret))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return ret;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">else</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return null;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int? parsed = TryParse(&quot;Not valid&quot;); if (parsed != null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Parsed to {0}&quot;, parsed.Value);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">else</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Couldn't parse&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may think there’s little to distinguish the two versions here—th<a name="bookmark1569"></a>ey’re the same number of lines, afte<a name="bookmark1570"></a>r all. But I believe there’s a difference in emphasis. The nullable version encapsulates the natural return value and the success or failure into a single variable. It also separates the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">doing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> from the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">testing</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which puts the emphasis in the right place in my opinion. Usually, if I call a method in the condition part of an if statement, that method’s primary purpose is to return a Boolean value. Here, the</font></p>
<p><a name="bookmark1571"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1572"></a>return value is in some ways less important than the output parameter. When you’re reading code, it’s easy to miss an output parameter in a method call and be left wondering what’s actually doing all the work and magically giving the answer. With the nullable version, this is more explicit—the result of the method has all the information we’re interested in. I’ve used this technique in a number of places (often with more method parameters, at which point output parameters become even harder to spot) and believe it has improved the general feel of the code. Of course, this only works for value types.</font></p>
<p><a name="bookmark1573"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1574"></a>Another advantage of this pattern is that it can be used in conjunction with the null coalescing operator—you can try to understand several pieces of input, stopping at the first valid one. The normal TryXXX pattern allows this using the short-circuiting operators, but the meaning isn’t nearly as clear when you use the same variable for two different output parameters in the same statement.</font></p>
<p><a name="bookmark1575"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The next pattern is an answer to a specific pain point—the irritation and fluff that can be present when writing multitiered comparisons.</font></p>
<p><a name="bookmark141"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1576"></a><a name="bookmark1577"></a>4.4.2 Painless comparisons with the null coalescing operator</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I suspect you dislike writing the same c<a name="bookmark1578"></a>ode over and over again as much as<a name="bookmark1579"></a> I do. Refactoring can often get rid of <a name="bookmark1580"></a>duplication, b<a name="bookmark1581"></a>ut some cases resist refactoring surprisingly effectively. Code for Equals and Compare often falls firmly into this category in my experience.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Suppos<a name="bookmark1582"></a>e you’re writing an e-commerce site and have a list of products. You may wish to sort them by popularity (descending), then price, then name—so that the five-star-rated products come first, but the cheapest five-star products come before the more expensive ones. If there are multiple products with the same price, products beginning with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">A</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> are listed before products beginning with B. <a name="bookmark1583"></a>This isn’t a problem specific to e-commerce sites—sorting data by multiple criteria is a fairly common requirement in computing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Assuming we have a suitable Product type, we can write the comparison with code like this in C# 1:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int Compare (Product first, Product second)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Reverse comparison of popularity to sort descending int ret = second.Popularity.CompareTo(first.Popularity);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (ret != 0)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return ret;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ret = first.Price.CompareTo(second.Price); if (ret != 0)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return ret;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return first.Name.CompareTo(second.Name);</font></p>
<p><a name="bookmark1584"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This assumes that we won’t be asked to compare null references, and that all of the properties will return non-null references too. We could use some up-front null comparisons and Comparer&lt;T&gt;.Default to handle those cases, but that would make the code even longer and more involved. The code could be shorter (and avoid returning from the middle of the method) if we rearranged it slightly, but the fundamental “compare, check, compare, check” pattern would still be present, and it wouldn’t be as obvious that once we have a nonzero answer, we’re done.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Ah... that last sentence is reminiscent of something else: the null coalescing operator. As we saw in section 4.3, if we have a lot of expressions separated by ??, then the operator will be repeatedly applied until it hits a non-null expression. Now all we have to do is work out a way of returning null instead of zero from a comparison. This is easy to do in a separate method that can also encapsulate the use of the default comparer. We can even have an overload to use a specific comparer if we want. We’ll also deal with the case where either of the Product references we’re passed is null. First, let’s look at the class implementing our helper methods, as shown in the following listing.</font></p>
<p><a name="bookmark1585"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 4.6 Helper class for providing partial comparisons</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static class PartialComparer {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static int? Compare&lt;T&gt;(T first, T second)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return Compare(Comparer&lt;T&gt;.Default, first, second);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static int? Compare&lt;T&gt;(IComparer&lt;T&gt; comparer,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T first, T second)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int ret = comparer.Compare(first, second); return ret == 0 ? new int?() : ret;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static int? ReferenceCompare&lt;T&gt;(T first, T second) where T : class</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return first == &nbsp;&nbsp;&nbsp;second &nbsp;&nbsp;&nbsp;? 0</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">: first == &nbsp;&nbsp;&nbsp;null ? &nbsp;&nbsp;&nbsp;-1</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">: second == null ? 1 : new int?();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1586"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The Compare methods in listing 4.6 are almost pathetically simple—when a comparer isn’t specified, the default comparer for the type is used, and all that happens to the comparison’s return value is that zero is translated to the null value.</font></p>
<p><a name="bookmark1587"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">NULL VALUES AND THE CONDITIONAL OPERATOR You may have been surprised to see me use new int?() rather than null to return the null value in the second Compare method. But the conditional operator requires that its second and third operands either be &nbsp;&nbsp;&nbsp;of the &nbsp;&nbsp;&nbsp;same &nbsp;&nbsp;&nbsp;type, &nbsp;&nbsp;&nbsp;or &nbsp;&nbsp;&nbsp;that &nbsp;&nbsp;&nbsp;there be &nbsp;&nbsp;&nbsp;an implicit</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">conversion from one &nbsp;&nbsp;&nbsp;to the &nbsp;&nbsp;&nbsp;other. &nbsp;&nbsp;&nbsp;That &nbsp;&nbsp;&nbsp;wouldn’t &nbsp;&nbsp;&nbsp;be &nbsp;&nbsp;&nbsp;the &nbsp;&nbsp;&nbsp;case &nbsp;&nbsp;&nbsp;with &nbsp;&nbsp;&nbsp;null,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">because the compiler wouldn’t know what type the value was meant to be— the language rules don’t take the overall aim of the statement (returning from a method with a return type of int?) into account when examining subexpressions. Other options include casting either operand to int? explicitly or using default (int?) for the null value. Basically, the important thing is to make sure that one of the operands is known to be an int? value.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The ReferenceCompare method uses another conditional operator—three of them, in fact. You m<a name="bookmark1588"></a>ay find this less readable than the (rather longer) equivalent code using if/else blocks —it depends on how comfortable you are with the conditional operator. I like it in terms of making the order of the comparisons clear. Also, this could easily have been a nongeneric method with two object parameters—but this for<a name="bookmark1589"></a>m prevents you from accidentally using the method to compare value types via boxing. The meth<a name="bookmark1590"></a>od really is<a name="bookmark1591"></a> only useful with reference types, which is indicated by the type parameter constraint.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even though this class is simple, it’s remarkably useful. We can now replace our previous product comparison with a neater implementation:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int Compare(Product first, Product second)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return PC.ReferenceCompare(first, second) ??</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Reverse comparison of popularity to sort descending PC.Compare(second.Popularity, first.Popularity) ?? PC.Compare(first.Price, second.Price) ??</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PC.Compare(first.Name, second.Name) ??</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">0;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you may have noticed, I’ve used PC rather than PartialComparer—this is solely for the sake of being able to fit the lines on the printed page. In real code, I’d use the full type name and still have one comparison per line. O<a name="bookmark1592"></a>f course, if you want<a name="bookmark1593"></a>ed short lines for some reason, you could specify a using directive to make PC an alias for PartialComparer—I just wouldn’t recommend it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The final 0 indicates that if all of the earlier comparisons have passed, the two Product instances are equal. We </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have just used Comparer&lt;string&gt;.Default. Compare(<a name="bookmark1594"></a>first .Name, second.Name) as the final comparison, but that would hurt the symmetry of the method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This comparison plays nicely with nulls, is easy to modify, forms an easy pattern to use for other comparisons, and only compares as far as it needs to: if the prices are different, the names won’t be compared.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may be wondering whether the same technique could be applied to equality tests, which often have similar patterns. There’s much less point in the case of equality, because after the nullity <a name="bookmark1595"></a>and reference equality tests, you can just use &amp;&amp;&nbsp;to provide the desired short-circuiting functionality for Booleans. A method returning a bool? can be used to obtain an initial </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">definitely equal, definitely not equal,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> or </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">unknown</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> result based on the references, though. The complete code of PartialComparer on this book’s website contains the appropriate utility method and examples of its use.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When faced with a problem, developers tend to take the easiest short-term solution, even if it’s not particularly e<a name="bookmark1596"></a>legant. That’s often the right decision—we don’t want to be guilty of overengineering, after all. But it’s always nice when a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">good</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> solution is also</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">easiest</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> solution.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Nullable types solve a specific problem that only had somewhat ugly solutions before C# 2. The features provided are just a better-supported version of a solution that was feasible but time consuming in C# 1. The combination of generics (to avoid code duplication), CLR support (to provide suitable boxing and unboxing behavior), and language support (to provide concise syntax along with convenient conversions and operators) makes the solution far more compelling than it was previously.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It so happens that in providing nullable types, the C# and Framework designers have made some other patterns available that just weren’t worth the effort before. We’ve looked at some of them in this chapter, and I wouldn’t be surprised to see more of them appearing over time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far our two new features (generics and nullable types) have addressed area<a name="bookmark1597"></a>s where in C# 1 we occasionally had to hold our noses due to unpleasant code smells. This pattern continues in the next chapter, where we discuss the enhancements to delegates. These form an important part of the subtle change of directio<a name="bookmark1598"></a>n of both the C# language and the .NET Framework, toward a slightly more functional viewpoint. This emphasis is made even clearer in C# 3, so though we’re not looking at those features </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">quite</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> yet, the delegate enhancements in C# 2 act as a bridge between the familiarity of C# 1 and the style of idiomatic C# 3, which can often be radically different from earlier versions.</font></p>
<p><a name="bookmark7"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark1599"></a><a name="bookmark1600"></a>Fast-tracked delegates</font></p>
<p><a name="bookmark1601"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Long-winded C# 1 syntax</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Simplified delegate construction</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Covariance and contravariance</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Anonymous methods</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Captured variables</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The journey of delegates in C# and .NET is an interesting o<a name="bookmark1602"></a>ne, showing remarkable foresight (or really good luck) on the part of the designers. The conventions suggested for event handlers in .NET 1.0/1.1 didn’t make a lot of sense—until C# 2 showed up. Likewise, the effort put into delegates for C# 2 seems in some ways out of proportion to how widely used they are—until you see how pervasive they are in idiomatic C# 3 code. In other words, it’s as if the language and platform designers had a vision of at least the rough direction they’d be taking, years before the destination itself became clear.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, C# 3 isn’t a “final destination” in itself—generic delegates get a bit more flexibility in C# 4, and we may see even more advances in the future—but the differences between C# 1 and C# 3 in this area are the most startling ones. (The primary change in C# 3 supporting delegates is in lambda expressions, which we’ll meet in chapter 9.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 2 is a sort of stepping stone in terms of delegates. Its new features pave the way for the dramatic changes of C# 3, keeping developers </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reasonably</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> comfortable while still providing useful benefits. I’m reliably informed that language designers were aware that the combined feature set of C# 2 would open up whole new ways of looking at code, but they didn’t necessarily know where those paths would lead. So far, their instincts have proved remarkably beneficial in the area of delegates.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Delegates play a more prominent part in .NET 2.0 than in earlier versions, although they’re not as common as they are in .NET 3.5. In chapter 3 we saw how they can be used to convert from one type of list to another, and way back in chapter 1 we sorted a list of products using the Comparison delegate instead of the IComparer interface. Although the framework and C# keep a respectful distance from each other where possible, I believe that the language and platform drove each other in this case: the inclusion of more delegate-based API calls supports the improved syntax available in C# 2, and vice versa.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this chapter we’ll see how C# 2 makes two small changes that make life easier when creating delegate instances from normal methods, and then we’ll look at the biggest change: anonymous methods, which allow you to specify a delegate instance’s action inline at the point of its creation. The largest section of the chapter is devoted to the most complicated part of anonymous methods—captured variables—which provide delegate instances with a richer environment to play in. We’ll cover the topic in significant detail due to its importance and complexity. Once you’ve come to grips with anonymous methods, lambda expressions are easy to understand.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First, though, let’s remind ourselves of the pain points of C# 1 ’s delegate facilities.</font></p>
<p><a name="bookmark145"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1603"></a>5.1 Saying goodbye to awkward delegate syntax</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The syntax <a name="bookmark1604"></a>for delegates in C# 1 does<a name="bookmark1605"></a>n’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">sound</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> too bad—t<a name="bookmark1606"></a>he language already <a name="bookmark1607"></a>has syntactic sugar around Delegate .Combine, Delegate.Remove, and the invocation of delegate instances. It makes sense to specify the delegate type when creating a delegate instance—it’s the same syntax used to create instances of other types, after all.</font></p>
<p><a name="bookmark1608"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1609"></a><a name="bookmark1610"></a><a name="bookmark1611"></a>This is all true, but for some reason it also sucks. It’s hard to say exactly why the delegate creation expressions of C# 1 rai<a name="bookmark1612"></a>se hackles, but they do—at least for me. When hooking up a bunch of event handlers, it just looks ugly to have to write “new Event-Handler” (or whatever is required) all over the place, when the event itself has specified which delegate type it’ll use. Beauty is in the eye of the beholder, of course, and you could argue that there’s less call for guesswork when reading event handler wiring code in the C# 1 style, but the extra text just gets in the way and distracts from the important part of the code: the method you want to handl<a name="bookmark1613"></a>e the event.</font></p>
<p><a name="bookmark1614"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1615"></a>Life becomes more black and white when you consider covariance and contravari-ance as applied to delegates. Suppose you have an event handling method that saves the current document, or just logs that it’s been called, or any number of other actions that may not need to know details of the event. The event itself shouldn’t mind that your method is capable of working with only the information provided by the EventHandler signature, even though it (the event) is declared to pass in mouse</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">event details. Unfortunately, in C# 1 you need to have a different method for each different event handler signature.</font></p>
<p><a name="bookmark1616"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Likewise it’s undeniably ugly to write methods that are so simple that their implementation is shorter than their signature, solely because delegates need to have an action to execute in the form of a method. It adds an extra layer of indirection between the code </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">creating</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the delegate instance and the code that should execute when it’s invoked. Often extra layers of indirection are welcome—and of course that option hasn’t <a name="bookmark1617"></a>been removed in C# 2—but at the same time it often makes the code harder to read, and pollutes the class with a bunch of methods that are only used for delegates.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Unsurprisingly, all of these issues are improved greatly in C# 2. The syntax can still be wordier than we might like (until we get lambda expressions in C# 3), but the difference is significant. To illustrate the pain, we’ll start with some code in C# 1 and improve it in the next couple of sections. The following listing builds a (very) simple form with a button and then subscribes to three of the button’s events.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.1 Subscribing to three of a button’s events</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void LogPlainEvent(object sender, EventArgs e)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;LogPlain&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void LogKeyEvent(object sender, KeyPressEventArgs e)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;LogKey&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void LogMouseEvent(object sender, MouseEventArgs e)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;LogMouse&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Button button = new Button(); button.Text = &quot;Click me&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">button.Click &nbsp;&nbsp;&nbsp;+= &nbsp;&nbsp;&nbsp;new EventHandler(LogPlainEvent);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">button.KeyPress += new KeyPressEventHandler(LogKeyEvent); button.MouseClick += new MouseEventHandler(LogMouseEvent);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Form form = new Form(); form.AutoSize = true; form.Controls.Add(button);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Application.Run(form);</font></p>
<p><a name="bookmark1618"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The output lines in the three event handling methods are there to prove that the code is working: if you p<a name="bookmark1619"></a>ress the spacebar with the button highlighted, you’ll see that the Click and KeyPress events are both raised. Pressing Enter just raises the Click event; clicking on the button raises the Click and MouseClick events. In the following sections we’ll improve this code using some of the C# 2 features.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s start by asking the compiler to make a pretty obvious deduction—which delegate type we want to use when subscribing to an event.</font></p>
<p><a name="bookmark147"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1620"></a>5.2 Method group conversions</font></p>
<p><a name="bookmark1621"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In C# 1, if you want to create a delegate instance, you need to specify both the d<a name="bookmark1622"></a>elegate type and the action. If you remember from chapter 2, we defined the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">action</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as the method to call and (for instance methods) the target to call it on.<a name="bookmark1623"></a> So, for example, in listing 5.1 when we needed to create a KeyPressEventHandler, we used this expression:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new KeyPressEventHandler(LogKeyEvent)</font></p>
<p><a name="bookmark1624"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">As a standalone expression, it doesn’t look too bad. Even used in a simple event subscription it’s tolerable. It becomes uglier when used as part of a longer expression, though. A common example of this is starting a new thread:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Thread t = new Thread(new ThreadStart (MyMethod));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">What we want to do is start a new thread that’ll execute MyMethod. As ever, we want to express ourselves as <a name="bookmark1625"></a>simply as possible, a<a name="bookmark1626"></a>nd C# 2 allows you to do this by means of an implicit conversion from a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">method group</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to a compatible delegate type. A method group is simply the name of a method, optionally with a target—exactly the same kind of expression as we used in C# 1 to create delegate instances. (Indeed, the expression was called a method group back then—it’s just that the conversion wasn’t available.) If the method is generic, the method group may also specify type arguments—although this is rarely used in my experience. The new implicit conversion allows us to turn our event subscription into</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">button.KeyPress += LogKeyEvent;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Likewise the thread creation code becomes simply</font></p>
<p><a name="bookmark1627"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Thread t = new Thread(MyMethod);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The readability differences between the original and the streamlined versions aren’t huge for a single line, but in the context of a significant amount of code, they can reduce the clutter considerably. To make it look less like magic, let’s briefly look at what this conversion is doing.</font></p>
<p><a name="bookmark1628"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1629"></a>First, let’s consider the expressions LogKeyEvent and MyMethod as they appear in the examples. The reason they’re classified as method </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">groups</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is because more than one method may be available, due to overloading. The implicit conversions available will convert a method group to any delegate type with a compatible signature. So, if you had two method signatures as follows</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void MyMethod()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void MyMethod(object sender, EventArgs e)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">you could use MyMethod as the method group in an assignment to either a Thread-Start or an EventHandler as follows:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ThreadStart x = MyMethod;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">EventHandler y = MyMethod;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">couldn’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use it as the parameter to a method that itself was overloaded to take either a Threa<a name="bookmark1630"></a>dStart or an EventHandler—the compiler would c<a name="bookmark1631"></a>omplain that the call was ambiguous. Likewise, you unfortunately can’t <a name="bookmark1632"></a>use an implicit method group conversion to convert to the plain System.Delegate type, since the compiler doesn’t know which specific delegate type to create an instance of. This is a <a name="bookmark1633"></a>pain, but you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can </font><font style="font-size:x-small;font-family:Times New Roman, serif;">still be slightly briefer than in C# 1 by making the conversion explicit. For example:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Delegate invalid = SomeMethod;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Delegate valid = (ThreadStart)SomeMethod;</font></p>
<p><a name="bookmark1634"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">For local variables, this usually isn’t a problem—but it’s somewhat more annoying when <a name="bookmark1635"></a>you’re using an API that has a parameter of type Delegate, such as Control. Invoke. There are a <a name="bookmark1636"></a>few solutions here: using a helper method, casting, or using an intermediate variable. Here’s an example using the Methodlnvoker delegate type, which takes no parameters and doesn’t return anything:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void SimpleInvoke(Control control,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MethodInvoker invoker)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">control.Invoke(invoker);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SimpleInvoke(form, UpdateUI); form.Invoke((MethodInvoker)UpdateUI);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Methodlnvoker invoker = UpdateUI; form.Invoke(invoker);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Different situations will encourage different solutions; none of these is particularly appealing, but they’re not awful either.<sup><a name="footnote37"></a><a href="#bookmark1637">37</a></sup></font></p>
<p><a name="bookmark1638"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1639"></a>As with generics, the precise rules of conversion validity are slightly complicated, and the just-try-it approach works well: if the compiler complains that it doesn’t have enough information, just tell it what conversion to use and all should be well. If it doesn’t <a name="bookmark1640"></a>complain, you should be fine. For the exact details, consult the language specification, section 6.6. Speaking of possible conversions, there may be more than you expect, as we’ll see in our next section.</font></p>
<p><a name="bookmark149"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1641"></a>5.3 Covariance and contravariance</font></p>
<p><a name="bookmark1642"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1643"></a>We’ve already talked a lot about the concepts of covariance and contravariance in different contexts, usually bemoaning their absence, but delegate construction is the one area in which they’re actually available in C# prior to version 4. If you want to refresh yourself about the meaning of the terms at a relatively detailed level, refer back to section 2.2.2—but the <a name="bookmark1644"></a>gist of the topic with re<a name="bookmark1645"></a>spect to delegates is that if it would be valid (in a static typing sense) to call a method and use its return value every<a name="bookmark1646"></a>where that you could invoke an instance of a particular delegate type and use </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">its </font><font style="font-size:x-small;font-family:Times New Roman, serif;">return value, then that method can be used to create an instance of that delegate type. That’s wordy, but it’s a lot simpler with examples.</font></p>
<p><a name="bookmark1647"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">DIFFERENT TYPES OF VARIANCE IN DIFFERENT VERSIONS You may already be aware that C# 4 offers </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">generic</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> covariance and contravariance for delegates and interfaces. This is entirely different from the variance we’re looking at here— we’re only dealing with creating </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">new</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> instances of delegates at the moment.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Generic variance uses </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reference conversions,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which don’t create new objects— they just view the existing object as a different type.</font></p>
<p><a name="bookmark1648"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1649"></a>We'll look at contravariance first, then covariance.</font></p>
<p><a name="bookmark150"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1650"></a>5.3.1 Contravariance for delegate parameters</font></p>
<p><a name="bookmark1651"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1652"></a><a name="bookmark1653"></a>Let’s consider the event handlers we have in our little Windows Forms application. The signatures<sup>2</sup> of the three delegate types involved are as follows:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void EventHandler (object<a name="bookmark1654"></a> sender, EventArgs e)</font></p>
<p><a name="bookmark1655"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void KeyPressEventHand<a name="bookmark1656"></a>ler (object sender, KeyPressEve<a name="bookmark1657"></a>ntArgs e) void MouseEventHandler (object sender, MouseEventArgs e)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now, consider that KeyPressEventArgs and MouseEventArgs both derive from Event-Args (as do a lot of other types—MSDN lists 403 types that derive directly from Event-Args in .NET 4). So, if you have a method with an EventArgs parameter, you could always call it with a KeyPressEventArgs argument instead. It therefore makes sense to be able to use a method with the same signature as EventHandler to create an instance of KeyPressEventHandler—and that’s exactly what C# 2 does. This is an example of contravariance of parameter types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To see that in action, let’s think back to listing 5.1 and suppose that we don’t need to know which event was firing—we just want to write out the fact that an event has happened. Using method group conversion<a name="bookmark1658"></a>s and contravariance, our code becomes a lot simpler, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.2 Demonstration of method group conversions and delegate contravariance</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void LogPlainEvent(object sender, EventArgs e)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;An event occurred&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Button button = new Button(); button.Text = &quot;Click me&quot;; button.Click += LogPlainEvent; button.KeyPress += LogPlainEvent; button.MouseClick += LogPlainEvent;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Form form = new Form(); form.AutoSize = true; form.Controls.Add(button);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Application.Run(form);</font></p>
<p><a name="bookmark1659"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1660"></a>We’ve managed to completely remove the two handler methods that dealt specifically with key and mouse events, using one event handling method </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">for everything. Of course, this isn’t terribly useful if you want to do different things for different types of events, but sometimes all you need to know is that an event occurred and, potentially, the source of the event. The subscription to the Click event </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">only uses the implici<a name="bookmark1661"></a>t conversion we discussed in the<a name="bookmark1662"></a> previous section because it has a simple EventArgs parameter, but the other event subscriptions </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">G </font><font style="font-size:x-small;font-family:Times New Roman, serif;">involve the conversion and contravariance due to their different parameter types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I mentioned earlier that the .NET 1.0/1.1 event handler convention didn’t make much sense when it was first introduced. This example shows exactly why the guidelines are more useful with C# 2. The convention dictates that event handlers should have a signature with two parameters, the first of which is of type object and is the origin of the event, and the second of which carries any extra information about the event in a type deriving from EventArgs. Before contravariance became available, this wasn’t useful—there was no benefit to making the informational parameter derive from EventArgs, and sometimes there wasn’t much use for the origin of the event. It was often more sensible to pass the relevant information directly in the form of normal parameters with appropriate types, just like any other method. Now, you can use a method with the EventHandler signature as the action for </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">any</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> delegate type that honors the convention.</font></p>
<p><a name="bookmark1663"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we’ve looked at the values entering a method or delegate—what about the value coming out?</font></p>
<p><a name="bookmark151"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1664"></a><a name="bookmark1665"></a>5.3.2 Covariance of delegate return types</font></p>
<p><a name="bookmark1666"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Demonstrating covariance is harder, as relatively few of the delegates available in .NET 2.0 are declared with a nonvoid return type, and those that are tend to return value types. There are some available, but it’s easier to declare our own delegate type that uses Stream as its return type. For simplicity we’ll make it parameterless:<sup><a name="footnote38"></a><a href="#bookmark1667">38</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate Stream StreamFactory();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We can now use this with a method that’s declared to return a specific type of stream, as shown in listing 5.3. We declare a method that always returns a MemoryStream with some sequential data (bytes 0, 1, 2, and so on up to 15), and then use that method as the action for a StreamFactory delegate instance.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.3 Demonstration of covariance of return types for delegates</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate Stream StreamFactory(); static MemoryStream GenerateSampleData()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">byte[] buffer = new byte[16]; for (int i = 0; i &lt;&nbsp;buffer.Length; i++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">buffer[i] = (byte) i;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new MemoryStream(buffer);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StreamFactory factory = GenerateSampleData; using (Stream stream = factory())</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int data;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">while ((data = stream.ReadByte()) != -1)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(data);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The actual generation and display of the data in listing 5.3 is only present to give the code something to do. The important points are the annotated lines. We declare that the delegate type has a return type of Stream </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, but the GenerateSampleData method </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">C</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> has a return type of MemoryStream. The line creating the delegate instance</font></p>
<p><a name="bookmark1668"></a><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">performs the conversion we saw earlier and uses covariance of return types to allow GenerateSampleData to be used for the action for StreamFactory. By the time we invoke the delegate instance, </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">the compiler no longer knows that a MemoryStream will be returned—if we changed the type of the stream variable to MemoryStream, we’d get a compilation error.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Covariance and contravariance can also be used to construct one delegate instance from another. For instance, consider these two lines of code (which assume an appropriate HandleEvent method):</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">EventHandler general = new EventHandler(HandleEvent);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">KeyPressEventHandler key = new KeyPressEventHandler(general);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first line is valid in C# 1, but the second isn’t—in order to construct one delegate from another in C# 1, the signatures of the two dele<a name="bookmark1669"></a>gate types involved hav<a name="bookmark1670"></a>e to match. For instance, you could create a MethodInvoker from a ThreadStart—but you couldn’t do what we’re doing in the previous code. We’re using c<a name="bookmark1671"></a>ontravari<a name="bookmark1672"></a>ance to create a new delegate instance from an existing one with a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">compatible</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> delegate type signature, where compatibility is defined in a less restrictive manner in C# 2 than in C# 1. All of this is positive, except for one small fly in the ointment.</font></p>
<p><a name="bookmark152"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1673"></a>5.3.3 A small risk of incompatibility</font></p>
<p><a name="bookmark1674"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This new flexibility in C# 2 causes one of the few cases where existing valid C# 1 code may prod<a name="bookmark1675"></a>uce different results when compiled under C# 2. Suppose a derived class overloads a method declared in its base class,<a name="bookmark1676"></a> and you try to create an instance of a delegate using a method group conversion. A conversion that previously only matched the base class method could match the derived class method due to covariance or contravariance in C# 2, in which case that derived class method would be chosen by the compiler. The following listing gives an example of this.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.4 Demonstration of breaking change between C# 1 and C# 2</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate void SampleDelegate(string x); public void CandidateAction(string x)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Snippet.CandidateAction&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class Derived : Snippet</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void CandidateAction(object o)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Derived.CandidateAction&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Derived x = new Derived();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleDelegate factory = new SampleDelegate(x.CandidateAction); factory(&quot;test&quot;);</font></p>
<p><a name="bookmark1677"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Remember that Snippy<sup><a name="footnote39"></a><a href="#bookmark1678">39</a></sup> will be generating all of this code within a class called Snippet, which the nested type derives from. Under C# 1, listing 5.4 would print Snippet. CandidateAction because the method taking an object parameter wasn’t compatible with SampleDelegate. Under C# 2, it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> compatible and is the method chosen due to being declared in a more derived type—so t<a name="bookmark1679"></a>he result is that Derived.CandidateAction is printed. Fortunately, the <a name="bookmark1680"></a>C# 2 compiler knows that this is a breaking change and issues an appropriate warning. I’ve included this section because you ought to be aware of the possibility of such a problem, but I'm sure it’s rarely encountered in real life.</font></p>
<p><a name="bookmark1681"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Enough doom and gloom about potential breakage. We’ve still got to see the most important new feature regarding delegates: anonymous methods. They’re a bit more complicated than the topics we’ve covered so far, but they’re also </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> powerful—and a large step toward C# 3.</font></p>
<p><a name="bookmark154"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1682"></a>5.4 Inline delegate actions with anonymous methods</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Back in C# 1, it was common to implement a delegate with a particular signature, even though you already had a method with exactly the right behavior but with a slightly different set of parameters. Likewise, you’d often want a delegate to do just one teeny,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">tiny thing—but that meant you needed a whole extra method. The new method would represent behavior that was only relevant within the original method, but was now exposed to the whole class, creating noise in IntelliSense and generally getting in the way.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All this was intensely frustrating. The covariance and contravariance features we’ve just talked about can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">sometimes</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> help with the first problem, but often they don’t. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Anonymous methods,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which are also new in C# 2, can pretty much </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> help with these issues.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Informally,<a name="bookmark1683"></a> anonymous methods allow you to specify the action for a delegate instance inline as part of the delegate instance creation expression. They also provide some far more powerful behavior in the form of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">closures,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> but we’ll come to those in section 5.5. For the moment, let’s stick with relatively simple stuff.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First we’ll see examples of anonymous methods that take parameters but don’t return any values; then we’ll explore the syntax involved in providing return values and a shortcut available when we don’t need to use the parameter values passed to us.</font></p>
<p><a name="bookmark1684"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Starting simply: acting on a parameter</font></p><div>
<p><a name="bookmark155"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">5.4.1</font></p></div><br clear="all"/>
<p><a name="bookmark1685"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">.NET 2.0 introduced a generic delegate type called Action&lt;T&gt;, which we’ll use for our examples. Its signature is simple (aside from the fact that it’s generic):</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public delegate void Action&lt;T&gt;(T obj)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In other words, an Action&lt;T&gt; does something with a value of type T. So an Action&lt;string&gt; could reverse the string and print it out, an Action&lt;int&gt; could print out the square root of the number passed to it, and an Action&lt;IList&lt;double&gt;&gt; could find the average of all the numbers given to it and print that out. By complete coincidence, these examples are all implemented using anonymous methods in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.5 Anonymous methods used with the Action&lt;T&gt; delegate type</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Action&lt;string&gt; printReverse = delegate(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">char[] chars = text.ToCharArray();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Array.Reverse(chars);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(new string(chars));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Action&lt;int&gt; printRoot = delegate(int number)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(Math.Sqrt(number));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Action&lt;IList&lt;double&gt;&gt; printMean = delegate(IList&lt;double&gt; numbers)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">double total = 0;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (double value in numbers) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">total += value;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(total / numbers.Count);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">printReverse(&quot;Hello world&quot;); printRoot(2);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">printMean(new double[] { 1.5, 2.5, 3, 4.5 });</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.5 shows a few of the different features of ano<a name="bookmark1686"></a>nymous methods. First, the syntax of anonymous methods: use the delegate keyword, followed by the parameters (if there are any), followed by the code for the action of the delegate instance, in a block. The<a name="bookmark1687"></a> string reversal code O shows that the block can contain local variable declara-</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">tions, and the “list averaging” code Q demonstrates looping within the block. Basi-</font></p>
<p><a name="bookmark1688"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">cally you can do (almost) anything in an anonymous method that you can do in a normal method body. Likewise, the result of an anonymous method is a delegate instance that can be used like any <a name="bookmark1689"></a>other one G. Be warned that contravari<a name="bookmark1690"></a>ance doesn’t apply to anonymous methods: you have to specify the parameter types that match the delegate type exactly.</font></p>
<p><a name="bookmark1691"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">A COUPLE OF RESTRICTIONS... One slight oddity is that if you’re writing an anonymous method in a value type, you can’t reference this from within it. There’s no such restriction within a reference type.</font></p>
<p><a name="bookmark1692"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1693"></a>Additionally, in the Microsoft C# 2 and 3 compiler implementations, accessing a base mem<a name="bookmark1694"></a>ber within an anonymous method via the base keyword resulted in a warning that the resulting code was unverifiable. This has been fixed for the C# 4 compiler.</font></p>
<p><a name="bookmark1695"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In terms of implementation, we’re still creating a method in IL for each anonymous method in the source code: in this case the compiler will generate a method within the existing class and use that as the action when it creates the delegate instance, just as if it were a normal method.<sup><a name="footnote40"></a><a href="#bookmark1696">40</a></sup> The CLR neither knows nor cares that an anonymous metho<a name="bookmark1697"></a>d was used. <a name="bookmark1698"></a>You can see the extra methods within the compiled code using ildasm or Reflector. (Reflector knows how to interpret the IL to display anonymous methods in the method that use<a name="bookmark1699"></a>s them, but the extra methods are still visible.) These methods have </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">unspeakable names</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—ones that are valid in IL, but invalid in C#. This stops you from atte<a name="bookmark1700"></a>mpting to refer to them directly in your C# code, and avoids the possibility of naming collisions. Many of the features of C# 2 and later versions are implemented <a name="bookmark1701"></a>in a similar way; one easy way to spot them is that they usually contain angle brackets. For example, an anonymous method in a Main method </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">mig<a name="bookmark1702"></a>ht</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> cause a</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">method called &lt;Main&gt;b_0 to be created. It’s enti<a name="bookmark1703"></a>rely implementation-specific,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">though. Microsoft could change its private conventions in a future version, for example. This shouldn’t break anything, as nothing should be relying on these names.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth pointing out at this stage that listing 5.5 is exploded compared with how anonymous methods normally look in real code. You’ll often see them used as arguments to another m<a name="bookmark1704"></a>ethod (rather th<a name="bookmark1705"></a>an assigned to a variable of the delegate type) and with few line breaks—compactness is part of the reason for using them, after all. To</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">demonstrate this, we’ll use the List&lt;T&gt; .ForEach method that takes an Action&lt;T&gt; as a parameter and performs that action on each element. Listing 5.6 shows an extreme example, applying the same square-rooting action we used in listing 5.5, but in a compact form.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.6 Extreme example of code compactness. Warning: unreadable code ahead!</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;int&gt; x = new List&lt;int&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Add(5);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Add(10);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Add(15);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Add(20);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Add(25);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.ForEach(delegate(int n){Console.WriteLine(Math.Sqrt(n));});</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s pretty horrendous—especially when at first sight the last six characters appear to be ordered al<a name="bookmark1706"></a>most at random. There’s a happy medium, of course. I tend to break my usual “br<a name="bookmark1707"></a>aces on a line on their own” rule for anonymo<a name="bookmark1708"></a>us methods (as I do for trivial properties) but still allow a decent amount of whitespace. I might well write the last line of listing 5.6 in one of these two forms:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.ForEach(delegate(int n)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ Console.WriteLine(Math.Sqrt(n)); }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.ForEach(delegate(int n) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(Math.Sqrt(n));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">});</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even just adding spaces to listing 5.6 would’ve helped, of course. In each of these formats, the parentheses and braces are now less confusing, and the “what it does” part stands out appropriately. Of course, how you space out your code is entirely your own business, but I encourage you to actively thi<a name="bookmark1709"></a>nk about where you want to strik<a name="bookmark1710"></a>e the balance, and talk about it with your teammates to try <a name="bookmark1711"></a>to achieve some consistency. Consistency doesn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> lead to the most readable code, though—sometimes keeping everything on one line is the most straightforward format.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far the only interaction we’ve had with the calling code is through parameters. What about return values?</font></p>
<p><a name="bookmark156"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1712"></a><a name="bookmark1713"></a>5.4.2 Returning values from anonymous methods</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Action&lt;T&gt; delegate has a void return type, so we haven’t had to return anything from our anonymous methods. To demonstrate how we can do so when we need to, we’ll use the Predicate&lt;T&gt; delegate type from .NET 2.0, which has this signature:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public delegate bool Predicate&lt;T&gt;(T obj)</font></p>
<p><a name="bookmark1714"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1715"></a>Listing 5.7 shows an anonymous method creating an instance of Predicate&lt;T&gt; to return whether the ar<a name="bookmark1716"></a>gument passed in is odd or even. Predicates are usually used in filtering and matching—you could use the code in listing 5.7 to filter a list to contain just the even elements, for instance.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.7 Returning a value from an anonymous method</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Predicate&lt;int&gt; isEven = delegate(int x) { return x % 2 == 0; };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(isEven(1));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(isEven(4));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The new syntax is almost certainly what you’d have expected—we just return the appropriate value as if the anonymous method were a normal method. You may have expected to see a return type declared near the delegate keyword, but there’s no need. The compiler just c<a name="bookmark1717"></a>hecks that all the possible return values are compatible with the declared return type of the delegate type it’s trying to convert the anonymous method into.</font></p>
<p><a name="bookmark1718"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">JUST WHAT ARE YOU RETURNING FROM? When you return a value from an anonymous method, it really is only returning from the anonymous method—it’s not returning from the method creating the delegate instance.</font></p>
<p><a name="bookmark1719"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s easy to look down some code, see the return keyword, and think that it’s an exit point from the current method, so be careful.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As I mentioned before, relatively few delegates in .NET 2.0 return values, although as we’ll see in part 3, .NET 3.5 uses this idea </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">much</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> more often, particularly with LINQ. Th<a name="bookmark1720"></a>ere’s another reasonably common <a name="bookmark1721"></a>delegate ty<a name="bookmark1722"></a>pe in .NET 2.0 though: Comparison &lt;T&gt;, which ca<a name="bookmark1723"></a>n be used when sorting collections. It’s the delegate equivalent of the IComparer&lt;T&gt; interface, effectively. Often you only need a particular sort order in one situation, so it makes sense to be able to specify that order inline, rather than exposing it as a method within the rest of the class. The following listing demonstrates this, printing out the files within the C:\ directory, ordering them first by name and then (separately) by size.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.8 Using anonymous methods to sort files simply</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void SortAndShowFiles(string title, Comparison&lt;FileInfo&gt; sortOrder) {</font></p>
<p><a name="bookmark1724"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FileInfo[] files = new DirectoryInfo(@&quot;C:\&quot;).GetFiles();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Array.Sort(files, sortOrder);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(title); foreach (FileInfo file in files)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot; {0} &nbsp;&nbsp;&nbsp;({1} &nbsp;&nbsp;&nbsp;bytes)&quot;, &nbsp;&nbsp;&nbsp;file.Name, &nbsp;&nbsp;&nbsp;file.Length);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SortAndShowFiles(&quot;Sorted by name:&quot;, delegate(FileInfo f1, FileInfo f2)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ return f1.Name.CompareTo(f2.Name); }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SortAndShowFiles(&quot;Sorted by length:&quot;, delegate(FileInfo f1, FileInfo f2)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ return f1.Length.CompareTo(f2.Length); }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If we weren’t using anonymous methods, we’d need a separate method for each sort order. Instead, listing 5.8 makes it clear what we’ll sort by in each case right where we call SortAndShowFiles. (Sometimes you’ll be calling Sort directly at the point where the anonymous method is called for. In this case we’re performing the same fetch/ sort/display sequence twice, just with different sort orders, so I encapsulated those steps in their own method.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One special syntactic shortcut is sometimes applicable. If you don’t care about the parameters of a delegate, you don’t have to declare them at all. Let’s see how that works.</font></p>
<p><a name="bookmark157"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1725"></a><a name="bookmark1726"></a>5.4.3 Ignoring delegate parameters</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Occasionally, you want to implement a delegate that doesn’t depend on its parameter values. You may wish to write an event handler whose behavior was only appropriate for one event and didn’t depend on the event arguments: saving the user’s work, for instance. The event handlers from our original example in list<a name="bookmark1727"></a>ing 5.1 fit this criterion perfectly.<a name="bookmark1728"></a> In this case, you can leave out the parameter list entirely, just using the delegate keyword and then the block of code to use as the action for the method. The following listing is equivalent to listing 5.1 but uses the shorter syntax.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.9 Subscribing to events with anonymous methods that ignore parameters</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark1729">Button button = new Button(); button.Text = &quot;Click &nbsp;&nbsp;&nbsp;me&quot;;</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark1730">button.Click &nbsp;&nbsp;&nbsp;+= &nbsp;&nbsp;&nbsp;delegate &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;LogPlain&quot;); &nbsp;&nbsp;&nbsp;};</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">button.KeyPress &nbsp;&nbsp;&nbsp;+= &nbsp;&nbsp;&nbsp;delegate &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;LogKey&quot;); };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark1731">button.MouseClick &nbsp;&nbsp;&nbsp;+= &nbsp;&nbsp;&nbsp;delegate &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;LogMouse&quot;); &nbsp;&nbsp;&nbsp;};</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Form form = new Form(); form.AutoSize = true; form.Controls.Add(button);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Application.Run(form);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Normally we’d have had to write each subscription as something like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">button.Click += delegate (object sender, EventArgs e) { ... };</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That wastes a lot of space for little reason—we don’t need the values of the parameters, so the compiler lets us get away with not specifying them at <a name="bookmark1732"></a>all. I’ve found this shortcut most useful when it c<a name="bookmark1733"></a>omes to implementing my own events. I get sick of having to perform a nullity check before raising an event. One way of getting around this is to make sure that the event starts off with a handler, which is then never removed. As long as the handler doesn’t do anything, all you lose is a tiny bit of performance. Before C# 2, you had to explicitly create a method with the right signature, which usually wasn’t worth the benefit... but now you can write code like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public event EventHandler Click = delegate {};</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">From then on, you can just call Click without any nullity tests.</font></p>
<p><a name="bookmark1734"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You should be aware of one trap about this parameter wildcarding feature—if the anonymous method could be converted to multiple delegate types (for example, to call different method overloads) then the compiler needs more help. To show you what I mean, we’ll take the same troublesome example we saw with method group conversions: starting a new thread. There are four thread constructors in .NET 2.0:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Thread(ParameterizedThreadStart start) public Thread(ThreadStart start)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Thread(ParameterizedThreadStart start, int maxStackSize) public Thread(ThreadStart start, int maxStackSize)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The two delegate types involved are</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public delegate void ThreadStart()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public delegate void ParameterizedThreadStart(object obj)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now, consider the following three &nbsp;&nbsp;&nbsp;attempts to create a new thread:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark1735">new Thread(delegate() &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;t1&quot;); &nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;);</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark1736">new Thread(delegate(object &nbsp;&nbsp;&nbsp;o) &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;t2&quot;); &nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;);</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark1737">new Thread(delegate &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;t3&quot;); &nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;);</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first and second lines contain parameter lists—the compiler knows that it c<a name="bookmark1738"></a>an’t convert the anonymous method in the first line into a ParameterizedTh<a name="bookmark1739"></a>readStart, or convert the anonymous method in the second line into a ThreadStart. Those lines compile, because there’s only on<a name="bookmark1740"></a>e applicable constructor overload in each case. The third line, though, is ambiguous—the anonymous method can be converted into either delegate type, so both of the single parameter constructor overloads are applicable. In this situation, the compiler throws its hands up and issues a<a name="bookmark1741"></a>n error. You can solve this either by specifying the parameter list explicitly or casting the anonymous method to the right delegate type.</font></p>
<p><a name="bookmark1742"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1743"></a>Hopefully what you’ve seen of anonymous methods so far will have provoked some thought about your own code, and made you consider where you could use these techniques to good effect. Indeed, even if anonymous methods could </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> do what we’ve already seen, they’d still be very useful. But there’s more to anonymous methods than just avoiding the inclusion of an extra method in your code. Anonymous methods are C# 2’<a name="bookmark1744"></a>s implementation of a feature known elsewhere as </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">closures</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> by way of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">captured variables.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Our next section explains both of these terms and shows how anonymous methods can be extremely powerful—and confusing if you’re not careful.</font></p>
<p><a name="bookmark159"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1745"></a>5.5 Capturing variables in anonymous methods</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I don’t like having to give warnings, but I think it makes sense to include one here: if this topic is new to you, then don’t start this section until you’re feeling reasonably awake and have a bit of time to spend on it. I don’t want to alarm you unnecessarily, and you should feel confident that there’s nothing so insanely complicated that you won’t be able to understand it with a little effort. It’s just that captured variables can be somewhat confusing to start with, partly because they overturn some of your existing knowledge and intuition.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Stick <a name="bookmark1746"></a>with it, though! The payback can be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">massive</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in terms of code simplicity and readability. This topic will also be crucial when we come to look at lambda expressions and LINQ in C# 3, so it’s worth the investment. Let’s start with a few definitions.</font></p>
<p><a name="bookmark1747"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1748"></a>Defining closures and different types of variables</font></p>
<p><a name="bookmark1749"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1750"></a><a name="bookmark1751"></a><a name="bookmark1752"></a>The concept of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">closures</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is an old one, first implemented in Scheme, b<a name="bookmark1753"></a>ut it’s been gaining more prominence in recent years as <a name="bookmark1754"></a>more mainstream languages have taken it on board. The basic idea is that a function<sup><a name="footnote41"></a><a href="#bookmark1755">41</a></sup> is able to interact with an environment beyond the parameters provided to it. That’s all there is to it in <a name="bookmark1756"></a>abstract terms, but to understand how it ap<a name="bookmark1757"></a>plies to C# 2, we need a couple more terms:</font></p>
<p><a name="bookmark1758"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1759"></a>■ &nbsp;&nbsp;&nbsp;An </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">outer variable</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is a local v<a name="bookmark1760"></a>ariable or parameter<sup><a name="footnote42"></a><a href="#bookmark1761">42</a></sup> whose scope includes an anonymous method. The this reference also cou<a name="bookmark1762"></a>nts as an outer variable of any anonymous method within an instance member of a class.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;A </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">captured outer variable</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (usually shortened to just </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">captured variable)</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is an outer variable that’s used within an anonymous method. So to go back to closures, the function part is the anonymous method, and the environment it can interact with is the set of variables captured by it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s all very dry and may be hard to imagine, but the main thrust is that an anonymous method can use local variables defined in the same method that declares it. This may not sound<a name="bookmark1763"></a> like a big deal, but in many situations it’s enormously handy—you can use contextual information that you have on hand rather than having to set up extra types just to store data you already know. We’ll see some </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">useful</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> concrete examples soon, I promise—but first it’s worth looking at some code to clarify these definitions. Listing 5.10 provides an example with a number of local variables. It’s just a single method, so it can’t be run on its own. I’m not going to explain how it would work or what it would do yet; I just want to <a name="bookmark1764"></a>discuss how the different variables are classified. Again we’re using the MethodInvoker delegate type for simplicity.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.10 Examples of different kinds of variables with respect to anonymous methods</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void EnclosingMethod()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int outerVariable = 5; string capturedVariable = &quot;captured&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (DateTime.Now.Hour == 23)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int normalLocalVariable = DateTime.Now.Minute; Console.WriteLine(normalLocalVariable);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MethodInvoker x = delegate()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><a name="bookmark1765"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string anonLocal = &quot;local to anonymous method&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(capturedVariable + anonLocal); &nbsp;&nbsp;&nbsp;&lt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">-. Capture of</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><sup>}</sup>' &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">A outer variable</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x(); &nbsp;&nbsp;&nbsp;</font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;"><sup>F</sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s go through all the variables from the simplest to the most complicated:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;normalLocalVariable </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">isn’t<a name="bookmark1766"></a> an outer variable because there are no anonymous methods within its scope. It behaves exactly the way that local variables always have.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;anonLocal </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">isn’t an outer variable either, but it’s local to the anonymous method, not to Enclosi<a name="bookmark1767"></a>ngMethod. It’ll only exist (in terms of being present in an executing stack frame) when the delegate instance is invoked.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;outerVariable </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is an outer variable because the anonymous method is declared within its scope. But the anonymous method doesn’t refer to it, so it’s not captured.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;capturedVariable </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is an outer variable because the anonymous method is declared within its scope, and it’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">captured</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> by virtue of being used at </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><a name="bookmark1768"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Okay, so we now understand the terminology, but we’re not a lot closer to seeing what captured variables do. I suspect you could guess the output if we ran the method from listing 5.10, but there are some other cases that would probably surprise you. We’ll start off with a simple example and gradually build up to more complex ones.</font></p>
<p><a name="bookmark161"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1769"></a>5.5.2 Examining the <a name="bookmark1770"></a>behavior of captured variables</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When a variable is captured, it really is the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">variable</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that’s captured by the anonymous method, not its value at the time the delegate instance is created. We’ll see later that this has far-reaching consequences, but first we’ll make sure we understand what that means for a relatively straightforward situation. Listing 5.11 has a captured variable and an anonymous method that both prints out and changes the variable. We’ll see that changes to the variable from outside the anonymous method are visible within the anonymous method, and vice versa.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.11 Accessing a variable both inside and outside an anonymous method</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string captured = &quot;before x is created&quot;; MethodInvoker x = delegate</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(captured); captured = &quot;changed by x&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">captured = &quot;directly before x is invoked&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(captured);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">captured = &quot;before second invocation&quot; x();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">directly before x is invoked changed by x</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">before second invocation</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s look at how this happens. First, we declare the variable captured and set its value with a perfectly normal string literal. So far, there’s nothing special about the variable. We then declare x and set its value using an anonymous method that captures captured. The delegate instance will always print out the current value of captured, and then set it to “changed by x.” Don’t forget that creating this delegate instance </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">doesn’t execute it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To make it absolutely clear that just creating the delegate instance didn’t read the variable and stash its value away somewhere, we now change the value of captured to “directly before x is invoked.” We then invoke x for the first time. It reads the value of captured and prints it out—our first line of output. It sets the value of captured to “changed by x” and returns. When the delegate instance returns, the normal method continues in the usual way. It prints out the current value of captured, giving us our second line of output.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The normal method then changes the value of captured yet again (this time to “before second invocation”) and invokes x for the second time. The current value of captured is printed out, giving our last line of output. The delegate instance changes the value of captured to “changed by x” and returns, at which point the normal method has run out of code and we’re done.</font></p>
<p><a name="bookmark1771"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s a lot of detail about how a short piece of code works, but there’s really only one crucial idea in it: </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">the captured variable is the same one that the rest of the method uses.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> For some people, that’s hard to grasp; for others it comes naturally. Don’t worry if it’s tricky to start with—it’ll get easier over time. Even if you’ve understood everything easily so far, you may be wondering why you’d want to do any of this. It’s about time we had an example that was actually useful.</font></p>
<p><a name="bookmark162"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1772"></a>5.5.3 What’s the point of captured variables ?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To put it simply, captured variables eliminate the need to write extra classes just to store the information a delegate needs t<a name="bookmark1773"></a>o act on, beyond what it’s passed via parameters. Befor<a name="bookmark1774"></a>e Parame<a name="bookmark1775"></a>terizedThreadStart existed, if you wanted to start a new (non-threadpool) thread and give it some information—the URL of a page to fetch, for instance—you had to create an extra type to hold the URL and put the action of the ThreadStart delegate instance in that type. Even with ParameterizedThreadStart, your method had to accept a parameter of type object and cast it to the type you really wanted. It was all an ugly way of achieving something that should’ve been simple.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As another example, suppose you had a list of people and wanted to write a method that would return a second list containing all the people who were under a given age. List&lt;T&gt; has a method called FindAll that returns another list of everything matching the specified predicate. Before anonymous methods and captured <a name="bookmark1776"></a>variables, it wouldn’t have made much sense for List&lt;T&gt;.FindAll to exist, because of all the hoops you’d have to go through in order to create the right delegate to start with. It would’ve been simpler to do all the iteration and copying manually. With C# 2, though, we can do it all very easily:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Person&gt; FindAllYoungerThan(List&lt;Person&gt; people, int limit)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return people.FindAll(delegate (Person person)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ return person.Age &lt;&nbsp;limit; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here we’re capturing the limit parameter within the delegate instance—if we’d had anonymous methods but not captured variables, we could’ve performed a test against a hardcoded limit, but not one that was passed into the method as a parameter. I hope you’ll agree that this approach is neat: it expresses exactly </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">what</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> we want to do with much less fuss about exactly </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">how</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> it should happen than you’d have seen in a C# 1 version. (It’s even neater in C# 3, admittedly...<sup>8</sup>) It’s relatively rare that you come across a situation where you need to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">write</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to a captured variable, but again that can certainly have its uses.</font></p>
<p><a name="bookmark1777"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1778"></a>Still with me? Good. So far, we’ve only used the delegate instance within the method that creates it. That doesn’t raise many questions about the lifetime of the captured variables—but what would happen if the delegate instance escaped into the big bad world? How would it cope after the method that created it had finished?</font></p>
<p><a name="bookmark163"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1779"></a>5.5.4 The extended lifetime of captured variables</font></p>
<p><a name="bookmark1780"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The simplest way of tackling this topic is to state a rule, give an example, and then think about what would happen if the rule weren’t in place. Here we go:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">A captured variable lives for at least as long as any delegate instance referring to it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Don’t worry if it doesn’t make a lot of sense yet—that’s what the example is for. Listing 5.12 shows a method that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">returns</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a delegate instance. That delegate instance is created using an anonymous method that captures an outer variable. So, what’ll happen when the delegate is invoked after the method has returned?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.12 Demonstration of a captured variable having its lifetime extended</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static MethodInvoker CreateDelegateInstance()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int counter = 5;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MethodInvoker ret = delegate {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(counter);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">counter++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ret() ;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return ret;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MethodInvoker x = CreateDelegateInstance();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The output of listing 5.12 consists of the numbers 5, 6, and 7 on separate lines. The first line of output comes from the invocation of the delegate instance within Create-DelegateInstance, so it makes sense that the value of counter is available at that point. But what about af<a name="bookmark1781"></a>ter the method has returned? Normally we’d consider counter to be on the stack, so when the stack frame for CreateDelegateInstance is destroyed we’d expect counter to effectively vanish... and yet subsequent invocations of the returned delegate instance seem to kee<a name="bookmark1782"></a>p using it!</font></p>
<p><a name="bookmark1783"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The secret is to challenge the assumption that counter is o<a name="bookmark1784"></a>n the stack in the first place. It isn’t. The compiler has </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">actually</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> created an extra class to hold the variable. The CreateDelegateInstance method has a reference to an instance of that class so it can use cou<a name="bookmark1785"></a>nter, and the delegate has a reference to the same instance—which lives on the heap in the normal way. That instance isn’t eligible for garbage collection until the dele<a name="bookmark1786"></a>gate is ready to be collected. Some aspects of anonymous methods are very compiler-specific (different compilers could achieve the same semantics in different ways), but it’s <a name="bookmark1787"></a>hard to see how the specified behavior could be achieved </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">without</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <a name="bookmark1788"></a>using an extra class to hold the captured variable. Note that if you only capture this, no extra types are required—the compiler just creates an instance method to act as the delegate’s action. As I mentioned before, you probably shouldn’t worry about the stack and heap details too much, but it’s worth knowing the kind of thing the compiler is capable of doing, just in case you get confused as to how the specified behavior is even possible.</font></p>
<p><a name="bookmark1789"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Okay, so local variables can live on even after a method has returned. You may be wondering what I could possibly throw at you next—how about multiple delegates capturing different instances of the same variable? It sounds crazy, so it’s just the kind of thing you should be expecting by now.</font></p>
<p><a name="bookmark1790"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Local variable instantiations</font></p><div>
<p><a name="bookmark164"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">5.5.5</font></p></div><br clear="all"/>
<p><a name="bookmark1791"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">On a good day, captured variables act exactly the way I expect them to at a glance. On a bad day, I’m still surprised when I’m not careful. When there are problems, it’s almost always due to forgetting how many “instances” of local variables I’m actually creating. A local variable is said to be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">instantiated</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> each time execution enters the scope where it’s declared. Here’s a simple example comparing two very similar bits of code:</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int single;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">for (int i = 0; i &lt;&nbsp;10; i++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">single = 5;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(single + i);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">for (int i = 0; i &lt;&nbsp;10; i++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int multiple = 5;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(multiple + i);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In the good old days, it was reasonable to say that pieces of code like this were semantically identical. Indeed, they’d usually compile to the same IL—and they still will, if there aren’t any anonymous methods involved. All the space for local variables is allocated on the stack at the start of the method, so there’s no cost to redeclaring the variable for each iteration of the loop.<sup><a name="footnote43"></a><a href="#bookmark1792">43</a></sup> In our new terminology, the single variable will be instantiated only once, but the multiple variable will be instantiated 10 times—it’s as if there were 10 local variables, all called multiple, which were created one after another.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m sure you can see where I’m going—when a variable is captured, it’s the relevant<a name="bookmark1793"></a> “instance” of the variable that’s captured. If we captured multiple inside the loop, the variable captured in the first iteration would be different from the variable captured the second time round, and so on. The following listing shows exactly this effect.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.13 Capturing multiple variable instantiations with multiple delegates</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;MethodInvoker&gt; list = new List&lt;MethodInvoker&gt;(); for (int index = 0; index &lt;&nbsp;5; index++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int counter = index * 10; list.Add(delegate {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(counter); counter++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">});</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (MethodInvoker t in list) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">t();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">list[0](); list[0](); list[0]();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">list[1]();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.13 creates five different delegate instances </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—one for each time we go around the loop. Invoking the delegate will print out the value of counter and then increment it. Now, because counter is declared </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">inside</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the loop, it’s instantiated for each iteration </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and so each delegate captures a different variable. So, when we go through and invoke each delegate </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, we see the different values initially assigned to counter: 0, 10, 20, 30, 40. Just to hammer the point home, when we then go back to the first delegate instance and execute it three more times </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, it keeps going from where that instance’s counter variable had left off: 1, 2, 3. Finally we execute the</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">second delegate instance Q, and that keeps going from where </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">that</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> instance’s counter variable had left off: 11.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, each of the delegate instances has captured a different variable in this case. Before we leave this example, I should point o<a name="bookmark1794"></a>ut what would’ve happened if we’d captured index—the variable declared by the for loop—instead of counter. In this case, all the delegates would have shared the same variable. The output would’ve been the numbers 5 to 13; 5 first because the last assignment to index before the loop terminates would’ve set it to 5, and then incrementing the same variable re<a name="bookmark1795"></a>gardless of which delegate was involved. We’d see the same behavior with a foreach loop: the variable declared by the initial part of the loop is only instantiated once. It’s easy to get this wrong! If you want to capture the value of a loop variable for that particular iteration of the loop, introduce another variable within the loop, copy the loop variable’s value into it, and capture that new variable—effectively what we’ve done in listing 5.13 with the counter variable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">THIS COULD CHANGE... Though the behavior in a for loop is reasonable—the variable does appear to be declared just once, after all—it’s more surprising in the foreach case. In fact, it’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">almost always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> wrong to capture a foreach iteration variable in an anonymous method that’s going to exist beyond the immediate iteration. (It’s fine if the delegate instance is only used within that iteration.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This has cause<a name="bookmark1796"></a>d problems for so many developers that the C# team is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">considering</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> changing the semantics of foreach in a future version, to make it act more naturally—as if each iteration has its own separate variable. At the time of this writing, this is still only an idea being kic<a name="bookmark1797"></a>ked around, but it’s worth keeping your ear to the ground for future changes in this area.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For our final example, let’s look at something really nasty—sharing some captured variables but not others.</font></p>
<p><a name="bookmark165"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1798"></a>5.5.6 Mixtures of shared and distinct variables</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let me say before I show you this next example that it’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> code I’d recommend. In fact, the whole point of presenting it is to show how if you try to use captured variables in too complicated a fashion, things can get tricky really fast. Listing 5.14 creates two delegate instances that each capture “the same” two variables. But the story gets more convoluted when we look at what’s actually captured.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 5.14 Capturing variables in different scopes. Warning: nasty code ahead!</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MethodInvoker[] delegates = new MethodInvoker[2]; int outside = 0;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">for (int i = 0; i &lt;&nbsp;2; i++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int inside = 0;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegates[i] = delegate {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;({0},{1})&quot;, outside, inside);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">outside++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">inside++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MethodInvoker first = delegates[0];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MethodInvoker second = delegates[1];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">first() first() first()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">second() ; second() ;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">How long would it take you to predict the output from listing 5.14 (even with the annotati<a name="bookmark1799"></a>ons)? Frankly it would take me a while—longer than I like to spend understanding code. Just as an exercise, though, let’s look at what h<a name="bookmark1800"></a>appens.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First let’s consider the outside variable </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. The scope it’s declared in is only entered once, so it’s a straightforward case—there’s only ever one of it, effectively. The inside variable </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is a different matter—each loop iteration instantiates a new one. Tha<a name="bookmark1801"></a>t means that when we create the delegate instance </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, the outside variable is shared between the two delegate instances, but each of them has its own inside variable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">After the loop has ended, we call the first delegate instance we created three times. Because it’s incrementing both of its captured variables each time, and we started off with them both as 0, we see (0,0), then (1,1), then (2,2). The difference between the two variables in terms of scope becomes apparent when we execute the second delegate instance. It has a different inside variable, so that still has its initial value of 0, but the outside variable is the one we’ve already incremented three times. The output from calling the second delegate twice is therefore (3,0), then (4,1).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just for the sake of interest, let’s think about how this is imple<a name="bookmark1802"></a>mented—at least with Microsoft’s C# 2 compiler. What happens is that one extra class is generated to hold the outer variable, and another one is generated to hold an inner variable </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">and a reference to the first extra class.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Essentially, each scope that contains a captured variable gets its own type, with a reference to the next scope out that contains a captured variable. In our case, there were two instances of the type holding inner, and they both refer to the same instance of the type holding outer. Other implementations may vary, but this is the most obvious way of doing things. Figure 5.1 shows the values after listing 5.14 has executed. (The names aren’t the ones that the compiler would generate, but they’re close enough. Note that the delegate instances would also have other members in reality—only the target is interesting here, though.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even after you understand this code fully, it’s still a good template for experimenting with other elements of captured variables. As we noted earlier, certain elements of variable capture are implementation specific, and it’s often useful to refer to the</font></p><img src="images/15.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 5.1 Snapshot of multiple captured variable scopes in memory</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">specification to see what’s guaranteed—but it’s also important to be able to just </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">play </font><font style="font-size:x-small;font-family:Times New Roman, serif;">with code to see what happens.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s possible that there are situations where code like listing 5.14 would be the simplest and clearest way of expressing the desired behavior—but I’d have to see it to believe it, and I’d certainly want comments in the code to explain what would happen. So, when is it appropriate to use captured variables, and what do you need to look out for?</font></p>
<p><a name="bookmark166"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1803"></a>5.5.7 Captured variable guidelines and summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Hopefully this section has convinced you to be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> careful with captured variables. They make good logical sense (and almost any change to make them simpler would probably make them either less useful or less logical), but they also make it easy to produce horribly complicated code.</font></p>
<p><a name="bookmark1804"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Don’t let that disco<a name="bookmark1805"></a>urage you from using them sensibly, though—they can save you masses of tedious code, and when they’re used appropriately they can be the most readable way of getting the job done. But what counts as </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">sensible</font><font style="font-size:x-small;font-family:Times New Roman, serif;">?</font></p>
<p><a name="bookmark1806"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">GUIDELINES FOR USING CAPTURED VARIABLES</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The following is a list of suggestions for using captured variables:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;If code that doesn’t use captured variables is just as simple as code that does, don’t use them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Before capturing a variable declared by a for or foreach statement, consider whether your delegate is going to live beyond the loop iteration, and whether you want it to see the subsequent values of that variable. If not, create another variable inside the loop that just copies the value you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> want.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;If you create multiple delegate instances (whether in a loop or explicitly) that capture variables, put thought into whether you want them to capture the same variable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">■</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;If you capture a variable that doesn’t actually change (either in the anonymous method or the enclosing method body), then you don’t need to worry as much.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;If the delegate instances you create never escape from the method—in other words,<a name="bookmark1807"></a> they’re never stored anywhere else, or returned, or used for starting threads—life is a lot simpler.</font></p>
<p><a name="bookmark1808"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Consider the extended lifetime of any captured variables in terms of garbage collection. This is normally not an issue, but if you capture an object that’s expensive in terms of memory, it may be significant.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first point is the golden rule. Simplicity is a good thing—so any time the use of a captured variable m<a name="bookmark1809"></a>akes your code simpler after you’v<a name="bookmark1810"></a>e factored in the additional inherent complexity of forcing your code’s maintainers to understand what the captured variable does, use it. You need to include that e<a name="bookmark1811"></a>xtra complexity in your considerations, that’s all—don’t just go for minimal line count.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve covered a lot of ground in this section, and I’m aware that it can be hard to take in. I’ve listed the most important things to remember next, so that if you need to come back to this section another time, you can jog your memory without having to read through the whole thing again:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">variable</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is captured—not its value at the point of delegate instance creation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Captured variables have lifetimes extended to at least that of the capturing delegate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Multiple delegate<a name="bookmark1812"></a>s can capture the same variable...</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;...but within loops, the same variable declaration can effectively refer to different variable “instances.”</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;for/foreach loop declarations create variables that live for the duration of the loop—they’re not instantiated on each iteration.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Extra types are created where necessary to hold captured variables.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Be careful! Simple is almost always better than clever.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll see more variables being captured when we look at C# 3 and its lambda expressions, but for now you may be relieved to hear that we’ve finished our rundown of the new C# 2 delegate features.</font></p>
<p><a name="bookmark167"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1813"></a>5.6 Summary</font></p>
<p><a name="bookmark1814"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 2 has radically changed the ways in which delegates can be created, and in doing so it’s opened up the framework to a more functional style of programming. There are more methods in .NET 2.0 that take delegates as parameters than there were in .NET 1.0/1.1, and this trend continues in .NET 3.5. The List&lt;T&gt; type is the best example of this, and is a good test-bed for checking your skills at using anonymous methods and captured variables. Programming in this way requires a slightly different mind-set—you must be able to take a step back and consider what the ultimate aim is, and</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">whether it’s best expressed in the traditional C# manner, or whether a functional approach makes things clearer.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All the changes to delegate handling are useful, but they do add c<a name="bookmark1815"></a>omplexity to the language, particularly when it comes to captured variables. Cl<a name="bookmark1816"></a>osures are always tricky in terms of determining exactly how the available environment is shared, and C# is no different in this respect. The reason the concept has lasted so long, though, is that it can make code simpler to understand and more immediate. The balancing act between complexity and simplicity is always a difficult one, and it’s worth being cautious to start with. But over time you should expect to get better at working with captured variables and understanding how they b<a name="bookmark1817"></a>ehave. LINQ encourages their use even further, and a great deal of modern, idiomatic C# code uses closures frequently.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Anonymous methods aren’t the only change in C# 2 that involves the compiler creating extra types behind the scenes and doing devious things with variables that appear to be local. We’ll see a lot more of this in our next chapter, where the compiler effectively builds a whole state machine for us in order to make it easier for the developer to implement iterators.</font></p>
<p><a name="bookmark8"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark1818"></a><a name="bookmark1819"></a>Implementing iterators the easy way</font></p>
<p><a name="bookmark1820"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Implementing iterators in C# 1</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Iterator blocks in C# 2</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Sample iterator usage</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Iterators as coroutines</font></p>
<p><a name="bookmark1821"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1822"></a><a name="bookmark1823"></a>The iterator pattern is an example of a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">behavioral pattern</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—a design pattern that simplifies communication between objects. It’s one of the simplest patterns to understand, and inc<a name="bookmark1824"></a>redibly easy to use. In essence, it allows you to access all the elements in a sequence of items without caring about what kind of sequence it is—an array, a list,<a name="bookmark1825"></a> a linked list, or none of the above. This can be effective for building a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">data pipeline,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> where an item of data enters the pipeline and goes through a number of different transformations or filters before coming out at the other end. Indeed, this is one of the core patterns of LINQ, as we’ll see in part 3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In .NE<a name="bookmark1826"></a>T, the iterator pattern is encapsulated by the IEnumerator and IEnumerable inte<a name="bookmark1827"></a>rfaces and their generic <a name="bookmark1828"></a>equivalents. (The naming is unfortu-nate—the pattern is normally called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">iteration</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to avoid getting confused with other</font></p>
<p><a name="bookmark1829"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1830"></a><a name="bookmark1831"></a>meanings of the word </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">enumeration</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. I’ve used </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">iterator</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">iterable</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> throughout this chapter.) If a type i<a name="bookmark1832"></a>mplements IEnumerable, that means it can be iterated over; calling the GetEnumerator method will return the IEnumerator implementation, <a name="bookmark1833"></a>which is the iterator itself. You can think of the iterator as being like a database cursor: a position within the sequence. The iterator can only move forward within the sequence, and there can be many iterators operating on the same sequence at the same time.</font></p>
<p><a name="bookmark1834"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">As a language, C# 1 has built-in support for consuming iterators using the foreach statement. This makes it easy to iterate over collections—easier than using a straight for loop—and is nicely expressive. The foreach statement c<a name="bookmark1835"></a>ompiles down to calls to the GetEnumerator and MoveNext methods and t<a name="bookmark1836"></a>he Current property, with support for disposing the iterator afterward if IDisposable has been implemented. It’s a small but useful piece of syntactic sugar.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In C# 1, though, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">implementing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> an iterator is a relatively difficult task. C# 2 makes this much simpler, which can sometimes lead to the iterator pattern being worth implementing in cases where otherwise it would’ve caused more work than it saved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this chapter we’ll look at what’s required to implement an iterator and the support given by C# 2. After we’ve looked at the syntax in detail, we’ll examine a few examples from the real world, including an exciting (if slightly off-the-wall) use of the iteration syntax in a concurrency library from Microsoft. I’ve held off on providing the examples until the end of the description, because there isn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> much to learn—and the examples will be a lot clearer when you can understand what the code is doing. If you really want to read the examples first, they’re in sections 6.3 and 6.4.</font></p>
<p><a name="bookmark1837"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">If you just want a teaser, think about the last time you iterated over the lines in a file. <a name="bookmark1838"></a>Assuming you didn’t want to load the whole file in one go with File.ReadAll-Lines, you probably ended up using a slightly ugly while loop. Wouldn’t foreach have been nicer? If only there were some way we could lazily iterate over lines in a file as if they were just another collection...</font></p>
<p><a name="bookmark1839"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">As in other chapters, let’s start off by looking at what life was like before C# 2. We’ll implement an iterator the hard way.</font></p>
<p><a name="bookmark170"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1840"></a>6.1 C# 1: the pain of handwritten iterators</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve already seen one example of an iterator implementation in section 3.4.3 when we looked at what happens when you iterate over a generic collection. In some ways that was harder than a real C# 1 iterator implementation would’ve been, because we implemented the generic interfaces as well—but it was also easier in other ways because it wasn’t actually iterating over anything useful.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To put the C# 2 features into context, we’ll first implement an iterator that’s about as simple as it can be while still providing real functionality. Suppose we wanted a new type of collection based on a circular buffer. We’ll implement IEnumerable so that users of our new class can easily iterate over all the values in the collection. We’ll ignore the guts of the collection here and just concentrate on the iteration side. Our collection will store its values in an array (object[]—no generics here!), and the</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">collection will have the interesting feature that you can set its logical starting point— so if the array had five elements, you could set the start point to 2, and expect eleme<a name="bookmark1841"></a>nts 2, 3, 4, 0, and then 1 to be returned. Although I won’t show the full circular buffer code here, it’s in the downloadable code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To make the class easy to demonstrate, we’ll provide both the values and the starting point in the constructor. So, we should be able to write code such as listing 6.1 in order to iterate over the collection.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 6.1 Code using the (as yet unimplemented) new collection type</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object[] values = {&quot;a&quot;, &nbsp;&nbsp;&nbsp;&quot;b&quot;, &nbsp;&nbsp;&nbsp;&quot;c&quot;, &nbsp;&nbsp;&nbsp;&quot;d&quot;, &nbsp;&nbsp;&nbsp;&quot;e&quot;};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IterationSample collection = new IterationSample(values, 3); foreach (object x in collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (x);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Running listing 6.1 should (eventually) produce output of “d”, “e”, “a”, “b”, and finally “c” because we specified a starting point of 3. Now that we know what we need to achieve, let’s look at the skeleton of the class as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 6.2 Skeleton of the new collection type, with no iterator implementation</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System.Collections;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class IterationSample : IEnumerable</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object[] values; int startingPoint;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IterationSample(object[] values, int startingPoint)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">this.values = values; this.startingPoint = startingPoint;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IEnumerator GetEnumerator()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new NotImplementedException();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1842"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1843"></a>As you can see, we haven’t implemented GetEnumerator yet, but the rest of the code is ready to go. So, how do we go about writing the GetEnumerator code? The first thing to understand is that we need to store some </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">state</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> somewhere. One important aspect of the iterator pattern is that we don’t return all of the data in one go—the client just asks for one element at a time. That means we need to keep track of how far we’ve already gone through our array. The stateful nature of iterators will be important when we look at what the C# 2 compiler does for us, so keep a close eye on the state required in this example.</font></p>
<p><a name="bookmark1844"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1845"></a><a name="bookmark1846"></a>So, where should this state live? Suppose we <a name="bookmark1847"></a>tried to put it in the IterationSample class itself, making that implement IEnumerator as well as IEnumerable. At first sight, this looks like a good plan—after all, the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">data</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is in the right place, including the starting point. Our GetEnumerator method could just return this. But there’s a big problem with this approach—if GetEnumerator is called several times, several independent iterators should be returned. For instance, we should be able to use two foreach statements, one inside another, to get all possible pairs of values. The two iterators need to be independent—which suggests we need to create a new object each time GetEnumerator is called. We </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> still implement the functionality directly within IterationSample, but then we’d have a class that didn’t have a single clear responsibil-ity—it would be pretty confusing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Instead, let’s create an<a name="bookmark1848"></a>other class to implement the iterator itself. <a name="bookmark1849"></a>We’ll use<a name="bookmark1850"></a> the fact that in C# a nested type has access to its enclosing type’s private members, which means we can just store a reference to the parent IterationSample, along with the state of how far we’ve gone so far. This is shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 6.3 Nested class implementing the collection’s iterator</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class IterationSampleIterator : IEnumerator</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IterationSample parent; int position;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">internal IterationSampleIterator(IterationSample parent)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">this.parent = parent; position = -1;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public bool MoveNext()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (position != parent.values.Length)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">position++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return position &lt;&nbsp;parent.values.Length;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public object Current</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (position == -1 ||</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">position == parent.values.Length)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new InvalidOperationException();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int index = position + parent.startingPoint; index = index % parent.values.Length; return parent.values[index];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void Reset()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">position = -1;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">What a lot of code to perform such a simple task! We remember the original collection of values we’re iterating over O and keep track of where we’d be in a simple zero-based array ©. To return an element, we offset that index by the starting point ©. In keeping with the interface, we consider our iterator to start logically before the first element ©, so the client will have to call MoveNext before using the Current property for the first time. The conditional increment at © makes the test at © simple and correct even if MoveNext is called again after it’s first reported that no more data is available. To reset the iterator, we set our logical position back to before the first element ©.</font></p>
<p><a name="bookmark1851"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Most of the logic involved is fairly straightforward, although there’s lots of room for off-by-one errors; my first implementation failed its unit tests for precisely that reason. The good news is that it works, and that we only need to implement IEnumerable in IterationSample to complete the example:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IEnumerator GetEnumerator()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new IterationSampleIterator(this);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I won’t reproduce the combined code here, but it’s available on the book’s website, including listing 6.1, which now has the expected output.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth bearing in mind that this is a relatively simple example—there’s not a lot of state to keep track of, and no attempt to check whether the collection has changed between iterations. With such a large burden involved to implement a simple iterator, we shouldn’t be surprised at the rarity of implementing the pattern in C# 1. Developers were generally happy to use foreach on the collections provided by the framework, but more direct (and collection-specific) access when it came to their own collections.</font></p>
<p><a name="bookmark1852"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">So, about 40 lines of code to implement the iterator in C# 1. Let’s see if C# 2 can do any better.</font></p>
<p><a name="bookmark172"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1853"></a>6.2 C# 2: simple iterators with yield statements</font></p>
<p><a name="bookmark1854"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve always been the kind of person who likes to stay up until midnight on Christmas Eve in order to open a present as soon as Christmas Day arrives. In the same way, I’d find it almost impossible to wait any significant amount of time before showing you how neat the solution is in C# 2.</font></p>
<p><a name="bookmark173"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1855"></a><a name="bookmark1856"></a>6.2.1 Introducing iterator blocks and yield return</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This chapter wouldn’t exist if C# 2 didn’t have a powerful feature that cuts down the amount of code you have to write to implement iterators. In some other topics the amount of code has only been reduced slightly, or has just made something more elegant. In this case, though, the amount of code required is r<a name="bookmark1857"></a>educed </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">massively</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Listing 6.4 shows the complete implementation of the GetEnumerator method in C# 2.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 6.4 Iterating through the sample collection with C# 2 and yield return</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IEnumerator GetEnumerator()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">for (int index = 0; index &lt;&nbsp;values.Length; index++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">yield return values[(index + startingPoint) % values.Length];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Four lines of implementation, two of which are just braces. To be clear, that replaces the whole of the IterationSampleIterator class. Completely. At least in the source code... Later on we’ll see what the compiler has done behind our back, and some of the quirks of the implementation it’s provided, but for the moment let’s look at the source code we’ve used.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The method looks perfectly normal until you see the use of yield return. That’s what tells the <a name="bookmark1858"></a>C# compiler that this isn’t a normal method but one implemented with an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">iterator block.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> The method is declared to return an IEnumerator, and you can only use iterator blocks to implement methods<sup><a name="footnote44"></a><a href="#bookmark1859">44</a></sup> that have a retur<a name="bookmark1860"></a>n type of IEnumerable, IEnumerator, or one of the generic equivalents. The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">yield type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the iterator block is object if the declared return type of the method is a nongeneric interface, or the type argument of the generic interface otherwise. For instance, a method declared to return IEnumerable&lt;string&gt; woul<a name="bookmark1861"></a>d have a yield type of string.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">No normal return statements are allowed within iterator blocks—only yield return. All yield return statements in the block must try to return a value compatible with the yield type of the block. To use our previous example, you couldn’t write yield return 1; in a method declared to return IEnumerable&lt;string&gt;.</font></p>
<p><a name="bookmark1862"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1863"></a>RESTRICTIONS ON YIELD RETURN There are a few further restrictions on yield statements. You can’t use yield return inside a try block if it has any catch blocks, and you can’t use either yield return or yield break (which<a name="bookmark1864"></a> we’ll come to shortly) in a finally block. That doesn’t mean you can’t use try/ catch or try/finally blocks inside iterators—itjust restricts what you can do in them.<sup><a name="footnote45"></a><a href="#bookmark1865">45</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The big idea that you need to get your head around when it comes t<a name="bookmark1866"></a>o iterator bl<a name="bookmark1867"></a>ocks is that although you’ve written a method that looks like it exec<a name="bookmark1868"></a>utes sequentially, what you’ve actually asked the compiler to do is create a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">state machine</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for you. This is necessary for exactly the same reason we had to put so much effort into implementing the iterator in C# 1—the caller only wants to see one element at a time, so we need to keep track of what we were doing when we last returned a value.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When the compiler encounters an iterator block, it creates a nested type for the state machine. This type remembers exactly where we are within the block and the values of local variables (including parameters). The generated class is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">somewhat</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> similar to the longhand implementation we wrote earlier, in that it keeps all the necessary state as instance variables. Let’s think about what this state machine has to do in order to implement the iterator:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It has to have some <a name="bookmark1869"></a>initial state.</font></p>
<p><a name="bookmark1870"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Whenever MoveNext is called, it has to execute code from the GetEnumerator method until we’re ready to provide the next value (in other words, until we hit a yield return st<a name="bookmark1871"></a>atement).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;When the Current property is used, it has to return the last value we yielded.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It has to know when we’ve finished yielding values so that MoveNext can return false.</font></p>
<p><a name="bookmark1872"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The second point in this list is the tricky one, because it always needs to restart <a name="bookmark1873"></a>the code from the point it had previously reached. Keeping track of the local variables (as they <a name="bookmark1874"></a>appear in the method) isn’t too hard—they’re just represented by instance variables in the state machine. The restarting aspect is trickier, but the good news is that unless you’re writing a C# compiler yourself, you needn’t care about how it’s achieved: the result from a black box point of view is that it just works. You can write perfectly normal code within the iterator block and the compiler is responsible for making sure that the flow of execution is exactly as it would be in any other method; the difference is that a yield return stateme<a name="bookmark1875"></a>nt appears to only temporarily exit the method—you could think of it as being paused, effectively.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Next we’ll examine the flow of execution in more detail, and in a more visual way.</font></p>
<p><a name="bookmark174"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1876"></a>6.2.2 &nbsp;&nbsp;&nbsp;Visualizing an iterator’s workflow</font></p>
<p><a name="bookmark1877"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It may help to think about how iterators execute in terms of a sequence diagram (see <a href="http://mng.bz/jH7I">http://mng.bz/j</a>H7l). Rather than drawing the diagram by hand, listing 6.5 prints it out for us. The iterator itself just provides a sequence of numbers (0, 1, 2, -1) and then finishes. The interesting part isn’t the numbers provided so much as the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">flow</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 6.5 Showing the sequence of calls between an iterator and its caller</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static readonly string Padding = new string(' ', 30); static IEnumerable&lt;int&gt; CreateEnumerable()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}Start of CreateEnumerable()&quot;, Padding); for (int i=0; i &lt;&nbsp;3; i++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}About to yield {1}&quot;, Padding, i); yield return i;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}After yield&quot;, Padding);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}Yielding final value&quot;, Padding); yield return -1;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}End of CreateEnumerable()&quot;, Padding);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;int&gt; iterable = CreateEnumerable();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerator&lt;int&gt; iterator = iterable.GetEnumerator(); Console.WriteLine(&quot;Starting to iterate&quot;); while (true)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Calling MoveNext()...&quot;); bool result = iterator.MoveNext();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;... MoveNext result={0}&quot;, result); if (!result)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">break;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Fetching Current...&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;... Current result={0}&quot;, iterator.Current);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 6.5 isn’t pretty, particularly around<a name="bookmark1878"></a> the iteration side of things. In the normal course of events we’d just use a foreach loop, but to show exactly </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">what's</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> happening </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">when,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> I had to break the use of the iterator out into pieces. This code broadly does what foreach does, although foreach also calls Dispose at the end. This is important for iterator blocks, as we’ll explore shortly. As you can see, there’s no difference in the syntax within the iterator method even though this time we’re returning IEnumerable&lt;int&gt; instead of IEnumerator&lt;int&gt;. Usually you’ll only want to return IEnumerator&lt;T&gt; in order to implement IEnumerable&lt;T&gt;; if you want to just yield a sequence from a method, return IEnumerable&lt;T&gt; instead.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here’s the output from listing 6.5:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Starting to iterate Calling MoveNext()...</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Start of CreateEnumerable()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">About to yield 0</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">... MoveNext result=True Fetching Current...</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">... Current result=0 Calling MoveNext()...</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">After yield About to yield 1</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">... MoveNext result=True Fetching Current...</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">... Current result=1 Calling MoveNext()...</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">After yield About to yield 2</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">... MoveNext result=True Fetching Current...</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">... Current result=2 Calling MoveNext()...</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">After yield</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Yielding final value</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">... MoveNext result=True Fetching Current...</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">... Current result=-1 Calling MoveNext()...</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">End of CreateEnumerable()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">... MoveNext result=False</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are various important things to note from this output:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;None of the code we wrote in CreateEnumerable is called until the first call to MoveNext.</font></p>
<p><a name="bookmark1879"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1880"></a>■ &nbsp;&nbsp;&nbsp;Calling MoveNext is where all the work gets done; fetching Current doesn’t run any of our code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The code stops executing at yield return and picks up again just afterward at the next call to MoveNext.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;We can have multiple yield return statements in different places in the method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The code doesn’t end at the last yield return—instead, the call to MoveNext that causes us to reach the end of the method is the one that returns false.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first point is particularly important, because it means you can’t use an iterator block for any code that has<a name="bookmark1881"></a> to be executed immediately when the method is called— such as argument validation. If you put normal checking into a method implemented with an iterator block, it won’t behave nicely. You’ll almost certainly fall foul of this at some point—it’s an extremely common error, and hard to understand until you think about what the iterator block is doing. We’ll see the solution to the problem in section</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">6.3.7.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two things we haven’t seen yet—an alternative way of halting the iteration, and how finally blocks work in this somewhat odd form of execution. Let’s take a look at them now.</font></p>
<p><a name="bookmark175"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1882"></a>6.2.3 Advanced iterator execution flow</font></p>
<p><a name="bookmark1883"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In normal methods, the return statement has two effects. First, it supplies the valu<a name="bookmark1884"></a>e the caller sees as the return value. Second, it terminates the execution of the method, executing any appropriate finally blocks on the way out. We’ve seen that the yield return statement temporarily exits the method, but only until MoveNext is called again, and we haven’t examined the behavior of finally blocks at all yet. How can we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">really</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> stop the method, and what happens to all of those finally blocks? We’ll start with a fairly simple construct—the yield break statement.</font></p>
<p><a name="bookmark1885"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">ENDING AN ITERATOR WITH YIELD BREAK</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can always find a way to make a method have a single exit point, and many people work hard to achieve this.<sup><a name="footnote46"></a><a href="#bookmark1886">46</a></sup> The same techniques can be applied in iterator blocks. But should you wish to have an early out, the yield break statement is your friend. This effectively terminates the iterator, making the current call to MoveNext return false.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 6.6 demonstrates this by counting up to 100 but stopp<a name="bookmark1887"></a>ing early if it runs out of time. This also demonstrates the use of a method parameter in an iterator block,<sup><a name="footnote47"></a><a href="#bookmark1888">47</a></sup> and proves that the name of the method is irrelevant.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 6.6 Demonstration of yield break</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">static IEnumerable&lt;int&gt; CountWithTimeLimit(DateTime limit)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">{</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">for (int i = 1; i &lt;= 100; i++)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">{</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">if (DateTime.Now &gt;= limit)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">{</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">yield break;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">yield return i;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">DateTime stop = DateTime.Now.AddSeconds(2); foreach (int i in CountWithTimeLimit(stop))</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">{</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Console.WriteLine(&quot;Received {0}&quot;, i);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Thread.Sleep(300);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Typically when you run listing 6.6, you’ll see about seven lines of output. The foreach loop terminates perfectly normally—as far as it’s concerned, the iterator has just run out of elements to iterate over. The yield break statement behaves much like a return statement in a normal method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far, so simple. There’s one last aspect of execution flow to explore: how and when finally blocks are executed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">EXECUTION OF FINALLY BLOCKS</font></p>
<p><a name="bookmark1889"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1890"></a>We’re used to finally blocks executing whenever we leave the relevant scope. Iterator blocks don’t behave quite like normal methods, though—as we’ve seen, a yield return statement effectively pauses the method rather than exiting it. Following that logic, we wouldn’t expect any finally blocks to be executed at that point—and they aren’t.</font></p>
<p><a name="bookmark1891"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1892"></a>But appropriate finally blocks </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> executed when a yield break statement is hit, just as you’d expect them to be when returning from a normal me<a name="bookmark1893"></a>thod.<sup><a name="footnote48"></a><a href="#bookmark1894">48</a></sup> The most common use of finally in <a name="bookmark1895"></a>an iterator block is to dispose of resources, typically with a convenient using statement. We’ll see a real-world example of this in section 6.3.6, but for now we’re just trying to see how and when finally blocks are executed. The</font></p><img src="images/16.png"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerable&lt;int&gt; CountWithTimeLimit(DateTime limit) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">try</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">for (int i = 1; i &lt;= 100; i++)</font></p><div>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">following listing shows this in action—it’s the same code as listing 6.6, but with a finally block. The changes are shown in bold.</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (DateTime.Now &gt;= limit)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">yield break;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">yield return i;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">finally</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Stopping!&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime stop = DateTime.Now.AddSeconds(2); foreach (int i in CountWithTimeLimit(stop))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Received {0}&quot;, i);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Thread.Sleep(300);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The finally block in listing 6.7 is executed whether the iterator block finishes by counting to 100, or whether it has to stop due to the time limit being reached. (It would also execute if the code threw an exception.) But there are other ways we might try to avoid the finally block from being called... Let’s try to be sneaky.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen that code in the iterator block is only executed when MoveNext is called. So what happens if we never call MoveNext? Or if we call it a few times and then stop? Let’s consider changing the calling part of listing 6.7 to this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime stop = DateTime.Now.AddSeconds(2); foreach (int i in CountWithTimeLimit(stop))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Received {0}&quot;, i); if (i &gt;&nbsp;3)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Returning&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Thread.Sleep(300);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here we’re not stopping early in the iterator code—we’re stopping early in the code </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">using</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the iterator. The output is perhaps surprising:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Received 1 Received 2 Received 3 Received 4 Returning Stopping!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here, code is being executed after the return statement in the foreach loop. That doesn’t normally happen unless a finally block is involved—and in this case there are two! We already know about the finally block in the iterator method, but the question is w<a name="bookmark1896"></a>hat’s causing it to be executed. I gave a hint to this earlier on—foreach calls Dispose on the iterator returned by GetEnumer<a name="bookmark1897"></a>ator, in its own finally block (just like the using statement). When you call Dispose on an iterator created with an iterator block before it’s finished iterating, the state machine executes any finally blocks that are in the scope of where the code is currently “paused.” That’s a complicated and somewhat d<a name="bookmark1898"></a>etailed explanation, but the result is simpler to express: so long as callers use a foreach loop, finally works within iterator blocks in the way you want it to.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We can prove easily that it’s the call to Dispose that triggers this by using the iterator manually:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime stop = DateTime.Now.AddSeconds(2);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;int&gt; iterable = CountWithTimeLimit(stop);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerator&lt;int&gt; iterator = iterable.GetEnumerator();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">iterator.MoveNext();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Received {0}&quot;, iterator.Current); iterator.MoveNext();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Received {0}&quot;, iterator.Current);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This time the stopping line is never printed. If you add a call to Dispose explicitly, you’ll see the extra line in the output again. It’s relatively rare that you’ll want to terminate an iterator before it’s finished, and it’s relatively rare that you’ll be iterating manually instead of using foreach, but if you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, remember to wrap the iterator in a using statement.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve now covered most of the behavior of iterator blocks, but before we end this section it’s worth considering a few oddities to do with the current Microsoft implementation.</font></p>
<p><a name="bookmark176"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1899"></a><a name="bookmark1900"></a>6.2.4 Quirks in the implementation</font></p>
<p><a name="bookmark1901"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1902"></a>If you compile iterator <a name="bookmark1903"></a>blocks with t<a name="bookmark1904"></a>he Microsoft C# 2 compiler and look at the resulting IL in either ildasm or Reflector, you’ll see the nested type that the compiler has generated for us behind the scenes. In my case when compiling our (evolved) first</font></p>
<p><a name="bookmark1905"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">iterator block example, it was called IterationSample.&lt;GetEnumerator&gt;d__0 (where</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">the angle brackets make it an unspeakable name—nothing to do with generics). I won’t go through exactly what’s generated in detail here, but it’s worth looking at it in Reflector to get a feel for what’s going on, preferably with the language specification <a name="bookmark1906"></a>next to you, open at section 10.14: the specification defines different states the type can be in, and this description ma<a name="bookmark1907"></a>kes the generated code easier to follow. T<a name="bookmark1908"></a>he bulk of the work is performed in MoveNext, which is generally a big switch statement.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Fortunately, as developers we don’t need to care much about the hoops the compiler has to jump through. But there are a few quirks about the implementation that are worth knowing about:</font></p>
<p><a name="bookmark1909"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Before MoveNext is called for the first t<a name="bookmark1910"></a>ime, the Current property will always return the default value for the yield type of the iterator.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;After MoveNext has returned false, the Current property will always return the final <a name="bookmark1911"></a>value yielded.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Reset always throws an exception instead of resetting like our manual implementation did. This is required behavior, laid down in the specification.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The nested <a name="bookmark1912"></a>class always implements both the generic and<a name="bookmark1913"></a> nongeneric form of IEnumerator (and the generic and nongeneric IEnumerable where appropriate).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Failing to implement Reset is reasonable—the compiler can’t work out what you’d need to do in order to reset the iterator, or even whether it’s feasible. Arguably Reset shouldn’t have been in the IEnumerator interface to start with, and I can’t remember the last time I called it. Many collections don’t support it, so callers can’t generally rely on it anyway.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Implementing extra interfaces does no harm either. It’s interesting that if your method returns IEnume<a name="bookmark1914"></a>rable, you end up with one class implementing five interfaces (including IDisposable). The language specification explains it in detail, but the upshot is that as a developer you don’t need to worry. The fact that it implements both IEnumerable and IEnumerator is slightly unusual—the compiler goes to some pains to make sure that the behavior is correct whatever you do with it, but also manages to create a single instance of the nested type in the common case where you just iterate through the collection in the same thread that created it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The behavior of Current is odd—in particular, keeping hold of <a name="bookmark1915"></a>the last item after supposedly moving off it could keep it from being garbage collected. It’s possible that this may be fixed in a later release of the C# compiler, though it’s unlikely, as it could break existing code.<sup><a name="footnote49"></a><a href="#bookmark1916">49</a></sup> Strictly speaking, it’s correct from the point of view of the C# 2 language specification—the behavior of the Current property is undefined in this situation. It’d be nicer, though, if it implemented the property in the way that the framework documentation suggests, throwing exceptions at appropriate ti<a name="bookmark1917"></a>mes.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, there are a few tiny drawbacks from using the autogenerated code, but </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">sensible </font><font style="font-size:x-small;font-family:Times New Roman, serif;">callers won’t have any problems—and let’s face it, we’ve saved a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lot</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of code in order to come up with the implementation. This means it makes sense to use iterators more widely than we might’ve done in C# 1. Our next section provides some sample code so you can check your understanding of iterator blocks and see how they’re useful in real life rather than in theoretical scenarios.</font></p>
<p><a name="bookmark178"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;"><a name="bookmark1918"></a><a name="bookmark1919"></a>6.3 </font><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Real-life iterator examples</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Have you ever written some code that’s really simple in itself but makes your project </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">much</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> neater? It happens to me every so often, and it usually makes me happier than it probably ought to—enough to get strange looks from colleagues, anyway. That sort of childlike delight is particularly strong when it comes to using a new language feature in a way that’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">clearly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> nicer and not just doing it for the sake of playing with new toys.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even after using iterators for a few year<a name="bookmark1920"></a>s now, I still come across situations where a solution presents itself using iterator blocks, and the resulting code is brief, clean, and easy to understand. In this section I’ll share three such scenarios with you.</font></p>
<p><a name="bookmark179"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1921"></a>6.3.1 Iterating over the dates in a timetable</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">While working on a project involving timetables, I came across a few loops, all of which started like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">for (DateTime day = timetable.StartDate; day &lt;= timetable.EndDate; day = day.AddDays(1))</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I was working on this area of code a lot, and I always hated that loop, but it was only when I was reading the code out loud to another developer as pseudo-code that I realized I was missing a trick. I said something like, “For each day within the timetable.” In retrospect, it’s obvious that what I really wanted was a foreach loop. (This may have been obvious to you from the start—apologies if this is the case. Fortunately I can’t see you looking smug.) The loop is much nicer when rewritten as</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (DateTime day in timetable.DateRange)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In C# 1, I might’ve looked at that as a fond dream but not bothered implementing it: we’ve seen how messy it is to implement an iterator by hand, and the end result only made a few for loops neater in this case. In C# 2, though, it was easy. Within the class representing the timetable, I simply added a property:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IEnumerable&lt;DateTime&gt; DateRange {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">for (DateTime day = StartDate; day &lt;= EndDate; day = day.AddDays(1))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">yield return day;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This has just moved the original loop into the timetable class, but that’s okay—it’s much nicer for it to be encapsulated there, in a property that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">just</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> loops through the days, yielding them one at a time, than to be in business code that was dealing with those days. If I ever wanted to make it more complex (skipping weekends and public holidays, for instance), I could do it in one place and reap the rewards everywhere.</font></p>
<p><a name="bookmark1922"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1923"></a>This one small change made a massive improvement to the readability of the code base. As it happens, I stopped refactoring at that point in the commercial code. I did </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">think</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> about introducing a Range&lt;T&gt; type to represent a general-purpose range, but as I only needed it in this one situation, it didn’t make sense to expend a<a name="bookmark1924"></a>ny more effort on the problem. It turns out that was a wise move. In t<a name="bookmark1925"></a>he first edition of this book, I created just such a type—but it had some shortcomings that were har<a name="bookmark1926"></a>d to address in a book-friendly manner. I redesigned it significantly for my utility library, but I still have a few misgivings. Types lik<a name="bookmark1927"></a>e this often sound simpler than they really are, and soon you end up with a corner case to be handled at every turn. The details of the difficulties I encountered don’t really belong in this book—they’re more points about general design than C#—but they’re interesting in their own right, so I’ve written them up as an article on the book’s website (see <a href="http://mng.bz/GAmS">http://mng.bz/</a>GAmS).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The next example is one of my favourites—it demonstrates everything I love about iterator blocks.</font></p>
<p><a name="bookmark180"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1928"></a><a name="bookmark1929"></a><a name="bookmark1930"></a>6.3.2 Iterating over lines in a file</font></p>
<p><a name="bookmark1931"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I mentioned this in the introduction to the chapter because it’s such a common task. I dread to think how often I’ve written code like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using (TextReader reader = File.OpenText(filename))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string line;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">while ((line = reader.ReadLine()) != null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Do something with line</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1932"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We have four separate concepts here:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;How to obtain a TextReader</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Managing the lifetime of the TextReader</font></p>
<p><a name="bookmark1933"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Iterating over the lines returned by TextReader.ReadLine</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Doing something with each of those lines</font></p>
<p><a name="bookmark1934"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Only the firs<a name="bookmark1935"></a>t and last of these a<a name="bookmark1936"></a>re generally specific to the situation—the lifetime management and the mechanism for iterating are just boilerplate code. (At<a name="bookmark1937"></a> least the lifetime management is simple in C#. Thank goodness for u<a name="bookmark1938"></a>sing statements !) There are two ways we could improve things. We </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use a delegate—we could write a utility method that would take a reader and a delegate as parameters, call the delegate for each line in<a name="bookmark1939"></a> the file, and <a name="bookmark1940"></a>close the reader at the end. That’s often used as an example of closures and delegates—but the<a name="bookmark1941"></a>re’s an alternative that I find <a name="bookmark1942"></a>more elegant, and which fits in much better with LINQ. Instead of passing our logic into a method as a delegate, we can use an iterator to return a single line at a time from the file, so we can use the normal foreach loop.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can achiev<a name="bookmark1943"></a>e this using a whole t<a name="bookmark1944"></a>ype implementing IEnumerable&lt;string&gt; (I have a LineReader class in my MiscUtil library for this purpose) but a standalone method in another class will work fine, too. It’s really simple, as the next listing proves.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 6.8 Looping over the lines in a file using an iterator block</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerable&lt;string&gt; ReadLines(string filename)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using (TextReader reader = File.OpenText(filename))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string line;</font></p>
<p><a name="bookmark1945"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">while ((line = reader.ReadLine()) != null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">yield return line;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (string line in ReadLines(&quot;test.txt&quot;))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(line);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The body of the method is pretty exactly what we had before—except that what we’re doing with the line is yielding it to the caller when it iterates over the collection. As before, we open the file, read a line at a time, and then close the reader when we've finished... although the concept of “when we’ve finished” is more interesting in this case than with a using statement in a normal method, where the flow control is more obvious.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is why it’s important that the foreach loop dispose of the iterator—because that’s what makes sure the reader gets cleaned up. The <a name="bookmark1946"></a>using statement in the iterator method is acting as a try/finally block; <a name="bookmark1947"></a>that finally block will execute if </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">either</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> we get to the end of the file </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">or</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> we call Dispose on the IEnumerator&lt;string&gt; when we’re part of the way through. It’d be possible for calling code to abuse the IEnumerator &lt;string&gt; returned by ReadLines(...).GetEnum<a name="bookmark1948"></a>erator() and end up with a resource leak, but that’s usually the case with IDisposable—if you don’t call Dispose, you may leak resources. It’s rarely a problem though, as foreach does the right thing. It’s important to be aware of this potential abuse—if you relied upon some sort of try/ finally block in an iterator <a name="bookmark1949"></a>to grant some permission and then remove it again later, that really </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">would</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be a security <a name="bookmark1950"></a>hole.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This method encapsulates the first three of the four concepts I listed earlier—but it's a bit restrictive. It’s reasonable to lump together the lifetime management and iteration aspects, but what if <a name="bookmark1951"></a>we want to read t<a name="bookmark1952"></a>ext from a network stream instead? Or if we want to use an encoding other than UTF-8? We need to put the first part back in control of the caller. The most<a name="bookmark1953"></a> obvious approach would be to change the method signature to accept a TextReader, like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerable&lt;string&gt; ReadLines(TextReader reader)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is a bad idea, though. We want to take ownership of the reader so that we can clean it up conveniently for the caller—but that means we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to clean it up, so long as the caller uses us sensibly. The problem is, if something happens before the first call to MoveNext (), we’re never going to have any chance to clean up: none of our code will run. The IEnumerable&lt;string&gt; itself isn’t disposable, and yet it would’ve stored this piece of state which required disposal. Another problem would occur if Get-Enumerator() were called twice: that ought to generate two independent iterators, but they’d both be using the same reader. We could mitigate this somewhat by changing the return type to IEnumerator&lt;string&gt;, but that would mean the result couldn’t be used in a foreach loop, and we still wouldn’t get to run any cleanup code if we never got as far as the first MoveNext () call. Fortunately, there’s a way around this.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just as our code doesn’t get to run immediately, we don’t need the reader immediately. Wh<a name="bookmark1954"></a>at we need is a way of getting the reader when we need it. We could use an interface to represent the idea of “I can<a name="bookmark1955"></a> provide a TextReader when you want one,” but the idea of a single method interface should usually make you reach for a delegate. We’re going to <a name="bookmark1956"></a>cheat slightly, by introducing a delegate that’s part of .NET 3.5. It’s actually overloaded by different numbers of type parameters, but we only need one:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public delegate TResult Func&lt;TResult&gt;()</font></p>
<p><a name="bookmark1957"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see, this delegate has no parameters, but r<a name="bookmark1958"></a>eturns a result of the same type as the type parameter. It’s a classic provider or factory signature. In this case, we want to get a TextReader, so we’ll use Func&lt;TextReader&gt;. The changes to the method are simple:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerable&lt;string&gt; ReadLines(Func&lt;TextReader&gt; provider)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using (TextReader reader = provider())</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string line;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">while ((line = reader.ReadLine()) != null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">yield return line;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1959"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now the resource is only acquired j<a name="bookmark1960"></a>ust before we actually need it—and by that point, we’re in the context of IDisposable <a name="bookmark1961"></a>so we can release the resource at the appropriate time. Furthermore, if GetEnumerator () is called multiple times on the returned value, each call will result in an independent Text<a name="bookmark1962"></a>Reader being created.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We can easily use anonymous methods to add overloads to open files, optionally specifying an encoding:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerable&lt;string&gt; ReadLines(string filename)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return ReadLines(filename, Encoding.UTF8);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerable&lt;string&gt; ReadLines(string filename, Encoding encoding)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return ReadLines(delegate<a name="bookmark1963"></a> {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new StreamReader(filename,encoding);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">});</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This single example uses generics, an anonymous method (which captures parameters), and an iterator block. All that’s missing is nullable value types and you’d have the full house of C# 2’s major features. I’ve used this code on a number of occasions, and it’s always much cleaner than the cumbersome code we started off with.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As a final example, let’s get a first taste of LINQ—even though we’ll only use C# 2.</font></p>
<p><a name="bookmark181"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1964"></a>6.3.3 Filtering items lazily using an iterator block and a predicate</font></p>
<p><a name="bookmark1965"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark1966"></a><a name="bookmark1967"></a>Even though we haven’t started to look at LINQ properly yet, I’m sure you have some idea of what it’s about: it allows you to query data in a simple and powerful way, across multiple data sources such as in-<a name="bookmark1968"></a>memory collections an<a name="bookmark1969"></a>d databases. C# 2 doesn’t have any of the language integration for query expressions, nor the lambda expressions and extension methods that can make it so concise, but we can still achieve some of the same effects.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One of the core featur<a name="bookmark1970"></a>es of LINQ is filtering with the Where<a name="bookmark1971"></a> method. You provide a collection and a predicate, and the result is a lazily evaluated query that’ll yield only the<a name="bookmark1972"></a> items in the collection that match the predicate. This is a little like List&lt;T&gt;. Find-All, but it’s lazy and works with any IEnumera<a name="bookmark1973"></a>ble&lt;T&gt;. One of the beautiful <a name="bookmark1974"></a>things about LINQ</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup><a name="footnote50"></a><a href="#bookmark1975">50</a></font><font style="font-size:small;font-family:Times New Roman, serif;"></sup> is that the cleverness is in the design. It’s quite simple to implement LINQ to Objects—as we’ll prove now, at least for the Where method. Ironically even though most of the language features that make LINQ shine are part of C# 3, these are almost all about how you can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">access</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> methods such as Where, rather than how they’re i<a name="bookmark1976"></a>mplemented. Listing 6.9 shows a full example, includi<a name="bookmark1977"></a>ng simple argument validation, and uses the filter to display all the using directives in the source file that contains the sample code itself.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 6.9 Implementing LINQ's Where method using iterator blocks</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static IEnumerable&lt;T&gt; Where&lt;T&gt;(IEnumerable&lt;T&gt; source,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Predicate&lt;T&gt; predicate)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (source == null || predicate == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new ArgumentNullException();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return WhereImpl(source, predicate);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static IEnumerable&lt;T&gt; WhereImpl&lt;T&gt;(IEnumerable&lt;T&gt; source,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Predicate&lt;T&gt; predicate)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (T item in source)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (predicate(item))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">yield return item;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;string&gt; lines = LineReader.ReadLines(&quot;../../FakeLinq.cs&quot;); Predicate&lt;string&gt; predicate = delegate(string line)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ return line.StartsWith(&quot;using&quot;); }; foreach (string line in Where(lines, predicate))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(line);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark1978"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see, we’ve split t<a name="bookmark1979"></a>he implementation up into two parts: argument validation, and the real business logic of filtering. This is slightly ugly, but entirely necessary for sensible error handling. Suppose we put everything in the same method—what would happen when we called Where&lt;string&gt;(null, null)? The answer is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">nothing...</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> or at least, the desired exception wouldn’t be thrown. This is due to the lazy semantics of iterator blocks: none of the code in the body of the method runs until the first call to MoveNext(), as we saw in section 6.2.2. Typically you want to check the preconditions to the method </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">eagerly</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—there’s no point in delaying the exception, and it just makes debugging harder. The standard workaround for this is to split the method in half, as we do in listing 6.9. First we check the arguments O in a normal method, and then call the method implemented using an iterator block to lazily process the data as and when it’s requested ©.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The iterator block itself is mind-numbingly straightforward: for each item in the original collection, we test the predicate O and yield the value if it matches. If it doesn’t match, we try the next item and so on until we find something that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> match, or we run out of items. It’s straightforward—but a C# 1 implementation would’ve been much harder to follow (and couldn’t have been generic, of course).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The final piece of code to demonstrate the method in action uses our previous example to provide the data—in this case, the source code of the implementation. The predicate simply tests a line to see whether it begins with “using”—it could contain far more complicated logic, of course. I’ve created separate variables for the data and the predicate just to make the formatting clearer, but it could all have been written inline. It’s important to note the principal difference between this examp<a name="bookmark1980"></a>le and the equivalen<a name="bookmark1981"></a>t that could’ve been achieved using Fi<a name="bookmark1982"></a>le.ReadAllLin<a name="bookmark1983"></a>es and Array.FindAll&lt;string&gt;: this implementation is entirely lazy and streaming. Only a single line from the source file is ever required in memory at a time. Of course, that wouldn’t matter in this particular case where the file is small—but if you imagine a multigigabyte log file, you can see the benefits of this approach.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I hope these examples have given you an inkling of why iterator blocks are so important—as well as perhaps a desire to hurry on and find out more about LINQ. Before that, I’d like to mess with your mind a bit, and introduce you to a thoroughly bizarre (but really neat) use of iterators.</font></p>
<p><a name="bookmark183"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark1984"></a><a name="bookmark1985"></a><a name="bookmark1986"></a>6.4 Pseudo-synchronous code with the Concurrency and Coordination Runtime</font></p>
<p><a name="bookmark1987"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Concurrency and Coordination Runtime (CCR)</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is a libra<a name="bookmark1988"></a>ry developed by Microsoft to offer an alte<a name="bookmark1989"></a>rnative way of writing asynchronous code that’s amenable to complex coordination. A<a name="bookmark1990"></a>t the time of this writing, it’s only available as part of the Microsoft Robotics St<a name="bookmark1991"></a>udio (see <a href="http://www.microsoft.com/robotics">http://www.microsoft.com/robotics</a>) or the Microsoft CCR and DSS Toolkit (see <a href="http://www.microsoft.com/ccrdss/">http://www.micro<a name="bookmark1992"></a>soft.com/ccrdss/</a>). Microsoft has been putting a lot of resources into concurrency in various projects, and the Parallel Extensions framework included in .NET 4 is probably the most important one for the majority of developers. But I wanted to use the CCR to show you how iterator blocks can change the whole execution model.<sup><a name="footnote51"></a><a href="#bookmark1993">51</a></sup> The sample code does actually work (against dummy services) but the ideas are more important than the details.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Suppose we’re writing a server that needs to handle lots of requests. As part of dealing with those requests, we need to first call a web service to fetch an authentication token, and<a name="bookmark1994"></a> then use that token to <a name="bookmark1995"></a>get data from two independent data sources (say a database and another web service). We then process that data and return the result. Each of the fetch stages could <a name="bookmark1996"></a>take a while—perhaps a few seconds. Normally we’d consider the simple synchronous route or the stock asynchronous approach. The synchronous version might look something like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">HoldingsValue ComputeTotalStockValue(string user, string password)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Token token = AuthService.Check(user, password);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Holdings stocks = DbService.GetStockHoldings(token);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StockRates rates = StockService.GetRates(token); return ProcessStocks(stocks, rates);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s easy to understand, but if each re<a name="bookmark1997"></a>quest takes two seconds, the whole operation will take six seconds and tie up a thread for the whole time it’s running. If we want to scale up to hundreds of thousands of requests running in parallel, we’re in trouble. Now let’s consider a fairly simple asynchronous v<a name="bookmark1998"></a>ersion, which avoids tying up a thread when nothing’s happening<sup><a name="footnote52"></a><a href="#bookmark1999">52</a></sup> and uses parallel calls where possible:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void StartComputingTotalStockValue(string user, string password)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">AuthService.BeginCheck(user, password, AfterAuthCheck, null);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void AfterAuthCheck(IAsyncResult result)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Token token = AuthService.EndCheck(result);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IAsyncResult holdingsAsync = DbService.BeginGetStockHoldings (token, null, null);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StockService.BeginGetRates(token, AfterGetRates, holdingsAsync);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void AfterGetRates(IAsyncResult result)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IAsyncResult holdingsAsync = (IAsyncResult)result.AsyncState;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StockRates rates = StockService.EndGetRates(result);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Holdings stocks = DbService.EndGetStockHoldings(holdingsAsync); OnRequestComplete(ProcessStocks(stocks, rates));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark2000"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This is much <a name="bookmark2001"></a>harder to read and understand—and that’s only a simple version! The coordination of the two parallel c<a name="bookmark2002"></a>alls is only achievable in a simple way because we don’t need to pass any other state around,<a name="bookmark2003"></a> and even so it’s not <a name="bookmark2004"></a>ideal. If the stock service call completes quickly, we’ll still block a thread pool thread waiting for the database call to complete. More importantly, it’s far from obvious what’s going on, because the code jumps between different methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">By now you may be asking yourself where iterators come into the picture. Well, the iterator blocks provided by C# 2 effectively allow you to pause current execution at certain points of the flow through the block, and then come back to the same place, with the same state. The clever folks desi<a name="bookmark2005"></a>gning the CCR realized that that’s exactly what’s needed for a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">continuation-passing style</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of coding. We need to tell the system that there are certain operations we need to perform—including starting other operations asynchronously—but that we’re then happy to wait until the asynchronous operations have finished before we continue. We do this <a name="bookmark2006"></a>by providing the CCR with an implementation of IEnumerator&lt;ITask&gt; (where ITask is an interface defined by the CCR). Here’s some code to achieve the same results using this style:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerator&lt;ITask&gt; ComputeTotalStockValue(string user, string pass)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string token = null;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">yield return Arbiter.Receive(false, AuthService.CcrCheck(user, pass), delegate(string t) { token = t; });</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;Holding&gt; stocks = null;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IDictionary&lt;string,decimal&gt; rates = null; yield return Arbiter.JoinedReceive(false, DbService.CcrGetStockHoldings(token),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StockService.CcrGetRates(token),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate(IEnumerable&lt;Holding&gt; s, IDictionary&lt;string,decimal&gt; r)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ stocks = s; rates = r; });</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">OnRequestComplete(ComputeTotal(stocks, rates))</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Confused? I certainly was when I first saw it—but now I’m in awe of how neat it is. The CCR calls into our code (with a call to MoveNext on the iterator), and we execute until and including the first yield return statement. The CcrCheck method within Auth-Service kicks off an asynchronous request, and the CCR waits (without using a dedicated thread) until it has completed, calling the supplied delegate to handle the result. It then calls MoveNext again, and our method continues. This time we kick off two requests in parallel, and ask the CCR to call another delegate with the results of both operations when they’ve </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">both</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> finished. After that, MoveNext is called for a final time and we get to complete the request processing.</font></p>
<p><a name="bookmark2007"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2008"></a>Although it’s obviously more complicated than the synchronous version, it’s still all in one method, it gets executed in the order written, and the method itself can hold the state (in the local variables, which become state in the extra type generated by the compiler). It’s fully asynchronous, using as few threads as it can get away with. I haven’t shown any error handling, but that’s also available in a sensible fashion that forces you to think about the issue at appropriate places.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve deliberately not gone into the details of the Arbiter class, the ITask interface, and so forth here. I’m not trying to promote the CCR in this section, although it’s fascinating to read about and experiment with; I suspect that Parallel Extensions will have more impact on mainstream developers. The point has been to show that iterators can be used in radically different contexts that have little to do with traditional collections. At the heart of this use of them is the idea of a state machine: two of the tricky aspects of asynchronous development are handling state and effectively pausing until something interesting happens. Iterator blocks are a natural fit for both of these problems.</font></p>
<p><a name="bookmark185"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2009"></a>6.5 Summary</font></p>
<p><a name="bookmark2010"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">C# supports many patterns indirectly, in terms of it being feasible to implement them in C#. But relatively few patterns are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">directly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> supported in terms of language features being specifically targeted at a particular pattern. In C# 1, the iterator pattern was directly supported from the point of view of the calling code, but not from the perspective of the collection being iterated over. Writing a correct implementation of IEnumerable was time consuming and error-prone, without being interesting. In C# 2, the compiler do<a name="bookmark2011"></a>es all the mundane work for you, building a state machine to cope with the call-back nature of iterators.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It should be noted that iterator blocks have one aspect in common with the anonymous methods we saw in chapter 5, even though the actual features are very different. In both cases, extra types may be generated, and a potentially complicated code transformation is applied to the original source. Compare this with C# 1, where most of the transformations for syntactic sugar (lock, using, and foreach being the most obvious examples) were straightforward. We’ll see this trend toward smarter compilation continuing with almost every aspect of C# 3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve shown you one piece of LINQ-related functionality in this chapter: filtering a collection. IEnumerable&lt;T&gt; is one of the most important types in LINQ, and if you ever want to write your own LINQ operators on top of LINQ to Objects,<sup>10</sup> you’ll be eternally grateful to the C# team for including iterator blocks in the language.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In addition to seeing some real-life examples of the use of iterators, we’ve looked at how one particular library has used them in a fairly radical way that has little to do with what comes to mind when we think about iteration over a collection. It’s worth bearing in mind that many languages have <a name="bookmark2012"></a>also looked at this sort of problem before—in computer science the term </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">coroutine</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is applied to concepts of this nature. Different languages have historically supported them to a greater or lesser extent, with tri<a name="bookmark2013"></a>cks being applicable to simulate them sometimes—for example, Simon Tatham has an excellent a<a name="bookmark2014"></a>rticle on how even C can express coroutines if you’re willing to bend coding standards somewhat (see <a href="http://mng.bz/H8YX">http://mng.bz/</a>H8YX). We’ve seen that C# 2 makes coroutines easy to write and use.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Having seen some major and sometimes mind-warping language changes focused around a few key features, our next chapter is a change of pace. It describes a number of small changes that make C# 2 more pleasant to work with than its predecessor, learning from the little niggles of the past to produce a language that has fewer rough edges, more scope for dealing with awkward backward-compatibility cases, and a better story around working with generated code. Each feature is relatively straightforward, but there are quite a few of them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup>10</sup> This is less daunting and more fun than it sounds. We’ll look at a few guidelines around this topic in chapter 12.</font></p>
<p><a name="bookmark9"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark2015"></a>Concluding C# 2: the final features</font></p>
<p><a name="bookmark2016"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Partial types</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Static classes</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Separate getter/setter property access</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Namespace aliases</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Pragma directives</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Fixed-size buffers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Friend assemblies</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we’ve looked at the four biggest new features in C# 2: generics, nullable types, delegate enhancements, and iterator blocks. Each addresses a fairly complex requirement, which is why we’ve gone into them in some depth. The remaining new features of C# 2 knock a few rough edges off C# 1. They’re little niggles that the language designers decided to correct—either areas where the language needed a bit of impr<a name="bookmark2017"></a>ovement for its own sake, or where the experience of working with code generation and native code could be made more pleasant.</font></p>
<p><a name="bookmark2018"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Over time, Microsoft has received a lot of feedback from the C# community (and its own developers, no doubt) about areas where C# hasn’t gleamed quite as brightly as it might. Several smaller changes made it into C# 2 along with the larger ones, for the purpose of alleviating some of these small pain points.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">None of the features in this chapter is particularly difficult, and we’ll go through them fairly quickly. Don’t underestimate how important they are, though—just because a topic can be explored in a few pages doesn’t mean it’s useless. You’re likely to use some of these features on a frequent basis. Here’s a quick rundown of the features covered in this chapter, so you know what to expect:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Partial types</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—The ability to write the code for a type in multiple source files; particularly handy for types where part of the code is autogenerated and the rest is written manually.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Static classes</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Tidying up utility classes so that the compiler can spot when you’re trying to use them inappropriately, and making your intentions clearer.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Separate getter/setter property access</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Finally, the ability to have a public getter and a private setter for properties! (That’s not the only combination available, but it’s the most common.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Namespace aliases</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Ways out of sticky situations where type names aren’t unique.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Pragma directives</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Compiler-specific instructions for actions such as suppressing specific warnings for a particular section of code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Fixed-size buffers</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—More control over how structs handle arrays in unsafe code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">InternalsVisibleToAttribute (friend assemblies)</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> —A feature spanning language, framework, and runtime, this allows selected assemblies more access when required.</font></p>
<p><a name="bookmark2019"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You may be itching to get on to the sexy stuff from C# 3 by this point, and I don’t blame you. Nothing in this chapter is going to set the world on fire—but each of these features can make your life more pleasant, or dig you out of a hole in some cases. Having dampened your expectations somewhat, our first feature is actually pretty nifty.</font></p>
<p><a name="bookmark188"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2020"></a>7.1 Partial types</font></p>
<p><a name="bookmark2021"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The first change we’ll look a<a name="bookmark2022"></a>t is due to the power struggle t<a name="bookmark2023"></a>hat was usually<a name="bookmark2024"></a> involved when using code generators with<a name="bookmark2025"></a> C# 1. For Windows Forms, the designer in Visual Studio required its own regions of code that couldn’t be touched by developers, within the same file that developers </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">had</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to edit for user interface functionality. This was clearly a brittle situation.</font></p>
<p><a name="bookmark2026"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In other cases, code generators create source that’s compiled alongside manually written code. In C# 1, adding extra functionality involved deriving new classes from the autogenerated ones, which is ugly. There are plenty of other scenarios where having an unnecessary link in the inheritance chain can cause problems or reduce encapsulation. For instance, if two different parts of your code want to call each other, <a name="bookmark2027"></a>you need virtual methods for the parent type to call the child, and protected methods for the reverse situation, where normally you’d just use two private nonvirtual methods.</font></p>
<p><a name="bookmark2028"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 2 allows more than one file to contribute to a type, and IDEs can extend this notion so that some of the code used for a type may not even be visible as C# source code at all. Types built from multiple source files are <a name="bookmark2029"></a>called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">partial types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this section we’ll also learn about </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">partial methods,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which are only relevant in partial types and allow a rich but efficient way of adding manually written hooks into autogenerated code. This is actually a C# 3 feature (this time based on feedback about C# 2), but it’s more logical to discuss it when we examine partial types than to wait until the next part of the book.</font></p>
<p><a name="bookmark189"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2030"></a>7.1.1 Creating a type with multiple files</font></p>
<p><a name="bookmark2031"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2032"></a>Creating<a name="bookmark2033"></a> a partial type is a<a name="bookmark2034"></a> cinch—you just need to include the partial contextual keyword in the declaration for the type in each file it occurs in. A partial type can be declared within as many files as you like, although all the examples in this section use two.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler effectively combines all the source files together before compiling. This means that code in one file can call code in <a name="bookmark2035"></a>another and vice versa, as shown in figure 7.1—there’s no need for forward references or other tricks.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can’t write half of a member in one file and half of it in another—each individual <a name="bookmark2036"></a>member has to be complete within its own file.<sup>1</sup> There are a few obvious restrictions about the declarations of the type—the declarations have to be compatible. Any file can specify interfaces to be implemente<a name="bookmark2037"></a>d (and they don’t have to be imp<a name="bookmark2038"></a>lemented in that file); any file can specify the base type; any file can specify constraints on a type parameter. But if multiple files specify a base type, those base types have to be the same, and if multiple files specify type constraints, the constraints have to be identical. Listing 7.1 gives an example of the flexibility afforded (while not doing anything even remotely useful).</font></p><div>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup>1</sup> There’s an exception here: partial types can contain nested partial types spread across the same set of files.</font></p></div><br clear="all"/><img src="images/17.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 7.1 Code in partial types is able to see all of the members of the type, regardless of which file each member is in.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.1 Demonstration of mixing declarations of a partial type</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Example1.cs using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">partial class Example&lt;TFirst, TSecond&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">: IEquatable&lt;string&gt; where TFirst : class</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public bool Equals(string other)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return false;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Example2.cs using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">partial class Example&lt;TFirst, TSecond&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">: EventArgs, IDisposable</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void Dispose()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I stress that this listing is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">solely</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for the purpose of talking about what’s legal in a decla-ration—the types involved were only picked for convenience and familiarity. We can see that both declarations (</font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">) contribute to the list of interfaces that must be implemented. In this example, each file implements the interfaces it declares, and that’s a common scenario, but it would be legal to move the implementation of IDisposable </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to Example1.cs and the implementation of IEquatable&lt;string&gt; </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to Example2.cs. I’ve used the ability to specify interfaces separately from the implementation myself, encapsulating methods with the same signature generated for multiple different types into an interface. The code generator doesn't know about the interface, so it wouldn’t know to declare that the type implements it.</font></p>
<p><a name="bookmark2039"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Only </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">specifies any type constraints, and only </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">specifies a base class. If </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">had specified a base class, it would have to be EventArgs, and if </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">had specified any type constraints they’d have to be exactly as in </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. In particular, we can’t specify a type constraint for TSecond in </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">even<a name="bookmark2040"></a> though it’s not mentioned in </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Both types have to have the same access modifier, if any—we couldn’t make one declaration internal and the o<a name="bookmark2041"></a>ther public, for example. Essentially, the rul<a name="bookmark2042"></a>es around combining files allow flexibility in most cases while encour<a name="bookmark2043"></a>aging consistency.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In single file types, initialization of member and static variables is guaranteed to occur in the order they appear in the file, bu<a name="bookmark2044"></a>t there’s no guaranteed order when multiple files are involved. Relying on the order of declaration within the file is brittle to start with—it leaves your code open to subtle bugs if a developer decides to “harmlessly” move things around. So, it’s worth avoiding this situation where you can anyway, but </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">particularly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> avoid it with partial types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we know what we can and can’t do, let’s take a closer look at why we’d </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">want</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to do it.</font></p>
<p><a name="bookmark190"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2045"></a>7.1.2 Uses of partial types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As I mentioned earlier, partial types are primarily useful in conjunction with designers and other code generators. If a code generator has to modify a file that’s owned by a developer, there’s always a risk of things going wrong. With the partial types model, a code generator can own the file where it’ll work, and completely overwrite the whole file every time it wants to.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Some code generators may even choose not to generate a C# file at all until the build<a name="bookmark2046"></a> is<a name="bookmark2047"></a> well <a name="bookmark2048"></a>under way. For instance, Snippy has Extensible Application Markup Language (XAML) files that describe the user interface. When the project is built, each XAML file is converted into a C# file in the obj directory (the filenames end with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">.g.cs </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to show they’ve been generated) and compiled along with the partial class providing extra code for that type (typically event handlers and extra construction code). This completely prevents developers from tweaking the generated code, at least without going to the extreme lengths of hacking the build fil<a name="bookmark2049"></a>e.</font></p>
<p><a name="bookmark2050"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve been careful to use the phrase </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">code generator</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> instead of just </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">designer</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> because there are plenty of code generators around besides designers. For instance, in Visual Studio web service proxies are generated as partial classes, and you may have your own tools that generate code based on othe<a name="bookmark2051"></a>r data <a name="bookmark2052"></a>sources. One reasonably common example of this is object-relational mapping (ORM)—some ORM tools use database entity descriptions from a configuration file (<a name="bookmark2053"></a>o<a name="bookmark2054"></a>r straight from the database) and ge<a name="bookmark2055"></a>nerate partial cl<a name="bookmark2056"></a>asses represen<a name="bookmark2057"></a>ting those entities. Likewise my .NET port of the Google Protocol Buffer serialization framework generates partial classes—a feature that has proven useful even within the implementation itself.</font></p>
<p><a name="bookmark2058"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2059"></a>This makes it straightforward to add behavior to the type: overriding virtual methods of the base class, adding new members with business logic, and so forth. It’s a great way of letting the developer and the tool work together, rather than constantly squabbling about who’s in charge.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One scenario that’s occasionally useful is for one file to be generated containing multiple partial types, and then some of those types are enhanced in other files, one manually generated file per type. To return to the ORM example, the tool could generate a single file containing all the entity definitions, and some of those entities could have extra code provided by the develop<a name="bookmark2060"></a>er, using one file per entity. This keeps the number of automatically generated files low, but still provides good visibility of the manual code involved.</font></p>
<p><a name="bookmark2061"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 7.2 shows how the uses of partial types for XAML and entities are similar, but with slightly different timing involved when it comes to creating the autogenerated C# code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A somewhat different use of partial types is as an aid to refactoring. Sometimes a type gets too big and assumes too many responsibilities. One first step to dividing the</font></p><img src="images/18.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 7.2 Comparison between XAML precompilation and autogenerated entity classes</font></p>
<p><a name="bookmark2062"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">bloated type into smaller, more coherent types can be to first split it into a partial type over two or more files. This can be done with no risk and in an experimental manner, moving methods between files until each file only addresses a particular concern. Although the next step of splitting the type up is still far from automatic at that stage, it should be a lot easier to see the end goal.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One final use to mention: unit testing. Often the set of unit tests for a class can end up being much larger than the implementation itself. One way to split the tests into more understandable chunks is using partial types. You can still easily run all the tests for a type in one go (as you still have a single test class), but you can easily see the test<a name="bookmark2063"></a>s for different areas of functionality in different files. By hand-editing the p<a name="bookmark2064"></a>roject file, you can even have the same parent/child expansion in Solution Explorer as you see when partial types are used for Visual Studio’s generated code. This won’t be to everyone's tastes, but I’ve found it to be a useful way of managing tests.</font></p>
<p><a name="bookmark2065"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When partial types first appeared in C# 2, no one knew exactly how they’d be used. One feature that was almost immediately requested was a way to provide optional extra code for generated methods to call. This need has been addressed by C# 3 with partial methods.</font></p>
<p><a name="bookmark191"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2066"></a>7.1.3 &nbsp;&nbsp;&nbsp;Partial methods</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">—</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C# 3 only!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To reiterate my previous explanation, I realize that the rest of this part of the book just deals with C# 2 features—but partial methods don’t fit with any of the other C# 3 features and they </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> fit in well when describing partial types. Apologies for any confusion this may cause.</font></p>
<p><a name="bookmark2067"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Back to the feature: sometimes we want to be able to specify behavio<a name="bookmark2068"></a>r in a manually created file and use that behavior from an automatically generated file. For instance, in a class that has lots of automatically gener<a name="bookmark2069"></a>ated properties, we might want to be able to specify code to be executed as validation of a new value for some of those properties. Another common scenario is for a code generator to include constructors—man-ually written code may want to hook into object construction to set default values, perform some logging, and so forth.</font></p>
<p><a name="bookmark2070"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In C# 2, these requirements could only be met either by using events that the manually generated code could subscribe to, or by making the automatically generated code </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">assume</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that the handwritten code will include methods of a particular name— making the whole code fail to compile unless the relevant methods are provided. Alternatively, the generated code can provide a base class with virtual methods that do nothing by default. The manually generated code can then derive from the class and override some or all of the methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All of these sol<a name="bookmark2071"></a>utions are somewhat messy. C# 3’s partial methods effectively provide </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">optional</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> hooks that have no cost wh<a name="bookmark2072"></a>atsoever if they’re not imple<a name="bookmark2073"></a>mented—any calls to the unimplemented partial methods are removed by the compiler. This allows tools to be very generous in terms of the hooks they provide—in the compiled code, you only pay for what you use. It’s easiest to understand this with an example. Listing 7.2 shows a partial type specified in two files, with the constructor in the automatically generated code calling two partial methods, one of which is implemented in the manually generated code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.2 A partial method called from a constructor</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Generated.cs using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">partial class PartialMethodDemo</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public PartialMethodDemo()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">OnConstructorStart();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Generated constructor&quot;); OnConstructorEnd();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">partial void OnConstructorStart(); partial void OnConstructorEnd();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Handwritten.cs using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">partial class PartialMethodDemo</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">partial void OnConstructorEnd()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Manual code&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As shown in listing 7.2, partial methods are declared just like abstract methods: by providing the signature without any i<a name="bookmark2074"></a>mplementation but using the partial modifier. Similarly, the actual implementations just have the partial modifier but are otherwise like normal methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Calling the parameterless constructor of PartialMethodDemo would result in “Generated constructor” and then “Manual code” being printed out. Examining the IL for the constructor, you wouldn’t see a call to OnConstructorStart because it no longer exists—there’s no trace of it anywhere in the compiled type.</font></p>
<p><a name="bookmark2075"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2076"></a>Because the metho<a name="bookmark2077"></a>d may not exist, partial methods must have a return type of void and can’t take out parameters. They have to be private, but they can be static and/or generic. If the method isn’t implemented in one of <a name="bookmark2078"></a>the files, the whole statement calling it is removed,<a name="bookmark2079"></a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">including any argument evaluations.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> If evaluating any of the arguments has a side effect that you want to occur whether or not the partial method is implemented, you should perform the evaluation separately. For instance, suppose you have the following code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">LogEntity(LoadAndCache(id));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here LogEntity is a partial method, and LoadAndCache loads an entity from the database and inserts it into the cache. You might want to use this instead:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MyEntity entity = LoadAndCache(id);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">LogEntity(entity);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That way, the entity is loaded and cached regardless of whether an implementation has been provided for LogEntity. Of course, if the entity can be loaded equally cheaply later on, and may not even be required, you should leave the statement in the first form and avoid an unnecessary load in some cases.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To be honest, unless you’re writing your own code generators, you’re more likely to be implementing partial methods than declaring and calling them. If you’re only implementing them, you don’t need to worry about the argument evaluation side of things.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In summary, partial methods in C# 3 allow generated code to interact with handwritten code in a rich manner without any performance penalties for situations where the interaction is unnecessary. This is a natural continuation of the C# 2 partial types feature, which enables a much more productive relationship between code generators and developers.</font></p>
<p><a name="bookmark2080"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Our next feature is entirely different, and is just a way of telling the compiler more about the intended nature of a type so that it can perform more checking on both the type itself and any code using it.</font></p>
<p><a name="bookmark193"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2081"></a>7.2 Static classes</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our second new feature is in some ways completely<a name="bookmark2082"></a> unnecessary—it just makes things tidier and more elegant when you write </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">utility classes</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><a name="bookmark2083"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Everyone has utility classes. I haven’t seen a significant project in either Java or C# that didn’t have at least one class consisting solely of static methods. <a name="bookmark2084"></a>The classic example appearing in developer code is a type with string helper methods, doing anything from escaping, reversin<a name="bookmark2085"></a>g, smart replacing—you name it. An example from the Framework is the System.Math class. The key features of a utility<a name="bookmark2086"></a> class are as follows:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;All members are static (except a priva<a name="bookmark2087"></a>te constructor).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The class derives directly<a name="bookmark2088"></a> from object.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Typically there’s no state at all, u<a name="bookmark2089"></a>nless some caching or a singleton is involved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;There are no visib<a name="bookmark2090"></a>le constructors.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The class is sealed if the developer remembers to do so.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The last two points are optional, and if there are no visible constructors (including protected ones) then the class is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">effectively</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> sealed anyway. Both of them help make the purpose of the class more obvious, though.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The following listing gives an example of a C# 1 utility class—then we’ll see how C# 2 improves matters.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.3 A typical C# 1 utility class</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public sealed class NonStaticStringHelper {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private NonStaticStringHelper()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static string Reverse(string input)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">char[] chars = input.ToCharArray();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Array.Reverse(chars);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new string(chars);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The class is sealed </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">s<a name="bookmark2091"></a>o that no one tries to derive from it. Inheritance is supposed to be about specialization, and there’s nothing to specialize here, as all the members are static </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">except the private constructor </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. That constructor may seem odd at first sight—why have it at all if it’s private and never going to be used? The reason is because if you don’t suppl<a name="bookmark2092"></a>y any constructors for a class, t<a name="bookmark2093"></a>he C# 1 compiler will always provide a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">default constructor</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that’s public and parameterless. In this case, we don’t want any visible constructors, so we have to provide a private one.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This pattern works reasonably well, but C# 2 makes it explicit and actively prevents the type from being misused. First we’ll see what changes are needed to turn listing 7.3 into a proper static class as defined in C# 2. As you can see from listing 7.4, little action is required.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.4 The same utility class as in listing 7.3 but converted into a C# 2 static class</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public </font><font style="font-size:x-small;font-family:Times New Roman, serif;">static </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class StringHelper {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static string Reverse(string input)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">char[] chars = input.ToCharArray();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Array.Reverse(chars); return new string(chars);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark2094"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve used the static modifier in the class declaration this time instead of sealed, and we haven’t included a constructor at all—those are the only code differences. The C# 2 compiler knows that a static class shouldn’t have any constructors, so it doesn’t provide a default one. In fact, the compiler enforces a number of constraints on the class definition:</font></p>
<p><a name="bookmark2095"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2096"></a><a name="bookmark2097"></a>■ &nbsp;&nbsp;&nbsp;It can’t be declared as abstract or sealed, although it’s implicitly both.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It can’t specify any imple<a name="bookmark2098"></a>mented interfaces.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It can’t specify a base type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It can’t include any nonstatic<a name="bookmark2099"></a> members, including constructors.</font></p>
<p><a name="bookmark2100"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It can’t include any operators.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It can’t include any protected or protected internal members.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth noting that although all the m<a name="bookmark2101"></a>embers must be static, you have to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">explicitly </font><font style="font-size:x-small;font-family:Times New Roman, serif;">make them static. Although nested types are implicitly static members of the enclosing class, the nested type itself can be a nonstatic type if that’s required.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler doesn’tju<a name="bookmark2102"></a>st put constraints on the definition of static classes—it also guards against their misuse. As it knows that there can never be any instances of the class, it prevents any use that would require one. For instance, all of the following are invalid when StringHelper is a static class:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StringHelper variable = null;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StringHelper[] array = null;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void Method1(StringHelper x) {}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public StringHelper Method1() { return null; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;StringHelper&gt; x = new List&lt;StringHelper&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">None of these is prevented if the class just follows the C# 1 pattern—but all of them are essentially useless. In short, static classes in C# 2 don’t allow you to do anything you couldn’t do before—but they prevent you from doing things that you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">shouldn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;">have been doing anyway. They also explicitly state your intentions. By making a class static, you’re saying that you definitely </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">don't want</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> any i<a name="bookmark2103"></a>nstances to be created—it’s just not a quirk of the implementation; it’s a design choice.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The next feature on our list has a more positive feel. It’s aimed at a specific— although widely encountered—situation, and allows a solution that’s neither ugly nor breaks encapsulation, which was the choice available in C# 1.</font></p>
<p><a name="bookmark195"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2104"></a>7.3 Separate getter/setter property access</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ll admit to being bemused when I first s<a name="bookmark2105"></a>aw that C# 1 didn’t allow you to have a public getter an<a name="bookmark2106"></a>d a private setter for properties. This isn’t the only combination of access modifiers that’s proh<a name="bookmark2107"></a>ibited by C# 1, <a name="bookmark2108"></a>but it’s the most commonly desired one. In fact, in C# 1 both the getter and the setter need to have the same accessibility—it’s declared as part of the property declaration rather than as part of the getter or setter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are perfectly good reasons to want d<a name="bookmark2109"></a>ifferent <a name="bookmark2110"></a>accessibil<a name="bookmark2111"></a>ity for the getter and the setter—often you may want some validation, logging, locking, or other code to be executed when changing a variable that backs the property but you don’t want to make the property writable t<a name="bookmark2112"></a>o code outside the class. In C# 1 the alternatives were either to break encapsulation by making the property publicly writable against your better judgment or to write a SetXXX() method in the class to do the setting, which frankly looks ugly when you’re used to real properties.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 2 fixes the problem by allowing either the getter or the setter to explicitly have more restrictive access than that declared for the property itself. This is most easily seen with an example:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string name; public string Name {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get { return name; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private set</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Validation, logging etc here name = value;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this case, the Name property is effectively read-only to all other types,<sup><a name="footnote53"></a><a href="#bookmark2113">53</a></sup> but we can use the familiar property syntax for setting the property within the type itself. The same syntax is also available for indexers as well as properties. You </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> make the setter more public than the getter (a protected getter and a public setter, for example) but that’s a pretty rare situation, in the same way that write-only properties are few and far between compared with read-only properties.</font></p>
<p><a name="bookmark2114"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2115"></a><a name="bookmark2116"></a>TRIVIA: THE <a name="bookmark2117"></a>ONLY PLACE WH<a name="bookmark2118"></a>ERE “PRIVATE” IS REQUIRED Everywhere else in C#, the default access modifier in any given situation is the most private one possible. For example, if something can be declared to be private, it will default to private if you don't specify any access modifiers. This is a nice element of language design, because it’s hard to get it wrong accidentally: if you want something to be more public than it is, you’ll notice when you try to use it. But if you accidentally make something too public, then the compiler can’t help you to spot the problem. Specifying the access of a property getter or setter is the one exception to this rule—if you don’t specify anything, the default is to give the getter/setter the same access as the overall property itself.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note that you can’t declare the property itself to be private and make the getter pub-lic—you can only make a particular getter/setter </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">more</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> private than the property. Also, you can’t specify an access modifier for both the getter and the setter—that would be silly, as you could declare the property itself to be whichever is the more public of the two modifiers.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This aid to encapsulation is extremely welcome. There’s still nothing in C# 2 to stop other code in the same class from bypassing the property and going directly to whatever fields are backing it, unfortunately. As we’ll see in the next chapter, C# 3 fixes this in one particular case, but not in general.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We move from a feature you may want to use regularly to one that you’ll want to avoid most of the time—it allows your code to be absolutely explicit in terms of which types it’s referring to, but at a significant cost to readability.</font></p>
<p><a name="bookmark2119"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark196"></a>7.4 Namespa<a name="bookmark2120"></a>ce aliases</font></p>
<p><a name="bookmark2121"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Namespaces are primarily intended as a means of org<a name="bookmark2122"></a>anizing types into a useful hierarchy. They </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> all<a name="bookmark2123"></a>ow you to keep fully qualified names of types distinct even when the unqualified names may be the same. This shouldn’t be seen as an invitation to reuse unqualified type names without good cause—but there are times when it’s the natural thing to do.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">An example of this is the unqualified name Button. There are two classes with that name in the .NET 2.0 Framework: System.Windows.Forms.Button and System.Web. UI.WebControls.Button. Although they’re both called Button, it’s easy to tell them apart by their namespaces. This mirrors real life closely—you may know several people called Jon, but you’re unlikely to know anyone else called Jon Skeet. If you’re t<a name="bookmark2124"></a>alking with friends in a particular context, you may be able to use just the name Jon without specifying which one you’re talking about—but in other contexts you may need to provide more <a name="bookmark2125"></a>exact information.</font></p>
<p><a name="bookmark2126"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The using directive of C# 1 (not to be confused with the using statement t<a name="bookmark2127"></a>hat calls Dispose a<a name="bookmark2128"></a>utomatic<a name="bookmark2129"></a>ally) was available in two flavors—one created an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">alias</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for a namespace or type (for example, using Out = System.Console;) and the other just introduced a namespace into the list of contexts the compiler would search when looking for a type (for example, using System. IO;). By and large, this was adequate, but there are a few situations that the language couldn’t cope with. In some other cases, automatically generated code would have to go out of its way to make absolutely sure that the right namespaces and types were being used whatever happened.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 2 fixes these problems, bringing additional expressiveness to the language. You can now write code that’s guaranteed to mean what you want it to regardless of which other types, assemblies, and namespaces are introduced. These extreme measures are rarely needed outside automatically generated code, but it’s nice to know that they’re there when you need them. In C# 2 there are three types of aliases: the namespace aliases of C# 1, the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">global</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> namespace alias, and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extern</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> aliases. We’ll start off with the one type of alias that was already present in C# 1, but we’ll introduce a new way of using aliases to ensure that the compiler knows to treat it as an alias rather than checking to see whether it’s the name of another namespace or type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even in C# 1, it was a good idea to avoid namespace aliases wherever possible. Every so often you might find that one type name clashed with another—as with our Button example earlier—and so you either had to specify the full name including the namespace every time you used them, or have an alias that distinguished the two, in some ways acting like a shortened form of the namespace. The following listing shows an example where the two types of Button are used, qualified by an alias.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.5 Using aliases to distinguish between different Button types</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using WinForms = System.Windows.Forms; using WebForms = System.Web.UI.WebControls;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Test {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(WinForms.Button));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(WebForms.Button));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.5 compiles without any errors or warnings, although it’s still not as pleasant as it would be if we only needed to deal with one kind of Button to start with. There’s a problem, though—what if someone were to introduce a type or namespace called WinForms or WebForms? The compiler wouldn’t know what WinForms.Button meant, and would use the type or namespace in preference to the alias. We want to be able to tell the compiler that we need it to tre<a name="bookmark2130"></a>at WinForms as an alias, <a name="bookmark2131"></a>even though it’s available elsewhere. C# 2 introduces the :: </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">namespace alias qualifier</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> syntax to do this, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.6 Using :: to tell the compiler to use aliases</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using WinForms = System.Windows.Forms; using WebForms = System.Web.UI.WebControls;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class WinForms {}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Test {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(WinForms::Button));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(WebForms::Button));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Instead of WinForms.Button, listing 7.6 uses WinForms: :Button, and the compiler is happy. If you change the :: back to . you’ll get a compilation error. So, if you use :: everywhere you use an alias, you’ll be fine, right? Well, not quite...</font></p>
<p><a name="bookmark198"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2132"></a>7.4.2 The global namespace alias</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s one part of the namespace hierarchy that you can’t define your own alias for: the root of it, or the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">global</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> namespace. Suppose you have two classes, both named Configuration; one within a namespace of MyCompany and the other with no namespace specified at all. How can you refer to the root Configuration class from within the MyCompany namespace? You can’t use a normal alias, and if you just specify Configuration the compiler will use MyCompany.Configuration.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In C# 1, there was no way of getting around this. Again, C# 2 comes to the rescue, allowing you to use global: Configuration to tell the compiler exactly what you want. The following listing demonstrates both the problem and the solution.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.7 Use of the global namespace alias to specify the desired type exactly</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System; class Configuration {} namespace Chapter7 {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Configuration {} class Test {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(Configuration));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(global::Configuration));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(global::Chapter7.Test));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Most of listing 7.7 is just setting up the situation—the three lines within Main are the interesting ones. The first line prints “Chapter7.Configuration” as the compiler resolves Configuration to that type before moving out to the namespace root. The second line indicates that the type has to be in the global namespace, and so simply prints “Configuration.” I included the third line to demonstrate that using the global alias, you can still refer to types within namespaces, but you have to specify the fully qualified name.</font></p>
<p><a name="bookmark2133"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2134"></a>At this point we can get to any uniquely named type, using the global namespace alias if necessary—and if you ever write a code generator where the code doesn’t need to be readable, you may wish to use this feature liberally to make sure that you always refer to the correct type whatever other types are present by the time the code is compiled. What do we do if the type’s name isn’t unique even when we include its namespace? The plot thickens...</font></p>
<p><a name="bookmark199"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2135"></a>7.4.3 Extern aliases</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">At the start of this section, I referred to human names as examples of namespaces and contexts. I specifically said that you’re unlikely to know more than one person called</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Jon Skeet. But I know that there </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> more than one person with my name, and it’s not beyond the realm of possibility that you might know two or more of us. In this case, in order to specify which one you mean, you have to provide some more information beyond just the full name—the reason you know the particular person, or the country he lives in, or something similarly distinctive.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 2 lets you specify that extra information in the form of an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extern alias</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—a name that exis<a name="bookmark2136"></a>ts not only in your source code, but also in the parameters you p<a name="bookmark2137"></a>ass to the compiler. For the Microsoft C# compiler, this means specifying the assembly that contains the types in question. Let’s suppose that two assemblies—First.dll and Second.dll—both contain a type called Demo.Example. We can’t just use the fully qualified name to distinguish them, as they both have the same fully qualified name. Instead, we can use extern aliases to specify which we mean. The follo<a name="bookmark2138"></a>wing listing shows an example of the C# code involved, along with the command line needed to compile it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.8 Working with different types of the same type in different assemblies</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Compile with</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// csc Test.cs /r:FirstAlias=First.dll /r:SecondAlias=Second.dll</font></p><div>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">extern alias extern alias</font></p></div><br clear="all"/><div>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FirstAlias;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SecondAlias;</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using FD = FirstAlias::Demo; class Test {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(FD.Example)); Console.WriteLine(typeof(SecondAlias::Demo.Example));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><sup>}</sup> &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">Uses &nbsp;&nbsp;&nbsp;extern &nbsp;&nbsp;&nbsp;alias &nbsp;&nbsp;&nbsp;directly</font></p>
<p><a name="bookmark2139"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The code in listing 7.8 is straightforward. The first thing we have to do is introduce the two extern aliases O. After that we can use them either<a name="bookmark2140"></a> via namespace aliases (© and ©) or directly ©. In fact, a normal using directive without an alias (such as using FirstAlias:: Demo;) would’ve allowed us to use the name Example without any further qualification at all. One extern alias can cover multiple assemblies, and several extern aliases can all refer to the same assembly—although I’d think carefully before using either of these features, and partic<a name="bookmark2141"></a>ularly before combining them together. To specify an extern<a name="bookmark2142"></a>al alias in Visual Studio, just select the assembly reference within Solution Explorer and modify the Aliases value in the Properties window, as shown in figure 7.3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Hopefully I don’t need to persuade you to avoid this kind of situation wherever you can. It can be necessary to work with assemblies from different third parties who happen to have used the same fully qualified type name, at which point you’d otherwise be</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">stu<a name="bookmark2143"></a>ck. Where you have more control over the naming, make sure that your names never lead you into this territory in the first place.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our next feature is almost a meta-feature. The exact functionality it provides depends on which compiler you’re using, because its purpose is to enable control over compiler-specific features— but we’ll concentrate on the Microsoft compiler.</font></p><div><img src="images/19.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 7.3 Part of the Properties window of Visual Studio 2010, showing an extern alias of FirstAlias for the First.dll <a name="bookmark2144"></a>reference</font></p></div><br clear="all"/>
<p><a name="bookmark2145"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark200"></a>7.5 Pragma directives</font></p>
<p><a name="bookmark2146"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Describing </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">pragma directives</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in general is extremely ea<a name="bookmark2147"></a>sy: a pragma directive is a preprocessing directive represented by a line beginning with #pragma. The rest of the line can contain any text at all. The result of a pragma directive can’t change the <a name="bookmark2148"></a>behavior of the program to contravene anything within the C# language specification, but it can do anything outside the scope of the specification. If<a name="bookmark2149"></a> the compiler d<a name="bookmark2150"></a>oesn’t understand a particular pragma directive, it can issue a warning, but not an error.</font></p>
<p><a name="bookmark2151"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2152"></a>That’s basically everything the specification has to say on the subject. The Microsoft C# compiler understands two pragma directives: warnings and checksums.</font></p>
<p><a name="bookmark201"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2153"></a>7.5.1 Warning pragmas</font></p>
<p><a name="bookmark2154"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Occasionally, the C# compiler issues warnings that are justifiable but annoying. The correct response to a compiler warning is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">almost always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to fix it—the code is rarely made worse by fixing the warning, and usually it’s improved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But sometimes there’s a good reason to ignore a warning—and that’s what warning pragmas are available for. As an example, we’ll create a private field that’s never read from or written to. It’s almost always going to be useless... unless we happen to know that it’ll be used by reflection. The following listing is a complete class demonstrating this.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.9 Class containing an unused field</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class FieldUsedOnlyByReflection {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int x;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you try to compile listing 7.9, you’ll get a warning message like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FieldUsedOnlyByReflection.cs(3,9): warning CS0169:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">The private field 'FieldUsedOnlyByReflection.x' is never used</font></p>
<p><a name="bookmark2155"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s<a name="bookmark2156"></a> the output from the command line compiler. In the Error List window of Visual Studio, you can see the same information (plus the project it’s in) </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">except</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that you don’t get the warning number (CS0169). To find the number, you need to either select the warning and bring up the help related to it, or look in the Output window, where the full text is shown. We need the number in order to make the code compile without warnings, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.10 Disabling (and restoring) warning CS0169</font></p>
<p><a name="bookmark2157"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class FieldUsedOnlyByReflection {</font></p>
<p><a name="bookmark2158"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">#pragma warning disable 0169</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int x;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">#pragma warning restore 0169</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark2159"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.10 is self-explanatory—the first pragma disables the particular warning we’re interested in, and the second one restores it. It’s good practice to disable warnings for as short a space as you can, so that you don’t miss any warnings you genuinely ought to fix. If you want to disable or restore multiple warnings in a single line, just use a comma-separated list of warning numbers. If you don’t specify any warning numbers at all, the result is to disable or restore </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> warnings in one fell swoop—but that’s a bad idea in almost every imaginable scenario.</font></p>
<p><a name="bookmark202"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2160"></a>7.5.2 Checksum pragmas</font></p>
<p><a name="bookmark2161"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You’re unlikely to need the second form of pragma recognized by the Microsoft compiler. It supports the debugger by allowing it to check that it’s found the right source file. Normally when a C# file is compiled, the compiler generates a checks<a name="bookmark2162"></a>um from the file and includ<a name="bookmark2163"></a>es it in the debugging information. When the debugger needs to locate a source file and finds multiple potential matches, it can generate the checksum itself for each of the c<a name="bookmark2164"></a>andidate files and see which is correct.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now, when an ASP.NET page is converted into C#, the generated <a name="bookmark2165"></a>file is what the C# compiler sees. The generator calculates the checksum of the .aspx page, and uses a checksum pragma to tell the C# compiler to use </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">that</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> checksum instead of calculating one from the generated page.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The syntax of the checksum pragma is</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">#pragma checksum &quot;filename&quot; &quot;{guid}&quot; &quot;checksum bytes&quot;</font></p>
<p><a name="bookmark2166"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The GUID indicates which hashing algorithm has be<a name="bookmark2167"></a>en used to calcul<a name="bookmark2168"></a>ate the c<a name="bookmark2169"></a>hecksum. The documentation for the CodeChecksumPragma class gives GUIDs for SHA-1 and MD5, should you ever wish to implement your own dynamic compilation framework with debugger support.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s possible that future versions of the C# co<a name="bookmark2170"></a>mpiler will incl<a name="bookmark2171"></a>ude more pragma directives, and other compilers (such as the Mono compiler, gmcs) could have their own support for different features. Consult your compiler documentation for the most up-to-date information.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The next feature is another one that you may never use—but if you ever do, it’s likely to make your life somewhat simpler.</font></p>
<p><a name="bookmark2172"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark203"></a>7.6 Fixed-size buffers in uns<a name="bookmark2173"></a>afe code</font></p>
<p><a name="bookmark2174"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When calling into native code with P/Invoke, it’s not unusual to find yourself dealing with a structure that’s defined to have a buffer of a particular length within <a name="bookmark2175"></a>it. Prior to C# 2, such structures were difficult to handle directly, even with unsafe code. Now, you can declare a buffer of the right size to be embedded directly with the rest of the data for the structure.</font></p>
<p><a name="bookmark2176"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This capability isn’tjust available for calling native code, although that’s its primary use. You could use it to easily populate a data structure directly corresponding to a file format, for instance. The syntax is simple, and once again we’ll demonstrate it with an example. To create a field that embeds an array of 20 bytes within its enclosing structure, you’d use</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">fixed byte data[20];</font></p>
<p><a name="bookmark2177"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This would allow data to be used as if it were a by<a name="bookmark2178"></a>te* (a pointer to byte data), although the implementation used by the C# compiler is t<a name="bookmark2179"></a>o create a new nested type within the dec<a name="bookmark2180"></a>laring type and apply the new FixedBuffer attribute to the variable itself. The CLR then takes care of allocating the memory appropriately.</font></p>
<p><a name="bookmark2181"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2182"></a>One downside of this feature is that it’s only available within unsafe code: the enclosing structure has to be declared in an unsafe context, and you can only use the fixed-size buffer member within an unsafe context. This limits the situations in which it’s useful, but it can still be a nice tric<a name="bookmark2183"></a>k to have up your sleeve. Also, fixed-size buffers are only applicable to primitive types, and can’t be members of classes (only structures).</font></p>
<p><a name="bookmark2184"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are remarkably few Windows APIs where this feature is directly useful. Numerous situations call for a fixed array of characters—the TIME_Z ONE_ INFORMATION structure, for example—but unfortunately fixed-si<a name="bookmark2185"></a>ze buffers of characters appear to be handled poorly by P/Invoke, with the marshaler getting in the way.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As one example, though, listing 7.11 is a console application that displays the colors available in<a name="bookmark2186"></a> the current console window. It uses an API function, GetConsole-ScreenBufferEx, that was introduced in Windows Vista and Windows Server 2008, and that retrieves extended console information. The following listing displays all 16 colors in hexadecimal format (bbggrr).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.11 Demonstration of fixed-size buffers to obtain console color information</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System.Runtime.InteropServices; struct COORD {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public short X, Y;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">struct SMALL_RECT {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public short Left, Top, Right, Bottom;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">unsafe struct CONSOLE_SCREEN_BUFFER_INFOEX {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int StructureSize;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public COORD ConsoleSize, CursorPosition;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public short Attributes;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public SMALL_RECT DisplayWindow;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public COORD MaximumWindowSize;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public short PopupAttributes;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int FullScreenSupported;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public fixed int ColorTable[16];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static class FixedSizeBufferDemo {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">const int StdOutputHandle = -11;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[DllImport(&quot;kernel32.dll&quot;)]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static extern IntPtr GetStdHandle(int nStdHandle); [DllImport(&quot;kernel32.dll&quot;)]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static extern bool GetConsoleScreenBufferInfoEx</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(IntPtr handle, ref CONSOLE_SCREEN_BUFFER_INFOEX info);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">unsafe static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IntPtr handle = GetStdHandle(StdOutputHandle);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CONSOLE_SCREEN_BUFFER_INFOEX info;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">info = new CONSOLE_SCREEN_BUFFER_INFOEX();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">info.StructureSize = sizeof(CONSOLE_SCREEN_BUFFER_INFOEX); GetConsoleScreenBufferInfoEx(handle, ref info);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">for (int i=0; i &lt;&nbsp;16; i++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;{0:x6}&quot;, info.ColorTable[i]);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark2187"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.11 uses fixed-size buffers for the table of colors. Before fixed-size buffers, we could still have used the API either with a field for eac<a name="bookmark2188"></a>h color table entry or by marshalling a nor<a name="bookmark2189"></a>mal array a<a name="bookmark2190"></a>s UnmanagedType .ByValArray. But this would’ve created a separate array on the heap instead of keeping the informati<a name="bookmark2191"></a>on all within the structure. That’s not a problem here, but in some high-performance situations it’s nice to be able to keep lumps of data together. On a different performa<a name="bookmark2192"></a>nce note, if the buffer is part of a data structure on the managed heap, you have to pin it before accessing it. If you do this a lot, it can significantly affect the garbage collector. Stack-based structures don’t have this problem, of course.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m not going to claim that fixed-size buffers are a hugely important feature in C# 2—at least, they’re not important to most people. I’ve included them for completeness—doubtless someone, somewhere, will find them invaluable. Our final feature can barely be called a C# 2 </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">language</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> feature at all—but it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">just</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> about counts, so I’ve included it for completeness.</font></p>
<p><a name="bookmark205"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2193"></a>7.7 Exposing internal members to selected assemblies</font></p>
<p><a name="bookmark2194"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Some features are obviously in the language—iterator blocks, for example. Some features obviously belong to the runtime, such as JIT compiler optimizations. Some clearly sit in both camps, such as generics. This last feature has a toe in each but is sufficiently odd that it doesn’t merit a <a name="bookmark2195"></a>mention in </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">either</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> specification. In addition, it uses a term that has different meanings in C++ and VB.NET—adding a third meaning to the mix. To be fair, all the terms are used in the context of access permissions, but they have different effects.</font></p>
<p><a name="bookmark206"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2196"></a>7.7.1 Friend assemblies in the simple case</font></p>
<p><a name="bookmark2197"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2198"></a>In .NET 1.1 it was entirely accurate to say that something defined to be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">internal </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(whether a type, a method, a property, a variable, or an event) could only be accessed within the same assembly in which it was declared.<sup><a name="footnote54"></a><a href="#bookmark2199">54</a></sup> In .NET 2.0 that’s still </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">mostly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> true, but there’<a name="bookmark2200"></a>s a new attribute to let you bend the rules slightly: InternalsVisibleTo-Attribute, usually referred to as just InternalsVisibleTo. (When applying an attribute whose name ends with Attribute, the C# compiler will apply the suffix automatically.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">InternalsVisibleTo can only be applied to an assembly (not a specific member), and you can apply it multiple times to the same assembly. We’ll call the assembly containing the attribute the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">source assembly</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, although this is unofficial terminology. When you apply the attribute, you have to specify another assembly, known as the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">friend assembly</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. The result is that the friend assembly can see all the internal members of the source assembly as if they were public. This may sound alarming, but it can be useful, as we’ll see in a minute.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The following listing shows this with three classes in three different assemblies.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 7.12 Demonstration of friend assemblies</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Compiled to Source.dll using System.Runtime.CompilerServices; [assembly:InternalsVisibleTo(&quot;FriendAssembly&quot;)] public class Source {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">internal static void InternalMethod() {} public static void PublicMethod() {}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Compiled to FriendAssembly.dll public class Friend {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Source.InternalMethod(); Source.PublicMethod();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Compiled to EnemyAssembly.dll public class Enemy {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Source.InternalMethod();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Source.PublicMethod();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In listing 7.12 a special relationship exists between FriendAssembly.dll and Source .dl l—although it only operates one way: Source.dl l has no access to internal members of FriendAssembly.dll. If we were to uncomment the line at O, the Enemy class would fail to compile.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, why on earth would we want to open up our well-designed assembly to certain assemblies to start with?</font></p>
<p><a name="bookmark207"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2201"></a>7.7.2 &nbsp;&nbsp;&nbsp;Why use InternalsVisibleTo?</font></p>
<p><a name="bookmark2202"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I can’t say I’ve ever used InternalsVisibleTo between two production assemblies. I’m not saying there aren’t legitimate use cases for that,<a name="bookmark2203"></a> but I’ve not come across them. I </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> used the attribute when it comes to unit <a name="bookmark2204"></a>testing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Some say you should only test the public interface to code. Personally I’m happy to test whatever I can in the simplest manner possible. Friend assemblies make that a lot easier: suddenly it’s trivial to test code that only has internal access without taking the dubious step of making members public just for the sake of testing, or including the test code within the production assembly. (It does occasionally mean making members internal for the sake of testing where they might otherwise be private, but that’s less worrying.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The only downside to this is that the name of your test asse<a name="bookmark2205"></a>mbly lives on in your production assembly. I<a name="bookmark2206"></a>n theory this could represent a security attack vector if your assemblies <a name="bookmark2207"></a>aren’t signed, and if your code normally ope<a name="bookmark2208"></a>rates under a restricted set of permissions. (Anyone with full trust could use reflection to access the members in the first place. You could do that yourself for unit tests, but it’s much nastier.) If this ever ends up as a genuine issue for anyone, I’ll be very surprised. But it does bring the option of signing assemblies into the picture. Just when you thought this was a nice, simple little feature...</font></p>
<p><a name="bookmark208"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2209"></a>7.7.3 &nbsp;&nbsp;&nbsp;InternalsVisibleTo and signed assemblies</font></p>
<p><a name="bookmark2210"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2211"></a>If a friend assembly is signed, the source assembly needs to specify the public key of the friend assembly, to make sure it’s trusting the right code. You need the full public key, not just the public key token. For instance, consider the following command line and output (rewrapped and modified slightly for formatting) used to discover the public key of a signed FriendAssembly.dll:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">c:\Users\Jon\Test&gt;sn -Tp FriendAssembly.dll</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Microsoft (R) .NET Framework Strong Name Utility Version 3.5.21022.8 Copyright (c) Microsoft Corporation. All rights reserved.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Public key is</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">0024000004800000940000000602000000240000525341310004000001 000100a51372c81ccfb8fba9c5fb84180c4129e50f0facdce932cf31fe 563d0fe3cb6b1d5129e2832 6060a3a539f287aaf59affc5aabc4d8f981 e1a82479ab795f410eab22e32 66033c633400463ee7513378bb4ef41fc 0cae5fb03986d133 677c82a865b278c48d99dc251201b9c43edd7bedef d4b53 06efd0dec7787ec6b664471c2</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Public key token is 647b99330b7f792c</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The source code for the Source class would now need to have this as the attribute:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[assembly:InternalsVisibleTo(&quot;FriendAssembly,PublicKey=&quot; + &quot;0024000004800000940000000602000000240000525341310004000001&quot; + &quot;000100a51372c81ccfb8fba9c5fb84180c4129e50f0facdce932cf31fe&quot; + &quot;563d0fe3cb6b1d5129e2832 6060a3a539f287aaf59affc5aabc4d8f981&quot; + &quot;e1a82479ab795f410eab22e32 66033c633400463ee7513378bb4ef41fc&quot; + &quot;0cae5fb03986d133 67 7c82a865b278c48d99dc251201b9c43edd7bedef&quot; + &quot;d4b5306efd0dec7787ec6b664471c2&quot;)]</font></p>
<p><a name="bookmark2212"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Unfortunately, you need to either have the public key on one line or use string concat-enation—whitespace in the public key will cause a compilation failure. It’d be a lot more pleasant to look at if we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> specify the token instead<a name="bookmark2213"></a> of the whole key, but fortunately this ugliness is usually confined to AssemblyInfo .cs, so you won’t need to see it often.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In theory, it’s possible to have an unsigned source assembly and a signed friend assembly. In practice, that’s not terribly useful, as the friend assembly typically wants to have a reference to the source assembly—and you can’t refer to an unsigned assembly from one that’s signed! Likewise a signed assembly can’t specify an unsigned friend assembly, so typically you end up with both assemblies being signed if either one of them is.</font></p>
<p><a name="bookmark210"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2214"></a>7.8 Summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This completes our tour of the new features in C# 2. The topics we’ve looked at in this chapter have broadly fallen into two categories: “nice to have” improvements that streamline development, and “hope you don’t need it” features that can get you out of tricky situations when you need them. To make an analogy between C# 2 and improvements to a house, the major features from our earlier chapters are comparable to full-scale additions. Some of the features we’ve seen in this chapter (such as partial types and static classes) are more like redecorating a bedroom, and features such as namespace aliases are akin to fitting smoke alarms—you may never see a benefit, but it’s nice to know they’re there if you ever need them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The range of features in C# 2 is broad—the designers tackled many of the areas where developers were feeling pain, without any one overarching goal. That’s not to say the features don’t work well together—nullable value types wouldn’t be feasible without generics, for instance—but there’s no one aim that every feature contributes to, unless you count general productivity.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve finished examining C# 2, it’s time to move on to C# 3, where the picture is very different. Nearly every feature in C# 3 forms part of the grand picture of LINQ, a conglomeration of technologies that massively simplifies many tasks.</font></p>
<p><a name="bookmark2215"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Part 3</font></p>
<p><a name="bookmark11"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark2216"></a>C# 3: revolutionizing how we code</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><sub>T</sub></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">here’s no doubt that C# 2 is a significant improvement over C# 1. The benefits of generics in particular are fundamental to other changes, notjust in C# 2 but also in C# 3. But C# 2 is in some sense a piecemeal collection of features. Don’t get me wrong: they fit together nicely enough, but they address a set of individual issues. That was appropriate at that stage of C#’s development, but C# 3 is different.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Almost every feature in C# 3 enables one specific technology: LINQ. Many of the features are useful outside this context, and you certainly shouldn’t confine yourself to only using them when you happen to be writing a query expression, for example—but it’d be equally silly not to recognize the complete picture created by the set of jigsaw puzzle pieces presented in the remaining chapters.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When I originally wrote about C# 3 and LINQ in 2007, I was highly impressed on a somewhat academic level. The more deeply you study the language, the more clearly you see the harmony between the various elements that have been introduced. The elegance of query expressions—and in particular the ability to use the same syntax for both in-process queries and providers like LINQ to SQL—was very appealing. LINQ had a great deal of promise.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now, two and a half years later, I can look back on the promises and see how they’ve played out. In my experience with the community—particularly on Stack Overflow—it’s obvious that LINQ has been widely adopted and really has changed how we approach many data-oriented tasks. Database providers aren’t</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">just restricted to those from Microsoft—LINQ to NHibernate and SubSonic are just two of the other options available. Microsoft hasn’t stopped innovating around LINQ either: in chapter 12 we’ll see Parallel LINQ and Reactive Extensions, two very different ways of handling data that still use the familiar LINQ operators. And then there’s LINQ to Objects—the simplest, most predictable, almost mundane LINQ provider— and the one that’s most pervasive in industry. The days of writing yet another filtering loop, yet another piece of code to find some maximum value, yet another check to see whether any items in a collection satisfy some condition have gone—and good riddance.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Despite the broad adoption of LINQ, I still see a number of questions which make it clear that some developers regard LINQ as a sort of magic black box. What’s going to happen when I use a query expression, compared with using extension methods directly? When does the data actually get read? How can I make it work more efficiently? Though you can learn a lot of LINQ just by playing with it and looking at examples in blog posts, you’ll get a great deal more out of it by seeing how it all works at a language level, and then learning about what the various libraries do for you.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is not a book about LINQ—I’m still concentrating on the language features that enable LINQ rather than going into details of concurrency considerations for the Entity Framework and so on. But once you’ve seen the language elements individually and how they fit together, you’ll be in a much better position to learn the details of specific providers.</font></p>
<p><a name="bookmark12"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark2217"></a>Cutting fluff with a smart compiler</font></p>
<p><a name="bookmark2218"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Automatically implemented properties</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Implicitly typed local variables</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Object and collection initializers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Implicitly typed arrays</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Anonymous types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We start looking at C# 3 in the same way that we finished looking at C# 2—with a collection of<a name="bookmark2219"></a> relatively simple features. These are just the first small steps on the path to LINQ. Each of them can be used outside that context, but almost all are important for simplifying code to the extent that LINQ requires in order to be effective.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One important point to note is that though<a name="bookmark2220"></a> two of the biggest features of C# 2— generics and nullable types—required CLR changes, there were no significant changes to the CLR that shipped with .NET 3.5. There were some tweaks, but nothing fundamental. The framework grew to support LINQ, along with introducing a few more features to the base class library, but that’s a different matter. It’s worth</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">being clear in your mind which changes are only in the C# </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">language</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">library </font><font style="font-size:x-small;font-family:Times New Roman, serif;">changes, and which are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">CLR</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> changes.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This <a name="bookmark2221"></a>means that almost all of the new features exposed in C# 3 are due to the compiler being willing to do more work for you. We saw some evidence of this in part 2—particularly with anonymous methods and iterator blocks—and C# 3 continues in the same vein. In this chapter, we’ll meet the following features that are new to C# 3:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Automatically implemented properties</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Remove the drudgery of writing simple properties backed directly by fields</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Implicitly typed local variables</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Reduce redundancy from local variable declarations by inferring the variable type from the initial value</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Object and collection initializers</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Simplify the creation and initialization of objects in single expressions</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Implicitly typed arrays</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Reduce redundancy from array creation expressions by inferring the array type from the contents</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Anonymous types</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Enable the creation of ad hoc types to contain simple properties</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In addition to describing what the new features do, I’ll make recommendations about their use. Many of the features of C# 3 require a certain amount of discretion and restraint on the part of the developer. That’s not to say they’re not powerful and incredibly useful—quite the opposite—but the temptation to use the latest and greatest funky syntax shouldn’t be allowed to overrule the drive toward clear and readable code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The considerations I’ll discuss in this chapter (and the rest of <a name="bookmark2222"></a>the book) will rarely be black<a name="bookmark2223"></a> and white. Perhaps more than ever before, readability is in the eye of the beholder—and as you become more comfortable with the new features, they’re likely to become more readable to you. I should stress, though, that unless you have good reason to suppose you’ll be the only one to ever read your code, you should consider the needs and views of your colleagues carefully.</font></p>
<p><a name="bookmark2224"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Enough navel gazing for the moment. We’ll start off with a feature that shouldn’t cause any controversy. Simple but effective, automatically implemented properties just make life better.</font></p>
<p><a name="bookmark214"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2225"></a>8.1 Automatically implemented properties</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our first feature is probably the simplest in the whole of C# 3. It’s even simpler than any of the new features in C# 2. Despite that—or possibly </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">because</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of that—it’s also immediately applicable in many, many situations. When you read about iterator blocks in chapter 6, you may not immediately have thought of any areas of your current codebase that could be improved by using them, but I’d be surprised to find any nontrivial C# program that couldn’t be modified to use automatically implemen<a name="bookmark2226"></a>ted properties. This fabulously simple feature allows you to express trivial properties with less code than before.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 8.1 Transformation of an automatically implemented property</font></p>
<p><a name="bookmark2227"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">What do I mean by a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">trivial property</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> ? I mea<a name="bookmark2228"></a>n one that’s read/write <a name="bookmark2229"></a>and that stores its value in a straightforward private variable without any validation or other custom code. Trivial properties only take a few lines of code, but it’s still a lot when you consider that you’re only expressing a very simple<a name="bookmark2230"></a> concept. C# 3 reduces the verbosity by applying a simple compile-time transformation, as shown in figure 8.1.</font></p><div><img src="images/20.png"/></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Th<a name="bookmark2231"></a>e code at the bottom isn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">qui<a name="bookmark2232"></a>te</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> valid C#, of course. The field has an unspeakable name to prevent naming collisions, in the same way as we’ve seen before for anonymous methods and iterator blocks. But that’s effectively the code that’s generated by the automatically implemented property at the top.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Where previously you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">might</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have been tempted to use a public variable for the sake of simplicity, there’s now even less<a name="bookmark2233"></a> excuse for not using a property instead. This is particularly true for throwaway code—which we all know tends to live far longer than anticipated.</font></p>
<p><a name="bookmark2234"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2235"></a><a name="bookmark2236"></a><a name="bookmark2237"></a>TERMINOLOGY: AUTOMATIC OR AUTOMATICALLY IMPLEMENTED PROPERTY? When automatically implemented properties were first discussed, long before the full C# 3 specification was published, they were called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">automatic properties</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Personally, I find this less of a mouthful than the full name, and it’s more widely used in the community. There’s no risk of ambiguity, so for the rest of this book I’ll use </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">automatic property</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">automatically implemented property</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> synonymously.</font></p>
<p><a name="bookmark2238"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2239"></a>The f<a name="bookmark2240"></a>eature of C# 2 that allows you to specify different a<a name="bookmark2241"></a>ccess for the getter and the setter is still available here, and you can also create static automatic properties. But static automatic properties are almost alwa<a name="bookmark2242"></a>ys pointless. Although most type<a name="bookmark2243"></a>s don’t claim to have thread-safe instance members, publicly visible static members usually </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">should</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be thread-safe, and the compiler doesn’t do anything to help you in this respect. Listing 8.1 gives an example of a safe, but useless, static automatic property that counts how many instances of a class have been created, along with instance properties for the name and age of a person.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 8.1 Demonstration of the awkwardness of static automatic properties</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class Person {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public string Name { get; private set; } public int Age { get; private set; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static int InstanceCounter { get; set; } private static readonly object counterLock = new object();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public InstanceCountingPerson(string name, int age)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Name = name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Age = age;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">lock (counterLock)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">InstanceCounter++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark2244"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re using a lock to make sure we don’t have threading problems, and we’d also need to use the same lock whenever we <a name="bookmark2245"></a>accessed the property. There are better alternatives here involving the Interlocked class, but they require access to fields. In short, the only scenario in which I can see static automatic properties being useful is where the get<a name="bookmark2246"></a>ter is public, the setter is private, and the setter is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> called within the type initializer.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The other properties in listing 8.1, representing the name and age of the person, tell a much happier tale—using automatic properties is a no-brainer here. Where you have properties that you’d have implemented trivially in previous versions of C#, there’s no benefit in </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> using automatic properties.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">O<a name="bookmark2247"></a>ne slight wrinkle occurs if you use automatic properties when writing your o<a name="bookmark2248"></a>wn stru<a name="bookmark2249"></a>cts: all of your constructors need to explicitly call the parameterless constructor— this()—so that the compiler knows that all the fields have been definitely assigned. You can’t set the fields directly because they’re anonymous, and you can’t use the properties until all the fields have been set. The only way of proceedin<a name="bookmark2250"></a>g is to call the parameterless constructor, which will set the fields to their default values.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s all there is to automatically implemented properties. There are no bells and whistles to them—for instance, there’s no way of decla<a name="bookmark2251"></a>ring them with initial default values, and no way of making them genuinely read-only (a private setter is as close as you can get). If all the C# 3 features were that simple, we could cover </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">everything</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in a single chapter. Of course, that’s not the case—but there are still some features that don’t take </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">too</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> much explanation. Our next topic removes duplicate code in another common but specific situation—declaring local variables.</font></p>
<p><a name="bookmark216"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2252"></a>8.2 Implicit typing of local variables</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In chapter 2, I discussed the nature of the C# 1 type system. In particular, I stated that it was static, explicit, and safe. That’s still true in C# 2, and in C# 3 it’s still </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">almost</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> completely true. The static and safe parts are still true (ignoring explicitly unsafe code, just as we did in chapter 2) and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">most</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the time it’s still explicitly typed—but you can ask the compiler to infer the types of local variables for you.<sup><a name="footnote55"></a><a href="#bookmark2253">55</a></sup></font></p>
<p><a name="bookmark217"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2254"></a><a name="bookmark2255"></a>8.2.1 Using var to declare a local variable</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In order to use implicit typing, all<a name="bookmark2256"></a> you need to do is replace the type part of a normal local variable declaration with var. Certain restrictions exist (we’ll come to those in a moment), but essentially it’s as easy as changing this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MyType variableName = someInitialValue;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">into this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var variableName = someInitialValue;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The results of the two lines (in terms of compiled code) are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly the same,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> assuming that the type of someInitialValue is MyT<a name="bookmark2257"></a>ype. The compiler simply takes the compiletime type of the initialization expression and makes the variable have that type too. The type can be any normal .NET type, including generics, delegates, and interfaces. The variable is still statically typed; you just haven’t written the name of the type in your code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is important to understand, as it goes to the heart of what a <a name="bookmark2258"></a>lot of developer<a name="bookmark2259"></a>s initially fear when they see this feature—that var makes C# dynamic or weakly typed. That’s not true at all. The best way of explaining this is to show you some invalid code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">. var stringVariable = &quot;Hello, world.&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">INVALID &nbsp;&nbsp;&nbsp;. &nbsp;&nbsp;&nbsp;. &nbsp;&nbsp;&nbsp;„ &nbsp;&nbsp;&nbsp;. , &nbsp;&nbsp;&nbsp;_</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-stringVariable = 0;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That doesn’t compile, because the type of stringVariable is System.String, and you can’t assign the value 0 to a string variable. In many dynamic languages, the code </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">would</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have co<a name="bookmark2260"></a>mpiled, leaving the variable with no particularly useful type as far as the compile<a name="bookmark2261"></a>r, IDE, or runti<a name="bookmark2262"></a>me env<a name="bookmark2263"></a>ironment is concerned. Using var is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> like using a VARIANT<a name="bookmark2264"></a> type from COM or VB6. The variable is statically typed; the type has just been inferred by the compiler. I apologize if I seem to be laboring this point somewhat, but it’s incredibly imp<a name="bookmark2265"></a>ortant, and has been the cause of a lot of confusion.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In Vis<a name="bookmark2266"></a>ual Studio, you can tell the type that the compiler has used for the variable by hovering over t<a name="bookmark2267"></a>he var part of the declaration, as shown in figure 8.2. Note how the type parameters for the generic Dictionary type are also explained.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If this looks familiar, that’s because it’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the same behavior you get when you declare local variables explicitly.</font></p><img src="images/21.png"/>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">Figure 8.2 Hovering over var in Visual Studio displays the type of the declared variable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Tooltips aren’t just available at the point of declaration, either. As you’d probably expect, the tooltip displayed when you hover over the variable name later on in the code indicates the type of the variable too. This is shown in figure 8.3, where the same declaration is used and then I’ve hovered over a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">use</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the variable.</font></p>
<p><a name="bookmark2268"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Again, that’s exactly the same behavior as a normal local variable declaration. Now, there are two reasons for bringing up Visual Studio in this context. The first is that it’s more evidence of the static typing involved—the compiler clearly knows the type of the variable. The second is to point out that you can easily discover the type involved, even from deep within a method. This’ll be important when we talk about the pros and cons of using implicit typing in a minute. First, though, I ought to mention some limitations.</font></p>
<p><a name="bookmark218"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2269"></a>8.2.2 Restrictions on implicit typing</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can’t use implicit typing for every variable in every situation. You can only use it when</font></p>
<p><a name="bookmark2270"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2271"></a>■ The<a name="bookmark2272"></a> variable being declared is a local variable, rather than a static or instance</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">field.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The variable is initialized as part of the declaration.</font></p>
<p><a name="bookmark2273"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2274"></a><a name="bookmark2275"></a>■ &nbsp;&nbsp;&nbsp;The initialization expression isn’t a method group or anonymous function<sup>2</sup> (without casting).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The initialization expression isn’t null.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Only one variable is declared in the statement.</font></p>
<p><a name="bookmark2276"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The type you want the variable to have is the compile-time type of the initialization expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The initialization expression doesn’t involve the variable being declared.<sup>3</sup></font></p><div>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;The term </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">anonymous function</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> covers both anonymous methods and lambda expressions, which we’ll delve into in chapter 9.</font></p></div><br clear="all"/><div>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;It’d be highly unusual to do so anyway, but with normal declarations it’s possible if you try hard enough.</font></p></div><br clear="all"/><img src="images/22.png"/>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">Figure 8.3 Hovering over the use of an implicitly typed local variable displays its type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The third and fourth points are interesting. You can’t write this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">INVALID^- var starter = delegate)) { Console.WriteLine)); }</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is because the compiler doesn’t know what type to use. You </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> write this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var starter = (ThreadStart) delegate() { Console.WriteLine(); }</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">but if you’re going to do that you’d be better off explicitly decla<a name="bookmark2277"></a>ring the variable in the first place. The same is true in the null case—you could cast the null appropriately, but there’d be no point. Note that you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use the result of method calls or properties as the initialization expression—you’re not limited to constants and constructor calls. For instance, you could use</font></p>
<p><a name="bookmark2278"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var args = Environment.GetCommandLineArgs();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In that case args woul<a name="bookmark2279"></a>d then be of type string[]. In fact, initializing a variable with the result of a method call is likely to be the most common situation where implicit typing is used, as part of LINQ. We’ll see all that later on—just bear it in mind as the examples progress.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s also worth noting that you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> al<a name="bookmark2280"></a>lowe<a name="bookmark2281"></a>d to use imp<a name="bookmark2282"></a>licit typing for the local variables declared in the first part of a using, for, or foreach statement. For example, the following are all valid (with appropriate bodies, of course):</font></p>
<p><a name="bookmark2283"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">for (var i = 0; i &lt;&nbsp;10; i++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using (var x = File.OpenText(&quot;test.dat&quot;))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var s in Environment.GetCommandLineArgs())</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The variables in question would end up with types of int, StreamReader, &nbsp;&nbsp;&nbsp;and string,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">respectively. Of course, just because you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> do this doesn’t &nbsp;&nbsp;&nbsp;mean &nbsp;&nbsp;&nbsp;you &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">should.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;Let’s</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">look at the reasons for and against using implicit typing.</font></p>
<p><a name="bookmark219"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2284"></a>8.2.3 Pros and cons of implicit typing</font></p>
<p><a name="bookmark2285"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The question of when it’s a good idea to use implicit typing is the cause of a lot of community discussion. Views range from “everywhere” to “nowhere” with plenty of more balanced approaches between the two. We’ll see in section 8.5 that in order to use another of C# 3’s features—anonymous types—you often </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">need</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to use implicit typing. You could avoid anonymous types as well, of course, but that’s throwing the baby out with the bathwater.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The main reason </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">for</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> using implicit typing (leaving an<a name="bookmark2286"></a>onymous types aside for the moment) is not that it reduces the nu<a name="bookmark2287"></a>mber of keystrokes required to<a name="bookmark2288"></a> enter the code, but that it makes the code less cluttered (and therefore more readable) on the screen. In particular, when generics are involved, the type names can get very long. Figures 8.1 and 8.2 used a type of Dictionary&lt;string, List&lt;Person&gt;&gt;, which is 33 characters. By the time you have that twice on a line (once for the declaration and once for the initialization), you end up with a massive l<a name="bookmark2289"></a>ine just for declaring and initializing a single variable! An alternative is to use an alias, but that puts the real type involved a long way (conceptually at least) from the code that uses it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When reading the code, there’s no point in seeing the same long type name twice on the same line when it’s obvious that they </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">should</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be the same. If the declaration isn’t visible on the screen, you’re in the same boat whether implicit typing was used or not (all the ways you’d use to find out the variable type are still valid) and if it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> visible, the expression used to initialize the variable tells you<a name="bookmark2290"></a> the type anyway.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Additionally, using var changes the emphasis of the code. Sometimes you want the reader to pay close attention to the precise types i<a name="bookmark2291"></a>nvolved, because they’re <a name="bookmark2292"></a>significant. For example, even though the generic SortedList and Sor<a name="bookmark2293"></a>tedDictionary types have similar APIs, they have different performance characteristics, and that may be important for your particular piece of code. Other times, all you really care about is the operations that are being performed: you wouldn’t really mind if the expression used to initialize the variable changed, so long as you could achieve the same goals.<sup><a name="footnote56"></a><a href="#bookmark2294">56</a></sup> Using var <a name="bookmark2295"></a>allows the reader to focus on the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">use</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of a variable rather than the declaration—the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">what</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> rather than the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">how</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All of this sounds good, s<a name="bookmark2296"></a>o what are the arguments </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">against</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> implicit typing? Paradoxically enough, readability is the most important one, despite also being an argument in favor of implicit typing! By not being explicit about what type of variable you’re declaring, you may be making it harder to work it out just by reading the code. It breaks the “state what we’re declaring, then what value it’ll start off with” mindset that keeps the declaration and the initialization separate. To wh<a name="bookmark2297"></a>at extent that’s an issue depends on both the reader and the <a name="bookmark2298"></a>initialization expression involved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’re explicitly calling a constructor, it’s always going to be pretty obvious what type you’re creating. If you’re calling a method or using a property, it <a name="bookmark2299"></a>depends on how obvious the return type is just from looking at the call. Integer literals provide a good example of a case where it’s harder to guess the type of an expression than you might suppose. How quickly can you work out the type of each of the variables declared here?</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var a = 2147483647;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var b = 2147483648;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var c = 4294967295;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var d = 4294967296;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var e = 9223372036854775807;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var f = 9223372036854775808;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The answers are int, uint, uint, long, long, and ulong, respectively—the type used depends on the value of the expression. There’s nothing new here in terms of the handling of literals—C# has always behaved like this—but implicit typing makes it easier to write obscure code in this case.</font></p>
<p><a name="bookmark2300"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The argument that’s rarely explicitly stated but that I believe is behind a lot of the concern over implicit typing is, “It just doesn’t feel right.” If you’ve been writing in a C-like language for years and years, there’s something unnerving about the</font></p>
<p><a name="bookmark2301"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2302"></a>whole business, however much you tell yourself that it’s still static typing under the covers. This may not be a rational concern, but that doesn’t make it any less real. If you’re uncomfortable, you’re likely to be less productive. If the advantages don’t outweigh your negative feelings, that’s fine. Depending on your personality, you may wish to try to push yourself to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">become</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> more comfortable with implicit typing—but you certainly don’t have to.</font></p>
<p><a name="bookmark220"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2303"></a>8.2.4 Recommendations</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here are some recommendations based on my experience with implicit typing. That’s all they are—recommendations—and you should feel free to take them with a pinch of salt:</font></p>
<p><a name="bookmark2304"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;If it’s important that someon<a name="bookmark2305"></a>e reading the code knows the type of the variable at a glance, use explicit typing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;If the variable is directly initialized with a constructor and the type name is long (which often occurs with generics), consider using implicit typing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;If the precise type of the variable isn’t important, but <a name="bookmark2306"></a>its general nature is clear from the context, use implicit typing to de-emphasize </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">how</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the code achieves its aim and concentrate on <a name="bookmark2307"></a>the higher level of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">what</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> it’s achieving.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Consult your teammates on the matter when embarking on a ne<a name="bookmark2308"></a>w project.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;When in doubt, try a line both ways and go with your gut feelings.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Unless there’s a significant gain in code simplicity, I tend to use explic<a name="bookmark2309"></a>it typing for production code. (Implicit typing is wonderful for throwaway code, though, and also test code.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Effectively, my recommendation boils down to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> using implicit typing either because it’s new or for reasons of laziness, saving a few keystrokes. Where it keeps the code tidier, allowing you to concentrate on the most important elements of the code, go for it. I’ll be using implicit typing extensively in the rest of the book, for the simple reason that code is harder to format in print than on a screen—not as much width is available.</font></p>
<p><a name="bookmark2310"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll come back to implicit typing when we see anonymous types, as they create situations where you are forced to ask the compiler to infer the types of some variables. Before that, let’s look at how C# 3 makes it easier to construct and populate a new object in one expression.</font></p>
<p><a name="bookmark222"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2311"></a>8.3 Simplified initialization</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One would’ve thought that object-oriented languages would’ve streamlined object creation long ago. After all, before you start using an object, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">something</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> has to create it, whether it’s through your code directly or a factory method of some sort. Despite this, few language features in C# 2 are geared toward making life<a name="bookmark2312"></a> easier when it comes to initialization. If you can’t do what you want using constructor arguments, you’re basically out of luck—you need to create the object, then manually initialize it with property calls and the like.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is particularly annoying when you want to create a whole bunch of objects in one go, such as in an array or other collection—without a sin<a name="bookmark2313"></a>gle-expression<a name="bookmark2314"></a> way of initializing an object, you’re forced to either use local variables for temporary manipulation, or create a helper method that performs the appropriate initialization based on parameters.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 3 comes to the rescue in a number of ways, as we’ll see in this section.</font></p>
<p><a name="bookmark223"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2315"></a>8.3.1 Defining our sample types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The expressions we’re going to be using in this section are called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">object initializers. </font><font style="font-size:x-small;font-family:Times New Roman, serif;">These are just ways of specifying i<a name="bookmark2316"></a>nitialization that should occur after an object has been created. You can set properties, set properties of properties (don’t worry, it’s simpler than it sounds), and add to collections that are accessible via properties. To demonstrate all this, we’ll use a Person class again. To start with, there’s the name and age we’ve used <a name="bookmark2317"></a>before, exposed as writable properties. We’ll provide both a parameterless constructor and one that accepts the name as a parameter. We’ll also add a list of friends and the person’s home location, both of which are accessible as read-only properties, but that can still be modified by manipulating the retrieved objects. A simple Location class provides Country and Town properties to represent the person’s home. The following listing shows the complete code for the classes.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 8.2 A fairly simple Person class used for further demonstrations</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class Person {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int Age { get; set; } public string Name { get; set; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Person&gt; friends = new List&lt;Person&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public List&lt;Person&gt; Friends { get { return friends; } }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Location home = new Location();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Location Home { get { return home; } }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Person() { } public Person(string name)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Name = name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class Location {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public string Country { get; set; } public string Town { get; set; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 8.2 is straightforward, but it’s worth noting that both the list of friends and the home location are created in a blank way when the person is created, rather than being left as just null references. The friends and home location properties are readonly, too. That’ll be important later on—but for the moment let’s look at the properties representing the name and age of a person.</font></p>
<p><a name="bookmark224"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2318"></a>8.3.2 Setting simple properties</font></p>
<p><a name="bookmark2319"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we have our Person type, we want to create some instances of it using the new features of C# 3. In this section we’ll look at setting the Name and Age properties— we’ll come to the others later.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In fact, object initiali<a name="bookmark2320"></a>zers aren’t restricted to using properties. Everything shown here also applies to fields, but the vast majority of the time you’ll be using properties. In a well-encapsulated system you’re unlikely to have access to fields anyway, unless you’re creating an instance of a type within that type’s own code. It’s worth knowing that you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use fields, of course—so for the rest of the section, just read </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">property and field</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> whenever the text says </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">property</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With that out of the way, let’s get down to business. Suppose we want to create a person called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Tom,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> who is six years old. Prior to C# 3, there were two ways this could be achieved:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person toml = new Person(); toml.Name = &quot;Tom&quot;; toml.Age = 6;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person tom2 = new Person(&quot;Tom&quot;); tom2.Age = 6;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first version simply uses the parameterless constructor and then sets both properties. The second version uses the constructor overload, which sets the name, and then sets the age afterward. Both of these options are still available in C# 3, of course, but there are other alternatives:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person tom3 = new Person() { Name=&quot;Tom&quot;, Age = 6 };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person tom4 = new Person { Name=&quot;Tom&quot;, Age = 6 };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person tom5 = new Person(&quot;Tom&quot;) { Age = 6 };</font></p>
<p><a name="bookmark2321"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The part in braces at <a name="bookmark2322"></a>the end of each line is the object initializer. Again, it’s just compiler trickery. The IL used to initialize tom3 and tom4 is identical, and is nearly<sup><a name="footnote57"></a><a href="#bookmark2323">57</a></sup> the same as we used for tom1. Predictably, the code f<a name="bookmark2324"></a>or tom5 is nearly th<a name="bookmark2325"></a>e same as for &nbsp;&nbsp;&nbsp;tom2.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how for tom4 we omitted the parentheses for the constructor. You &nbsp;&nbsp;&nbsp;can &nbsp;&nbsp;&nbsp;use &nbsp;&nbsp;&nbsp;this</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">shorthand for types with a parameterless constructor, which is what gets called in the compiled code.</font></p>
<p><a name="bookmark2326"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">After the constructor has been called, the specified properties are set in the obvious way. They’re set in the order specified in the object initializer, and you can only specify any particular property at most once—you can’t set the Name property twice, for example. (You could call the constructor taking the name as a parameter, and then set the Name property. It would be pointless, but the compiler wouldn’t stop you from doing it.) The expression used as the value for a property can be any expression that isn’t itself an assignment—you can call methods, create new objects (potentially using another object initializer), pretty much anything.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may be wondering just how useful this is—we’ve saved one or two lines of code, but surely that’s not a good enough reason to make the language more complicated, is it? There’s a subtle point here, though: we haven’tjust created an object in one </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">line</font><font style="font-size:x-small;font-family:Times New Roman, serif;">— we’ve created it in one </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">expression.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> That difference can be very important. Suppose you want to create an array<a name="bookmark2327"></a> of type Person [] with some predefined data in it. Even without using the implicit array typing we’ll see later, the code is neat and readable:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person[] family = new Person[]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark2328">new Person { Name = &quot;Holly&quot;, Age = 34 }, new Person &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;Jon&quot;, Age &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;33 },</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark2329">new Person &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;Tom&quot;, Age &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;6 &nbsp;&nbsp;&nbsp;},</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Person &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;William&quot;, &nbsp;&nbsp;&nbsp;Age &nbsp;&nbsp;&nbsp;= 3 },</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark2330">new Person &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;Robin&quot;, Age &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;3 }</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now, in a simple example like this we could’ve written a constructor taking both the name and age as parameters, and initialized the array in a similar way in C# 1 or 2. Bu<a name="bookmark2331"></a>t appropriate constructors aren’t always available—and if there are several constructor parameters, it’s often not clear which one means wha<a name="bookmark2332"></a>t just from the position. By the time a constructor needs to take five or six parameters, I often find myself relying on IntelliSense more than I want to. Using the property names is a great boon to readability in such cases.<sup>6</sup></font></p>
<p><a name="bookmark2333"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This form of object initializer is the one you’ll probably use most often. But there are two other forms—one for setting subproperties, and one for adding to collections. Let’s look at subproperties—properties of properties—first.</font></p>
<p><a name="bookmark225"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2334"></a>8.3.3 Setting properties on embedded objects</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we’ve found it easy to set the Name and Age properties, but we can’t set the Home property in the same way—it’s read-only. We </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> set the town and t<a name="bookmark2335"></a>he country of a person, by first fetching t<a name="bookmark2336"></a>he Home property and then setting properties on the result. The language specification refers to this as setting the properties of an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">embedded object.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Just to make it clear, what we’re talking about is the following C# 1 code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person tom = new Person(&quot;Tom&quot;); tom.Age = 6;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">tom.Home.Country = &quot;UK&quot;; tom.Home.Town = &quot;Reading&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When we’re populating the home location, each statement is doing a get to retrieve the Location instance, and then a set on the relevant property on that instance. There’s nothing new in that, but it’s worth slowing your mind down to look at it carefully; otherwise, it’s easy to miss what’s going on behind the scenes.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 3 allows all of this to be done in one expression, as shown here:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person tom = new Person(&quot;Tom&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Age = 6,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Home = { Country = &quot;UK&quot;, Town = &quot;Reading&quot; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiled code for these snippets is effectively the same. The compiler spots that to the right side of the = sign is another object initializer, and applies the properties to the embedded object appropriately. O<a name="bookmark2337"></a>ne point about the formatting I’ve used—just as in almost all C# features, it’s whitespace-independent: you can collapse the whitespace in the object initializ<a name="bookmark2338"></a>er, putting it all<a name="bookmark2339"></a> on one line if you like. It’s up to you to work out where the sweet spot is in b<a name="bookmark2340"></a>alancing long lines against lots of lines.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The absence of the new keyword in the part initializing Home is significant. If you need to work out where the compiler is going to create new objects and where it’s going to set properties on existing ones, look for occurrences of new in the initializer. Every time a new object is created, the new keyword appears </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">somewhere.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve dealt with the Home property—but what about Tom’s friends? There are properties we can set on a List&lt;Person&gt;, but none of them will add entries to the list. It’s time for the next feature—collection initializers.</font></p>
<p><a name="bookmark226"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2341"></a>8.3.4 Collection initializers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Creating a collection with some initial values is an extremely common task. Until C# 3 arrived, the only language feature that gave any assistance was ar<a name="bookmark2342"></a>ray creation—and even that was clumsy in many situations. C# 3 has </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">collection initializers,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which allo<a name="bookmark2343"></a>w you to use the same type of syntax as array initializers but with arbitrary collections and more flexibility.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-variant:small-caps;">creating new collections with collection initializer<a name="bookmark2344"></a>s</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As a first example, let’s use the now-familiar List&lt;T&gt; type. In C# 2, you could populate a list either by passing in an existing collection or by calling Add repeatedly after creating an empty list. Collection initializers in C# 3 take the latter approach. Suppose we want to populate a list of strings with some names—here’s the C# 2 code (on the left) and the close equivalent in C# 3 (on the right):</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;string&gt; names = new List&lt;string&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">names.Add(&quot;Holly&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">names.Add(&quot;Jon&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">names.Add(&quot;Tom&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">names.Add(&quot;Robin&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">names.Add(&quot;William&quot;);</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var names = new List&lt;string&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Holly&quot;, &quot;Jon&quot;, &quot;Tom&quot;, &quot;Robin&quot;, &quot;William&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just as with object initializers, you can specify constructor parameters if you want, or use<a name="bookmark2345"></a> a parameterless constructor either explicitly or implicitly. The use of implicit typing here was partly for space reasons—the names variable could equally well have been declared explicitly. Reducing the number of lines of code (without reducing readability) is nice, but there are two bigger benefits of collection initializers:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The create-and-initialize<a name="bookmark2346"></a> part counts as a single expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;There’s a lot less clutter in the code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first point becomes important when you want to use a collection as either an argument to a method or as one element in a larger collection. That happens </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">relatively </font><font style="font-size:x-small;font-family:Times New Roman, serif;">rarely (although often enough to still be useful)—but the second point is the real reason this is a killer feature in my view. If you look at the code on the right, you can easily see the information you need, with each piece of information written only once. The variable name occurs once, the type being used occurs once, and each of the elements of the initialized collection appears once. It’s al<a name="bookmark2347"></a>l extremely simple, and much clearer than the C# 2 cod<a name="bookmark2348"></a>e, which contains a lot of fluff around the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">useful</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> bits.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Collection initializers are<a name="bookmark2349"></a>n’t limited to just lists. You can use t<a name="bookmark2350"></a>hem with any type that implements IEnumerable, as long as it has an appropriate Add method for each element in the initializer. You can use an Add method with more than one parameter by putting the values within another set of braces. The mos<a name="bookmark2351"></a>t common use for this is creating dictionaries. For example, if we wanted a dictionary mapping names to ages, we could use the following code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dictionary&lt;string,int&gt; nameAgeMap = new Dictionary&lt;string,int&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ &quot;Holly&quot;, 34 },</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ &quot;Jon&quot;, 33 },</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ &quot;Tom&quot;, 6 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><a name="bookmark2352"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In this case, the Add(string, int) method would be called three times. If multiple Add methods are available, different elements of the initializer can call different overloads. If no compatible overload is available for a specified element, the code will fail to compile. There are two interesting points about the design decision here:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The fact that the type has to implement IEnumerable is never used by the compiler.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The Add method is only found by name—there’s no interface requirement specifying it.</font></p>
<p><a name="bookmark2353"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">These are both pragmatic decisions. Requiring IEnumerable to be implemented is a reasonable attempt to check that the type really is a collection of some sort, and using any accessible overload of the Add method (rather than requiring an exact signature) allows for simple initializations such as the earlier dictionary example.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">An early draft of the C# 3 specification required ICollection&lt;T&gt; to be implemented instead, and the implementation of the single-parameter Add method (as specified by the interface) was called rather than allowing different overloads. This sounds more pure, but there are far more types that implement IEnumerable than ICollection&lt;T&gt;—and using the single-parameter Add method would be inconvenient. For example, in our cas<a name="bookmark2354"></a>e it would’ve forced us to explicitly create an instance of a KeyValuePair&lt;string,int&gt; for each element of the initializer. Sacrificing a bit of academic purity has made the language far more useful in real life.</font></p>
<p><a name="bookmark2355"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">POPULATING COLLECTIONS WITHIN OTHER OBJECT INITIALIZERS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we’ve only seen collection initializers used in a stand-alone fashion to create whole new collections.<a name="bookmark2356"></a> They can also be combined with object initializers to populate embedded collections. To show this, we’ll go back to our Person example. The Friends property is read-only, so we can’t create a new collection and specify that as the collection of friends—but we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> add to whatever collection is returned by the property’s getter. The way we do this is similar to the syntax we’ve already seen for setting properties of embedde<a name="bookmark2357"></a>d objects, but we just specify a collection initializer instead of a sequence of properties.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s see this in action by creating another Person instance for Tom, this time with some of his friends.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 8.3 Building up a rich object using object and collection initializers</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Person tom = new Person</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Name = &quot;Tom&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Age = 6,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Home = { Town = &quot;Reading&quot;, Country = &quot;UK&quot; }, Friends =</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Person { Name = &quot;Alberto&quot; }, new Person(&quot;Max&quot;),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Person { Name = &quot;Zak&quot;, Age = 4 }, new Person(&quot;Ben&quot;), new Person(&quot;Alice&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Age = 6,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Home = { Town = &quot;Twyford&quot;, Country=&quot;UK&quot; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 8.3 uses all the features of object and collection initializers we’ve come across. The main part of interest is the collection initializer, which itself uses lots of different forms of object initializers internally. Note that we’re not creating a new collection here, just adding to an existing one. (If the property had a setter, we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> create a new collection and still use collection initializer syntax.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We could’ve gone further, specifying friends of friends, friends of friends of friends, and so forth. But we couldn’t specify that Tom is Alberto’s friend—while you’re still i<a name="bookmark2358"></a>nitializing an object, you don’t have access to it, so you can't express cyclic relationships. This can be awkward in a few cases, but usually isn’t a problem.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Collection initialization within object initializers works as a<a name="bookmark2359"></a> sort of cross between stand-alone collection initializers and setting embedded object properties. For each element in the collection initializer, the col<a name="bookmark2360"></a>lection property getter (Friends in this case) is called, and then the appropriate Add method is called on the returned value. The collection isn’t cleared in any way before elements are added. For example, if you were to decide that a person should always be his own friend, and added this to the</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">list of friends within the Person constructor, using a collection initializer would only add extra friends.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see, the combination of collection and object initializers can be used to populate whole trees of objects. But when and where is this likely to actually happen?</font></p>
<p><a name="bookmark227"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2361"></a>8.3.5 Uses of initialization features</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Trying to pin <a name="bookmark2362"></a>down exactly where these features are useful is reminiscent of being in a Monty Python sketch about the Spanish Inquisition—every time you think you have a reasonably complete list, another common example pops up. I’ll just mention three examples, which I hope will encourage you to consider where else </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">you</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> might use them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CONSTANT COLLECTIONS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s not uncommon for me to want some kind <a name="bookmark2363"></a>of collection (often a map) that’s effectively constant. Of course, it can’t be a constant as far as the C# language is concerned, but it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be declared static and read-only, with big warnings to say that it shouldn’t be changed. (It’s usual<a name="bookmark2364"></a>ly private, so that’s good enough. Alternatively, you can use <a name="bookmark2365"></a>Read-OnlyCollecti<a name="bookmark2366"></a>on&lt;T&gt;.) Typically, this used to involve writing a static constructor or a helper method, just to popu<a name="bookmark2367"></a>late the map. With C# 3’s collection initializers, it’s easy to set the whole thing up inline.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">SETTING Up UNIT TESTS</font></p>
<p><a name="bookmark2368"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When writing unit tests, I frequently want to populate an object just for one test, often passing it in as an argument to the method I’m trying to test at the time. Writing all of the initialization longhand can be long-winded and <a name="bookmark2369"></a>also hides the essential structure of the object from the reader of the code, just as XML creation code can often obscure what the document would look like if <a name="bookmark2370"></a>you viewed it (appropriately formatted) in a text editor. With appropriate indentation of object initializers, the nested structure of the object hierarchy can become obvious in the very shape of the code, as well as make the values stand out more than they would otherwise.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">THE BUILDER PATTERN</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For various reasons, sometimes you want to specify a lot of values for a single method or constructor call. The most common situation in my experience is creating an immutable object. Instead of having a huge set of parameters (which can become a readability problem <a name="bookmark2371"></a>as the meaning of each argument becomes unclear<sup><a name="footnote58"></a><a href="#bookmark2372">58</a></sup>), you can use the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">builder pattern:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> create a mutable type with appropriate properties, and then pass an instance <a name="bookmark2373"></a>of the builder into the constructor or method. The framework ProcessStartInfo typ<a name="bookmark2374"></a>e is a good example of this—the designers </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have overloaded Process.Start with many different sets of parameters, but using Process-StartInfo makes everything clearer.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Object and collection initializers allow you to create the builder object in a clearer manner—you can even specify it inline when you call the original member if you</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">want. Admittedl<a name="bookmark2375"></a>y you still have to write the builder type in the first place—but automatic properties help on that front.</font></p>
<p><a name="bookmark2376"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">&lt;INSERT YOUR FAVORITE USE HERE&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, there are uses beyond these three in ordinary code, and I don’t want to put you off using the new features elsewhere. There’s little reason </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to use them, other than possibly confusing developers who aren’t familiar with C# 3 yet. You may decide that using an object initializer just to set one property (as opposed to just explicitly setting it in a separate statement) is over the top—that’s a matter of aesthetics, and I can’t give you much objective guidance there. As with implicit typing, it’s <a name="bookmark2377"></a>a good idea to try the code both ways, and learn to predict your own (and your team’s) reading preferences.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we’ve looked at a fairly diverse range of features: implementing properties easily, simplifying local variable declarations, and populating objects in single expressions. In the remainder of this chapter we’ll be gradually bringing these topics together, using more implicit typing and more object population, and creating whole </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">types</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> without giving any implementation details.</font></p>
<p><a name="bookmark2378"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Our next topic appears to be quite similar to collection initializers when you look at code using it. I mentioned earlier that array initialization was a bit clumsy in C# 1 and 2. I’m sure it won’t surprise you to learn that it’s been streamlined for C# 3. Let’s take a look.</font></p>
<p><a name="bookmark229"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2379"></a>8.4 Implicitly typed array<a name="bookmark2380"></a>s</font></p>
<p><a name="bookmark2381"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In C# 1 and 2, initializing an array as part of a variable declaration and initialization statement was quite neat—but if you wanted to do it anywhere else, you had to specify the exact array type involved. So for example, this compiles without any problem:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string[] names = {&quot;Holly&quot;, &quot;Jon&quot;<a name="bookmark2382"></a>, &quot;Tom&quot;, &quot;Robin&quot;, &quot;William&quot;};</font></p>
<p><a name="bookmark2383"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This doesn’t work for parameters, though: suppose we want to make a call to MyMethod, declared as void MyMethod(string[] names). This code won’t work:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">INVALID^, MyMethod){&quot;Holly&quot;, &quot;Jon&quot;, &quot;Tom&quot;, &quot;Robin&quot;, &quot;William&quot;});</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Instead, you have to tell the compiler what type of array you want to initialize: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MyMethod(new string[] {&quot;Holly&quot;, &quot;Jon&quot;, &quot;Tom&quot;, &quot;Robin&quot;, &quot;William&quot;});</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 3 allows something in between:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MyMethod(new[] {&quot;Holly&quot;, &quot;Jon&quot;, &quot;Tom&quot;, &quot;Robin&quot;, &quot;William&quot;});</font></p>
<p><a name="bookmark2384"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Clearly the compiler needs to work out wha<a name="bookmark2385"></a>t type of array to use. It starts by forming a set containing all the compile-time types of the expressions inside the braces. If there’s exactly one type in that set that all the others can be implicitly converted to, that’s the type of the<a name="bookmark2386"></a> array. Otherwise, (or if all the<a name="bookmark2387"></a> values are typeless expressions, such as constant null values or anonymous methods, with no casts) the code won’t compile. Note that only the types of the expressions are considered as candidates for the overall array type. This means that occasionally you might have to explicitly cast a value to a less-specific type. For instance, this won’t compile:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">INVALID^. new[] { new MemoryStream () , new StringWriter () &nbsp;&nbsp;&nbsp;}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s no conversion from MemoryStream to StringWriter, or vice versa. Both are implicitly convertible to object and IDisposable, but the compiler only considers types that are in the original set produced by the expressions themselves. If we change one of the expressions in this situation so that its type is either object or IDisposable, the code compiles:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new[] { (IDisposable) new MemoryStream(), new StringWriter() }</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The type of this last expression is implicitly IDisposable[]. Of course, at that point you might as well explicitly state the type of the array just as you would in C# 1 and 2, to make it clearer what you’re trying to achieve.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Compared with the earlier features, implicitly typed arrays are a bit of an anticlimax. I find it hard to get excited about them, even though they </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> make life simpler in cases where an array is passed as an argumen<a name="bookmark2388"></a>t. You could argue that this feature do<a name="bookmark2389"></a>esn’t prove itself in the usefulness/complexity balance used by the language designers to decide what should be part of the language.</font></p>
<p><a name="bookmark2390"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The designers haven’t gone mad, though—there’s one important situation in which this implicit typing is absolutely crucial. That’s when you don’t know (and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;">know) the name of the type of the elements of the array. How can you possibly get into this peculiar state? Read on...</font></p>
<p><a name="bookmark231"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2391"></a>8.5 Anonymous types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Implicit typing, object and collection initializers, and implicit array typing are all useful in their own right, to a greater or lesser extent. But they also serve a higher pur-pose—they make it possible to work with this chapter's final feature, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">anonymous types. </font><font style="font-size:x-small;font-family:Times New Roman, serif;">They, in turn, serve a higher purpose—LINQ.</font></p>
<p><a name="bookmark232"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2392"></a>8.5.1 First encounters of the anonymous kind</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s much easier to explain anonymous types when you already have some idea of what they are through an example. I’m sorry to say that without the use of extension methods and lambda expressions, the examples in this section are likely to be a little contrived, but there’s a distinct chicken-and-egg situation here: anonymous types are most useful within the context of the more advanced features, but we need to understand the building blocks before we can see much of the bigger picture. Stick with it— it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">will</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> make sense in the long run, I promise.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s pretend we didn’t have the Person class, and the only properties we cared about were the name and age. Listing 8.4 shows how we could still build objects with those properties, without ever declaring a type.</font></p>
<p><a name="bookmark2393"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 8.4 Creating objects of an anonymous type with Name and Age properties</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var tom = &nbsp;&nbsp;&nbsp;new { &nbsp;&nbsp;&nbsp;Name = &nbsp;&nbsp;&nbsp;&quot;Tom&quot;, Age &nbsp;&nbsp;&nbsp;= 6 };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var holly &nbsp;&nbsp;&nbsp;= new &nbsp;&nbsp;&nbsp;{ Name &nbsp;&nbsp;&nbsp;= &quot;Holly&quot;, &nbsp;&nbsp;&nbsp;Age = 34 &nbsp;&nbsp;&nbsp;};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var jon = &nbsp;&nbsp;&nbsp;new { &nbsp;&nbsp;&nbsp;Name = &nbsp;&nbsp;&nbsp;&quot;Jon&quot;, Age &nbsp;&nbsp;&nbsp;= 33 };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0} is {1} years old&quot;, jon.Name, jon.Age);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can tell from listing 8.4, the syntax for initializing an anonymous type is similar to the object initializers we saw in section 8.3.2—it’s just that the name of the type is missi<a name="bookmark2394"></a>ng between new and the opening brace. We’re using implicitly typed local variables because that’s all we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use (other than object of course)—we don’t have a type name to declare the variable with. As you can see from the last line, the type has properties for the Name and Age, both of which <a name="bookmark2395"></a>can be read and which will have the values specified in the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">anonymous object initializer</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> used to create the instance—so in this case the output is “Jon is 33 years old.” The properties have the same types as the expressions in the initializers—string for Name, and int for Age. Just as in normal object initializers, the expressions used in anonymous object initializers can call methods or constructors, fetch properties, perform calculations—whatever you need to do.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may now be starting to see why implicitly typed arrays are important. Suppose we want to create an array containing the whole family, and then iterate through it to work out the total age.<sup><a name="footnote59"></a><a href="#bookmark2396">59</a></sup> The following listing does just that—and demonstrates a few other interesting features of anonymous types at the same time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 8.5 Populating an array using anonymous types and then finding the total age</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var family = new[]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark2397">new &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;Holly&quot;, Age &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;34 },</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark2398">new &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;Jon&quot;, Age = &nbsp;&nbsp;&nbsp;33 },</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark2399">new &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;Tom&quot;, Age = &nbsp;&nbsp;&nbsp;6 &nbsp;&nbsp;&nbsp;},</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark2400">new &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;Robin&quot;, Age &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;3 },</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark2401">new &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;William&quot;, Age &nbsp;&nbsp;&nbsp;= 3 &nbsp;&nbsp;&nbsp;}</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int totalAge = 0; foreach (var person in family)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">totalAge += person.Age;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Total age: &nbsp;&nbsp;&nbsp;{0}&quot;, &nbsp;&nbsp;&nbsp;totalAge);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Putting together listing 8.5 and what we learned about implicitly typed arrays in section 8.4, we can deduce something important: </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all the people in the family are of the same type.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> If each use of an anonymous object initializer in Q referred to a different type, the compiler coul<a name="bookmark2402"></a>dn’t infer an appropriate type for the array declared at O. Within any given assembly, the compiler treats two anonymous object initializers as the same</font></p><img src="images/23.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 8.4 Hovering over a variable that’s declared (implicitly) to be of an anonymous type shows the details of that anonymous type.</font></p>
<p><a name="bookmark2403"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">type if there are the same nu<a name="bookmark2404"></a>mber of properties, with the same names and types, and they appear in the same order. In other words, if we swapped the Name and Age properties in one of the initializers, there’d be two different types involved—likewise if we introduced an extra property in one line, or used a long instead of an int for the age of one person,<a name="bookmark2405"></a> another anonymous type would’ve been introduced. At that point the type inference for the array would fail.</font></p>
<p><a name="bookmark2406"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">IMPLEMENTATION DETAIL: HOW MANY TYPES? If you ever decide to loo<a name="bookmark2407"></a>k at the IL (or decompiled C#) for an anonymous type generated by Microsoft 's compiler, be aware that although two anonymous object initializers with the same property names in the same order but using different property types will produce two different types, they’ll actually be generated from a single generic type. The generic type is parameterized, but the closed, constructed types will be different because they’ll be given different type arguments for the different initializers.</font></p>
<p><a name="bookmark2408"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Notice that we can use a foreach statement to iterate over the array just as we would any other collection. The type involved is inferred ©, and the type of the person variable is the same anonymous type we’ve used in the array. Again, we can use the same variable for different instances because they’re all of the same type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 8.5 also proves that the Age property really is strongly typed as an int— otherwise trying to sum the ages © <a name="bookmark2409"></a>wouldn’t compile. The compiler knows about the an<a name="bookmark2410"></a>onymous type, and Visual Studio is even willing to share the information via tooltips, just in case you’re uncertain. Figure 8.4 shows the result of hovering over the person part of the person.Age expression from listing 8.5.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve seen anonymous types in action, let’s go back and look at what the compiler is actually doing for us.</font></p>
<p><a name="bookmark233"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2411"></a>8.5.2 Members of anonymous types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Anonymous types are created by the compiler and included in the compiled assembly in the same way as the extra types for anonymous methods and iterator blocks. The CLR treats them as perfectly ordinary types, and so they are—if you later move from an anonymous type to a normal, manually coded type with the behavior described in this section, you shouldn’t see anything change. Anonymous types contain the following members:</font></p>
<p><a name="bookmark2412"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2413"></a>■ &nbsp;&nbsp;&nbsp;A constructor taking all the initialization values. The parameters are in the same order as they were specified in the anonymous object initializer, and have the same names and types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Public read-only prope<a name="bookmark2414"></a>rties.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Private read-only fiel<a name="bookmark2415"></a>ds backing the<a name="bookmark2416"></a> properties.</font></p>
<p><a name="bookmark2417"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2418"></a>■ &nbsp;&nbsp;&nbsp;Overrides for Equals, GetHashCode, and ToString.</font></p>
<p><a name="bookmark2419"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2420"></a>That’s it—there are no implemented interfaces, no cloning or serialization capabilities—just a constructor, some properties, and the normal methods from obj ect.</font></p>
<p><a name="bookmark2421"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The constructor and the properties do the obvious things. Equality between two instances of the same anonymous type is determined in the natural manner, comparing each property value in turn using the property type’s Equals method. The hash code generation is similar, calling GetHashCode on each property value in turn and combining the results. The exact method for combining the various hash codes together to form one composite hash is unspecified, and you shouldn’t write code that depends on it anyway—you just need to be confident that two equal instances will return the same hash, and two unequal instances will </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">usually</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> return different hashes. All of this only works if the Equals and GetHashCode implementations of all the different types involved as properties conform to the normal rules, of course.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note that because the properties are read-only, all anonymous types are immutable so long as the types used for their properties are immutable. This provides you with all the normal benefits of immutability—being able to pass v<a name="bookmark2422"></a>alues to methods without fear of them changing, simple sharing of data across threads, and so forth.</font></p>
<p><a name="bookmark2423"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">VB ANONYMOUS TYPE PROPERTIES ARE MUTABLE BY DEFAULT Anonymous types are also available in Visual Basic 9 and 10. But by default their properties are mutable: you need to declare any properties you want to be immutable with the Key modifier. Only properties declared as keys are used in hashing and equality comparisons. This is easy to overlook when converting code from one language to another.</font></p>
<p><a name="bookmark2424"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re almost done with anonymous types now. But there’s one slight wrinkle still to talk about—a shortcut for a situation that’s fairly common in LINQ.</font></p>
<p><a name="bookmark234"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2425"></a>8.5.3 Projection initializers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The anonymous object initializers we’ve seen so far have all been lists of name/value pairs—Name=&quot;Jon&quot;, Age=33 and the like. As it happens, I’ve always used constants because they make for smaller examples, but in real code you often want to copy properties from an existing object. Sometimes you’ll want to manipulate the values in some way, but often a straight copy is enough.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Again, without LINQ it’s hard to give convincing examples of this, but let’s go back to our Person class, and just </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">suppose</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> we had a good reason to want to convert a collection of Person instances into a similar collection where each element has just a name</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">and a flag to say whether that person is an adult. Given an appropriate person variable, we could use something like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new { Name = person.Name, IsAdult = (person.Age &gt;= 18) &nbsp;&nbsp;&nbsp;}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That works, and for just a single property the syntax for setting the <a name="bookmark2426"></a>name (the part in bold) isn’t too clumsy—but if you were copying several properties it would get tiresome. C# 3 provides a shortcut: if you don’t specify the property name, but just the expression to evaluate for the value, it’ll use the last part of the expression as the name—provided it’s a simple field or property. This is called a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">projection initializer.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> It means we can rewrite the previous code as</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new { person.Name, IsAdult = (person.Age &gt;= 18) &nbsp;&nbsp;&nbsp;}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s common for all the bits of an anonymous object initializer to be projection initial-izers—it typically happens when you’re taking some properties from one object and some properties from another, often as part of a join operation. Anyway, I’m getting ahead of myself. Th<a name="bookmark2427"></a>e following listing shows the previous code in action, using the List&lt;T&gt;.ConvertAll method and an anonymous method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 8.6 Transformation from Person to a name and adulthood flag</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Person&gt; family = new List&lt;Person&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Person { Name=&quot;Holly&quot;, Age=34 }, new Person { Name=&quot;Jon&quot;, Age=33 }, new Person { Name=&quot;Tom&quot;, Age=6 }, new Person { Name=&quot;Robin&quot;, Age=3 }, new Person { Name=&quot;William&quot;, Age=3 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var converted = family.ConvertAll(delegate(Person person)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ return new { person.Name, IsAdult = (person.Age &gt;= 18) &nbsp;&nbsp;&nbsp;}; &nbsp;&nbsp;&nbsp;}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var person in converted)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0} is an adult? {1}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">person.Name, person.IsAdult);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In addition to the use of a projection i<a name="bookmark2428"></a>nitializer for the Name prop<a name="bookmark2429"></a>erty, listing 8.6 shows the value of delegate type inference and anonymous methods. Without them, we couldn’t have retained our strong typing of converted, as we wouldn’t have been able to specify what the TOutput type parameter of Converter should be. As it is, we can iterate through the new list and access the Name and IsAdult properties as if we were using any other type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Don’t spend too long thinking about projection initializers at this point—the important thing is to be aware that they exist, so you won’t get confused when you see them later. In fact, that advice applies to this entire section on anonymous types—so without going into details, let’s look at why they’re present at all.</font></p>
<p><a name="bookmark235"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2430"></a><a name="bookmark2431"></a>8.5.4 What's the point?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I hope you’re not feeling cheated at this point, but I sympathize if you are. Anonymous types are a fairly complex solution to a problem we haven’t really encountered yet... except that I bet you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> seen part of the problem b<a name="bookmark2432"></a>efore, really.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’ve ever done any real-life work involving databases, you’ll know that you don’t always want all of the data that’s available on all the rows that match your query criteria. Often<a name="bookmark2433"></a> it’s not a problem to fetch more than you need, but if you only need two columns out of the 50 in the table, you wouldn’t bother to select all 50, would you?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The s<a name="bookmark2434"></a>ame problem occurs in nondatabase code. Suppose we have a class that reads a log file and produces a sequence of log lines with many fields. Keeping all of the information might <a name="bookmark2435"></a>be far too memory-intensive if we only care about a couple of fields from the log. LINQ lets you filter that information easily.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But what’s the result of that filtering? <a name="bookmark2436"></a>How can we keep some data and discard the rest? How can we easily keep some </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">derived</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> data that isn’t directly represented in the original form? How can we combine pieces of data that may not initially have been consciously associated, or that may only have a relationship in a particular situation? Effectively, we want a new data type—but manually creating such a type in every situation is tedious, particularly when you have tools such as LINQ available that make the rest of the process so simple. Figure 8.5 shows the three elements that make anonymous types a powerful feature.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you find yourself creating a type t<a name="bookmark2437"></a>hat’s only used in a single method, and that only contains fields and trivial properties, consider whether an anonymous type would be appropriate. I suspect that you’ll find that most of the times when you find yourself leaning toward anonymous types, you could also use LINQ to help you.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you find yourself using the same sequence of properties for the same purpose in several places, though, you might want to consider creating a normal type for the purpose, even if it still just contains trivial properties. Anonymous types naturally infect whatever code they’re used in with implicit typing—which is often fine, but can be a nuisance at other times. In particular, it means you can't easily create a method to</font></p><div><img src="images/24.png"/></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 8.5 Anonymous types allow you to keep just the data you need for a particular situation, in a form that’s tailored to that situation, without the tedium of writing a fresh type each time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">return an instance of that type in a strongly typed way. As with the previous features, use anonymous types when they genuinely make the code simpler to work with, not just because they’re new and cool.</font></p>
<p><a name="bookmark236"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2438"></a>8.6 Summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">What a seemingly mixed bag of features! We’ve seen four features that are quite similar, at least in syntax: object initializers, collection initializers, implicitly typed arrays, and anonymous types. The other two features—automatic properties and implicitly typed local variables—are somewhat different. Likewise, most of the features would’ve been useful individually in C# 2, whereas implicitly typed arrays and anonymous types only pay back the cost of learning about them when the rest of the C# 3 features are brought into play.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So what<a name="bookmark2439"></a> <a name="bookmark2440"></a>do these features really have in common? </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">They <a name="bookmark2441"></a>all relieve the developer of tedious coding.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> I’m sure you don’t enjoy writing trivial properties any more than I do, or setting several properties, one at a time, using a local variable—particularly when you’re trying to build up a collection of similar objects. Not only do the new features of C# 3 make it easier to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">write</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the code, they also make it easier to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">read</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> it, at least when they’re applied sensibly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In our next chapter we’ll look at a major new language feature, along with a framework feature it provides direct support for. If you thought anonymous methods made creating delegates easy, just wait until you see lambda expressions.</font></p>
<p><a name="bookmark13"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark2442"></a>Lambda expressions and expression trees</font></p>
<p><a name="bookmark2443"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Lambda expression syntax</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Conversions from lambdas to delegates</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Expression tree framework classes</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Conversions from lambdas to expression trees</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Why expression trees matter</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Changes to type inference</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Changes to overload resolution</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In chapter 5 we saw how C# 2 made delegates much easier to use due to implicit conversions of method groups, anonymous methods, and return type and parameter variance. This is enough to make event subscription significantly simpler and more readable, but delegates in C# 2 are st<a name="bookmark2444"></a>ill too bulky to be used all the time: a page of code full of anonymous methods is painful to read, and you wouldn’t want to start putting multiple anonymous methods in a single statement on a regular basis.</font></p>
<p><a name="bookmark2445"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2446"></a>One of the fundamental building blocks of LINQ is the ability to create pipelines of operations, along with any state required by those operations. These operations can express all kinds of logic about data: how to filter it, how to order it, how to join different data sources together, and much more. When LINQ q<a name="bookmark2447"></a>ueries are executed inprocess, those operations are usually represented by delegates.</font></p>
<p><a name="bookmark2448"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Statements c<a name="bookmark2449"></a>ontaining several delegates are common when manipulating data with LINQ to Objects,<sup><a name="footnote60"></a><a href="#bookmark2450">60</a></sup> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lambda expressions</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in C# 3 make all of this possible without sacrifici<a name="bookmark2451"></a>ng readability. (While I’m mentioning readability, this chapter uses </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lambda expression</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lambda</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> interchangeably; as I need to refer to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">normal</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> expressions quite a lot, it helps to use the short version in many cases.)</font></p>
<p><a name="bookmark2452"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">IT’S ALL GREEK TO ME The term </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lambda expression</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> comes from </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lambda calculus, </font><font style="font-size:x-small;font-family:Times New Roman, serif;">also written as X-calculus, where X is the Greek letter lambda. This is an area of math and computer science dealing with defining and applying funct<a name="bookmark2453"></a>ions. It’s be<a name="bookmark2454"></a>en around for a long time and is the basis of functional languages such as ML. The good news is that you don’t need to know lambda calculus to use lambda expressions in C# 3.</font></p>
<p><a name="bookmark2455"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Executing delegates is only part of the LINQ story. To use databases and other query engines efficiently, we need a different representation of the operations in the pipeline: a way to treat code as data that can be examined programmatically. The logic within the operations can then be transformed into a different form, such as a web service call, a SQL or LDAP query—whatever’s appropriate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although it’s possible to build up representations of queries in a particular API, it’s usually tricky to read and sacrifices a lot of compiler support. This is where lambdas save the day again: not only can they be used to creat<a name="bookmark2456"></a>e delegate instances, but the C# compiler <a name="bookmark2457"></a>can also transform them into </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">expression trees</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—data structures representing the logic of the lambda expressions so that other code can examine it. In short, lambda expressions are the idiomatic way of representing the operations in LINQ data pipelines—but we’ll take things one step at a time, examining them in a fairly isolated way before we embrace the whole of LINQ.</font></p>
<p><a name="bookmark2458"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In this chapter we’ll look at both ways of using lambda expressions, although for the moment our coverage of expression trees will be relatively basic—we’re not going to create any SQL just yet. With the theory under your belt, you should be relatively comfortable with lambda expressions and expression trees by the time we hit the really impressive stuff in chapter 12.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In the final part of this chapter, we’ll examine how type inference has changed for C# 3, mostly due to lambdas with implicit parameter types. This is a bit like learning how to tie shoelaces: far from exciting, but without this ability you’ll trip over yourself when you start running.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s begin by seeing what lambda expressions look like. We’ll start with an anonymous method and gradually transform it into shorter and shorter forms.</font></p>
<p><a name="bookmark239"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2459"></a>9.1 &nbsp;&nbsp;&nbsp;Lambda expressions as del<a name="bookmark2460"></a>egates</font></p>
<p><a name="bookmark2461"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In many ways, lambda expressions can be seen as an evolution of anonymous methods from C# 2. Lambda expressions can do almost everything that anonymous methods can,<sup><a name="footnote61"></a><a href="#bookmark2462">61</a></sup> and they’re almost <a name="bookmark2463"></a>always more readable and compact. In particular, the behavior of captured variables is exactly the same in lambda expressions as in anonymous methods. In the most explicit form, not much difference exists between the two—but lambda expressions have a lot of shortcuts available to make them compact in common situations. Like anonymous methods, lambda expressions have special conversion rules—the type of the expression isn’t a delegate type in itself, but it can be converted into a delegat<a name="bookmark2464"></a>e instance in various ways, both implicitly and explicitly. The term </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">anonymous function</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> covers anonymous methods and lambda expressions—in many cases the same conversion rules apply to both of them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re going to start with a simple example, initially expressed as an anonymous method. We’ll create a delegate instance that takes a string parameter and returns an int (which is the length of the string). First we need to choose a delegate type to use; fortunately, .NET 3.5 comes with a whole family of generic delegate types to help us out.</font></p>
<p><a name="bookmark240"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2465"></a><a name="bookmark2466"></a><a name="bookmark2467"></a>9.1.1 &nbsp;&nbsp;&nbsp;Preliminaries: introducing the Func&lt;...&gt; delegate types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are five generic Func delegate types in .NET 3.5’s System namespace. T<a name="bookmark2468"></a>here’s nothing special about Func—it’s just handy to have some predefined generic types that are capable of handling many situations. Each delegate signature takes between zero and four parameters, the types of which are specified as type parameters.<sup><a name="footnote62"></a><a href="#bookmark2469">62</a></sup> The last type parameter is used for the return type in each case. Here are the signatures of all the Func delegate types in .NET 3.5:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TResult Func&lt;TResult&gt;()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TResult Func&lt;T,TResult&gt;(T arg)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TResult Func&lt;T1,T2,TResult&gt;(T1 arg1, T2 arg2)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TResult Func&lt;T1,T2,T3,TResult&gt;(T1 arg1, T2 arg2, T3 arg3)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TResult Func&lt;T1,T2,T3,T4,TResult&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For example, Func&lt;string,double,int&gt; is equivalent to a delegate type of the form</font></p>
<p><a name="bookmark2470"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a name="bookmark2471"></a>public delegate int SomeDelegate(string arg1, double arg2)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The A<a name="bookmark2472"></a>ction&lt;...&gt;<a name="bookmark2473"></a> set of delegates provides the equivalent functionality when you want a void return type. The single parameter form of Action existed in .NET 2.0, but the rest are new to .NET 3.5. If four arguments aren’t enough for you, then .NET 4 has the answer: it expands both the Action&lt;.. .&gt; and Func&lt;. ..&gt; families to take up to 1<a name="bookmark2474"></a>6 arguments—so Func&lt;T1,. ..,T16,TResult&gt; has an eye-watering 17 type parameters.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is primarily to help support the Dynamic Language Runtime that we’ll meet in chapter 14, and you’re unlikely to need to deal with it directly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For our example, we need a type that takes a string parameter and returns an int, so we’ll use Func&lt;string,int&gt;.</font></p>
<p><a name="bookmark241"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2475"></a><a name="bookmark2476"></a>9.1.2 First transformation to a lambda expression</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we know the delegate type, we can use an anonymous method to create our delegate instance. The following listing shows this, along with executing the delegate instance afterward so we can see it working.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.1 Using an anonymous method to create a delegate instance</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;string,int&gt; returnLength;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">returnLength = delegate (string text) { return text.Length; };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(returnLength(&quot;Hello&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.1 prints “5” just as we’d expect it to. I’ve separated &nbsp;&nbsp;&nbsp;the &nbsp;&nbsp;&nbsp;declaration &nbsp;&nbsp;&nbsp;of</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">returnLength from the assignment to it so we can keep it on one line—it’s &nbsp;&nbsp;&nbsp;easier &nbsp;&nbsp;&nbsp;to</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">keep track of that way. The anonymous method expression is the part in bold; that’s the part we’re going to convert into a lambda expressio<a name="bookmark2477"></a>n.</font></p>
<p><a name="bookmark2478"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The most long-winded form of a lambda expression is this:</font></p>
<p><a name="bookmark2479"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">(explicitly-typed-parameter-list)</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> =&gt; { </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">statements</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> }</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The =&gt; part is new to C# 3 and tells the compiler that we’re using a lambda expression. Most of the time lambda expressions are used with a delegate type that has a nonvoid return type—the syntax is slightly les<a name="bookmark2480"></a>s intuitive when there isn’t a result. This is another indication of the chan<a name="bookmark2481"></a>ges in idiom between C# 1 and C# 3. In C# 1, delegates were usually used for events<a name="bookmark2482"></a> and rarely returned anything. In LINQ they’re usually used as part of a data pipeline, taking input and returning a result to say what the projected value is, or whether the item matches the current filter, and so forth.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With the explicit parameters and statements in braces, this version looks very similar to an anonymous method. Listing 9.2 is equivalent to listing 9.1 but uses a lambda expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.2 A long-winded first lambda expression, similar to an anonymous method</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;string,int&gt; returnLength;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">returnLength = (string text) =&gt; { return text.Length; };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(returnLength(&quot;Hello&quot;));</font></p>
<p><a name="bookmark2483"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2484"></a>Again, I’ve used bold to indicate the expression used to create the delegate instance. When reading lambda expressions, it helps to think of the =&gt;part as “goes to”—so the example in listing 9.2 could be read as “text goes to text .Length.” As this is the only part of the listing that’s interesting for a while, I’ll show it alone from now on. You can replace the bold text from listing 9.2 with any of the lambda expressions listed in this section and the result will be the same.</font></p>
<p><a name="bookmark2485"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The same rules that govern return statements in anonymous methods apply to lambdas too: you can’t try to return a value from a<a name="bookmark2486"></a> lambda expression with a void return type, whereas if there’s a nonvoid return type, every code path has to return a compatible value.<sup><a name="footnote63"></a><a href="#bookmark2487">63</a></sup> It’s all pretty intuitive and rarely gets in the way.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far, we haven’t saved much space or made things particularly easy to read. Let’s start applying the shortcuts.</font></p>
<p><a name="bookmark242"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2488"></a>9.1.3 &nbsp;&nbsp;&nbsp;Using a single expression as the body</font></p>
<p><a name="bookmark2489"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The form we’ve seen so far uses a full block of code to return the value. This is flexi-ble—you can have multiple statements, perform loops, return from different places in the block, and so on, just as with ano<a name="bookmark2490"></a>nymous methods. But most of the time, you can easily express the whole of the body in a single expression, the value of which is the result of the lambda.<sup><a name="footnote64"></a><a href="#bookmark2491">64</a></sup> In these cases, you can specify just that expression, without any braces, return statements, or semicolons. The format then is</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">(explicitly-typed-parameter-list)</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> =&gt; </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">expression</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In our case, this means that the lambda expression becomes</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(string text) =&gt; text.Length</font></p>
<p><a name="bookmark2492"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s starting to look simpler already. Now, what about that parameter type? The compiler already knows that instances of Func&lt;string,int&gt; take a single string parameter, so we should be able to just name that parameter.</font></p>
<p><a name="bookmark243"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2493"></a>9.1.4 &nbsp;&nbsp;&nbsp;Implicitly typed parameter lists</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Most of the time, the compiler can guess the parameter types without you explicitly stating them. In these cases, you can write the lambda expression as</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">(implicitly-typed-parameter-list)</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> =&gt; </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">expression</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">An implicitly typed parameter list is just a comma-separated list of names, without the types. You can’t mix and match for different parameters—either the whol<a name="bookmark2494"></a>e list i<a name="bookmark2495"></a>s explicitly typed, or it’s all implicitly typed. Also, if any of the parameters are out or ref parameters, you’re forced to use explicit typing. In our case, it’s fine—so our lambda expression is now just</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(text) =&gt; text.Length</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s getting pretty short now—there’s not a lot more we could get rid of. The parentheses seem redundant, though.</font></p>
<p><a name="bookmark244"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2496"></a>9.1.5 Shortcut for a single parameter</font></p>
<p><a name="bookmark2497"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When the lambda expression only needs a single param<a name="bookmark2498"></a>eter, and that parameter can be implicitly typed, C# 3 allows us to omit the parentheses, so it now has this form:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">parameter-name</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> =&gt; </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">expression</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The final form of our lambda expression is therefore </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">text =&gt; text.Length</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may be wondering why there are so many special cases with lambda expressions— none of the rest of the language cares whether a method has one parameter or more, for instance. Well, what sounds like a particula<a name="bookmark2499"></a>r case actually turns out to be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extremely </font><font style="font-size:x-small;font-family:Times New Roman, serif;">common, and the improvement in readability from removing the parentheses from the parameter list can be significant when there are many lambdas in a short piece of code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth noting that you can put parentheses around the whole lambda expression if you want to, just like other expressions. Occasionally this helps readability in the case where you’re assigning the lambda to a variable or property—otherwise, the equals symbols can get confusing, at least to start with. Most of the time it’s perfectly readable without any extra syntax at all. Listing 9.3 shows this in the context of our original code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.3 A concise lambda expression</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;string,int&gt; returnLength returnLength = text =&gt; text.Length;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(returnLength(&quot;Hello&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">At first you may find listing 9.3 confusing to read, in the same way that anonymous methods appear strange to many developers until they get used to them. When you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are </font><font style="font-size:x-small;font-family:Times New Roman, serif;">used to lambda expressions, though, you can appreciate how concise they are. It’d be hard to imagine a shorter, clearer way of creating a delegate instance.<sup><a name="footnote65"></a><a href="#bookmark2500">65</a></sup> We could’ve changed the variable <a name="bookmark2501"></a>name text to something like x, and in full LINQ that’s often useful, but longer names give a bit more information to the reader.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve shown this transformation over the course of a few pages, but figure 9.1 makes it clear just how much extraneous syntax we’ve saved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The decision of whether to use the short form for the body of the lambda expression, specifying just an expression instead of a whole block, is completely independent from the decision about whether to use explicit or implicit parameters. We happen to have gone down one route of shortening the lambda, but we could’ve started off by making the parameters implicit. When you’re comfortable with lambda expressions you won’t think about this at all—you’ll just write the shortest available form naturally.</font></p><img src="images/25.png"/>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">Figure 9.1 Lambda syntax shortcuts</font></p>
<p><a name="bookmark2502"></a><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;"><a name="bookmark2503"></a>HIGHER-ORDER FUNCTIONS </font><font style="font-size:x-small;font-family:Times New Roman, serif;">The body of a lambda expression can itself contain a lambda expression—and this tends to be as confusing as it sounds. Alternatively, the parameter to a lambda expression can be another delegate, which is just as bad. Both of these are examples of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">higher-order functions</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. If you enjoy feeling dazed and confused, have a look at some of the sample code in the downloadable source. Although I’m being flippant, this approach is common in functional programming and can be useful. It just takes a certain degree of perseverance to get into the right mindset.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we’ve only dealt with a single lambda expression, just putting it into different forms. Let’s look at a few examples to make things more concrete before we examine the details.</font></p>
<p><a name="bookmark246"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2504"></a>9.2 Simple examples using List&lt;T&gt; and events</font></p>
<p><a name="bookmark2505"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When we look at extension <a name="bookmark2506"></a>methods in chapter<a name="bookmark2507"></a> 10, we’ll use lambda expressions all the time. Until then, </font><font style="font-size:x-small;font-family:Courier New, monospace;">List&lt;T&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and event handlers give us t<a name="bookmark2508"></a>he best examples. We’ll start off with lists, using automaticall<a name="bookmark2509"></a>y implemented properties, implicitly typed local variables, and collection initializers for the sake of brevity. We’ll then call methods that take delegate parameters—using lambda expressions to create the delegates, of course.</font></p>
<p><a name="bookmark247"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2510"></a><a name="bookmark2511"></a>9.2.1 Filtering, sorting, and actions on lists</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you remember the </font><font style="font-size:x-small;font-family:Courier New, monospace;">FindAll </font><font style="font-size:x-small;font-family:Times New Roman, serif;">method on </font><font style="font-size:x-small;font-family:Courier New, monospace;">List&lt;T&gt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, it takes a </font><font style="font-size:x-small;font-family:Courier New, monospace;">Predicate&lt;T&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and returns a<a name="bookmark2512"></a> new list with all the elements fro<a name="bookmark2513"></a>m the original list that match the predicate. The </font><font style="font-size:x-small;font-family:Courier New, monospace;">So<a name="bookmark2514"></a>rt </font><font style="font-size:x-small;font-family:Times New Roman, serif;">method takes a </font><font style="font-size:x-small;font-family:Courier New, monospace;">Comparison&lt;T&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and sorts the list accordingly. Finally, the </font><font style="font-size:x-small;font-family:Courier New, monospace;">ForEach </font><font style="font-size:x-small;font-family:Times New Roman, serif;">method takes an </font><font style="font-size:x-small;font-family:Courier New, monospace;">Action&lt;T&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to perform on each element. Listing 9.4 uses lambda expressions to provide the delegate instance to each of these methods. The</font></p>
<p><a name="bookmark2515"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">sample data in question is just the name and year of rel<a name="bookmark2516"></a>ease for various films. We print out the original list, then create and print out a filtered list of only old films, then sort and print out the original list, ordered by name. (It’s interesting t<a name="bookmark2517"></a>o consider how much more code would’ve been required to do the same thing in C# 1.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.4 Manipulating a list of films using lambda expressions</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Film {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public string Name { get; set; } public int Year { get; set; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var films = new List&lt;Film&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Film { Name = &quot;Jaws&quot;, Year = 1975 },</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Film { Name = &quot;Singing in the Rain&quot;, Year = 1952 },</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Film &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;Some Like it Hot&quot;, Year = 1959 },</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Film &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;The Wizard of Oz&quot;, Year = 1939 },</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Film { Name = &quot;It's a Wonderful Life&quot;, Year = 1946 },</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Film &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;American Beauty&quot;, Year = 1999 },</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Film &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;High Fidelity&quot;, Year = 2000 },</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Film &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;Name &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;&quot;The Usual Suspects&quot;, Year = 1995 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Action&lt;Film&gt; print =</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">film =&gt; Console.WriteLine(&quot;Name={0}, Year={1}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">film.Name, film.Year);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">films.ForEach(print);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">films.FindAll(film =&gt; film.Year &lt;&nbsp;1960)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.ForEach(print);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">films.Sort((f1, f2) =&gt; f1.Name.CompareTo(f2.Name)) films.ForEach(print);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first half of listing 9.4 involves setting up the data. I’ve created a named type just to make life easier—an anonymous type would’ve meant a few more hoops to jump through in this particular case.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before we use the newly created list, we create a delegate instance O, which we’ll use to print out the items of the list. We use this delegate instance three times, which is why I’ve created a variable to hold it rather than using a separate lambda expression each time. It just prints a single element, but by passing it into List&lt;T&gt;.ForEach we can d<a name="bookmark2518"></a>ump the whole list to the console. A subtle but important point<a name="bookmark2519"></a> is that the semicolon at the end of this statement is part of the assignment statement, not part of the lambda expression. If we were using the same lambda expression as an argument in a method call, there wouldn’t be a semicolon directly after Console.WriteLine(...).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first list we print out Q is just the original one without any modifications. We then find all the films in our list that were made before 1960 and print those out ©. This is done with another lambda expression, which is executed for each film in the list—it only has to determine whether a single film should be included in the filtered</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">list. The source code uses the lambda expression as a method argument, but really the compiler has created a method like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static bool SomeAutoGeneratedName(Film film)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return film.Year &lt;&nbsp;1960;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The method call to FindAll is then effectively this: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">films.FindAll(new Predicate&lt;Film&gt;(SomeAutoGeneratedName))</font></p>
<p><a name="bookmark2520"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The lambda expression support here is just like the anonymous method support in C# 2; it’s all cleverness on the part of the compiler. (In fact, the Microsoft compiler is even smarter in this case—it realizes it can <a name="bookmark2521"></a>get away with reusing the delegate instance if the code is ever called again, so it caches it.)</font></p>
<p><a name="bookmark2522"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Sorting the list O is also achieved using a lambda expression, which compares any two films using their names. I have to confess that explicitly calling CompareTo ourselves is a bit ugly. In the next chapter we’ll see how the OrderBy extension method allows us to express ordering in a neater way.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s look at another example, this time using lambda expressions with event handling.</font></p>
<p><a name="bookmark248"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2523"></a>9.2.2 Logging in an event handler</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you think back to chapte<a name="bookmark2524"></a>r 5, in listing 5.9 we saw an easy way of using anonymous methods to log which events were occurring—but we could only get away with a compact syntax b<a name="bookmark2525"></a>ecause we didn’t mind losing the parameter information. What if we wanted to log both the natu<a name="bookmark2526"></a>re of the event </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">and</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> information about its sender and arguments? Lambda expressions enable this in a neat way, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.5 Logging events using lambda expressions</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Log(string title, object sender, EventArgs e)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Event: &nbsp;&nbsp;&nbsp;{0}&quot;, &nbsp;&nbsp;&nbsp;title);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot; Sender: &nbsp;&nbsp;&nbsp;{0}&quot;, &nbsp;&nbsp;&nbsp;sender);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot; Arguments: &nbsp;&nbsp;&nbsp;{0}&quot;, &nbsp;&nbsp;&nbsp;e.GetType());</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (PropertyDescriptor prop in</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TypeDescriptor.GetProperties(e))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string name = prop.DisplayName; object value = prop.GetValue(e);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot; {0}={1}&quot;, name, value);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Button button = new Button { Text = &quot;Click me&quot; }; button.Click &nbsp;&nbsp;&nbsp;+= &nbsp;&nbsp;&nbsp;(src, &nbsp;&nbsp;&nbsp;e) &nbsp;&nbsp;&nbsp;=&gt; &nbsp;&nbsp;&nbsp;Log(&quot;Click&quot;, src, &nbsp;&nbsp;&nbsp;e);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">button.KeyPress &nbsp;&nbsp;&nbsp;+= &nbsp;&nbsp;&nbsp;(src, &nbsp;&nbsp;&nbsp;e) &nbsp;&nbsp;&nbsp;=&gt; &nbsp;&nbsp;&nbsp;Log(&quot;KeyPress&quot;, src, e);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">button.MouseClick &nbsp;&nbsp;&nbsp;+= &nbsp;&nbsp;&nbsp;(src, &nbsp;&nbsp;&nbsp;e) &nbsp;&nbsp;&nbsp;=&gt; &nbsp;&nbsp;&nbsp;Log(&quot;MouseClick&quot;, &nbsp;&nbsp;&nbsp;src, e);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Form form = new Form &nbsp;&nbsp;&nbsp;{ AutoSize = true, Controls = &nbsp;&nbsp;&nbsp;{ button } };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Application.Run(form);</font></p>
<p><a name="bookmark2527"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.5 uses lambda expressions to pass the event name </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">and parameters</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to the Log method, which logs details of the event. We don’t log the details of the event source, beyond whatever its ToString override returns, because an ov<a name="bookmark2528"></a>erwhelming amount of info<a name="bookmark2529"></a>rmation is associated with controls. <a name="bookmark2530"></a>But we use reflection over property descriptors to show the details of the EventArgs instance passed to us. Here’s some sample output when you click the button:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Event: Click</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Sender: System.Windows.Forms.Button, Text: Click me Arguments: System.Windows.Forms.MouseEventArgs Button=Left Clicks=1 X=53 Y=17 Delta=0</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Location={X=53,Y=17}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Event: MouseClick Sender: System.Windows.Forms.Button, Text: Click me Arguments: System.Windows.Forms.MouseEventArgs Button=Left Clicks=1 X=53 Y=17 Delta=0</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Location={X=53,Y=17}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All of this is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">possible</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> without lambda expressions, of course—but it’s a lot neater than it would’ve been otherwise. Now that we’ve seen lambdas being converted into delegate instances, it’s time to look at expression trees, which represent lambda expressions as data instead of code.</font></p>
<p><a name="bookmark250"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2531"></a>9.3 Expression trees</font></p>
<p><a name="bookmark2532"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The idea of “code as data” is an old one, but it hasn’t been used much in popular programming lan<a name="bookmark2533"></a>guages. You could argue that al<a name="bookmark2534"></a>l .NET programs use the concept, because the IL code is treated as data by the JIT, which then converts it into native code to run on your CPU. That’s deeply hidden though, and although libraries to manipulate IL prog<a name="bookmark2535"></a>rammatically exist, they’re not widely used.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression trees in .NET 3.5 prov<a name="bookmark2536"></a>ide an abstract way of representing some code as a tree of objects. It’s like CodeDOM but operating at a slightly higher level. The primary use of expression trees is in LINQ, and later in this section we’ll see how crucial expression trees are to the whole LINQ story.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 3 provides built-in support for converting lambda expressions to expression trees, but before we cover that, let’s explore how they fit into the .NET Framework without using any compiler tricks.</font></p>
<p><a name="bookmark251"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2537"></a>9.3.1 Building expression trees programmatically</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression trees aren’t as mystical as they sound, although some of the uses they’re put to look like magic. As the name suggests, they’re trees of objects, where each node</font></p>
<p><a name="bookmark2538"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2539"></a>in the tree is an expression in itself. Different types of expressions represent the different operations that can be performed in code: binary operations, such as addition; unary operations, such as taking the length of an array; method calls; constructor calls; and so forth.</font></p>
<p><a name="bookmark2540"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The System.Linq.Expressions namespace contains t<a name="bookmark2541"></a>he various classes that represent expressions. All of them derive from t<a name="bookmark2542"></a>he Expression class, which is abstract and mostly consists of static factory methods to create instances of other expression classes. It exposes two properties, though:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The Type property represents the .NET type of the evaluated expression—you can think of it like a return type. The type of an expression that fetches the Length prope<a name="bookmark2543"></a>rty of a string would be int, for example.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The NodeType property<a name="bookmark2544"></a> returns the kind of expression represented, as a member of the ExpressionType enumeration, with values such as LessThan, Multiply, and Invoke. To use the same example, in myString. Length the property access part would have a node type of MemberAccess.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are many classes derived from Ex<a name="bookmark2545"></a>pression, and some of them can have many different node types. BinaryExpression, for instance, represents any operation with two operands: arithmetic, logic, comparisons, array indexing, and the like. This is where the NodeType property is important, as it distinguishes between different kinds of expressions that are represented by the same class.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I don’t inten<a name="bookmark2546"></a>d to cover every expression class or node type—there are far too many, and MSDN does a perfectly good job of explaining them (see <a href="http://mng.bz/3vW3">http://mng.bz/3vW3</a>). Instead, we’ll try to get a general feel for what you can do with expression trees.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s start off by creating one of the simplest possible expression trees, adding two constant integers together. The following listing creates an expression tree to represent 2+3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.6 A simple expression tree, adding 2 and 3</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression firstArg = Expression.Constant(2);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression secondArg = Expression.Constant(3);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression add = Expression.Add(firstArg, secondArg);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(add);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Running listing 9.6 will produce the output “(2 + 3),” which demonstrates that the various expression classes override ToString to produce human-readable output. Figure 9.2 depicts the tree generated by the c<a name="bookmark2547"></a>ode.</font></p>
<p><a name="bookmark2548"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2549"></a>It’s worth noting that the leaf expressions are created first in the code: you build expressions from the bottom up. This is enforced by the fact that expressions are immutable—once you’ve created an expression, it’ll never change, so you can cache and reuse expressions at will.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve built up an expression tree, let’s try to actually execute it.</font></p><img src="images/26.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 9.2 Graphical representation of the expression tree created by listing 9.6</font></p>
<p><a name="bookmark252"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2550"></a><a name="bookmark2551"></a>9.3.2 Compiling expression trees into delegates</font></p>
<p><a name="bookmark2552"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One of the types derive<a name="bookmark2553"></a>d from Expression is LambdaExpression. The generic class Expression&lt;TDelegate&gt; then derives from LambdaExpression. It’s all slightly confusing—figure 9.3 shows the type hierarchy to make things clearer.</font></p>
<p><a name="bookmark2554"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2555"></a>The difference between E<a name="bookmark2556"></a>xpression and Expression&lt;TDelegate&gt; is that the generic class is statically typed to indicate what kind of expression it is, in terms of return type and parameters. Obviously, this is expressed by the TDelegate type parameter, which must be a delegate type. For instance, our simple addition expression takes no parameters and returns an integer—this is matched by the signature of Func&lt;int&gt;, so we could use an Expression&lt;Func&lt;int&gt;&gt; to represen<a name="bookmark2557"></a>t the expression in a statically typed manner. We do this using the Expression.Lambda method. This has a number of overloads—our examples<a name="bookmark2558"></a> use the generic method, which uses a type parameter to indicate the type of delegate we want to represent. See MSDN for alternatives.</font></p>
<p><a name="bookmark2559"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">So, what’s the point of doing this? Well, LambdaExpression has a Compile method that creates a delegate of the appropriate type; Expression&lt;TDelegate&gt; has another method by the same name, but statically typed to return a delegate of type TDelegate. This delegate can now be executed in the normal manner, as if it had been created using a normal method or any other means. Listing 9.7 shows this in action, with the same expression as before.</font></p><img src="images/27.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 9.3 Type hierarchy from </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression&lt;TDelegate&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">up to </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.7 Compiling and executing an expression tree</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression firstArg = Expression.Constant(2);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression secondArg = Expression.Constant(3);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression add = Expression.Add(firstArg, secondArg);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;int&gt; compiled = Expression.Lambda&lt;Func&lt;int&gt;&gt;(add).Compile();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(compiled());</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Arguably listing 9.7 is one of the most convoluted ways of printing out “5” that you could ask for. At the same time, it’s also rather impressive. We’re programmatically creating some logical blocks and representing them as normal objects, and then asking the framework to compile the whole thing into real code that can be executed. You may never need to actually use expression trees this way, or even build them up programmatically at all, but it’s useful background information that will help you understand how LINQ works.</font></p>
<p><a name="bookmark2560"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">As I said at t<a name="bookmark2561"></a>he begin<a name="bookmark2562"></a>ning of this section, expression trees aren’t too far removed from CodeDOM—Snippy compiles and executes C# code that has been entered as plain text, for instance. But two significant differences exist between CodeDOM and expression trees.</font></p>
<p><a name="bookmark2563"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">First, in .NET 3.5 expression trees were only able to represent single expressions. They weren’t designed for whole classes, methods, or even just statements. This has changed somewh<a name="bookmark2564"></a>at in .NE<a name="bookmark2565"></a>T 4, where they’re<a name="bookmark2566"></a> used to support dynamic typing—you can now create blocks, assign values to variables, and so on. But there are still significant restrictions compared with CodeDOM.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Second, C# supports expression trees directly in the language, through lambda expressions. Let’s take a look at that now.</font></p>
<p><a name="bookmark253"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2567"></a><a name="bookmark2568"></a>9.3.3 Converting C# lambda expressions to ex<a name="bookmark2569"></a>pression trees</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As we’ve already seen, lambda expressions can be converted to appropriate delegate instances, either implicitly or explicitly. That’s not the only conversion that’s available. You can also ask the compiler to build an expression tree from your lambda expression, creating an instance of Expression&lt;TDelegate&gt; at execution time. For example, the following listing shows a much shorter way of creating the “return 5” expression, compiling it, and then invoking the resulting delegate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.8 Using lambda expressions to create expression trees</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression&lt;Func&lt;int&gt;&gt; return5 = </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">() =&gt; 5;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;int&gt; compiled = return5.Compile();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(compiled());</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In the first line of listing 9.8, the () =&gt; 5 <a name="bookmark2570"></a>part is the lambda expression. Note that we don’t need any casts because the compiler can verify everything as it goes. We could’ve written 2+3 instead of 5, but the compiler would’ve optimized the addition away for us. The important point to take away is that the lambda expression has been converted into an expression tree.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">THERE ARE LIMI<a name="bookmark2571"></a>TATIONS Not </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> lambda expressions can be converted to expression trees. You can’t convert a lambda with a block of statements (even just one return statement) into an expression tree—it has to be in the form that just evaluates a single expression. That expression can’t contain assignments, either. Although these are the most common restrictions, they’re not the only ones—the full list isn’t worth describing here, as this issue comes up so rarely. If there’s a problem with an attempted conversion, you’ll find out at compile time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The restriction about only converting single expressions applies even in .NET 4 with its extended abilities for expression trees. It’s possible that a future version of C# will be more permissive about what kind of lambda expressions can be converted, but nothing has been announced at the time of this writing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s look at a more complicated example just to see how things work, particularly with respect to parameters. This time we’ll write a predicate that takes two strings and checks to see if the first one begins with the second. The code is simple when written as a lambda expression, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.9 Demonstration of a more complicated expression tree</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression&lt;Func&lt;string, string, bool&gt;&gt; expression =</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(x, y) =&gt; x.StartsWith(y);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var compiled = expression.Compile();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(compiled(&quot;First&quot;, &quot;Second&quot;)); Console.WriteLine(compiled(&quot;First&quot;, &quot;Fir&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The expression tree itself is more complicated, especially by the time we’ve converted it into an instance of LambdaExpression. The next listing shows how it could be built in code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.10 Building a method call expression tree in code</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Methodlnfo method = typeof(string).GetMethod (&quot;StartsWith&quot;, new[] { typeof(string) }); var target = Expression.Parameter(typeof(string), &quot;x&quot;); var methodArg = Expression.Parameter(typeof(string), &quot;y&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression[] methodArgs = new[] { methodArg };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression call = Expression.Call(target, method, methodArgs);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var lambdaParameters = new[] { target, methodArg }; var lambda = Expression.Lambda&lt;Func&lt;string, string, bool&gt;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(call, lambdaParameters);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var compiled = lambda.Compile();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(compiled(&quot;First&quot;, &quot;Second&quot;)); Console.WriteLine(compiled(&quot;First&quot;, &quot;Fir&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see, listing 9.10 is considerably more involved than the version with the C# lambda expression. But it does make it more obvious exactly what’s involved in the</font></p>
<p><a name="bookmark2572"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">tree and how parameters are bound. We start off by working out everything we need to know about the method call that forms the body of the final expression </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">: the target of the method (in other<a name="bookmark2573"></a> words, the string we’re calling StartsWith on); the method itself (as a MethodInfo); and the list of arguments (in this case, just the one). It so happens that our method target and argument will both be parameters passed into the expression, but they could be other types of expressions—constants, the results of other method calls, property evaluations, and so forth.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">After building the method call as an expression </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, we then need to convert it into a lambda expression<a name="bookmark2574"></a> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, binding the parameters as we go. We reuse the same ParameterExpression values we created as information for the method call: the order in which they’re specified when creating the lambda expression is the order in which they’ll be picked up when we eventually call the delegate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 9.4 shows the same final expression tree graphically. To be picky, even thou<a name="bookmark2575"></a>gh it’s still called an expression tree, the fact that we reuse the parameter expressions<a name="bookmark2576"></a> (and we have to—creating a new one with the same name and attempting to bind parameters that way causes an exception at execution time) means that it’s not really a tree in the purest sense.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Glancing at the complexity of figure 9.4 and listing 9.10 without trying to look at the details, you’d be forgiven for thinking that we were doing something really</font></p><img src="images/28.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 9.4 Graphical represe expression tree that calls a meth parameters from a lambda expres</font></p>
<p><a name="bookmark2577"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">complicated when in fact it’s just a single method call. Imagine what the expression tree for a genuinely complex expression would look like—and then be grateful that C# 3 can create expression trees from lambda expressions!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For o<a name="bookmark2578"></a>ne final way of looki<a name="bookmark2579"></a>ng at the same idea, Visual Studio 2010 provides a built-in visualizer for expression trees.<sup>7</sup> This can be useful if you’re trying to work out how to build up an expression tree in code, and want to get an idea of what it should look like: write a lambda expression that does what you want with some dummy data, look at the visualization in the debugger, and then work out how to build similar trees with the information you have in your real code. The visualizer relies on changes within .NET 4, so it won’t work with projects targeting .NET 3.5. Figure 9.5 shows the visualization for our “StartsWith” example.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The .Lambda a<a name="bookmark2580"></a>nd .Call parts of the<a name="bookmark2581"></a> visualization correspond to our calls to Expressio<a name="bookmark2582"></a>n.Lambda and Expression.Call; $x and $y correspond to the parameter expressions. The visualization is the same whether the expression tree has been built up explicitly through code or using a lambda expression co<a name="bookmark2583"></a>nversion.</font></p>
<p><a name="bookmark2584"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2585"></a>One small point to note is that although the C# compiler builds expression trees in the compiled code using code similar to listing 9.10, it has one shortcut up its sleeve: it doesn’t need to use normal reflection to get the Me<a name="bookmark2586"></a>thodInfo for string. StartsWith. I<a name="bookmark2587"></a>nstead, it uses the method equivalent of the typeof operator. This is only available in IL, not in C# itself—and the same operator is also used to create delegate instances from method groups.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve seen how expression trees and lambda expressions are linked, let’s take a brief look at why they’re so useful.</font></p>
<p><a name="bookmark254"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2588"></a>9.3.4 Expression trees at the heart of LNQ</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Without lambda expressions, expressi<a name="bookmark2589"></a>on trees would have relatively little value. They’d be an alternative to CodeDOM in cases where you only wanted to model a</font></p><img src="images/29.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 9.5 Debugger visualization of an expression tree</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup>7</sup> If you’re using Visual Studio 2008, you can download some sample code to build a similar visualizer (see <a href="http://mng.bz/g6xd">http://mng.bz/g6xd</a>), but obviously it’s easier to use the one shipped with Visual Studio 2010 if you have it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">single expression instead of whole statements, methods, types, and so forth—but the benefit would still be limited.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The reverse is also true to a limited extent: without expression trees, lambda expressions would certainly be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">less</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> useful. Having a more compact way of creati<a name="bookmark2590"></a>ng delegate instances would still be welcome, and the shift toward a more functional mode of development would still be viable. Lambda expressions are particularly effective when combined with extension methods, as we’ll see in the next chapter. But with expression trees in the picture as well, things get a lot more interesting.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So what do we get by combining lambda expressio<a name="bookmark2591"></a>ns, expression trees, and extension methods? The answer is the language side of LINQ, pretty much. The extra syntax we’ll see in chapter </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">11</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is icing on the cake, but the story would still have been compelling with just those t<a name="bookmark2592"></a>hree ingredients. For a long time we could have </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">either</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> nice compile-time checking<a name="bookmark2593"></a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">or</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the ability to tell another platform to run some code, usually expressed as text (SQL queries being the most obvious example). We couldn’t do both at the same time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">By combining lambda expressions that <a name="bookmark2594"></a>provide compile-time checks and expression trees that abstract the execution model away from the desired lo<a name="bookmark2595"></a>gic, we can have the best of both worlds—within reason. At the heart of out-of-process LINQ providers is the idea that we can produce an expression tree from a fa<a name="bookmark2596"></a>miliar source language (C# in our case) and use the result as an intermediate format that can then be converted into the native language of the target platform: SQL, for exa<a name="bookmark2597"></a>mple. In some cases there may no<a name="bookmark2598"></a>t be a simple native language so much as a native API—making different web service calls depending on what the ex<a name="bookmark2599"></a>pression represe<a name="bookmark2600"></a>nts, perhaps. Figure 9.6 shows the different paths of LINQ to Objects and LINQ to SQL.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In some cases the conversion may try to perform </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the logic on the target platform, whereas other cases may use the compilation facilities of expression trees to</font></p><img src="images/30.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 9.6 Both LINQ to Objects and LINQ to SQL start with C# code and end with query results. The ability to execute the code remotely comes through expression trees.</font></p>
<p><a name="bookmark2601"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">execute some of the expression locally and some elsewhere. We’ll look at some of the details of this conversion step in chapter </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">12</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, but you should bear this end goal in mind as we explore extension methods and LINQ syntax in chapters 10 and 11.</font></p>
<p><a name="bookmark2602"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">NOT ALL CHECKING CAN BE DONE BY THE COMPILER When expression trees are examined by some sort of converter, often some cases have to be rejected. For instance, although it’s possible to convert a call to s<a name="bookmark2603"></a>tring.StartsWith into a similar SQL expression, a call to string.IsInterned doesn’t make sense in a database environment. Expression trees allow a large amount of compile-time safety, but the compiler can only check that the lambda expression can be converted into a valid expression tree; it can’t make sure that the expression tree will be suitable for its eventual use.</font></p>
<p><a name="bookmark2604"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Though the most common uses of expression trees are related to LINQ, that’s not always the case...</font></p>
<p><a name="bookmark255"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2605"></a><a name="bookmark2606"></a>9.3.5 Expression trees beyond LINQ</font></p>
<p><a name="bookmark2607"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Bjarne Stroustrup once said, “I wouldn’t like to build a tool that could only do what I had been able to imagine for it.” Though expression trees were introduced into .NET primarily for LINQ, both the community and Microsoft have found other uses for them since then. This section is far from comprehensive, but it might give you a few ideas of where expression trees might help you.</font></p>
<p><a name="bookmark2608"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">OPTIMIZING THE DYNAMIC LANGUAGE RUNTIME</font></p>
<p><a name="bookmark2609"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2610"></a>We’re going to see a lot more of the <a name="bookmark2611"></a>Dynamic Language Runtime (DLR) in chapter 14, when we talk about dynamic typing in C#, but expression trees are a core part of the architecture. They have three properties that make them attractive to the DLR:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;They’re immutable,<a name="bookmark2612"></a> so you can cache them safely.</font></p>
<p><a name="bookmark2613"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2614"></a>■ &nbsp;&nbsp;&nbsp;They’re composable, so you can build complex behavior out of simple building blocks.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;They can be compiled into delegates that are JIT-compiled into native code as normal.</font></p>
<p><a name="bookmark2615"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2616"></a>The DLR has to make decisions about how to ha<a name="bookmark2617"></a>ndle various expressions where the meaning can change subtly based on different rules. Expression trees allow these rules (and the results) to be transformed into code that’s close to what you’d write by hand if you knew all the rules and results you’d seen so far. It’s a powerful concept, and one that allows dynamic code to execute surprisingly quickly.</font></p>
<p><a name="bookmark2618"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">REFACTOR-PROOF REFERENCES TO MEMBERS</font></p>
<p><a name="bookmark2619"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In section 9.3.3 I mentioned that <a name="bookmark2620"></a>the compiler can emit references to MethodInfo values in a similar way to the typeof operator. Unfortunately, C# doesn’t have the sam<a name="bookmark2621"></a>e ability, which means the only way of telling one piece of general-purpose, reflection-based code to “use the property called BirthDate defined in my type” has previousl<a name="bookmark2622"></a>y been to use a string literal and make sure that if you change the name of the property,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">you also change the literal. Using C# 3, you can build an expression tree representing a property reference using a lambda expression. The method can then dissect the expression tree and work out the property you mean. It could then do whatever it liked with the information—as well as compiling the expression tree into a delegate and using it directly, of course. As an example of how this might be used, you could write</font></p>
<p><a name="bookmark2623"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">serializationContext.AddProperty(x =&gt; x.BirthDate);</font></p>
<p><a name="bookmark2624"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The serialization context would then know that you wanted to serialize the BirthDate property, and it could record appropriate metadata as well as retrieve the value. Serialization is just one area where you may want a property or method reference; it’s fairly common within reflection-driven code. Now if you refactor the BirthDate property to call it DateOfBirth, the lambda expression will change too. Of course, it’s not foolproof—there’s no compile-time check that the expression really evaluates a simple property; that has to be an execution-time check in the AddProperty code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s possible that one day C# will gain the ability to<a name="bookmark2625"></a> do this within the language itself. Such an operator has already been named: infoof, pronounced either “info-of” or “in-foof’ depending on your level of light-heartedness. This has bee<a name="bookmark2626"></a>n on the C# team’s possible-feature list for a while, and unsurprisingly Eric Lippert has blogged about it (see <a href="http://mng.bz/24y7">http://mng.bz/24y7</a>)—but it hasn’t made the cut yet. Maybe in C# 5.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">SIMpLER REFLECTION</font></p>
<p><a name="bookmark2627"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The final use I want to mention before we delve into the murky dept<a name="bookmark2628"></a>hs of type<a name="bookmark2629"></a> inference is also about reflec<a name="bookmark2630"></a>tion. As I mentioned in chapter 3, arithmetic operators don’t play nicely with generics, which makes it hard to write generic code to (say) add up a series of values. Marc Gravell used expression trees to great effect to provide a generic Operator class and a nongeneric helper class allowing you to write code such as</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T runningTotal = initialValue; foreach (T item in values)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">runningTotal = Operator.Add(runningTotal, values);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This will even work in cases where the values are a different type than the running total—adding a whole sequence of TimeSpan values to a DateTime, for example. It’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">possible</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to do this in C# 2, but i<a name="bookmark2631"></a>t’s significantly more fiddly due to the ways that operators are exposed via reflection, particularly for the primitive types. Expression trees allow the implementat<a name="bookmark2632"></a>ion of this magic to be qu<a name="bookmark2633"></a>ite clean, and the fact that they’re compiled to normal IL which is then JIT compiled gives great performance.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">These are just some examples, and no doubt there are many developers busy working on completely different uses. But they mark an end to our direct coverage of lambda expressions and expression trees. We’ll see a good deal more of them when we look at LINQ, but before we go any further there are a few changes to C# that need some explanation. These are changes to type inference and how the compiler selects between overloaded methods.</font></p>
<p><a name="bookmark257"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2634"></a>9.4 Changes to type inference an<a name="bookmark2635"></a>d overload resolutio<a name="bookmark2636"></a>n</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The steps involved in type inferenc<a name="bookmark2637"></a>e and overload resolution were alter<a name="bookmark2638"></a>ed in C# 3 to accommodate lambda expressions and to make anonymous methods more useful. This may not count as a new feature of C# as such, but it can be important to understand what the compiler is going to do. If you find details like this tedious and irrelevant, feel free to skip to the chapter summary—but remember that this section exists, so you can read it if you run across a compilation error related to this topic and can’t understand why your code doesn’t work. (Alternatively, you might want to come back to this section if you find your code </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> compile, but you don’t think it should!)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even within this section I’m<a name="bookmark2639"></a> not going to go into every nook and cranny—that’s what the language specification is for; the details are in section 7.5.2 of the C# 4 spec. Instead, I’ll give an overview of the new behavior, providing examples of common cases. The primary reason for changing the specification is to allow lambda expressions to work in a concise fashion, which is why I’ve included the topic in this particular chapter. Let’s look a little deeper at what problems we’d have run into if the C# team had stuck with the old rules.</font></p>
<p><a name="bookmark258"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2640"></a>9.4.1 Reasons for change: streamlining generic method calls</font></p>
<p><a name="bookmark2641"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Type infere<a name="bookmark2642"></a>nce occurs in a few situations. We’ve already seen it apply to implicitly typed arrays, and it’s also required when you try to implicitly convert a method group to a delegate type. This can be particularly confusing when the conversion occurs whe<a name="bookmark2643"></a>n you’re using a method group as an argument to another method: with overloading of the method being called, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">and</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> overloading of methods within the method group, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">and</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> <a name="bookmark2644"></a>the possibility of generic methods getting involved, the set of potential conversions may be enormous.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">By far the <a name="bookmark2645"></a>most common situation for type infer<a name="bookmark2646"></a>ence is when you’re calling a generic method without specifying any type arguments. This happens all the time in LINQ—the way that query expressions work depends heavily on this ability. It’s all handled so smoothly that it’s easy to ignore how much the compiler has to work out on your behalf, all for the sake of making your code clearer and more concise.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The rules were </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reasonably</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> straightforward in C# 2, although method groups and anonymous methods weren’t always handled as well as we might’ve liked. The type inference process didn’t deduce any information from them, leading to situations where the desired behavior was obvious to developers<a name="bookmark2647"></a> but not to the compiler. Life is more complicated in C# 3 due to lambda expressions—if yo<a name="bookmark2648"></a>u call a generic method using a lambda expression with an implicitly typed parameter list, the compiler needs to work out what types you’re talking about before it can check the lambda expression’s body.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is much easier to see in code than in words. Listing 9.11 gives an example of the kind of issue we want to solve: calling a generic method using a lambda expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.11 Example of code requiring the new type inference rules</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void PrintConvertedValue&lt;TInput,TOutput&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(TInput input, Converter&lt;TInput,TOutput&gt; converter)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(converter(input));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintConvertedValue(&quot;I'm a string&quot;, x =&gt; x.Length);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The method PrintConvertedValue in listing 9.11 simply takes an input value and a delegate that can convert that value into a different type. It’s completely generic—it makes no assumptions about the type parameters TInput and TOutput. Now, look at the types of the arguments we’re calling it with in the bottom line of the listing. The first argument is clearly a string, but what about the second? It’s a lambda expression, so we need to convert it into a Converter&lt;TInput,TOutput&gt;—and that means we need to know the types of TInput and TOutput.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you remember from section 3.3.2, the type inference rules of C# 2 were applied to each argument individually, with no way of using the types inferred from one argument to another. In our case, these rules would’ve stopped us from finding the types of TInput and TOutput for the second argument, so the code in listing 9.11 would’ve failed to compile.</font></p>
<p><a name="bookmark2649"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2650"></a><a name="bookmark2651"></a>Our eventual goal is to understand what makes listing 9.11 compile in C# 3 (and it does, I promise you), but we’ll start with something more modest.</font></p>
<p><a name="bookmark259"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2652"></a>9.4.2 Inferred return types of anonymous functions</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The following listing shows another example of some code that looks like it should compile but doesn’t under the type inference rules of C# 2.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.12 Attempting to infer the return type of an anonymous method</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate T MyFunc&lt;T&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void WriteResult&lt;T&gt;(MyFunc&lt;T&gt; function) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(function());</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WriteResult(delegate { return 5; });</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Compiling listing 9.12 under C# 2 gives an error like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">error CS0411: The type arguments for method</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">'Snippet.WriteResult&lt;T&gt;(Snippet.MyFunc&lt;T&gt;)' cannot be inferred from the usage. Try specifying the type arguments explicitly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We can fix the error in two ways—either specify the type argument explicitly (as suggested by the compiler) or cast the anonymous method to a concrete delegate type:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WriteResult&lt;int&gt;(delegate { return 5; });</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WriteResult((MyFunc&lt;int&gt;)delegate { return 5; });</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Both of these work, but they’re ugly. We’d </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">like</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the compiler to perform the same kind of type inference as for nondelegate types, using the type of the returned expression to infer the type of T. That’s exactly what C# 3 does for both anonymous methods and lambda expressions—but there’s one catch. Although in many cases only one return statement is involved, there can sometimes be more. The following listing is a slightly modified version of listing 9.12 where the anonymous method sometimes returns an integer and sometimes returns an object.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.13 Code returning an integer or an object depending on the time of day</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate T MyFunc&lt;T&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void WriteResult&lt;T&gt;(MyFunc&lt;T&gt; function)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(function());</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WriteResult(delegate</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (DateTime.Now.Hour &lt;&nbsp;12)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return 10;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">else {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new object();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">});</font></p>
<p><a name="bookmark2653"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler uses the same logic to determine the return type in this situation as it does for implicitly typed arrays,<a name="bookmark2654"></a> as described in section 8.4. It forms a set of all the types from the return statements in the body of the anonymous function</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup><a name="footnote66"></a><a href="#bookmark2655">66</a></font><font style="font-size:x-small;font-family:Times New Roman, serif;"></sup> (in this case int and object) and checks to see if exactly one of the types can be implicitly converted to from all the others. There’s an implicit conversion from int to object (via boxing) but not from object to int, so the inference succeeds with object as the inferred return type. If there are no types matching that criterion (or more than one), no return type can be inferred and you’ll get a compilation error.</font></p>
<p><a name="bookmark2656"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2657"></a><a name="bookmark2658"></a>So, now we know how to work out the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">return</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type of an anonymous function—but what about lambda expressions where the parameter types can be implicitly defined?</font></p>
<p><a name="bookmark260"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2659"></a>9.4.3 Two-phase type inference</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The details of type inference in C# 3 are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">much</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> more complicated than they are for C# 2. It’s rare that you’ll need to reference the specification for the exact behavior, but if you do I recommend you write down all the type parameters, arguments, and so forth on a piece of paper, and then follow the specification step by step, carefully</font></p>
<p><a name="bookmark2660"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2661"></a>noting down every action it requires. You’ll end up with a sheet full of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">fixed</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">unfixed </font><font style="font-size:x-small;font-family:Times New Roman, serif;">type variables, with a different set of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">bounds</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for each of them. A </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">fixed</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type varia<a name="bookmark2662"></a>ble is one that the compiler has decided the v<a name="bookmark2663"></a>alue of; otherwise it’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">unfixed.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> A </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">bound</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is a piece of information about a type variable. In addition to a bunch of notes, I suspect you’ll get a headache; this stuff isn’t pretty.</font></p>
<p><a name="bookmark2664"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m going to present a more fuzzy way of thinking about type inference—one that’s likely to serve just as well as knowing the specification, and will be a lot easier to understand. The fact is, if the compiler doesn’t perform type inference in exactly the way you want it to, it’ll almost certainly result in a compilation error rather than code that builds but doesn’t behave properly. If your code doesn’t build, try giving the compiler more information—it’s as simple as that. But here’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">roughly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> what’s changed for C# 3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first big difference is that the method arguments work as a team in C# 3. In C# 2 every argument was used to try to pin down some type parameters </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and the compiler would complain if any two arguments came up with different results for a particular type parameter, even if they were compatible. In C# 3, argu<a name="bookmark2665"></a>ments can contribute </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">pieces</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of information—types that must be implicitly convertible to the final fixed value of a particular type variable. The logic used to come up with that fixed value is the same as for inferred return types and implicitly typed arrays. The following listing shows an example of this—without using any lambda expressions or even anonymous methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.14 Flexible type inference combining information from multiple arguments</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void PrintType&lt;T&gt;(T first, T second)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(typeof(T));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintType(1, new object());</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although the code in listing 9.14 is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">syntactically</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> valid in C# 2, it wouldn’t build: type inference would fail, because the first parameter would decide that T must be int and the second parameter would decide that T must be object. In C# 3 the compiler determines that T should be object in exactly the same way that it did for the inferred return type in listing 9.13. In fact, the inferred return type rules are effectively one example of the more general process in C# 3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Th<a name="bookmark2666"></a>e second change is that type inference is now performed in two phases. The first phase deals with normal arguments where the types involved are known to begin with. This includes anonym<a name="bookmark2667"></a>ous functions where the parameter list is explicitly typed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The second phase then kicks in, where implicitly typed lambda expressions and method groups have their types inferred. The idea is to see whether any of the information we’ve piece<a name="bookmark2668"></a>d together so far is enough to work out the parameter types of the lambda expression (or method group). If it is, the compiler can then examine the body of the lambda expression and work out the inferred return type—which is often another of the type parameters we’re looking for. If the second phase gives some</font></p><img src="images/31.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 9.7 The two-phase type inference flow</font></p>
<p><a name="bookmark2669"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">more information, we go through it again, repeating until either we run out of clues or we’ve worked out all the type parameters involved. Figure 9.7 shows this in flow chart form—but please bear in mind that this is still a heavily simplified version of the algorithm.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s look at two examples to show how it works. First we’ll take the code we started the section with—listing 9.11.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void PrintConvertedValue&lt;TInput,TOutput&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(TInput input, Converter&lt;TInput,TOutput&gt; converter)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(converter(input));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintConvertedValue(&quot;I'm a string&quot;, x =&gt; x.Length)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The type parameters we need to work out in listing 9.11 are TInput and TOutput. The steps performed are as follows:</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;Phase 1 begins.</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">2</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;The first parameter is of type TInput, and the first argument is of type string. We infer that there must be an implicit conversion from string to TInput.</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">3</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;The second parameter is of type Converter&lt;TInput, TOutput&gt;, and the second argument is an implicitly typed lambda expression. No inference is per-formed—we don’t have enough information.</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">4</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;Phase 2 begins.</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">5</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;TInput doesn’t depend on any unfixed type parameters, so it’s fixed to string.</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">6</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;The second argument now has a fixed </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">input</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type, but an unfixed </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">output</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type. We can consider it to be (string x) =&gt; x.Length and infer the return type as int. Therefore an implicit conversion must take place from int to TOutput.</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">7</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;Phase 2 repeats.</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">8</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;TOutput doesn’t depend on anything unfixed, so it’s fixed to int.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">9 &nbsp;&nbsp;&nbsp;There are now no unfixed type parameters, so inference succeeds.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Complicated, eh? Still, it does the job—the result is what we’d want (TInput=string, TOutput=int) and everything compiles without any problems. The importance of phase 2 repeating is best shown with another example. Listing 9.15 shows </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">two</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> conversions being performed, with the output of the first one becoming the input of the second. Until we’ve worked out the output type of the first conversion, we don’t know the input type of the second, so we can’t infer its output type either.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.15 Multistage type inference</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void ConvertTwice&lt;TInput,TMiddle,TOutput&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(TInput input,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Converter&lt;TInput,TMiddle&gt; firstConversion,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Converter&lt;TMiddle,TOutput&gt; secondConversion)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TMiddle middle = firstConversion(input);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TOutput output = secondConversion(middle);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(output);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ConvertTwice(&quot;Another string&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">text =&gt; text.Length,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">length =&gt; Math.Sqrt(length));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first thing to notice is that the method signature appears to be pretty horrific. It’s not too bad when you stop being scared and just look at it carefully—and certainly the example usage makes it more obvious. We take a string and perform a conversion on it: the same conversion as before, just a length calculation. We then take that length (an int) and find its square root (a double).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Phase 1 of type inference tells the compiler that there must be a conversion from string to TInput. The first time through phase 2, TInput is fixed to string and we</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">infer that there must be a conversion from int to TMiddle. The second time through phase 2, TMiddle is fixed to int and we infer that there must be a conversion from double to TOutput. The third time through phase 2, TOutput is fixed to double and type inference succeeds. When type inference has finished, the compiler can look at the code within the lambda expression properly.</font></p>
<p><a name="bookmark2670"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">CHE<a name="bookmark2671"></a>CKING THE BODY OF A LAMBDA EXPRESSION The body of a lambda expression </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">cannot be checked</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> until the input parameter types are known. The lambda expression x =&gt; x.Length is valid if x is an array or a string, but invalid in many other cases. This isn’t a problem when the parameter types are explicitly declared, but with an implicit parameter list the compiler needs to wait until it’s performed the relevant type inference before it can try to work out what the lambda expression means.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">These examples have shown only one change working at a time—in practice there can be several pieces of information about different type variables, potentially discovered in different iterations of the process. In an effort to save your sanity (and mine), I’m not going to present any more complicated examples—hopefully you understand the general mechanism, even if the exact details are hazy.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although it may seem as if this kind of situation will occur so rarely that it’s not worth having such complex rules to cover it, in fact it’s common in C# 3, particularly with LINQ. You could easily use type inference extensively without even thinking about it—it’s likely to become second nature to you. If it fails and you wonder why, you can always revisit this section and the language specification.</font></p>
<p><a name="bookmark2672"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We need to cover one more change, but you’ll be glad to hear it’s easier than type inference: let's look at method overloading.</font></p>
<p><a name="bookmark261"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2673"></a>9.4.4 Picking the right overloaded method</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Overloading occurs when there are multiple methods available with the same name but different signatures. Sometimes it’s obvious which method is appropriate, because it’s the only one with the right number of parameters, or it’s the only one where all the arguments can be converted into the corresponding parameter types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The tricky bit comes when there are multiple methods that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be the right one. The rules in section 7.5.3 of the specification a<a name="bookmark2674"></a>re quite complicated (yes, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">again</font><font style="font-size:x-small;font-family:Times New Roman, serif;">)—b<a name="bookmark2675"></a>ut the key part is the way that each argument type is converted into the parameter type</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">.<sup><a name="footnote67"></a><a href="#bookmark2676">67</a></sup> </font><font style="font-size:x-small;font-family:Times New Roman, serif;">For instance, consider these method signatures, as if they were both declared in the same type:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Write(int x) void Write(double y)</font></p>
<p><a name="bookmark2677"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The meaning of a call to Write(1.5) is obvious, because there’s no implicit conversion from double to int, but a call to Write(1) is trickier. There </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> an implicit conversion</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">from int to double, so both methods are possible. At that point, the compi<a name="bookmark2678"></a>ler considers the conversion from int to int, and<a name="bookmark2679"></a> from int to double. A conversion from any type to itself is defined to be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">better than</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> any conversion to a different type, so the Write( int x) method is better than Write(double y) for this particular call.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When there are multiple parameters, the compiler has to make sure there’s a best method to use. One method is better than another if all the argument conversions involved are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">at least as good as</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the corresponding conversions in the other method, and at least one conversion is strictly better. As a simple example, suppose we had</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Write(int x, double y) void Write(double x, int y)</font></p>
<p><a name="bookmark2680"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">A call to Write(</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;">) would be ambiguous, and the compiler would force you to add a cast to at least one of the parameters to make it clear which method you meant to call. Each overload has one better argument conversion, so neither of them is the best method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That logic still applies to C# 3, but with one extra rule about anonymous functions, which never specify a return type. In this case, the inferred return type (as described in section 9.4.2) is used in the better-conversion rules.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s see an example of the kind of situation that needs the new rule. The following listing contains two methods with the name Execute, and a call using a lambda expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 9.16 Sample of overloading choice influenced by delegate return type</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Execute(Func&lt;int&gt; action)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;action returns an int: &nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;+ &nbsp;&nbsp;&nbsp;action());</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Execute(Func&lt;double&gt; action)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;action returns a double: &nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;+ &nbsp;&nbsp;&nbsp;action());</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Execute(() =&gt; 1);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The call to Execute in listing 9.16 could’ve been written with an anonymous method or a method group instead—the same rules are applied whatever kind of conversion is involved. So, which Execute method sho<a name="bookmark2681"></a>uld be called? The overloading rules say that when two methods are both applicable after performing conversions on the arguments, t<a name="bookmark2682"></a>hose argument conversions are examined to see which one is better. The conversions here aren’t from a normal .NET type to the parameter type—they’re from a lambda expression to two different delegate types. So, which conversion is better?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Surprisingly enough, the same situation in C# 2 would result in a compilation error—there was no language rule covering this case. In C# 3, the method with the Func&lt;int&gt; parameter would be chosen. The extra rule that has been added can be paraphrased this way:</font></p>
<p><a name="bookmark2683"></a><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a name="bookmark2684"></a>If an anonymous function can be converted to two delegate types that have the same parameter list but different return types, then the delegate conversions are judged by the conversions from the inferred return type to the delegates’ return types.</font></p>
<p><a name="bookmark2685"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s pretty much gibberish without referring to an example. Let’s look back at listing 9.16: we’re converting from a lambda expression with no parameters and an inferred return type of int to either Func&lt;int&gt; or Func&lt;double&gt;. The parameter lists are the same (empty) for both delegate types, so the rule applies. We then just need to find the better conversion: int to int, or int to double. This puts us in more familiar territory—as we saw earlier, the int to int conversion is better. Listing 9.16 therefore prints out “action returns an int: </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.”</font></p>
<p><a name="bookmark262"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2686"></a><a name="bookmark2687"></a>9.4.5 &nbsp;&nbsp;&nbsp;Wrapping up type inference and overload resolution</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This section has been pretty heavy. I would’ve loved to have made it simpler—but it’s a fundamentally complicated topic. The terminology involved doesn’t make it any easier, especially as </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">parameter type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">type parameter</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> mean completely different things! Congratulations if you made it through and actually understood it all. Don’t worry if you didn’t: hopefully next time you read through the section, it’ll shed more light on the topic—particularly after you’ve run into situations where it’s relevant to your own code. For the moment, here are the most important points:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Anonymous functions (anonymous methods and lambda expressions) have inferred return types based on the types of all the return statements.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Lambda expressions can only be understood by the compiler when the types of all the parameters are known.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Type inference no longer requires that each argument independently come to exactly the same conclusion about type parameters, as long as the results stay compatible.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Type inference is now multistage: the inferred return type of one anonymous function may be used as a parameter type for another.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Finding the best overloaded method when anonymous functions are involved takes the inferred return type into account.</font></p>
<p><a name="bookmark263"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2688"></a>9.5 &nbsp;&nbsp;&nbsp;Summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In C# 3, lambda expressions almost entirely replace anonymous methods. Of course, anonymous methods are supported for the sake of backward compatibility, but idiomatic, freshly written C# 3 code will contain few of them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen how lambda expressions are more than just a more compact syntax for delegate creation. They can be converted into expression trees, subject to some limitations. The expression trees can then be processed by other code, possibly performing equivalent actions in different execution environments. Without this ability, LINQ would be resticted to in-process queries.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our discussion of type inference and overloading was a necessary evil to some extent: very few people actually </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">enjoy</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> discussing the sort of rules that are required, but it’s important to have at least a passing understanding of what’s going on. Before we all feel too sorry for ourselves, spare a thought for the poor language designers who have to live and breathe this kind of thing, making sure the rules are consistent and don’t fall apart in nasty situations. Then pity the testers who have to try to break the implementation!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s it in terms of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">describing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> lambda expressions—but we’ll be seeing a lot more of them in the rest of the book. For instance, our next chapter is all about </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extension methods</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Superficially, they’re completely separate from lambda expressions—but in reality the two features are often used together.</font></p>
<p><a name="bookmark2689"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Extension methods</font></p>
<p><a name="bookmark14"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2690"></a>This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Writing extension methods</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Calling extension methods</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Method chaining</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Extension methods in .NET 3.5</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Other uses for extension methods</font></p>
<p><a name="bookmark2691"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2692"></a>I’m not a fan of inheritance. Or rather, I’m not a fan of a <a name="bookmark2693"></a>number of places w<a name="bookmark2694"></a>here inheritance has been used in code that I’ve maintained, or class libraries I’ve worked with. As with so many things, it’s powerful when used properly, but its design overhead is often overlooked and can become painful over time. It’s sometimes used as a way of adding extra behavior and functionality to a class, even when no real i<a name="bookmark2695"></a>nformation is being added about the object—where nothing is being specialized.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Sometimes that’s appropriate—if objects of the new type should carry around the details of the extra behavior—but often it’s not. Often it’s just not possible<a name="bookmark2696"></a> to use inherit<a name="bookmark2697"></a>ance in this way i<a name="bookmark2698"></a>n the first place, if you’re working with a value type, a sealed c<a name="bookmark2699"></a>lass, or an interface. The alternative is usually to write a bunch of static methods, most of which take an instance of the type in question as at least one of</font></p>
<p><a name="bookmark2700"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">their parameters. This works fine, without the design penalty of inheritance, but it does tend to make code look ugly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 3 introduced the idea of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extension methods,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> w<a name="bookmark2701"></a>hich have the benefits of the static methods solution and also improve the readability of code that calls them. They let you call static methods as if they were instance methods of a completely different class. Don’t panic—it’s not as crazy or as arbitrary as it sounds.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this chapter we’ll first look at how to use extension methods and how to write them. We’ll then examine a few of the extension methods<a name="bookmark2702"></a> provided by .NET 3.5, and see how they can be chained together easily. This chaining ability is an important part of the reason for introducing extension methods to the language in the first place, and is an important part of LINQ.</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup><a name="footnote68"></a><a href="#bookmark2703">68</a></font><font style="font-size:small;font-family:Times New Roman, serif;"></sup> Finally, we’ll consider some of the pros and cons of using extension methods instead of plain static methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First, though, let’s have a closer look at why extension methods are sometimes desirable compared with what’s available in C# 1 and 2, particularly when you create utility classes.</font></p>
<p><a name="bookmark266"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2704"></a>10.1 Life before extension methods</font></p>
<p><a name="bookmark2705"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2706"></a>You may be getting a sense of deja vu at this point, because utility classes came up in chapter 7 when we looked at static classes. If you’ve written a lot of C# 2 code by the time you start using C# 3, you should look at your static classes—many of the methods in them may be good candidates for turning into extension methods. That’s not to say that all existing static classes are a good fit, but you may well recognize the following traits:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;You want to add some members to a type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;You don’t need to add any more data to the instances of the type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;You can’t change the type itself, because it’s in someone else’s code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One slight variation on this is where you want to work with an interface instead of a class, adding useful behavior while only calling methods on the int<a name="bookmark2707"></a>erface. A good example of this is IList&lt;T&gt;. Wouldn’t it be nice to be able to sort any (mutable) implementation of IList&lt;T&gt;? It’d be horrendous to force all implementations of the interface to implement sorting themselves, but it’d be nice from the point of view of the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">user</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the list.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The thing is, IList&lt;T&gt; provides all the building blocks for a completely generic sort routine (several, in fact), but you can’t put that implementation in the interface. IList&lt;T&gt; could’ve been specified as an abstract class instead, and the sorting functionality included that way, but as C# and .NET have single inheritance of implementation, that would’ve placed a significant restriction on the types deriving from it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Extension methods would allow us to sort any IList&lt;T&gt; implementation, making it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">appear</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as if the list itself provided the functionality.</font></p>
<p><a name="bookmark2708"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2709"></a>We’ll see later that a lot of the functionality of LINQ is built on extension methods over inter<a name="bookmark2710"></a>faces. For the moment, we’ll use a different type for our examples: System. IO. Stream, the bedrock of binary communication in .NET. Stream<a name="bookmark2711"></a> itself is an abstract class with sev<a name="bookmark2712"></a>eral concrete derived classes, such as NetworkStream, Fi<a name="bookmark2713"></a>leStream, and MemoryStream. Unfortunately, there are a few pieces of functionality that would’ve been handy to include in Stream but thatjust aren’t there.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The missing features I'm most oft<a name="bookmark2714"></a>en aware of are the ability to read the whole of a stream into memory as a byte array, and the ability to copy</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup><a name="footnote69"></a><a href="#bookmark2715">69</a></font><font style="font-size:x-small;font-family:Times New Roman, serif;"></sup> the contents of one stream into another. Both of these are frequently implemented badly, making assumptions about streams that just aren’t valid—the most common misconception being that Stream. Read will completely fill the given buffer if the data doesn’t run out first.</font></p>
<p><a name="bookmark2716"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">NOT SO “MISSING” AFTER A<a name="bookmark2717"></a>LL One of these features has been added to .NET 4: Stream now has a CopyTo method. This is actually useful in terms of demonstrating one slightly brittle aspect of extension methods—we’ll come back to it in section 10.2.3. ReadFully is still missing, but it should be used carefully anyway: you should only try to read the entirety of a stream if you’re confident it actually has an end, and that all the data fits into memory. Streams are under no obligation to have a finite amount of data.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’d be nice to have the functionality in a single pla<a name="bookmark2718"></a>ce, rather than duplicating it in several p<a name="bookmark2719"></a>rojects. That’s why I wrote the StreamUtil class in my<a name="bookmark2720"></a> miscellaneous utility library. The real code contains a fair amount of error checking and other functionality, but the following listing shows a cut-down version that’s more than adequate for our needs.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.1 A simple utility class to provide extra functionality for streams</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System.IO; public static class StreamUtil {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">const int BufferSize = 8192;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static void Copy(Stream input, Stream output)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">byte[] buffer = new byte[BufferSize]; int read;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">while ((read = input.Read(buffer, 0, buffer.Length)) &gt;&nbsp;0) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">output.Write(buffer, 0, read);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static byte[] ReadFully(Stream input)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using (MemoryStream tempStream = new MemoryStream())</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Copy(input, tempStream); return tempStream.ToArray();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The implementation details don’t matter much, although it’s worth noting that the ReadFully method calls the Copy method—that’ll be useful to demonstrate a point about extension methods later. The class is easy to use—the following listing shows how we can write a web response to disk, for example.</font></p>
<p><a name="bookmark2721"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.2 Using StreamUtil to copy a web response stream to a file</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WebRequest request<a name="bookmark2722"></a> = WebRequest.Create(&quot;<a href="http://manning.com">http://manning.com</a>&quot;); using (WebResponse response = request.GetResponse()) using (Stream responseStream = response.GetResponseStream()) using (FileStream output = File.Create(&quot;response.dat&quot;))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StreamUtil.Copy(responseStream, output);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.2 is quite compact, and the StreamUtil class has taken care of looping and asking the response stream for more data until it’s all been received. It’s done<a name="bookmark2723"></a> its job as a utility class perfectly reasonably. Even so, it doesn’t feel very object-oriented. We’d really like to ask the response str<a name="bookmark2724"></a>eam to copy itself to the output stream, just like the MemoryStream class has a WriteTo method. It’s not a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">big</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> problem, but it’s a little ugly as it is.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Inheritance wouldn’t help us in this situation (we want this behavior to be available for all streams, not just ones we’re responsible for) and we can’t go changing the Stream class itself—so what can we do? With C# 2, we were out of options—we had to stick with the static methods and live with the clumsiness. C# 3 allows us to change our static class to expose its members as extension methods, so we can pretend that the methods have been part of Stream all along. Let’s see what changes are required.</font></p>
<p><a name="bookmark268"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2725"></a>10.2 Extension meth<a name="bookmark2726"></a>od syntax</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Extension methods are almost embarrassingly easy to create, and simple to use, too. The considerations around when and how to use them are significantly deeper than the difficulties involved in learning how to write them in the first place. Let’s start by converting our StreamUtil class to have a couple of extension methods.</font></p>
<p><a name="bookmark269"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2727"></a>10.2.1 Declaring extension methods</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can’t use just any method as an extension method—it must have the following characteristics:</font></p>
<p><a name="bookmark2728"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2729"></a><a name="bookmark2730"></a><a name="bookmark2731"></a>■ &nbsp;&nbsp;&nbsp;It must be in a non-nested, nongeneric static class (and therefore must be a static method).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It must have at least one parameter.</font></p>
<p><a name="bookmark2732"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The &nbsp;&nbsp;&nbsp;first parameter must be prefixed with the thi<a name="bookmark2733"></a>s keyword.</font></p>
<p><a name="bookmark2734"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2735"></a>■ &nbsp;&nbsp;&nbsp;The &nbsp;&nbsp;&nbsp;first parameter can’t have any other modifiers (such <a name="bookmark2736"></a>as out or ref).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The &nbsp;&nbsp;&nbsp;type of the first parameter must not be a pointer type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s it—the method can be generic, return a value, have ref/out parameters other than the first one, be implemented with an iterator block, be part of a partial class, use nullable types—anything, as long as the preceding constraint<a name="bookmark2737"></a>s are met.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll call the type of the first parameter the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extended type</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the method, and say that the method </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">ext<a name="bookmark2738"></a>ends</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that type—so in this case we’re extending Stream. This isn’t official terminology from the specification, but it’s a useful piece of shorthand.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Not only does the previous list provide all the restrictions, but it also gives the details of what you need to do to turn a normal static method in a static class into an extension method—just add the this keyword. The following listing shows the same class as in listing </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">10</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, but this time with both methods as extension methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.3 The StreamUtil class again, but this time with extension methods</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static class StreamUtil {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">const int BufferSize = 8192;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static void CopyTo(this Stream input, Stream output)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">byte[] buffer = new byte[BufferSize]; int read;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">while ((read = input.Read(buffer, 0, buffer.Length)) &gt;&nbsp;0)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">output.Write(buffer, 0, read);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static byte[] ReadFully(this Stream input)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using (MemoryStream tempStream = new MemoryStream())</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CopyTo(input, tempStream); return tempStream.ToArray();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Yes, the only big change in listing 10.3 is the addition of the two modifiers, as shown in bold. I’ve also changed the name of the method from Copy to CopyTo. As we’ll see in a minute, that’ll allow calling code to read more naturally, although it does look slightly strange in the ReadFully method at the moment.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now, it’s not much use </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">having</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> extension methods if we can’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">use</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> them...</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve mentioned it in passing, but we haven’t yet seen what an extension method actually </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Simply put, it pretends to be an instance method of another type—the type of the first parameter of the method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The transformation of our example code that uses StreamUtil is as simple as the transformation of the utility class itself. This time, instead of adding something in, we’ll take it away. Listing 10.4 is a repeat performance of listing 10.2, but using the new syntax to call CopyTo. I say “new,” but it’s really not new at all—it’s the same syntax we’ve always used for calling instance methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.4 Copying a stream using an extension method</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WebRequest request = WebRequest.Create(&quot;<a href="http://manning.com">http://manning.com</a>&quot;); using (WebResponse response = request.GetResponse()) using (Stream responseStream = response.GetResponseStream()) using (FileStream output = File.Create(&quot;response.dat&quot;))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">responseStream.CopyTo(output);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In listing 10.4 it at least </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">looks</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> like we’re asking the response stream to do the copying. It’s still StreamUtil doing the work behind the scenes, but the code reads in a more natural way. In fact, the compiler has converted the CopyTo call into a normal static method call to StreamUtil.CopyTo, passing the value of responseStream as the first argument (followed by output as normal).</font></p>
<p><a name="bookmark2739"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that you can see t<a name="bookmark2740"></a>he code in question, I hope you can understand why I changed the method name from Copy to CopyTo. Some names work just as well for static methods as instance methods, but you’ll find that others need tweaking to get the maximum readability benefit.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If we want to make the StreamUtil code slightly more pleasant, you can change the line of ReadFully that calls CopyTo like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">input.CopyTo(tempStream);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">At this point, the name change is fully appropriate for all the uses—although there’s nothing to stop you from using the<a name="bookmark2741"></a> extension method as a normal static method, which is useful when you’re migrating a lot of code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may have noticed that nothing in these method calls indicates that we’re using an extension method instead of a regular instance method of Stream. This can be seen in two ways: it’s a good thing if our aim is to make extension methods blend in as much as possible and cause little alarm—but it’s a bad thing if you w<a name="bookmark2742"></a>ant to be able to immediately see what’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">really</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> going on. If you’re usin<a name="bookmark2743"></a>g Visual Studio, you can hover over a method call and get an indication in the tooltip when it’s an extension method, as shown in fig<a name="bookmark2744"></a>ure </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">10</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IntelliSense also indicates when it’s offering an extension method, in both the icon for the method and the tooltip when it’s selected. Of course, you don’t want to have to</font></p>
<p><font style="font-size:x-small;font-family:Consolas, monospace;font-weight:bold;">WebRequest request = WebRequest.Create(&quot;</font><font style="font-size:x-small;font-family:Consolas, monospace;font-weight:bold;text-decoration:underline;"><a href="http://manning.com">http://manning.com</font><font style="font-size:x-small;font-family:Consolas, monospace;font-weight:bold;"></a>&quot;) : using (WebResponse response = request.GetResponseQ) using (Stream responseStream = response.GetResponseStream()) using (FileStream output = File.Create(&quot;response.dat&quot;))</font></p>
<p><font style="font-size:small;font-family:Batang, serif;">{</font></p>
<p><font style="font-size:x-small;font-family:Consolas, monospace;font-weight:bold;">responseStream.CopyTo(output);</font></p>
<p><font style="font-size:small;font-family:Times New Roman, serif;font-weight:bold;">} &nbsp;&nbsp;&nbsp;(extension) &nbsp;&nbsp;&nbsp;void Stream.CopyTo(Stream output)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 10.1 Hovering over a method call in Visual Studio reveals whether the method is actually an extension method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">hover over every method call you make or be super careful with IntelliSense, but most of the time it doesn’t matter whether you’re calling an instance or extension method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s still one rather strange thing about our calling code—it doesn’t mention StreamUtil anywhere! How does the compiler know to use the extension method in the first place?</font></p>
<p><a name="bookmark271"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2745"></a><a name="bookmark2746"></a>10.2.3 Extension method discovery</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s important to know how to call extension methods—but it’s also important to know how to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> call them—how to avoid being presented with unwanted options. To achieve that, we need to know how the compiler decides which extension methods to use in the first place.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Extension methods are made available to the code in th<a name="bookmark2747"></a>e same way that classes are made available without qualification—with using directives. When the compiler sees an expression th<a name="bookmark2748"></a>at looks like it’s trying to use an instance method but none of the instance methods are compatible <a name="bookmark2749"></a>with the method call (if there’s no method with that name, for instance, or no overload matches the arguments given), it then looks for an appropriate extensio<a name="bookmark2750"></a>n method. It considers all the extension methods in all the imported namespaces<a name="bookmark2751"></a> and the current namespaces, and matches ones where there’s an implicit conversion from the expression type to the extended type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IMPLEMENTATION DETAIL: HOW DOES THE COMPILER SPOT AN EXTENSION METHOD?</font></p>
<p><a name="bookmark2752"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2753"></a><a name="bookmark2754"></a><a name="bookmark2755"></a>To work out whether to use an extension method, the compiler has to be able to tell the difference between an extension method and other methods within a static class that happen to have an appropriate signature. It does this by checking whether System.Runtime. CompilerServices. ExtensionAttribute has been applied to the method and the class. This attribute was introduced in .NET 3.5, but the compiler doesn’t check which assembly the attribute comes from. This means that you can still use extension methods even if your project targets .NET 2.0—you just need to define your own attribute with the right name, in the right namespace. You can then declare your extension methods as normal and the attribute will be applied automatically. The compiler also applies the attribute to the assembly </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">containing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the extension method, but it doesn’t currently require this when searching for extension methods.</font></p>
<p><a name="bookmark2756"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2757"></a>Introducing your own copies of system types can become problematic when you later need to use a version of the framework that already defines those types. If you do use this technique, it’s worth using preprocessor symbols to only declare the attribute conditionally. You can then build one version of your code targeting .NET 2.0, and another targeting .NET 3.5 and higher.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If multiple applicable extension methods are available for different extended types (usi<a name="bookmark2758"></a>ng implicit conversions), the most appropriate one is chosen with the better conversion rules used in overloading. For instance, if IChild inherits from IParent, and there’s an extension method with the same name for both, then the IChild extension method is used in preference to the one on IParent. Again, this feature is used in LINQ, as you’ll see in section 12.2 where we meet the IQueryable&lt;T&gt; interface.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s important to note that if an applicable instance method is available, that will always be <a name="bookmark2759"></a>used before searching for extension methods, but the compiler doesn’t issue a warning if an extension method also matches an existing instance method. For example, .NET 4 has a new Stream method that’s also called CopyTo. It has two overloads, one of which conflicts with our extension method. The result is that the new method is picked in preference to the extension method, so if you compile listing 10.4 against .NET 4, you’ll end up using Stream.CopyTo instead of StreamUtil.CopyTo. You can still call the StreamUtil method statically using the normal syntax of Stream-Util.CopyTo(input, output), but it’ll never be picked as an extension method. In this case there’s no harm to existing code: the new instance method has the same meaning as our extension method, so it doesn’t matter which one is used. In other cases there could be subtle differences in semantics that could be hard to spot until the code breaks.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Another potential problem with the way that extension methods are made available to code is that it’s very wide-ranging. If there are two classes in the same namespace containing methods with the same extended type, there’s no way of only using the extension methods from one of the classes. Likewise, there’s no way of importing a namespace for the sake of making types available using only their simple names, but without making the extension methods within that namespace available at the same time. You may want to use a namespace that solely contains static classes with extension methods to mitigate this problem, unless the rest of the functionality of the namespace is heavily dependent on the extension methods already (as is the case for System.Linq, for example).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One aspect of extension methods can be quite surprising when <a name="bookmark2760"></a>you first encounter it, but is also useful in some situations. It’s all about null references—let’s take a look.</font></p>
<p><a name="bookmark272"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2761"></a>10.2.4 Calling a method on a null reference</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’d be amazed if I ever encountered anyone who’d done a sig<a name="bookmark2762"></a>nificant amount of .NET programming without seeing a NullReferenceException due to calling a method via a varia<a name="bookmark2763"></a>ble whose value turned out to be a null re<a name="bookmark2764"></a>ference. You can’t call instance methods on null references in C# (although IL itself supports it for</font></p>
<p><a name="bookmark2765"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">nonvirtual calls)—but you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> call extension methods with a null reference. This is demonstrated by the following listing. Note that this isn’t a snippet since nested classes can’t contain extension methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.5 Extension method being called on a null reference</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using System;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static class NullUtil {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static bool IsNull(this object x)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return x == null;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class Test {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object y = null;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(y.IsNull()); y = new object();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(y.IsNull());</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The output of listing 10.5 is “True” then “False”—if IsNull had been a normal instance method, an exception would’ve been thrown in the second line of Main. Instead, IsNull was called with null as the argument. Prior to the advent of extension methods, C# had no way of letting you write the more readable y.IsNull() form safely, requiring NullUtil. IsNull(y) instead. There’s one particularly o<a name="bookmark2766"></a>bvious example in the framework where this could be useful: string.IsNullOrEmpty. C# 3 allows you to write an extension method that has the same signature (other than the extra parameter for the extended type) as an existing static method on the extended type. To save you reading through that sentence several times, here’s an example—even though the string class has a static, parameterless method IsNullOrEmpty, you can still create and use the following extension method:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static bool IsNullOrEmpty(this string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return string.IsNullOrEmpty(text);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">At first it seems odd to be able to call IsNullOrEmpty on a variable that’s null without an exception being thrown, particularly if you’re familiar with it as a static method from .NET 2.0. In my view, code using the extension method is more easily understandable. For instance, if you read the expression if (name. IsNullOrEmpty ()) out loud, it says exactly what it’s doing. As always, experiment to see what works for you— but be aware of the possibility of other people using this technique if you’re debugging code. Don’t be certain that an exception will be thrown on a method call unless you’re sure it’s not an extension method! Also note that you should think carefully</font></p>
<p><a name="bookmark2767"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">before reusing an existing name for an extension method—the previous extension method could confuse readers who are only familiar with the static method from the framework.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CHECKING FOR NULLITY As a conscientious developer, I’m sure that your production methods always check their arguments’ validity before proceeding.</font></p>
<p><a name="bookmark2768"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2769"></a>One question that naturally arises from this quirky feature of extension methods is what exception to throw when the first argument <a name="bookmark2770"></a>is null (assuming it’s not meant to be). Should it be ArgumentNullException, as if it were a normal argument, or should it be NullReferenceException, which is what would’ve happened if the extension method had been an instance method to start with? I recommend the former: it’s still an argument, even if the extension method syntax doesn’t make that obvious. This is the route that Microsoft has taken for t<a name="bookmark2771"></a>he extension methods in the framework, so it has the benefit of consistency too. Finally, bear in mind that extension methods can still be called as normal static methods—and in that situation, ArgumentNullException is clearly the preferred result.</font></p>
<p><a name="bookmark2772"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we know the syntax and behavior of extension methods, we can look at some examples of the ones provided in .NET 3.5 as part of the framework.</font></p>
<p><a name="bookmark274"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2773"></a>10.3 Extension methods in .NET 3.5</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The biggest use of extension methods in the framework is for LINQ. Some LINQ providers have a few extension methods to help them along, but there are two classe<a name="bookmark2774"></a>s that stand out,<a name="bookmark2775"></a> both of them appearing in the System.Linq namespace: Enumerable and Queryable. These contain many, many extension methods: most of the ones in Enumerable operate on IEnumerable&lt;T&gt; and most of those in Queryable operate on IQueryable&lt;T&gt;. We’ll see the purpose of IQueryable&lt;T&gt; in chapter 12, but for the moment let’s concentrate on Enumerable.</font></p>
<p><a name="bookmark275"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2776"></a>10.3.1 First steps with Enumerable</font></p>
<p><a name="bookmark2777"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Even just looking at Enumerable, we’re getti<a name="bookmark2778"></a>ng close to LINQ now. A lot of the time you don’t need full-blown query expressions to solve a problem. Enumerable has a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lot </font><font style="font-size:x-small;font-family:Times New Roman, serif;">of methods in it, and the purpose of this section isn’t to cover all of them but to give you enough of a feel for them to let you go off and experiment. It’s a joy to just play with everything av<a name="bookmark2779"></a>ailable in Enu<a name="bookmark2780"></a>merable—although this time it’s definitely worth firing up Visual Studio or LINQPad for your experiments (rather than using Snippy), as IntelliSense is handy for this kind of activity. Appendix A gives a quick run-down of the behavior too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All the complete examples in this section deal with a simple situation: we start with a collection of integers and transform it in various ways. Obviously real-life situations are likely to be somewhat more complicated, usually dealing with business-related types. At the end of this section, I’ll present a couple examples of just the transformation side of things applied to possible business situations, with full source code available on the book’s website—but that’s harder to play with than a straightforward</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">collection of numbers. It’s worth considering some recent projects you’ve been working on as we go: see if you can think of situations where you could’ve made your code simpler or more readable by using the kind of operations described here.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are a few methods in Enumerable that aren’t extension met<a name="bookmark2781"></a>hods, and we’ll use one of them in the examples for the rest of the chapter. The Range method takes two int parameters: a number to start with, and how many results to yield. The result is an IEnumerable&lt;int&gt;, which simply returns one number at a time in the obvious way. To demonstrate the Range method and give us a framework to play with, let’s just print out the numbers 0 to 9, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.6 Using Enumerable.Range to print out the numbers 0 to 9</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var collection = Enumerable.Range(0, 10); foreach (var element in collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(element);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">No extension methods are called in listing 10.6, just a plain static method. And yes, it really does just print the numbers 0 to 9—I never claimed this code would set the world on fire.</font></p>
<p><a name="bookmark2782"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">DEFERRED EXECUTION The Range method doesn’t build a list with the appropriate numbers—it just yields them at the appropriate time. In other words, constructing the enumerable instance doesn’t do the bulk of the work; it just gets things ready, so that the data can be provided in a just-in-time fashion at the appropriate point. This is called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">deferred execution</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—we’ve already seen this sort of behavior when we looked at iterator blocks in chapter </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">6</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, but we’ll see much more of it in the next chapter.</font></p>
<p><a name="bookmark2783"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Pretty much the simplest thing we can do with a sequence of numbers (which is already in order) is to reverse it. The following listing uses the Reverse extension method to do this—it returns an IEnumerable&lt;T&gt; that yields the same elements as the original sequence but in the reverse order.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.7 Reversing a collection with the Reverse method</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var collection = Enumerable.Range(0, 10)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Reverse();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var element in collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(element);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Predictably enough, this prints out 9, then </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">8</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, then 7, and so on right down to 0. We’ve called Reverse (seemingly) on an IEnumerable&lt;int&gt; and the same type has been returned. This pattern of returning one enumerable based on another is pervasive in the Enumerable class.</font></p>
<p><a name="bookmark2784"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2785"></a><a name="bookmark2786"></a><a name="bookmark2787"></a><a name="bookmark2788"></a><a name="bookmark2789"></a>EFFICIENCY: BUFFERING VERSUS STREAMIN<a name="bookmark2790"></a>G The extension methods provided by the framework try hard to stream or pipe data wherever possible—when an iterator is as<a name="bookmark2791"></a>ked for its next element, it’ll often take an element off the iterator it’s chained to, process that element, and then return something appropriate, preferably without using any more storage itself. Simple transformations and filters can do this easily, and it’s a powerful way of efficiently processing data where it’s possible—but some operations such as reversing the order, or sorting, require all the data to be available, so it’s all loaded into memory for bulk processing. The difference between this buffered approach and piping is similar to the difference between reading data by loading a whole DataSet versus using a DataReader to process one record at a time. It’s important to consider what’s required when using LINQ—a single method call can have significant performance implications.</font></p>
<p><a name="bookmark2792"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2793"></a>Streaming is also known as </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lazy evaluation;</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> buffering is also known as </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">eager evaluation.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> For example, the Reverse method uses deferred execution (it does nothing until the first call to MoveNext) but it then eagerly evaluates its data source. Personally I dislike the terms </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lazy</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">eager,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as they mean different things to different people (see <a href="http://mng.bz/3LLM">http://mng.bz/3LLM</a>).</font></p>
<p><a name="bookmark2794"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s do something more adventurous now—we’ll use a lambda expression to remove the even numbers.</font></p>
<p><a name="bookmark276"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2795"></a><a name="bookmark2796"></a>10.3.2 Filtering with Where and chaining method calls together</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Where extension method is a simple but powerful way of filtering collections: it accepts a predicate, which it applies to each of the elements of the original collection. Again, it returns an IEnumerable&lt;T&gt;, and this time any element that matches the predicate is included in the resulting collection. Listing 10.8 demonstrates this, applying the odd/even filter to t<a name="bookmark2797"></a>he collection of integers before reversing it. We don’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to use a lambda expression here—for instance, we could use a delegate we’d created earlier, or an anonymous method. In this case (and in many other real-life situations), it’s simple to put the filtering logic inline, and lambda expressions keep the code concise.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.8 Using the Where method with a lambda expression to find odd numbers</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var collection = Enumerable.Range(0, 10)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Where(x =&gt; x % 2 != 0)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Reverse();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var element in collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(element);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.8 prints out the numbers 9, 7, 5, 3, and 1. Hopefully you’ll have noticed a pattern forming—we’re chaining the method c<a name="bookmark2798"></a>alls together. The chaining idea itself isn’t new. For example, StringBuilder.Replace always returns the instance you call it on, allowing code like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">builder = builder.Replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)</font></p>
<p><a name="bookmark2799"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">String.Replace returns a string, but a new one each time—this allows chaining, but in a slightly different way. Both are handy pa<a name="bookmark2800"></a>tterns to know about; the “return the same reference” pattern works well for mutable types, whereas “return a n<a name="bookmark2801"></a>ew instance that’s a copy of the original with some changes” is required for immutable types.</font></p>
<p><a name="bookmark2802"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">These are both fine f<a name="bookmark2803"></a>or instance methods, but extension methods allow </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">static </font><font style="font-size:x-small;font-family:Times New Roman, serif;">method calls to be chained together. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">This is one of the primary reasons why extension methods exist.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> They’re </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">useful</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for oth<a name="bookmark2804"></a>er utility classes, but their true power is revealed in this ability to chain static methods in a natural way. That’s why extension methods primarily show up in Enumerabl<a name="bookmark2805"></a>e and Queryable in .NET: LINQ is geared toward this approach to data processing, with information effectively traveling through pipelines constructed of individual operations chained together.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">EFFICIENCY CONSIDERATION: REO<a name="bookmark2806"></a>RDERING METHOD CALLS TO AVOID WASTE I’m</font></p>
<p><a name="bookmark2807"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2808"></a>not a fan of micro-optimization without good cause, but it’s worth looking at the ordering of the method calls in listing 10.8. We could’ve added the Where call after the Reverse call instead and achieved the same results. But that would’ve wasted some effort—the Reverse call would’ve had to work out where the even numbers should come in the sequence even though they’ll be discarded from the final result. In this case it’s not going to make much difference, but it can have a significant effect on performance in real situations: if you can reduce the amount of wasted work without compromising readability, that’s a good thing. That doesn’t mean you should always put filters at the start of the pipeline, though; you need to think carefully about any reordering to make sure you’ll still get the correct results.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two obvious ways of writing the first part of listing 10.8 without using the fact that Reverse and Where are extension methods. One is to use a temporary variable, which keeps the structure intact:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var collection = Enumerable.Range(0, 10);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">collection &nbsp;&nbsp;&nbsp;= Enumerable.Where(collection, x =&gt; &nbsp;&nbsp;&nbsp;x % 2 &nbsp;&nbsp;&nbsp;!= &nbsp;&nbsp;&nbsp;0)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">collection &nbsp;&nbsp;&nbsp;= Enumerable.Reverse(collection);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I hope you’ll agree that the meaning of the code is far less &nbsp;&nbsp;&nbsp;clear &nbsp;&nbsp;&nbsp;here &nbsp;&nbsp;&nbsp;than &nbsp;&nbsp;&nbsp;in</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">listing 10.8. It gets even worse with the other option, &nbsp;&nbsp;&nbsp;which &nbsp;&nbsp;&nbsp;is &nbsp;&nbsp;&nbsp;to &nbsp;&nbsp;&nbsp;keep &nbsp;&nbsp;&nbsp;the &nbsp;&nbsp;&nbsp;single</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">statement style:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var collection = Enumerable.Reverse</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(Enumerable.Where</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(Enumerable.Range(0, 10), x =&gt; x % 2 != 0));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The method call order appears to be reversed, because the in<a name="bookmark2809"></a>nermost method call (Range) will be performed first, then the others, with execution working its way outward. Even with just three method calls it’s ugly—it becomes far worse for queries</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">involving more operators. Before we move on, let’s think a bit about what the Where method does.</font></p>
<p><a name="bookmark277"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2810"></a>10.3.3 &nbsp;&nbsp;&nbsp;Interlude: haven’t</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> we </font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">seen the Where method before?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If the Where method feels familiar, it’s because we implemented it in chapter </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">6</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. All we need to do is <a name="bookmark2811"></a>convert it into an extension method and change the delegate type from Predicate&lt;T&gt; to Func&lt;T,bool&gt; and we have a perfectly good alternative implementation to Enumerable.Where:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static IEnumerable&lt;T&gt; Where&lt;T&gt;(this IEnumerable&lt;T&gt; source,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;T, bool&gt; predicate)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (source == null || predicate == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new ArgumentNullException();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return WhereImpl(source, predicate);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static IEnumerable&lt;T&gt; WhereImpl&lt;T&gt;(IEnumerable&lt;T&gt; source,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;T, bool&gt; predicate)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (T item in source)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (predicate(item))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">yield return item;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We can convert our earlier example of calling this with in conjunction with our</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">LineReader class, too:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (string line in LineReader.ReadLines(&quot;../../FakeLinq.cs&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Where(line =&gt; line.StartsWith(&quot;using&quot;)))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(line);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark2812"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2813"></a>This is effectively a LINQ query without using the System.Linq namespace. It would work perfectly well in .NET 2.0 if you declared the appropriate Func delegate and [ExtensionAttribute]. You could even use that implementation for the where clause in a query expression (while still targeting .NET 2.0!) as we’ll see in the next chapter— but let’s not get ahead of ourselves. Filtering is one of the simplest operations in a query, and another is transforming or </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">projecting</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the results.</font></p>
<p><a name="bookmark278"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2814"></a>10.3.4 &nbsp;&nbsp;&nbsp;Projections using the Select method and anonymous types</font></p>
<p><a name="bookmark2815"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The most commonly used projection method in Enumerable is Select—it operates on an IEnumerable&lt;TSource&gt; and projects it into an IEnumerable&lt;TResult&gt; by way of a Func&lt;TSource,TResult&gt;, which is the transformation to use on each element, <a name="bookmark2816"></a>specified as a delegate. It’s much like the ConvertAll method in List&lt;T&gt;, but operating on any enumerable collection and using deferred execution to perform the projection only as each element is requested.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When I introduced anonymous types, I said they were useful with lambda expressions and LINQ—here’s an example of the kind of thing you can do with them. We currently have the odd numbers between 0 and 9 (in reverse order)—let’s create a type that encapsulates the square root of the number as well as the original number. The following listing shows both the projection and a slightly modified way of writing out the results. I’ve adjusted the whitespace solely for the sake of space on the printed page.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.9 Projection using a lambda expression and an anonymous type</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var collection = Enumerable.Range(0, 10)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Where(x =&gt; x % 2 != 0)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Reverse()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(x =&gt; new { Original = x, SquareRoot = Math.Sqrt(x) } ); foreach (var element in collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;sqrt({0})={1}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">element.Original,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">element.SquareRoot);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark2817"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This time the type of collection isn’t IEnumera<a name="bookmark2818"></a>ble&lt;int&gt;—it’s IEnumerable &lt;Something&gt;, where Something is the anonymous type created by the compiler. We can’t give the collection variable an explicit type e<a name="bookmark2819"></a>xcept either the nongeneric IEnumerable type or object. Implicit typing (with var) is what allows us to use the Original and SquareRoot properties when writing out the results. The output of listing 10.9 is as follows:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">sqrt(9)=3</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">sqrt(7)=2.64575131106459 sqrt(5)=2.23606797749979 sqrt(3)=1.732050807 56888 sqrt(1)=1</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, a Select method doesn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to use an anonymous type at all—we could’ve selected just the square root of the number, discarding the original. In that case the result would’ve been IEnumerable&lt;double&gt;. Alternatively, we could’ve manually written a type to encapsulate an integer and its square root—it was just easiest to use an anonymous type in this case.</font></p>
<p><a name="bookmark2820"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s look at one last method to round off our coverage of Enumerable for the moment: OrderBy.</font></p>
<p><a name="bookmark279"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2821"></a><a name="bookmark2822"></a>10.3.5 Sorting using the OrderBy method</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Sorting is a common requirement when processing <a name="bookmark2823"></a>data, and in LINQ this is usually performed using the OrderBy or OrderByDescending methods. The first call is some-</font></p>
<p><a name="bookmark2824"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2825"></a>times followed by ThenBy or ThenByDescending if you need to sort by more than one property of the data. This ability to sort on multiple properties has always been available the hard way using a complicated comparison, but it’s much clearer to be able to present a series of simple comparisons.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To demonstrate this, I’m going to make a small change to the operations involved. We’ll start off with the integers -5 to 5 (inclusive—11 elements in total), and then project to an anonymous type containing the original number and its square (rather than square root). Finally, we’ll sort by the square and then the original number. The following listing shows all of this.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 10.10 Ordering a sequence by two properties</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var collection = Enumerable.Range(-5, 11)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(x =&gt; new { Original = x, Square = x * x })</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.OrderBy(x =&gt; x.Square)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.ThenBy(x =&gt; x.Original);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var element in collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(element);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how aside from the call to Enumerable .Range, the code reads almost<a name="bookmark2826"></a> exactly lik<a name="bookmark2827"></a>e the textual description. This time I’ve decided to let the anonymous type’s ToString implementation do the formatting, and here are the results:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ Original = 0, Square = 0 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ Original = -1, Square = 1 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ Original = 1, Square = 1 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ Original = -2, Square = 4 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ Original = 2, Square = 4 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ Original = -3, Square = 9 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ Original = 3, Square = 9 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ Original = -4, Square = 16 } { Original = 4, Square = 16 }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{ Original = -5, Square = 25 } { Original = 5, Square = 25 }</font></p>
<p><a name="bookmark2828"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">As intended, the main sorting property is Square—but for two values that both have the same square, the negative original number is always sorted before the positive one. Writing a single comparison to do the same kind of thing (in a general case— there are mathematical tricks to cope with this particular example) would’ve been significantly more complicated, to the extent that you wouldn’t want to include the code inline in the lambda expression.</font></p>
<p><a name="bookmark2829"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One thing to note is that the ordering doesn’t change an existing collection—it returns a new sequence that yield<a name="bookmark2830"></a>s the same data as the input sequence, except sorted. Contrast this with List&lt;T&gt;.Sort or Array.Sort, which change the element order within the list or array. LINQ operators are intended to be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">side-effect free</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> : th<a name="bookmark2831"></a>ey don’t affect their input, and they don’t make any<a name="bookmark2832"></a> other changes to the environment, unless you’re iterating through a naturally stateful sequence (such as reading from a network</font></p>
<p><a name="bookmark2833"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">stream) or a <a name="bookmark2834"></a>delegate argument has side effects. This is a<a name="bookmark2835"></a>n approa<a name="bookmark2836"></a>ch from func<a name="bookmark2837"></a>tional progra<a name="bookmark2838"></a>mming, and <a name="bookmark2839"></a>it leads to code that’s more readable, testable, composable, predictable, thread-safe, and robust.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen just a few of the many extension methods availa<a name="bookmark2840"></a>ble in Enumerable, but hopefully you can appreciate how neatly they can be chained together. In the next chapter we’ll see how this can be expressed in a different way using extra syntax provided by C# 3 (query expressions)—as well as some other operations we haven’t covered here. It’s worth remembering that you don’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to use query expressions—often it can be simpler to make a couple of calls to methods in Enumerable, using extension methods to chain operations together.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve seen how all these apply to our collection-of-numbers example, it’s time for me to make good on the promise of some more business-related situations.</font></p>
<p><a name="bookmark280"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2841"></a>10.3.6 Business examples involving chaining</font></p>
<p><a name="bookmark2842"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Much of what we do as developers involves moving data around. In <a name="bookmark2843"></a>fact, for man<a name="bookmark2844"></a>y applications that’s the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> meaningful thing we do—the user interface, web services, database, and other components often exist solely to get data from one place to another, or from one form into another. It should be of no surprise that the extension methods we’ve looked at in this section are well-suited to many business problems. I’ll just give a couple of examples, as I’m sure you’ll be able to take them as a springboard into thinking about </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">your</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> business requirements and<a name="bookmark2845"></a> how C# 3 and the Enumerable class can help you solve problems more expressively than before. For each example I’ll only include a sample query—it should be enough to understand the purpose of the code, but without all the baggage. Full working code is on the book’s website.</font></p>
<p><a name="bookmark2846"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">AGGREGATION: SUMMING SALARIES</font></p>
<p><a name="bookmark2847"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The first example involves a company composed of several departments. Each department has a number of employees, each of whom has a salary. Suppose we want to report on total salary cost by department, with the most expensive department first. The query is simply</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">company.Departments</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(dept =&gt; new</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dept.Name,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Cost = dept.Employees.Sum(person =&gt; person.Salary)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">})</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.OrderByDescending(deptWithCost =&gt; deptWithCost.Cost);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This query uses an anonymous type to keep the department name (using a projection initializer) and the sum of the salaries of all the <a name="bookmark2848"></a>employees within that department. The salary summation uses a self-explanatory Sum extension method, again part of Enumerable. In the result, the department name and total salary can be retrieved as properties. If you wanted the original department reference, you’d just need to change the anonymous type used in the Select method.</font></p>
<p><a name="bookmark2849"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">GROUPING: COUNTING BUGS ASSIGNED TO DEVELOPERS</font></p>
<p><a name="bookmark2850"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’re a professional develop<a name="bookmark2851"></a>er, I’m sure you’ve seen many project management tools giving you different metrics. If you have access to the raw data, LINQ can help you transform it in practically any way you choose. As a simple example, we could look at a list of developers and how many bugs they have assigned to them at the moment:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bugs.GroupBy(bug =&gt; bug.AssignedTo)</font></p>
<p><a name="bookmark2852"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(list =&gt; new { Developer = list.Key, Count = list.Count() }) .OrderByDescending(x =&gt; x.Count);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This query uses<a name="bookmark2853"></a> the GroupBy extension method, which groups the original collection by a projection (the developer assigned to fix the bug in this case), resulting in an IGrouping&lt;TKey,TElement&gt;. There are many overloads of GroupBy, but I’ve used the simplest one here and then selected just the key (the name of the developer) and the number of bugs assigned to them. After that we’ve ordered the result to show the developers with the most bugs first.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One of the problems when looking at the Enumerable class can be working out exactly what’s going on—one of the overloads of GroupBy has four type parameters and five normal parameters (three of which are delegates), for instance. Don’t panic—just follow the steps shown in chapter 3, assigning different types to different type parameters until you have a concrete example of what the method would look like. That usually makes it a lot easier to un<a name="bookmark2854"></a>derstand what’s going on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll use the example of defect tracking as our sample data when we look at query expressions in the next chapter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">These<a name="bookmark2855"></a> examples aren’t particularly involved, but I hope you can see the power of chaining method calls together, where each method takes an origi<a name="bookmark2856"></a>nal collection and returns another one in some form or other, whether by fil<a name="bookmark2857"></a>tering out some values, ordering them, transforming each element, aggregating some values, or other options. In many cases, the resulting code can be read aloud and understood immedi-ately—and in other situations it’s still usually a lot simpler than the equivalent code would’ve been in previous versions of C#.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve seen some of the extension methods provided for us, we’ll consider just how and when it makes sense for you to write them yourself.</font></p>
<p><a name="bookmark282"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2858"></a>10.4 Usage ideas and guidelines</font></p>
<p><a name="bookmark2859"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2860"></a>Like implicit typing of local variables, extension methods are controversial. It’d be difficult to claim that they make the overall aim of the code harder to understand in many cases, but at the same time they </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> obscure the details of what method is getting called. In the words of one of the lecturers at my university, “I’m hiding the truth in order to show you a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">bigger</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> truth”—if you believe that the most important aspect of the code is its result, extension methods are great. If the implementation is more important to you, then explicitly calling a static method is more clear. Effectively, it’s the difference between the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">what</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">how.</font></p>
<p><a name="bookmark2861"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve already looked at using extension methods for utility classes and method chaining, but before we discuss the pros and cons further, it’s worth calling out a couple of aspects that may not be obvious.</font></p>
<p><a name="bookmark283"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2862"></a><a name="bookmark2863"></a>10.4.1 &nbsp;&nbsp;&nbsp;“Extending the world” and making interfaces richer</font></p>
<p><a name="bookmark2864"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Wes Dyer, a former developer on the C# compiler team, has a fantastic blog covering all kinds of subject matter (see <a href="http://mng.bz/1CYo">http://mng.bz/1CYo</a>). One of his posts about extension methods particularly caught my attention (see <a href="http://mng.bz/I4F2">http://mng.bz/I4F2</a>). It’s called “Extending the World,” and it talks about how extension methods can make code easier to read by effectively adapting your environment to your needs:</font></p>
<p><a name="bookmark2865"></a><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Typically for a given problem, a programmer is accustomed to building up a solution until it finally meets the requirements. Now, it is possible to extend the world to meet the solution instead of solely just building up until we get to it. That library doesn’t provide what you need, just extend the library to meet your needs.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This has implications beyond situations where you’d use a utility class. Typically developers only start creating utility classes when they’ve seen the same kind of code reproduced in dozens of places—but extending a library is about clarity of expression as much as avoiding duplication. Extension methods can make the calling code feel like the library is richer than it really is.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve already seen this with IEnumerable&lt;T&gt;, where even the simplest implementation </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">appears</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to have a wide set of operations available, such as sorting, grouping, projection, and filtering. Of course, the benefits aren’t limited to interfaces—you can also “extend the world” with enums, abstract classes, and so forth.</font></p>
<p><a name="bookmark2866"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The .NET Framework also provides a good example of another use for extension methods: fluent interfaces.</font></p>
<p><a name="bookmark284"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2867"></a>10.4.2 &nbsp;&nbsp;&nbsp;Fluent interfaces</font></p>
<p><a name="bookmark2868"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2869"></a><a name="bookmark2870"></a>There used to be a television program in the United Kingdom called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Catchphrase.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> The idea was that contestants would watch a screen where an animation would show some cryptic version of a phrase or saying, which they’d have to guess. The host would often try to help by instructing them: “Say what you see.” That’s pretty much the idea behind </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">fluent interfaces</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—that if you read <a name="bookmark2871"></a>the code verbatim, its purpose will leap off the screen as if it were written in a natural human lan<a name="bookmark2872"></a>guage. The ter<a name="bookmark2873"></a>m was originally coined by Martin Fowler (see <a href="http://mng.bz/3T9T">http://m<a name="bookmark2874"></a>ng.bz/3T9T</a>) and Eric Evans. If you’re familiar with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">domain-specific languages</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (DSLs), you may be wondering what the differences are between a fluent interface and a DSL. A lot has been written on the subje<a name="bookmark2875"></a>ct, but the con<a name="bookmark2876"></a>sensus seems to be that a DSL has more freedom to create its own syntax and grammar, whereas a fluent interface is constrained by the host language (C# in our case).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Some good examples of fluent interfaces in the framework are the OrderBy and ThenBy methods: with a bit of interpretation of lambda expressions, the code explains exactly what it does. In the case of our numbers example earlier, we could read “order by the square, then by the original number” without much work. Statements end up reading as whole sentences rather than just individual noun-verb phrases.</font></p>
<p><a name="bookmark2877"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 10.2 Pulling apart a fluent interface expression to create a meeting. The time of the meeting is specified using extension methods to create a </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TimeSpan </font><font style="font-size:x-small;font-family:Times New Roman, serif;">from an </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and a </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime </font><font style="font-size:x-small;font-family:Times New Roman, serif;">from a </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TimeSpan</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Writing fluent interfaces can require a change of mindset. Method names defy the normal descriptive-verb form, with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">And</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Then</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">If</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> sometimes being suitable methods in a fluent interface. The methods themselves often do little more than setting up context for future calls, often returning a type whose sole<a name="bookmark2878"></a> purpose is to act as a bridge between calls. Figure 10.2 gives an example of how this bridging works. It only uses two extension methods (on int and TimeSpan), but they make all the difference to the readability.</font></p><div><img src="images/32.png"/></div><br clear="all"/>
<p><a name="bookmark2879"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2880"></a>The grammar of the example in figure 10.2 could have many different forms: you may be able to add additional attendees to an UntimedMeeting, or create an Unat-tendedMeeting at a particular time before specifying the attendees, for instance. For a lot more guidance on DSLs, see </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Building Domain-Specific Languages in Boo</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> by Ayende Rahien (Manning).</font></p>
<p><a name="bookmark2881"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2882"></a>C# 3 only supports extension </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">methods</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> rather than extension </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">properties,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which restricts fluent interfaces slightly—it means we can’t have expressions such as 1.week.from.now or 2.days + 10.hours (which are both valid in Groovy with an appropriate package—see <a href="http://mng.bz/0s2a">http://mng.bz/0s2a</a>), but with a few superfluous parentheses we can achieve similar results. At first it looks odd to call a method on a number (such as 2.Dollars () or 3.Meters()), but it’s hard to deny that the meaning is clear. Without extension methods, this sort of clarity simply isn’t possible when you need to act on types such as numbers that aren’t under your control.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">At the time of this writing, the development community is still on the fence a<a name="bookmark2883"></a>bout fluent inter<a name="bookmark2884"></a>faces: they’re relatively rare in most fields, although many mocking and unit testing libraries have at least some fluent aspects. They’re certainly not universally applicable, but in the right situations they can radically transform the readability of the calli<a name="bookmark2885"></a>ng code. As an example, with appropriate extension methods from my MiscUtil library I can iterate over every day I've been alive in a readable way:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (DateTime day in 19.June(197 6).To(DateTime.Today)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Step(1.Days()))</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although the range-related implementation details are complicated, the extensio<a name="bookmark2886"></a>n methods allowing 19 .June (1976) and 1.Days () are extremely simple. This is culture-specific code, which you may not want to expose in your production code—but it can make unit tests a great deal more pleasant.</font></p>
<p><a name="bookmark2887"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">These aren’t the only uses available for extension methods, of course. I've used them for argument validation, implementing alternative approaches to LINQ, adding my own operators to LINQ to Objects, making composite comparisons easier to build, adding more flag-related functionality to enums, and much more. I’m constantly amazed at how such a simple feature can have such a profound impact on readability when used appropriately. The key word there is “appropriately”—which is easier to say than describe.</font></p>
<p><a name="bookmark285"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2888"></a><a name="bookmark2889"></a><a name="bookmark2890"></a>10.4.3 Using extension methods sensibly</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m in no position to dictate how y<a name="bookmark2891"></a>ou write your code. It may be possible to write tests to objectively measure readability for an average developer, but it only matters for those who’re going to use and maintain your code. So, you need to consult with the relevant people as far as you can: this depends on your type of project and its audience, of course, but it’s nice to present different options and get appropriate feedback. Extension methods make this particularly easy in many cases, as you can demonstrate both options in working code simultaneously—turning a method into an extension method doesn’t stop you from calling it explicitly in the same way as before.</font></p>
<p><a name="bookmark2892"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The main question to ask is the one I referred to at the start of this section: is the “what does it do” aspect of the code more important than the “how does it do it”? That varies by person and situation, but here are some guidelines to bear in mind:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Everyone on the development team should be aware of extension methods and where they might be used. Where possible, avoid surprising code maintainers.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;By putting extensions in their own namespace, you make it hard to use them accidentally. Even if it’s not obvious when </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reading</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the code, the developer </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">writing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> it should at least be<a name="bookmark2893"></a> aware of what she’s doin<a name="bookmark2894"></a>g. Use a project-wide or company-wide convention for naming the namespace. You may choose to<a name="bookmark2895"></a> take this one step further and use a single namespace for each extended type. For instance, you could create a TypeExtensions namespace for classes that extend System.Type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Think carefully before you extend very widely used types such as numbers or object, or before you write a method where the extended type is actually a type parameter. Some guidelines go as far as to recommend that you shouldn’t do this at all; I think such extensions have their place, but should have to really earn their place in your library. In this situation it’s even more important that the extension me<a name="bookmark2896"></a>thod be either internal or in its own namespace: I wouldn’t want IntelliSense to be suggesting the June extension method everywhere I used an integer, for example—only in classes that used at least </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">some</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> extension methods related to date and time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The decision to write an extension method should always be a conscious one. It shouldn’t become habitual—not every static method deserves to be an extension method.</font></p>
<p><a name="bookmark2897"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Document whether the first p<a name="bookmark2898"></a>arameter (the value your method appears to be called on) is allowed to be null—<a name="bookmark2899"></a>if it’s not, check the value in the method and throw an ArgumentNullException if necessary.</font></p>
<p><a name="bookmark2900"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Be careful not to use a method name that already has a meaning in the extended ty<a name="bookmark2901"></a>pe. If the extended type is a framework type or comes from a third-part<a name="bookmark2902"></a>y library, check all your extended method names whenever you change versions of the library. If you’re lucky (as I was with Stream.CopyTo) the new <a name="bookmark2903"></a>meaning is the same as the old—but even so, you may wish to deprecate your extension method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Question your instincts, but acknowledge that they affect your productivity. Just like with implicit typing, there’s little point in forcing yourself to use a feature you instinctively dislike.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Try to group extension methods into static classes dealing with the same extended type. Sometimes related classes (such as DateTime and TimeSpan) can be sensibly grouped together, but avoid grouping extension methods targeting disparate types such as Stream and string within the same class.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Think </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">really</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> carefully before adding extension methods with the same extended type and same name in two different namespaces, particularly if there are situations where the different methods may both be applicable (they have the same number of parameters). It’s reasonable for adding or removing a using directive to make a program fail to build, but it’s nasty if it still builds but changes the behavior.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Few of these guidelines are particularly clear-cut—to some extent you’ll have to feel your own way to the best use or avoidance of extension methods. It’s perfectly reasonable to never write your own extension methods at all but still use the LINQ-related ones for the readability gains available there. It’s worth at least </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">thinking</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> about what’s possible, though.</font></p>
<p><a name="bookmark286"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2904"></a>10.5 Summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The mechanical aspect of extension methods is straightforward—the feature is simple to describe and demonstrate. The benefits (and costs) of them are harder to talk about in a definitive manner—it’s a touchy-feely topic, and different people are bound to have different views on the value provided.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this chapter I’ve tried to show a bit of everything—early on we looked at what the feature achieves in the language, before we saw some of the capabilities available through the framework. In some ways, this was a relatively gentle introduction to LINQ: we’ll be revisiting some of the extension methods we’ve seen so far when we delve into query expressions in the next chapter, as well as seeing some new ones.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A wide variety of methods are available within the Enumerable class, and we’ve only scratched the surface in this chapter. It’s fun to come up with a scenario of your own devising (whether hypothetical or in a real project) and browse through MSDN to see what’s available to help you. I urge you to use a sandbox project of some description</font></p>
<p><a name="bookmark2905"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">to play with the extension methods provided—it does feel like play rather than work, and you’re unlikely to want to constrain yourself to just looking at what you need to achieve your most immediate goal. Appendix A has a list of the standard query operators from LINQ, w<a name="bookmark2906"></a>hich covers ma<a name="bookmark2907"></a>ny of the methods within Enumerable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">New patterns and practices keep emerging in software engineering, and ideas from some systems often cross-pollinate to others. That’s one of the things that keeps development exciting. Extension methods allow code to be written in a way that was previously unavailable in C#, creating fluent interfaces and changing the environment to suit our code rather than the other way around. Those are just the techniques we’ve looked at in this chapter—there are bound to be interesting future developments using the new C# features, whether individually or combined.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The revolution obviously doesn’t end here. For a few calls, extension methods are fine. In our next chapter we look at the real power tools: query expressions and fullblown LINQ.</font></p>
<p><a name="bookmark15"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark2908"></a>Query expressions and LINQ to Objects</font></p>
<p><a name="bookmark2909"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Streaming sequences of data</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Deferred execution</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Standard query operators</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Translating query expressions</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Range variables and transparent identifiers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Projecting, filtering, and sorting</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Joining and grouping</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Choosing which syntax to use</font></p>
<p><a name="bookmark2910"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2911"></a>You may be tired of all the hyperbole around LINQ by now. We’ve already seen some examples earlier in the book, and you’ve almost certainly read a lot about it on the web. This is where we separate myth from reality:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;LINQ isn’t going to turn the most complicated query into a one-liner.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;LINQ isn’t going to mean you never need to look at raw S<a name="bookmark2912"></a>QL again.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;LINQ isn’t going to magically imbue you with architectural genius.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Given all that, LINQ is still the best way of expressin<a name="bookmark2913"></a>g queries that I’ve seen within an object-oriented environment. It’s not a silver bullet, but it’s a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> powerful tool to have in yo<a name="bookmark2914"></a>ur development a<a name="bookmark2915"></a>rmory. We’ll explore<a name="bookmark2916"></a> two distinct aspe<a name="bookmark2917"></a>cts of LINQ: the framework support, and the compiler translation of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">query expressions.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> The latter can look odd to start with, but I’m sure you’ll learn to lo<a name="bookmark2918"></a>ve them.</font></p>
<p><a name="bookmark2919"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Query expressions are effectively preprocessed by the compiler into “normal” C# 3, which is then compiled in an ordinary way. This is a neat way of integrating queries into the language without changing the specification in more than one small section. Most of this chapter is a list of the preprocessing translations performed<a name="bookmark2920"></a> by the compiler, as <a name="bookmark2921"></a>well as the effects achieved when the result uses the Enumerable extension methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You won’t see any SQL or XML here—all that awaits us in chapter 12. But with this chapter as a foundation, you should be able to understand what the more exciting LINQ providers do when we meet them. Call me a spoilsport, but I want to take away some of their magic. Even without the air of mystery, LINQ is still very cool.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First let’s consider the basis of LINQ, and how we’re going to explore it.</font></p>
<p><a name="bookmark289"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2922"></a>11.1 &nbsp;&nbsp;&nbsp;Introducing LINQ</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A topic as large as LINQ needs a certain amount of background before we’re ready to see it in action. In this section we’ll look at a few of the core principles behind LINQ, and the data model we're going to use for the examples in this chapter and the next. I know you’re likely to be itching to get into the code, so I’ll keep it fairly brief.</font></p>
<p><a name="bookmark290"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2923"></a>11.1.1 &nbsp;&nbsp;&nbsp;Fundamental concepts in LINQ</font></p>
<p><a name="bookmark2924"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Most of this chapter is dedicated to exactly what the C# 3 compiler does with query expressions, but it won’t make much sense until we better understand the ideas under<a name="bookmark2925"></a>lying LINQ as a whole. On<a name="bookmark2926"></a>e of the problems with reducing the impedance mismatch between two data models is that it usually invo<a name="bookmark2927"></a>lves creating yet another model to act as the bridge. This section describes the LINQ model, beginning with its most important aspect: sequences.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">SEQUENCES</font></p>
<p><a name="bookmark2928"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You’re alrea<a name="bookmark2929"></a>dy familiar with the concept of a sequence: it’s encapsulated by the IEnumerable and IEnumerable&lt;T&gt; interfaces, and we looked at those fairly closely in chapter </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">6</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> when we studied iterators. A sequence is like a conveyor belt of items—you fetch them one at a time until either you’re no longer interested or the sequence has run out of data.</font></p>
<p><a name="bookmark2930"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Th<a name="bookmark2931"></a>e key differ<a name="bookmark2932"></a>ence between a sequence and other collection data structures such as lists and arrays is that when you’re reading from a sequence, you don’t generally know how many more items are waiting, or have access to arbitrary items—just the current one. Indeed, some sequences co<a name="bookmark2933"></a>uld be never-ending: you could easily have an infinite sequence of random numb<a name="bookmark2934"></a>ers, for example. Lists and arrays can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">act</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as sequences, of course—just as List&lt;T&gt; implements IEnumerable&lt;T&gt;—but the reverse isn’t always true. You can’t have an infinite array or list, for example.</font></p>
<p><a name="bookmark2935"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Sequences are LINQ’s bread and butter. When you read a query expression, you should think about the sequences involved: there’s always at least one sequence to start with, and it’s usually transformed into other sequences along the way, possibly being joined with yet more sequences. Examples of LINQ queries are frequently provided on the web with little explanation: when you take them apart by looking at each sequence in turn, things make a lot more sense. As well as being<a name="bookmark2936"></a> an aid to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reading </font><font style="font-size:x-small;font-family:Times New Roman, serif;">code, this can also help a lot when </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">writing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> it. Thinking in sequences can be tricky—it’s a bit of a mental leap sometimes—but if you can get there, it’ll help you immeasurably when you’re working with LINQ.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As a simple example, let’s take another query expression running a<a name="bookmark2937"></a>gainst a list of people. We’ll apply the same transformation as before, but with a filter involved that keeps only adults in the resulting sequence:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var adultNames = from person in people where person.Age &gt;= 18 select person.Name;</font></p><div>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 11.1 shows this query expression graphically, breaking it down into its individual steps.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Each arrow represents a sequence—the description is on the left side and some sample data is on the right. Each box is a step in our query expression. Initially, we have the whole family (as Person objects); then, after filtering, the sequence only contains adults (again, as Person objects); and the final result has the names of those adults as strings. Each time we take one sequence and apply an operation to produce a new sequence. The result isn’t the strings “Holly” and “Jon”—instead, it’s an IEnumerable&lt;string&gt;, which, when asked for its elements one by one, will first yield “Holly” and then “Jon”.</font></p><img src="images/33.png"/></div><br clear="all"/><div>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 11.1 A simple query expression broken down into the sequences and transformations involved</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This example was straightforward to start with, but we’ll apply the same technique later to more complicated query expressions in order to understand them more easily. Some advanced operations involve more than one sequence as input, but it’s still a lot less to worry about than trying to understand the whole query in one go.</font></p>
<p><a name="bookmark2938"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2939"></a>So, why are sequences so important? They’re the basis for a streaming model for data handling—one that allows us to fetch and process data only when we need it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">DEFERRED EXECUTION AND STREAMING</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When the query expression shown in figure 11.1 is created, no data is processed. The original list of people isn’t a<a name="bookmark2940"></a>ccessed </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">at all.<sup><a name="footnote70"></a><a href="#bookmark2941">70</a></font><font style="font-size:x-small;font-family:Times New Roman, serif;"></sup> Instead, a representation of t<a name="bookmark2942"></a>he query is built up in memory. Delegate <a name="bookmark2943"></a>instan<a name="bookmark2944"></a>ces are used to represent the predicate testing for adulthood and the conversion from a person to that person’s name. The wheels only start turning when the resulting IEnumerable&lt;string&gt; is asked for its first element.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This aspect of LINQ <a name="bookmark2945"></a>is called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">deferred execution</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Whe<a name="bookmark2946"></a>n the first element of the result is requested, the Select transformation asks the Where transformation for its first element. The Where transformation asks the list for its first element, checks whether the predicate matches (which it does in this case), and returns that element back to Select. That in turn extracts the name and returns it as the result.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">HAVEN'T WE SEEN THIS BEFORE? You may be getting a sense of deja vu here; I did mention all of this in chapter 10. But it’s such an important topic that it’s worth covering a second time, in more detail.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s a mouthful, but a se<a name="bookmark2947"></a>quence diagr<a name="bookmark2948"></a>am makes it all much clearer. I’m going to collapse the calls to MoveNext and Current to a single fetch operation: it makes the diagram a lot simpler. Just remember that each time the fetch occurs, it’s effectively checking for the end of the sequence as well. Figure 11.2 shows the first few stages of our sample query expression in operation, when we print out each element of the result using a foreach loop.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see in figure 11.2, only one element of data is processed at a time. If we decided to stop printing output after writing “Holly”, we’d never execute any of the operations on the other elements of the original sequence. Although several stages are involved here, processing data in a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">streaming</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> manner like this is efficient and flexible. In particular, regardless of how much source data there is, you don’t need to know about more than one element at any one point in time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is a best-case scenario. There are times where in order to fetch the first result of a query, you have to evaluate </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the data from the source. We’<a name="bookmark2949"></a>ve already seen one example of this in the previous chapter: the Enumerable.Reverse method needs to fetch all the data available in order to return the last original <a name="bookmark2950"></a>element as the first element of the resulting sequence. This<a name="bookmark2951"></a> makes Reverse a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">buffering</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> operation—which can have a huge effect on the efficiency (or even feasibility) of your overall operation. If</font></p><img src="images/34.png"/>
<p><a name="bookmark2952"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">you can’t afford to have all the data in memory at one time, you can’t use buffering operations.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just as the streaming aspect depends on which operation you perform, some transformations take place as soon a<a name="bookmark2953"></a>s you call them, rather than using deferred execution. This is called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">immediate execution.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Generally speaking, operations that return another sequence (usually an IEnumerable&lt;T&gt; or IQueryable&lt;T&gt;) use deferred execution, whereas operations that return a single value use immediate execution.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The operations that are widely available in LINQ are known as the standard query operators—let’s take a brief look at them now.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">STANDARD QUERY OPERATORS</font></p>
<p><a name="bookmark2954"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">LINQ’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">standard query operators</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> are a collection of transformations whose meanings are well understood. LINQ providers are encouraged to implement as many of these operators as possible, making the im<a name="bookmark2955"></a>plementation obey the expected behavior. This i<a name="bookmark2956"></a>s crucial in providing a consistent query framework across multiple data sources. Of course, some LINQ providers may expose more functionality, and some of the operators may not map appropriately to the target domain of the provider—but at least the opportunity for consistency is there.</font></p>
<p><a name="bookmark2957"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2958"></a><a name="bookmark2959"></a>IMPLEMENTATION-SPECIFIC DETAILS OF STANDARD OPERATORS Just because the standard query operators have common general meanings doesn’t mean they’ll work exactly the same for every implementation. For example, some LINQ providers may load the data for a whole query as soon as they need the first item—if you’re accessing a web service, that<a name="bookmark2960"></a> may make perfect sense. Likewise a query that works in LINQ to Objects may have subtly different semantics in LINQ to SQL. This doesn’t mean that LINQ has failed, just that you still need to consider which data source you’re accessing when you write a query. There’s still a massive advantage in having a single set of query operators and a consistent query syntax, even though it’s not a panacea.</font></p>
<p><a name="bookmark2961"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 3 has support for some of the standard query operators built into the language via query expressi<a name="bookmark2962"></a>ons, <a name="bookmark2963"></a>but they can always be called manually. You may be interested to know that VB 9 has more of the operato<a name="bookmark2964"></a>rs present in the language: as ever, ther<a name="bookmark2965"></a>e’s a trade-off between the added complexity of including a feature in the language and the benefits that feature brings. Personally I think the C# team has done an admirable job: I’ve always been a fan of a relatively small language with a large library behind it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">OPERATOR OVERLOADING The word </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">operator</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is used to describe both query operators (methods such as Select and Where) and the familiar operators such as addition, equality, and so on. Usually it should be obvious which one I mean from the context—if I’m talking about LINQ, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">operator</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> will almost always refer to a method used as part of a query.</font></p>
<p><a name="bookmark2966"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll see some of these operators in our examples as we go through this chapter and the next, but I don’t aim to give a comprehensive guide to them here: this book is primarily about C#, not the whole of LINQ. You don’t need to know all of the operators in order to be productive in LINQ, but your experience is likely to grow over time. Appendix A gives a brief description of each of the standard query operators, and MSDN gives more details of each specific overload. When you run into a problem, check the list: if it feels like there </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">ought</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be a built-in method to help you, <a name="bookmark2967"></a>there probably is! That’s not always the case, though—I founded the MoreLINQ open source project to add some extra opera<a name="bookmark2968"></a>tors to LINQ to Objects (see <a href="http://mng.bz/TuXP">http://mng.bz/</a> <a href="http://mng.bz/TuXP">Tu</a>XP). Likewise the Reactive Extensions package (see <a href="http://mng.bz/R7ip">http://mng.bz/R7ip</a>) has additions for the pull model of LINQ to Objects as well as the push model we’ll look at later. If the standard operators fail you, check both projects before building your own</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">solution. It’s not a disaster if you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have to write your own operator, though; it can be a lot of fun. In chapter 12 I’ll give a few tips on this subject.</font></p>
<p><a name="bookmark2969"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Having mentioned examples, it’s time to introduce the data model that most of the rest of the sample code in this chapter will use.</font></p>
<p><a name="bookmark291"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2970"></a>11.1.2 &nbsp;&nbsp;&nbsp;Defining the sample data model</font></p>
<p><a name="bookmark2971"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In section 10.3.4 I gave a brief example of defect tracking as a real use for extension methods and lambda expressions. We’ll use the same idea for almost all of the sample code in this chapter—it’s a fairly simple model, but one that can be manipulated in many different ways to give useful information. Defect tracking is also a domain that most professional developers are all t<a name="bookmark2972"></a>oo familiar with, unfortunately.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our fictional setting is SkeetySoft, a small software com<a name="bookmark2973"></a>pany with big a<a name="bookmark2974"></a>mbition. The founders hav<a name="bookmark2975"></a>e decided to attempt to create an office suite, a media player, and an instant messaging application. After all, there are no big players in those markets, are there?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The development department of SkeetySoft consists of five people: two developers (Deborah and Darren), two testers (Tara and Tim), and a manager (Mary). There’s currently a single customer: Colin. The aforementioned products are SkeetyOffice, SkeetyMediaPlayer, and SkeetyTalk, respectively</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">.<sup><a name="footnote71"></a><a href="#bookmark2976">71</a></font><font style="font-size:x-small;font-family:Times New Roman, serif;"></sup> We’re going to look at defects logged during May 2010, using the data model shown in figure 11.3.</font></p>
<p><a name="bookmark2977"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2978"></a>As you can see, we’re not recording a lot of data. In particular, there’s no real history to the defects, but there’s enough here to let us demonstrate the query expression features of C# 3. For the purposes o<a name="bookmark2979"></a>f this chapter, all the data i<a name="bookmark2980"></a>s stored in memory. We have a class named SampleData with properties AllDefects, AllUsers, AllProjects, and AllSubscriptions, which each return an appropriate type of IEnumerable&lt;T&gt;. The Start and End properties return DateTime in<a name="bookmark2981"></a>stances for the start and end of May respectively, and there are nested classes Users and Projects within SampleData to provide easy access to a particular user or proj<a name="bookmark2982"></a>ect. The one type that may not be immediately obvious is NotificationSubscription: the idea behind this is to send an email to the specified address every time a defect is created or changed in the relevant project.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are 41 defects in the sample data, created using C# 3 object initializers. All of the code is available on the book’s website, but I won’t include the sample data itself in this chapter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that the preliminaries are dealt with, let’s get cracking with some queries!</font></p>
<p><a name="bookmark293"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2983"></a>11.2 &nbsp;&nbsp;&nbsp;Simple beginnings: selecting elements</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Having brought up some general LINQ concepts beforehand, I’ll introduce the concepts that are specific to C# 3 as they arise in the course of the chapter. We’re going to start with a simple query (even simpler than the one we saw earlier) and work up to</font></p><img src="images/35.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">some complicated ones, not only building up your understanding of what the C# 3 compiler is doing, but also teaching you how to read LINQ code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All of our examples <a name="bookmark2984"></a>will follow the pattern of definin<a name="bookmark2985"></a>g a query and then p<a name="bookmark2986"></a>rinting the results to the console. We’re not interested in binding queries to data grids or anything like that—it’s all important, but not directly relevant to learning C# 3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We can use a simple expression that just prints out all our users as the starting point for examining what the compiler is doing behind the scenes and learning about </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">range variables</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><a name="bookmark294"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2987"></a><a name="bookmark2988"></a>11.2.1 Starting with a source and ending with a selection</font></p>
<p><a name="bookmark2989"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark2990"></a><a name="bookmark2991"></a>Every query expression in C# 3 starts off in the same way—stating the source of a sequence of data:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">element</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> in </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">source</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">element</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> part is just an identifier, with an optional type name before it. Most of the time you won’t need the type name, and we won’t have one for our first example. The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">source</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> part is just a normal expression. Lots of different things can happen after that first clause, but sooner or later you always end with a select clause or a group</font></p>
<p><a name="bookmark2992"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">clause. We’ll start off with a select clause to keep things nice and simple. The syntax for a select clause is also easy:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">expression</font></p>
<p><a name="bookmark2993"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The select clause is known as a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">projection.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Combining the two together and using the most trivial expression we can think of gives a simple (and practically useless) query, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.1 Trivial query to print the list of users</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from user in SampleData.AllUsers select user;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var user in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(user);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The query expression is the part highlighted in bold. I’ve overridden ToString for each of the entities in the model, so the results of listing </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">11.1</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> are as follows:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User: Tim Trotter (Tester)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User: Tara Tutu (Tester)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User: Deborah Denton (Developer)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User: Darren Dahlia (Developer)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User: Mary Malcop (Manager)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User: Colin Carton (Customer)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may be wondering how useful this is as an example: after all, we could’ve just used SampleData.AllUsers directly in our foreach statement. But we’ll use this query expression—trivial though it is—to introduce two new concepts. First we’ll look at the general nature of the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">translation</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> process the compiler uses when it encounters a query expression, and then we’ll discuss range variables.</font></p>
<p><a name="bookmark295"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark2994"></a><a name="bookmark2995"></a>11.2.2 Compiler translations as the basis of query expressions</font></p>
<p><a name="bookmark2996"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The C# 3 query expression support is based on the compiler translating query expressions into normal C# code. It does this i<a name="bookmark2997"></a>n a mechanical manner that doesn’t try to understand the code, apply type inference, check the validity of method calls, or any of the normal business of a compiler. That’s all done later, after the translation. In many ways, this first phase can be regarded as a preprocessor step. The compiler translates listing </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">11.1</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> into listing </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">11.2</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> before doing the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">real</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> compilation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.2 The query expression of listing 11.1 translated into a method call</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = SampleData.AllUsers.Select(user =&gt; user);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var user in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(user);</font></p>
<p><a name="bookmark2998"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The C# 3 compiler translates the query expression into </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that code before properly compiling it further. In particular, it doesn’t assume that it should use Enumerable.Select, or that List&lt;T&gt; will contain a method called Select. It merely translates the code and then lets the next phase of compilation deal with finding an appropriate method—whether as a straightforward member or as an ex<a name="bookmark2999"></a>tension method</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">.<sup>3</font><font style="font-size:x-small;font-family:Times New Roman, serif;"></sup> The parameter can be a suitable delegate type or an Expression&lt;T&gt; for an appropriate type T.</font></p>
<p><a name="bookmark3000"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This is where i<a name="bookmark3001"></a>t’s important that la<a name="bookmark3002"></a>mbda expressions can be converted into both delegate instances and expression trees. All the examples in this chapter will use delegates, but we’ll see how expression trees are used when we look at the other LINQ providers in chapter 12. When I present the signatures for some of the methods called by the compiler later on, remember that these are just the ones called in LINQ to Objects —whenever the parameter is a delegate type (which most of them are), the compiler will use a lambda expression as the argument, and then try to find a method with a suitable signature.</font></p>
<p><a name="bookmark3003"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s a<a name="bookmark3004"></a>lso important to remember that wherever a normal variable (such as a local variable within the method) appears within a lam<a name="bookmark3005"></a>bda expression after translation has been performed, it’ll become a captured variable in the same way that we saw back in chapter 5. This is normal lambda expression behavior—but unless you understand which variables will be captured, you could easily be confused by the results of your queries.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The language specification gives details of the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">query expression pattern</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which must be i<a name="bookmark3006"></a>mplemented for all query expressions to work, but this isn’t defined as an interface as you might expect. It makes a lot of sense: it allows LINQ to be applied to interfaces such as IEnumerable&lt;T&gt; using extension methods. This chapter tackles each element of the query exp<a name="bookmark3007"></a>ression pattern, one at a time. If you want to see exactly how the language specification defines each translation, see <a name="bookmark3008"></a>section 7.16 of the C# 4 spec.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.3 proves how the compiler translation works: it provides a dummy implementation of both Select and Where, with Select as a normal instance method and Where as an extension method. Our original<a name="bookmark3009"></a> simple query expression only contained a select clause, but I’ve included the where clause to show both kinds of methods in use. I’ve used a full listing rather than a snippet as extension methods can only be declared in top-level static classes.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.3 Compiler translation calling methods on a dummy LINQ implementation</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static class Extensions {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static Dummy&lt;T&gt; Where&lt;T&gt;(this Dummy&lt;T&gt; dummy,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;T,bool&gt; predicate)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Where called&quot;); return dummy;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Dummy&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Dummy&lt;U&gt; Select&lt;U&gt;(Func&lt;T,U&gt; selector)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;Select called&quot;); return new Dummy&lt;U&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class TranslationExample {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var source = new Dummy&lt;string&gt;(); var query = from dummy in source</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">where dummy.ToString() == &quot;Ignored&quot; select &quot;Anything&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Running listing 11.3 prints “Where called” and then “Select called” just as we’d expect, because the query expression has been translated into this code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = source.Where(dummy =&gt; dummy.ToString() == &quot;Ignored&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(dummy =&gt; &quot;Anything&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, we’re not doing any querying or transformation here, but it shows how the compiler is translating our query expression. If you’re puzzled as to why we’ve selected &quot;Anything&quot; instead of just dummy, it’s because a projection of just dummy (which is a do-nothing projection) would be removed by the compiler in this particular case. We’ll look at that later in section 11.3.2, but for the moment the important idea is the overall type of translation involved. We only need to learn what translations the C# compiler will use, and then we can take any query expression, convert it into the form that doesn’t use query expressions, and then look at what it’s doing from that point of view.</font></p>
<p><a name="bookmark3010"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how we don’t implement IEnumerable&lt;T&gt; at all in Dummy&lt;T&gt;. The translation from query expressions to normal code doesn’t depend on it, but in practice most LINQ providers will expose data either as IEnumerable&lt;T&gt; or IQueryable&lt;T&gt; (which we’ll look at in chapter 12). The fact that the translation doesn’t depend on any particul<a name="bookmark3011"></a>ar types but merely<a name="bookmark3012"></a> on the method names and parameters is a sort of compiletime form of duck typing. This is similar to the same wa<a name="bookmark3013"></a>y that the collection initializers pres<a name="bookmark3014"></a>ented in chapter </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">8</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> find a public method called Add using normal overload resolution rather than using an interface containing an Add method with a particular signature. Query expressions take this idea one step further—the translation occurs early in the compilation process in order to allow the compiler to pick either instance</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">methods or extension methods. You could even consider the translation to be the work of a separate preprocessing engine. You may think I’m banging on about this a lot, but it's all part of removing the mist that sometimes shrouds LINQ. If you rewrite a query expression as a series of method calls, eff<a name="bookmark3015"></a>ectively doing what the compiler would’ve done, you won’t change the performance and your query won’t behave any differently. They’re just two different ways of representing the same code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">WHY from ... where ... select INSTEAD OF select ... from ... w<a name="bookmark3016"></a>here? Many developers find the order of <a name="bookmark3017"></a>the clauses in query expressions confusing to start with. It looks just like SQL—except back to front. If you look back to the translation into methods, you’ll see the main reason behind it. The query expression is processed in the same order that it’s written: we start with a source in the from clause, then filter it in the where clause, then project it in the select clause. Another way of looking at it is to consider the diagrams throughout this chapter. The data flows from top to bottom, and the boxes appear in the diagram in the same order as their corresponding clauses appear in the query expression. Once you get over any initial discomfort due to unfamiliarity, you may find this approach appealing—I do. You may even find yourself asking the equivalent question about SQL.</font></p>
<p><a name="bookmark3018"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">So, we know that a source level translation is involved—but there’s another crucial concept to understand before we move on any further.</font></p>
<p><a name="bookmark296"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3019"></a>11.2.3 Range variables and nontrivial projections</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s look back at our original query expression in more depth. We haven’t examined the identifier in the from clause or the expression in the select clause. Figure 11.4 shows the query expression a<a name="bookmark3020"></a>gain, with each part labeled to explain its purpose.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The contextual keywords are easy to explain—they specify to the compiler what we want to do with the data. Likewise the source expression is just a normal C# expression—a property in this case, but it could just as easily have been a method call or a variable.</font></p><div><img src="images/36.png"/></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The tricky bits are the range variable declaration and the projection expression. Range variables aren’t like any other type of varia<a name="bookmark3021"></a>ble. In some ways they’re not variables at all! They’re only available in query expressions, and they’re<a name="bookmark3022"></a> effectively present to propagate context from one expression to another.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">They represent one element of a particular sequence at a time, and they’re used in the compiler translation to allow other</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup>ex</sup>p<sup>ressions to be turned into lambda</sup> <sub>F</sub>igu<sub>r</sub>e </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">11.4</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a simple query expression broken expressions easily. &nbsp;&nbsp;&nbsp;down into its constituent parts</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllUsers.Select(user =&gt; user)</font></p>
<p><a name="bookmark3023"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The left side of the lambda expression—the part that provides the parameter name — comes from the range variable declaration. The right side comes from the select clause. The translation is as simple as that (in this case). It all works out okay because we’ve used the same name on both sides. Suppose we’d written the query expression like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from user in SampleData.AllUsers select person</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In that case, the translated version would’ve been </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllUsers.Select(user =&gt; person)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">At that point the compiler would’ve complained because it wouldn’t have known what person referred to. Now that we know how simple the process is, it becomes easier to understand a query expression that has a slightly more complicated projection. The following listing prints out just the names of our users.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.4 Query selecting just the names of the users</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;string&gt; query = from user in SampleData.AllUsers</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select user.Name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (string name in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This time we’re using user.Name as the projection, and the result is a sequence of strings, not of User objects. (I’ve used an explicitly typed variable to emphasize this point.) The translation of the query expression follows the same rules as before, and becomes</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllUsers.Select(user =&gt; user.Name)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler allows this, because the chosen Select extension method from Enumerable has this signature</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">:<sup><a name="footnote72"></a><a href="#bookmark3024">72</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(this IEnumerable&lt;TSource&gt; source,</font></p>
<p><a name="bookmark3025"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a name="bookmark3026"></a>Func&lt;TSource,TResult&gt; selector)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The type inference described in chapter 9 kicks in, converting the lambda expression into a Func&lt;TSource,TResult&gt;. First it infers that TSource is User due to the type of SampleData.AllUsers. At that point it knows about the parameter type for the lambda expression, so it can resolve user.Name as a property access expression returning t<a name="bookmark3027"></a>ype string, thus inferring that T<a name="bookmark3028"></a>Result is string. This is why lambda expressions allow implicitly typed parameters, and why there are such complicated type inference rules: these are the gears and pistons of the LINQ engine.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">WHY DO YOU NEED TO<a name="bookmark3029"></a> KNOW ALL THIS? You can almost ignore what’s going on with range variables a lot of the time. You may have seen many, many queries and understood what they achieve without ever knowing about what’s going on behind the scenes. That’s fine for when things are working (as they tend to with examples in tutorials), but when things go wrong, it pays to know about the details. If you have a query expression that won’t compile because the compiler is complaining that it doesn’t know about a particular identifier, you should look at the range variables involved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we’ve only seen implicitly typed range variables. What happens when we include a type in the declaration? The answer lies in the Cast and Of Type standard query operators.</font></p>
<p><a name="bookmark297"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3030"></a><a name="bookmark3031"></a><a name="bookmark3032"></a>11.2.4 Cast, OfType, and explicitly typed range variables</font></p>
<p><a name="bookmark3033"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3034"></a>Most of the time, range<a name="bookmark3035"></a> variables can be implicitly typed; you’re likely to be working with generic collections where the specified type is all you need. What if that weren’t the case, though? What if we had an ArrayList, or perhaps an object[] that we wanted to perform a query on? It would be a pity if LINQ couldn’t be applied in those situations. Fortunately, there are two standard query operators that come to <a name="bookmark3036"></a>the rescue: Cast and OfType. Only Cast is supported directly by the query expression syntax, but we’ll look at both in this section.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The two operators are similar: both take an ar<a name="bookmark3037"></a>bitrary untyped sequence (they’re extension methods on the nongeneric IEnumerable type) and return a strongly typed sequence. Cast does this by casting each element to the target type (and failing on any element that isn’t of the right type) and OfType does a test first, skipping any elements of the wrong type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.5 demonstrates both of these operators, used as simple extension methods from Enumerable. Just for a change, we won’t be using our SkeetySoft defect system for our sample data—after all, that’s all strongly typed! Instead, we’ll just use two ArrayList objects.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.5 Using Cast and OfType to work with weakly typed collections</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ArrayList list = new ArrayList { &quot;First&quot;, &quot;Second&quot;, &quot;Third&quot; }; IEnumerable&lt;string&gt; strings = list.Cast&lt;string&gt;(); foreach (string item in strings)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(item);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">list = new ArrayList { 1, &quot;not an int&quot;, 2, 3 }; IEnumerable&lt;int&gt; ints = list.OfType&lt;int&gt;(); foreach (int item in ints)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(item);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first list contains only strings, so we’re safe to use Cast&lt;string&gt; to obtain a sequence of strings. The second list has mixed content, so in order to fetch just the integers from it we use OfType&lt;int&gt;. If we’d used Cast&lt;int&gt; on the second list, an exception would’ve been thrown when we tried to cast “not an int” to int. Note that this would only have happened </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">after</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> we’d printed “</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;">”—both operators stream their data, converting elements as they fetch them.</font></p>
<p><a name="bookmark3038"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3039"></a><a name="bookmark3040"></a><a name="bookmark3041"></a>IDENTITY, REFERENCE, AND UNBOX<a name="bookmark3042"></a>ING CONVERSIONS ONLY The behavior of Cast changed subtly in .NET 3.5 SP1. In the original .NET 3.5, it would perform more conversions—so using Cast&lt;int&gt; on a List&lt;s<a name="bookmark3043"></a>hort&gt; would convert each short into a int as it was fetched. In service pack 1 this will throw an exception. If you want any conversion other than a reference conversion or an unboxing conversion (or the no-op identity conversion), use a Select projection instead. OfType only performs these conversions too, although it doesn’t throw an exception if they fail.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When you introduce a range variable with an explicit type, the compiler uses a call to Cast to make sure the sequence used by the rest of the query expression is of the appropriate type. The following listing shows this, with a projection using the Substring method to prove that the sequence generated by the from clause is a sequence of strings.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.6 Using an explicitly typed range variable to automatically call Cast</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ArrayList list = new ArrayList { &quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;}; var strings = from string entry in list</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select entry.Substring(0, 3); foreach (string start in strings)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(start);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The output of listing 11.6 is “Fir,” “Sec,” “Thi”—but what’s more interesting is the translated query expression:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">list.Cast&lt;string&gt;().Select(entry =&gt; entry.Substring(0,3));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Without the cast, we wouldn’t be able to call Select at all, because the extension method is only defined for IEnumera<a name="bookmark3044"></a>ble&lt;T&gt; rather than IEnumerable. Even when you’re using a strongly typed collection, you might still want to use an explicitly typed range variable. For instance, you could have a collection that’s defined to be a List&lt;ISomeInterface&gt; but you know that all the elements are instances of MyImplementation. Using a range variable with an explicit type of MyImplementation allows you to access all the members of MyImplementation without manually inserting casts all over the code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve covered a lot of important conceptual ground so far, even though we haven’t achieved any impressive results. To recap the most important points briefly:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;LINQ is based on sequences of data, which are streamed wherever possible.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Creating a query doesn’t usually execute it: most operations use deferred execution.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Query expressions in C# 3 involve a preprocessing phase that converts the expression into normal C#, which is then compiled properly with all the normal rules of type inference, overloading, lambda expressions, and so forth.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The variables declared in query expressions don’t act like anything else: they are range variables, which allow you to refer to data consistently within the query expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I know that there’s a lot of somewhat abstract information to take in. Don’t worry if you’re beginning to wonder if LINQ is worth all this trouble. I promise you that it is. With a lot of the groundwork out of the way, we can start doing genuinely useful things—such as filtering our data, and then ordering it.</font></p>
<p><a name="bookmark299"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3045"></a>11.3 Filtering and ordering a sequence</font></p>
<p><a name="bookmark3046"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You may be surprised to learn that these two operations are some of the simplest to explain in terms of compiler translations. This is because they always return a sequence with the same element type as their input, which means we don’t need to worry about any new range variables being introduced. It also helps that we’ve seen the corresponding extension methods in chapter </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">10</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><a name="bookmark300"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3047"></a>11.3.1 Filtering using a where clause</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s remarkably easy to understand the where clause. The syntax is just</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">where </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">filter-expression</font></p>
<p><a name="bookmark3048"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler translates this into a call to the Where method with a lambda expression, which uses the appropriate range variable as the parameter and the filter expression as the body. The filter expression is applied as a predicate to each element of the incoming stream of data, and only those t<a name="bookmark3049"></a>hat return true are present in the resulting sequence. Using multiple where clauses results in multiple chained Where calls—only elements that match </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the predicates are part of the resulting sequence. The following listing demonstrates a query expression that finds all open defects assigned to Tim.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.7 Query expression using multiple where clauses</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User tim = SampleData.Users.TesterTim;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in SampleData.AllDefects where defect.Status != Status.Closed where defect.AssignedTo == tim</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select defect.Summary;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var summary in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(summary);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The query expression in listing 11.7 is translated into this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllDefects.Where(defect =&gt; defect.Status != Status.Closed) .Where(defect =&gt; defect.AssignedTo == tim)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(defect =&gt; defect.Summary)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The output of listing 11.7 is as follows:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Installation is slow Subtitles only work in Welsh Play button points the wrong way Webcam makes me look bald</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Network is saturated when playing WAV file</font></p>
<p><a name="bookmark3050"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, we could write a single where clause that combined the two conditions as an alternative to using multiple where clauses. <a name="bookmark3051"></a>In some cases this may improve performance, but it’s worth bearing the readability of the query expression in mind, too. Once more, this is likely to be fairly subjective. My personal inclination is to combine conditions that are logically related but keep others separate. In this case, both parts of the expression deal directly with a defect (as that’s all our sequence contains), so it’d be reasonable to combine them. As before, it’s worth trying both forms to see which is clearer.</font></p>
<p><a name="bookmark3052"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In a moment, we’ll start trying to apply some ordering rules to our query, but first we should look at a small detail to do with the select clause.</font></p>
<p><a name="bookmark301"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3053"></a>11.3.2 Degenerate query expressions</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">While we have a fairly simple translation to work with, let’s revisit a point I glossed over earlier in section 11.2.2 when I first introduced the compiler translations. So far, all our translated query expressions have included a call to Select. What happens if our select clause does nothing, effectively returning the same sequence as it’s given? The answer is that the compiler removes that call to Select—but only if there are other operations being performed within the query expression. For example, the following query expression just selects all the defects in the system:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from defect in SampleData.AllDefects select defect</font></p>
<p><a name="bookmark3054"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This is known as a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">degenerate query expression.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> The compiler deliberately generates a call to Select even though it seems to do nothing:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllDefects.Select(defect =&gt; defect)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s a big difference between this and using SampleData.AllDefects as a simple expression though. The items returned by the two sequences are the same, but the result of the Select method is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">just</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the sequence of items, not the source itself. The result of a query expression is never the same object as the source data, unless the</font></p>
<p><a name="bookmark3055"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">LINQ provider has been poorly coded. This can be important from a data integrity point of view—a provider can return a mutable result object, knowing that changes to the returned data sequence won’t affect the master even in the face of a degenerate query.</font></p>
<p><a name="bookmark3056"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When other operations are involved, there’s no need for the compiler to keep noop select clauses. For example, suppose we change the query expression in listing 11.7 to select the whole defect rather than just the name:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from defect in SampleData.AllDefects where defect.Status != Status.Closed</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">where defect.AssignedTo == SampleData.Users.TesterTim select defect</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We now don’t need the final call to Select, so the translated code is just this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllDefects.Where(defect =&gt; defect.Status != Status.Closed) .Where(defect =&gt; defect.AssignedTo == tim)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">These rules rarely get in the way when you’re writing query expressio<a name="bookmark3057"></a>ns, but they can cause confusion if you decompile the code with a tool such as Reflector—it can be surprising to see the Select call go missing for no apparent reason.</font></p>
<p><a name="bookmark3058"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">With that knowledge in hand, let’s improve our query so that we know what Tim should work on next.</font></p>
<p><a name="bookmark302"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3059"></a>11.3.3 Ordering using an orderby clause</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s not uncommon for developers and testers to be asked to work on the most critical defects before they tackle more trivial ones. We can use a simple query to tell Tim the order in which he should tackle the open defects assigned to him. The following listing does exactly this using an orderby clause, printing out all the details of the defects, in descending order of priority.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.8 Sorting by the severity of a defect, from high to low priority</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User tim = SampleData.Users.TesterTim;</font></p>
<p><a name="bookmark3060"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in SampleData.AllDefects where defect.Status != Status.Closed where defect.AssignedTo == tim orderby defect.Severity descending</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select defect;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var defect in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, defect.Severity, defect.Summary);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The output of listing 11.8 shows that we’ve sorted the results appropriately:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Showstopper: Webcam makes me look bald</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Major: Subtitles only work in Welsh</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Major: Play button points the wrong way</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Minor: Network is saturated when playing WAV file</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Trivial: Installation is slow</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can see that we have two major defects. Which order should those be tackled in? Currently no clear ordering is involved. Let’s change the query so that after sorting by severity in descending order, we sort by last modified time in </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">ascending</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> order. This means that Tim will test the defects that were fixed a long time ago before those addressed more recently. This just requires an extra expression in the orderby clause, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.9 Ordering by severity and then last modified time</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User tim = SampleData.Users.TesterTim;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in SampleData.AllDefects where defect.Status != Status.Closed where defect.AssignedTo == tim</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">orderby defect.Severity descending, defect.LastModified select defect;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var defect in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}: &nbsp;&nbsp;&nbsp;{1} &nbsp;&nbsp;&nbsp;({2:d})&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">defect.Severity, defect.Summary, defect.LastModified);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The results of listing 11.9 are shown here. Note how the order of the two major defects has been reversed:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Showstopper: Webcam makes me look bald (05/27/2010)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Major: Play button points the wrong way (05/17/2010)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Major: Subtitles only work in Welsh (05/23/2010)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Minor: Network is saturated when playing WAV file (05/31/2010)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Trivial: Installation is slow (05/15/2010)</font></p>
<p><a name="bookmark3061"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">So, that’s what the q<a name="bookmark3062"></a>uery expres<a name="bookmark3063"></a>sion looks like—but what does the<a name="bookmark3064"></a> compiler do? It simply calls the OrderBy and ThenBy methods (or OrderByDescending/ThenByDescending for descending orders). Our query expression is translated into</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllDefects.Where(defect =&gt; defect.Status != Status.Closed) .Where(defect =&gt; defect.AssignedTo == tim) .OrderByDescending(defect =&gt; defect.Severity) .ThenBy(defect =&gt; defect.LastModified)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve seen an example, we can look at the general syntax of orderby clauses. They’re basically the contextual keyword orderby followed by one or more orderings. An </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">ordering</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is just an expression (which can use range variables) optionally followed by ascending or descending, which have the obvious <a name="bookmark3065"></a>meanings. (The default order is ascending.) The translation for the primary ordering is a call to OrderBy or OrderBy-Descending, followed by as many calls to ThenBy or ThenByDescending as you have subsequent orderings.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The difference between OrderBy and ThenBy is simple: OrderBy assumes it has primary control over the ordering, whereas ThenBy understands that it’s subservient to one or more previous orderings. For LINQ to Objects, ThenBy is only defined as an</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">extension method for IOrderedEnumerable&lt;T&gt;, which is the type returned by OrderBy (and by ThenBy itself, to allow further chaining).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s important to note that although you can use multiple orderby clauses, each one will start with its own OrderBy or OrderByDescending clause, which means the last one will effectively win. I’ve yet to see a situation in which this is useful unless you do something else to the query between orde<a name="bookmark3066"></a>rby clauses: you should almost always use a single clause containing multiple orderings instead.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As noted in chapter 10, applying an ordering requires all the data to be loaded (at least for LINQ to Objects)—you can’t order an infinite sequence, for example. Hopefully the reason for this is obvious: you don’t know whether you’ll see something that should come at the start of the resulting sequence until you’ve seen all the elements.</font></p>
<p><a name="bookmark3067"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3068"></a>We’re about halfway through learning about query expressions, and you may be surprised that we haven’t seen any </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">joins</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> yet. Obviously they’re important in LINQ just as they’re important in SQL, but they’re also complicated. I promise we’ll get to them in due course, but in order to introduce just one new concept at a time, we’ll detour via let clauses first. That way we can learn about transparent identifiers before we hit joins.</font></p>
<p><a name="bookmark304"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3069"></a>11.4 Let clauses and transparent identifiers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Most of the rest of the operators we still need to look at involve </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">transparent identifiers. </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Just like range variables, you can get along perfectly well without understanding transparent identifiers, if you only want to have a fairly shallow grasp of query expressions. If you’ve bought this book, I hope you want to know C# at a deeper level, which will (among other things) enable you to look compilation errors in the face and know what they’re talking about.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You don’t need to know </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">everything</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> about transparent identifiers, but I’ll teach you enough so that if you see one in the language specification you won’t feel like running and hiding. You’ll also understand why they’re needed at all—and that’s where an example will come in handy. The let clause is the simplest transformation available that uses transparent identifiers.</font></p>
<p><a name="bookmark305"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3070"></a><a name="bookmark3071"></a>11.4.1 Introducing an intermediate computation with let</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A let clause introduces a new range variable with a value that can be based on other range variables. The syntax is as easy as pie:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">let </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">identifier</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> = </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">expression</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To explain this operator in terms that don’t use any other complicated operators, I’m going to resort to a very artificial example. Suspend your disbelief, and imagine that finding the length of a string is a costly operation. Now imagine that we had a completely bizarre system requirement to order our users by the lengths of their names, and then display the name and its length. Yes, I know it’s unlikely. Listing 11.10 shows one way of doing this without a let clause.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.10 Sorting by the lengths of user names without a let clause</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from user in SampleData.AllUsers orderby user.Name.Length select user.Name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var name in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, name.Length, name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That works fine, but it uses the dreaded Length property twice—once to so<a name="bookmark3072"></a>rt the users, and once in the display side. Surely not even the fastest supercomputer could cope with fi<a name="bookmark3073"></a>nding the lengths of six strings </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">twice!</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> No, we need to avoid that redundant computation. We can do so with the let clause, which evaluates an expression and introduces it as a new range variable. Listing 11.11 achieves the same result as listing 11.10, but only uses the Length property once per user.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.11 Using a let clause to remove redundant calculations</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from user in SampleData.AllUsers let length = user.Name.Length</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">orderby length</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select new { Name = user.Name, Length = length }; foreach (var entry in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;entry.Length, entry.Name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.11 introduces a new range variable called length, which contains the length of the user’s name (for the current user in the original sequence). We then use that new range variable for both sorting and the projecti<a name="bookmark3074"></a>on at the end. Have you spotted the problem yet? We need to use two range variables, but the lambda expression passed to Select only takes one parameter! This is where transparent identifiers come on the scene.</font></p>
<p><a name="bookmark306"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3075"></a>11.4.2 Transparent identifiers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In listing 11.11, we have </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">two</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> range variables involved in the final projection, but the Select method only acts on a single sequence. Ho<a name="bookmark3076"></a>w can we combine the range variables? The answer is to create an anonymous type that contains both variables, and then to apply a clever translation to make it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">look</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as if we actually have two parameters for the select and orderby clauses. Figure 11.5 shows the sequences involved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The let clause achieves its objectives by using another call to Select, creating an anonymous type for the resulting sequence, and effectively creating a new range variable whose name can never be seen or used in source code. Our query expression from listing </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">11.11</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is translated into something like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllUsers</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(user =&gt; new { user, length = user.Name.Length })</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.OrderBy(z =&gt; z.length)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(z =&gt; new { Name = z.user.Name, Length = z.length })</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Each part of the query has been adjusted appropriately: where the original query expression referenced user or length directly, if the reference occurs after the let clause, it’s replaced by z.user or z.length. The choice of z as the name here is arbitrary—it’s all hidden by the compiler.</font></p>
<p><a name="bookmark3077"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3078"></a>ANONYMOUS TYPES ARE AN IMPLEMENTATION DETAIL Strictly speaking, it’s up to the C# compiler implementation to decide how to group together different range variables to make transparent identifiers work.<a name="bookmark3079"></a> The Microsoft implementation uses anonymous types, and the specification shows the translations in those terms as well—so I’ve followed the trend. Even if another compiler chose a different approach, it shouldn’t affect the results.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you consult the language specification about let clauses (section 7.16.2.4), you’ll see that<a name="bookmark3080"></a> t<a name="bookmark3081"></a>he translation it describes is from one query expression to another. It uses an asterisk (*) to re<a name="bookmark3082"></a>present the transparent identifier introduced. The tra<a name="bookmark3083"></a>nsparent identifier is then </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">erased</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as a final step in translation. I won’t use that notation in this chapter, as it’s hard to come to grips with and unnecessary at the level of detail we’re going</font></p><img src="images/37.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 11.5 Sequences involved in listing </font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">11</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">11</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, where a let clause introduces the length range variable</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">into. Hopefully with this background, the specification won’t be quite as impenetrable as it might be otherwise, should you need to refer to it.</font></p>
<p><a name="bookmark3084"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The good news is that we can now look at the rest of the translations making up C# 3’s query expression support. I won’t go into the details of every transparent identifier introduced, but I’ll mention the situations in which they occur. Let’s look at the support for joins first.</font></p>
<p><a name="bookmark308"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3085"></a>11.5 Joins</font></p>
<p><a name="bookmark3086"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3087"></a><a name="bookmark3088"></a>If you’ve ever read </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">anything</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> ab<a name="bookmark3089"></a>out SQL, you probably have <a name="bookmark3090"></a>an idea what a database join is. It takes two tables (or views, or <a name="bookmark3091"></a>table-valued functions, and so forth) and creates a result by matching one set of <a name="bookmark3092"></a>rows against another set of rows. A LINQ join is similar, except it works on sequences. Three types of join are available, although not all of them use the join keyword in the query expression. We’ll start with the join that’s closest to a SQL inner join.</font></p>
<p><a name="bookmark309"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3093"></a>11.5.1 Inner joins using join clauses</font></p>
<p><a name="bookmark3094"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Inner joins involve two sequences. One </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">key selector</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> expression is applied to each element of the first sequence and another key selector (which may be totally different) is applied to each element of the second sequence. The result of the join is a sequence of all the pairs of elements where the key from the first element is the same as the key from the second element.</font></p>
<p><a name="bookmark3095"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3096"></a><a name="bookmark3097"></a><a name="bookmark3098"></a><a name="bookmark3099"></a>TERMINOLOGY CLASH! INNER AND OUTER SEQUENCES The MSDN documentation for the Join met<a name="bookmark3100"></a>hod used to evaluate inner joins calls the sequences involved inner and outer, and the real method parameters are based on these names too. This has nothing to do with inner joins and outer joins—it’s just a way of differen<a name="bookmark3101"></a>tiating between the sequences. You can think of them as first and second, left and right, Bert and Ernie—anything you like that helps you. I’ll use left and right for this chapter, so that it's clear which is which in the diagram. Usually, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">outer</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> corresponds with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">left</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">inner</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> corresponds with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">right.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The two sequences can be anything you like: the right sequence can even be the same as the left sequence, if that’s useful. (Imagine finding pairs of people who were born on the same day, for example.) The only thing that matters is that the two key selector expressions must result in the same type of key</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">.<sup><a name="footnote73"></a><a href="#bookmark3102">73</a></font><font style="font-size:x-small;font-family:Times New Roman, serif;"></sup> You can’t join a sequence of people to a sequence of cities by saying that the birth date of the person is the same as the population of the city—it doesn’t <a name="bookmark3103"></a>make any sense. But one important pos<a name="bookmark3104"></a>sibility is to use an a<a name="bookmark3105"></a>nonymous ty<a name="bookmark3106"></a>pe for the key: this works because anonymous types implement equality and hashing appropriately. If you need to effectively create a multicolumn key, anonymous types are the way to go. This is also applicable for the grouping operations we’ll see later.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The syntax for an inner join looks more complicated than it is:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">[query selecting the left sequence]</font></p>
<p><a name="bookmark3107"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">join <a name="bookmark3108"></a></font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">right-range-variable in right-sequence</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">on </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">left-key-selector</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> equals </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">right-key-selector</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Seeing equals as a contextual keyword rather than using symbols can be disconcerting, but it makes it easier to distinguish the left key selector from the right key selector. Often (but not always) at least one of the key selectors is a trivial one that just selects the exact element from that sequence. The contextual keyword is used by the compiler to separate the key selectors into different lambda expressions. The ability to obtain <a name="bookmark3109"></a>the keys for each value (on each side of the join) is important both for performance in LINQ t<a name="bookmark3110"></a>o Objects and for the feasibility of translating the query into other forms such as SQL.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s look at an example from our defect system. Suppose we’d just added the notification feature, and wanted to send the first batch of emails for all the existing defects. We need to join the list of notifications against the list of defects, where their projects match. The following listing performs just such a join.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.12 Joining the defects and notification subscriptions based on project</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in SampleData.AllDefects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">join subscription in SampleData.AllSubscriptions on defect.Project equals subscription.Project select new { defect.Summary, subscription.EmailAddress };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var entry in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;entry.EmailAddress, &nbsp;&nbsp;&nbsp;entry.Summary);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.12 will show each of the media player defects twice—once for media-<a href="mailto:bugs@skeetysoft.com">bugs@skeetysoft.com</a> and once for <a href="mailto:theboss@skeetysoft.com">theboss@skeetysoft.com</a> (because the boss really cares about the media player project).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this particular case we could easily have made the join the other way around, reversing the left and right sequences. The result would’ve been the same entries but in a different order. The implementation in LINQ to Objects returns entries such that all the pairs using the first element of the left sequence are returned (in the order of the right sequence), then all the pairs us<a name="bookmark3111"></a>ing the second element of the left<a name="bookmark3112"></a> sequence, and so on. The right sequence is buffered, but the left sequence is streamed—so if you want to join a massive sequence to a tiny one, it’s worth using the tiny one as the right sequence if you can. The operation is still deferred: it waits until you ask for the first pair before reading any data from either sequence. At that point, it reads the entirety of the right sequence in order to build a lookup from keys to the values producing those keys. After that, it doesn’t need to read from the right sequence again, and can begin to iterate over the left sequence, yielding pairs appropriately.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One error that might trip you up is putting the key selectors the wro<a name="bookmark3113"></a>ng way around. In the left key selector, only the left sequence range variable is in scope; in the</font></p><img src="images/38.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 11.6 The join from listing 11.12 in graphical form, showing two different sequences (defects and subscriptions) used as data sources</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">right key selector, only the right range variable is in scope. If you reverse the left and right sequenc<a name="bookmark3114"></a>es, you have to reverse the left and right key selectors too. Fortunately the compiler knows that this is a common mistake and suggests the appropriate course of action.</font></p>
<p><a name="bookmark3115"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Just to make it more obvious what’s going on, figure 11.6 shows the sequences as they’re processed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Often you want to filter the sequence, and filtering before the join occurs is more efficient than filtering it afterward. At this stage the query expression is simpler if the left sequence is the one requiring filtering. For instance, if we wanted to show only defects that are closed, we could use this query expression:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from defect in SampleData.AllDefects where defect.Status == Status.Closed join subscription in SampleData.AllSubscriptions</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">on defect.Project equals subscription.Project select new { defect.Summary, subscription.EmailAddress }</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> perform the same query with the sequences reversed, but it’s messier:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from subscription in SampleData.AllSubscriptions join defect in (from defect in SampleData.AllDefects where defect.Status == Status.Closed select defect) on subscription.Project equals defect.Project select new { defect.Summary, subscription.EmailAddress }</font></p>
<p><a name="bookmark3116"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how you can use one query expression inside another—the language specification describes many of the compiler translations in these terms. Nested query expressions are useful but hurt readability as well: it’s often worth looking for an alternative, or using a variable for the sequence on the right in order to make the code clearer.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ARE INNER JOINS USEFUL IN LINQ TO OBJECTS? Inner joins are used all the </font><font style="font-size:x-small;font-family:Times New Roman, serif;text-decoration:underline;">tim</font><font style="font-size:x-small;font-family:Times New Roman, serif;">e</font></p>
<p><a name="bookmark3117"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3118"></a><a name="bookmark3119"></a>in SQL. They’re effectively the way that<a name="bookmark3120"></a> we navigate<a name="bookmark3121"></a> from one entity to a related one, usually joining a foreign key in one table to the primary key on another. In the object-oriented model, we tend to navigate from one object to another via references. For instance, retrieving the summary of a defect and the name of the user assigned to work on<a name="bookmark3122"></a> it would require a join in SQL—in C# we often just use a chain of properties. If we’d had a reverse association from Project to the list of NotificationSubscription objects associated with it in our model, we wouldn’t have needed the join to achieve the goal of this example, either. That’s not to s<a name="bookmark3123"></a>ay that inner joins aren’t useful sometimes even within object-oriented models—but they don’t naturally occur nearly as often as in relational models.</font></p>
<p><a name="bookmark3124"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Inner joins are translated by the compiler into calls to the Join method, like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">leftSequence.Join(rightSequence,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">leftKeySelector,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">rightKeySelector,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">resultSelector)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The signature of the overload used for LINQ to Objects is as follows (this is the real signature, with the real parameter names—hence the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">inner</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">outer</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> references):</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; ( this IEnumerable&lt;TOuter&gt; outer,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;TInner&gt; inner,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;TOuter,TKey&gt; outerKeySelector,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;Inner,TKey&gt; innerKeySelector,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;TOuter,TInner,TResult&gt; resultSelector</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first three parameters are self-explanatory when you’ve remembered to treat </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">inner </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">outer</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">right</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">left,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> respectively, but the last one is more interesting. It’s a projection from two elements (one from the left sequence and one from the right sequence) into a single element of the resulting sequence. When the join is followed by anything other than a select clause, the C# 3 compiler introduces a transparent</font></p>
<p><a name="bookmark3125"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">identifier in order to make the range variables used in both sequences available for later clauses, and creates an anonymous type and simple mapping to use for the resultSelector parameter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But if the next part of the query expression is a select clause, the projection from the select clause is used directly as the resultSelector parameter—there’s no point in creating a pair and then calling Select when you can do the transformation in one step. You can still </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">think</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> about it as a ‘join” step followed by a “select” step despite the two being squished into a single method call. This leads to a more consistent mental model in my view, and one that’s easier to reason about. Unless you’re looking at the generated code, just ignore the optimization the compiler is performing for you.</font></p>
<p><a name="bookmark3126"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The good news is that having learned about inner joins, our next type of join is much easier to approach.</font></p>
<p><a name="bookmark310"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3127"></a>11.5.2 Group joins with join ... into clauses</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen that the result sequence from a normal join clause consists of pairs of elements, one from each of the input sequences. A </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">group join</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> looks similar in terms of the query expression but has a significantly different outcome. Each element of a group join result consists of an element from the left sequence (using its original range variable) and also a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">sequence</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of all the matching elements of the right sequence, exposed as a new range variable specified by the identifier coming after into in the join clause.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s change our previous example to use a group join. Listing 11.13 again shows all the defects and the notifications required for each of them, but breaks them out in a per-defect manner. Pay particular attention to how we’re displaying the results with a nested foreach loop.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.13 Joining defects and subscriptions with a group join</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in SampleData.AllDefects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">join subscription in SampleData.AllSubscriptions on defect.Project equals subscription.Project into groupedSubscriptions select new { Defect = defect,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Subscriptions = groupedSubscriptions };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var entry in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(entry.Defect.Summary); foreach (var subscription in entry.Subscriptions)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot; &nbsp;&nbsp;&nbsp;{0}&quot;, &nbsp;&nbsp;&nbsp;subscription.EmailAddress);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Subscriptions property of each entry is the embedded sequence of subscriptions matching that entry’s defect. Figure 11.7 shows how the two initial sequences are combined.</font></p><img src="images/39.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 11.7 Sequences involved in the group join from listing 11.13. The short arrows indicate embedded sequences within the result entries. In the output, some entries contain multiple email addresses for the same defect.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One important difference between an inner join and a group join—and between a group <a name="bookmark3128"></a>join and normal grouping—is that a group join has a one-to-one correspondence between the left sequence and the result sequence, even if some of the elements in the left sequence don’t match any elements of the r<a name="bookmark3129"></a>ight seque<a name="bookmark3130"></a>nce. This can be important, <a name="bookmark3131"></a>and is so<a name="bookmark3132"></a>metimes used to simulate a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">left outer join</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> from SQL. The embedded sequence is empty when the left <a name="bookmark3133"></a>element doesn’t match any rig<a name="bookmark3134"></a>ht elements. As with an inner join, a group join buffers the right sequence but streams the left one.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.14 shows an example of thi<a name="bookmark3135"></a>s, counting the number of defects created on each day in May. It uses a DateTimeRange type to generate a sequence of dates in May</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">as the left sequence, and a projection that calls Count() on the embedded sequence in the result of the group join.<sup><a name="footnote74"></a><a href="#bookmark3136">74</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.14 Counting the number of defects raised on each day in May</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var dates = new DateTimeRange(SampleData.Start, SampleData.End);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from date in dates</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">join defect in SampleData.AllDefects on date equals defect.Created.Date into joined</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select new { Date = date, Count = joined.Count() }; foreach (var grouped in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><a name="bookmark3137"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0:d}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;grouped.Date, &nbsp;&nbsp;&nbsp;grouped.Count);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Count() method uses immediate execution, iterating through all the elements of the sequence it’s called on—but we’re only calling it in the projection part of the query expression, so it becomes part of a lambda expression. This means we still have deferred execution: nothing is evaluated until we start the foreach loop.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here’s the first part of the results of listing 11.14, showing the number of defects created each day in the first week of May:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">05/01/2010: 1 05/02/2010: 0 05/03/2010: 2 05/04/2010: 1 05/05/2010: 0 05/06/2010: 1 05/07/2010: 1</font></p>
<p><a name="bookmark3138"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler translation involved for a group join is simply a call to the GroupJoin method in the same way as Join. Here's the signature for Enumerable .GroupJoin:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;( this IEnumerable&lt;TOuter&gt; outer,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;TInner&gt; inner,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;TOuter,TKey&gt; outerKeySelector,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;TInner,TKey&gt; innerKeySelector,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;TOuter,IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is exactly the same as for inner joins, except that the resultSelector parameter has to work with a sequence of right-hand elements, not just a single one. As with inner joins, if a group join is followed by a select clause, the projection is used as the result selector of the GroupJoin call; otherwise, a transparent identifier is introduced. In this case we have a select clause immediately after the group join, so the translated query looks like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dates.GroupJoin(SampleData.AllDefects, date =&gt; date,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">defect =&gt; defect.Created.Date,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(date, joined) =&gt; new { Date = date,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Count = joined.Count() })</font></p>
<p><a name="bookmark3139"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Our final type of join is known as a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">cross join</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—but it’s not as straightforward as it might initially seem.</font></p>
<p><a name="bookmark311"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3140"></a><a name="bookmark3141"></a><a name="bookmark3142"></a><a name="bookmark3143"></a>11.5.3 Cross joins and flattening sequences using multiple from clauses</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far all our joins have been </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">equijoins</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—a match has been performed between elements of the left and right sequences. Cross joins don’t perform any matching between the sequences: the result contains every possible pair of elements. They’re achieved by simply using two (or more) from clauses. For the sake of sanity we’ll only consider two from clauses for the moment—when there are more, just mentally perform a cross join on the first two from clauses, then cross join the resulting sequence with the next from clause, and so on. Each extra from clause adds its own range variable via a transparent identifier.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.15 shows a simple (but useless) cross join in action, producing a sequence where each entry consists of a user and a project. I’ve deliberately picked two completely unrelated initial sequences to show that no matching is performed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.15 Cross joining users against projects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from user in SampleData.AllUsers</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from project in SampleData.AllProjects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select new { User = user, Project = project };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var pair in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}/{1}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">pair.User.Name,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">pair.Project.Name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The output of listing 11.15 begins like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Tim Trotter/Skeety Media Player Tim Trotter/Skeety Talk Tim Trotter/Skeety Office Tara Tutu/Skeety Media Player Tara Tutu/Skeety Talk Tara Tutu/Skeety Office</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 11.8 shows the sequences involved to get this result.</font></p>
<p><a name="bookmark3144"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’re famili<a name="bookmark3145"></a>ar with SQL, you’re probably comfortable so far—it looks just like a Cartesian product obtained from a query specifying multiple tables. But more power is available when you want it: the right sequence can depend on the current value of the left sequence. In other words, each element of the left sequence is used to generate a right sequence, and then that left element is paired with each element of the new sequence. When this is the case, it’s not a cross join in the no<a name="bookmark3146"></a>rmal sense of the term. Instead, it’s effectively flattening a sequence of sequences into one single sequence. The query expression translation is the same whether or not we’re using a</font></p><img src="images/40.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 11.8 Sequences from listing 11.15, cross joining users and projects. All possible combinations are returned in the results.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">true cross join, so we need to understand the more complicated scenario in order to understand the translation process.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before we dive into the details, let’s see the effect it produces. The following listing shows a simple example, using sequences of integers.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.16 Cross join where the right sequence depends on the left element</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from left in Enumerable.Range(1, 4)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from right in Enumerable.Range(11, left) select new { Left=left, Right=right };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var pair in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Left={0}; Right={1}&quot;, pair.Left, pair.Right);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.16 starts with a simple range of integers, 1 to 4. For each of those integers, we create another range, beginning at 11 and having as many elements as the original integer. By using multiple from clauses, the left sequence is joined with each of the generated right sequences, resulting in this output:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Left=1; Right=11 Left=2; Right=11 Left=2; Right=12 Left=3; Right=11 Left=3; Right=12 Left=3; Right=13 Left=4; Right=11 Left=4; Right=12 Left=4; Right=13 Left=4; Right=14</font></p>
<p><a name="bookmark3147"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The method the compiler calls to generate this sequence is SelectMany. It takes a single input sequen<a name="bookmark3148"></a>ce (the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">left</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> sequence in our terminology), a delegate to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">generate </font><font style="font-size:x-small;font-family:Times New Roman, serif;">another sequence from any element of the left sequence, and a delegate to generate a result element given an element of each of the sequences. Here’s the signature of Enumerable.SelectMany:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt;( this IEnumerable&lt;TSource,TCollection&gt; source, Func&lt;TSource,IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As with the other joins, if the part of the query expression following the join is a select clause, that projection is used as the final argument; otherwise, a transparent identifier is introduced to make the range variables of both the left and right sequences available later in the query.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just to make this all a bit more concrete, here’s the query expression of listing 11.16, as the translated source code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Enumerable.Range(1, 4)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.SelectMany (left =&gt; Enumerable.Range(11, left),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(left, right) =&gt; new {Left = left, Right = right})</font></p>
<p><a name="bookmark3149"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One interesting feature of SelectMany is that the execution is completely streamed— it only needs to process one element of each sequence at a time, because it uses a freshly generated right sequence for each different element of the left sequence. Compare this with inner joins and group joins: they both load the right sequence completely before starting to return any results. You should bear in mind the expected size of sequence, and how expensive it might be to evaluate it multiple times, when considering which type of join to use and which sequence to use as the left and which as the right.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The flattening behavior of SelectMa<a name="bookmark3150"></a>ny can be very useful. Consider a situation where you want to process a lot of log files, a line at a time. We can process a seamless sequence of lines with barely any work. The following pseudo-code is filled in more</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">thoroughly in the downloadable source code, but the overall meaning and usefulness should be clear:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from file in Directory.GetFiles(logDirectory, &quot;*.log&quot;) from line in ReadLines(file) let entry = new LogEntry(line) where entry.Type == EntryType.Error select entry;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In just five lines of code we’ve retrieved, parsed, and filtered a whole collection of log files, returning a sequence of entries representing errors. Crucially, we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">haven’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> had to load even a single full log file into memory all in one go, let alone all of the files—all the data is streamed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Having tackled joins, the last items we need to look at are slightly easier to understand. We’re going to look at grouping elements by a key, and continuing a query expression after a group ... by or select clause.</font></p>
<p><a name="bookmark313"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3151"></a>11.6 Groupings and continuations</font></p>
<p><a name="bookmark3152"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One common requirement is to group a<a name="bookmark3153"></a> sequ<a name="bookmark3154"></a>ence of elements by one of its properties. LINQ makes this easy with the group ... by clause. In addition to describing this final type of claus<a name="bookmark3155"></a>e, we’ll also revisit our earliest one (select) to see a feature called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">query continuations</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that can be applied to both groupings and projections. Let’s start with a simple grouping.</font></p>
<p><a name="bookmark314"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3156"></a>11.6.1 Grouping with the group ... by clause</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Grouping is largely intuitive, and LINQ makes it simple. To group a sequence in a query expression, all you need to do is use the group ... by clause, with this syntax:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">group </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">projection</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> by </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">grouping</font></p>
<p><a name="bookmark3157"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3158"></a>This clause comes at the end of a query expression in the same way a select clause does. The similarities between the<a name="bookmark3159"></a>se clauses don’t end there: the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">projection</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> expression is the same kind of projection that select clauses use. The outcome is somewhat different, though.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">grouping</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> expression determines what the sequence is grouped by—the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">key</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the grouping. The overall result is a seque<a name="bookmark3160"></a>nce where each element is itself a sequence of projected elements, and also has a Key property, which is the ke<a name="bookmark3161"></a>y for that group; this combination is encapsulated in the IGrouping&lt;TKey,TElement&gt; interface, which extends IEnumerable&lt;TEle<a name="bookmark3162"></a>ment&gt;. Again, if you want to group by multiple values, you can use an anonymous type for the key.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s look at a simple example from the SkeetySoft defect system: grouping defects by their current assignee. Listing 11.17 does this with the simplest form of projection, so that the resulting sequence has the assignee as the key, and a sequence of defects embedded in each entry.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.17 Grouping defects by assignee—trivial projection</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in SampleData.AllDefects where defect.AssignedTo != null group defect by defect.AssignedTo;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var entry in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(entry.Key.Name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var defect in entry)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot; ({0}) &nbsp;&nbsp;&nbsp;{1}&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">defect.Severity, defect.Summary);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark3163"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.17 might be useful in a daily build report, to quickly see what defects each person needs to look at. We’ve filtered out all the defects that don’t need any more attention </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and then grouped using the AssignedTo property. Although this time we’re just using a property, the grouping expression can be anything you like—it’s applied to each entry in the incoming sequence, and the sequence is grouped based on the result of the expression. Note that grouping can’t stream the results: it applies the key selection and projection to each element in the input and buffers the grouped sequences of projected elements. Even though it’s not streamed, execution is still deferred until you start retrieving the results.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The projection we’ve applied in the grouping </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is trivial—it just selects the original element. As we go through the resulting sequence, each entry has a Key property, which is of type User </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and each entry also implements IEnumerable&lt;Defect&gt;, which is the sequence of defects assigned to that user </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The results of listing 11.17 start like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Darren Dahlia</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(Showstopper) MP3 files crash system</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(Major) Can't play files more than 200 bytes long</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(Major) DivX is choppy on Pentium 100</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(Trivial) User interface should be more caramelly</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">After all of Darren’s defects have been printed out, we see Tara’s, then Tim’s, and so on. The implementation effectively keeps a list of the assignees it’s seen so far, and adds a new one every time it needs to. Figure 11.9 shows the sequences generated throughout the query expression, w<a name="bookmark3164"></a>hich may m<a name="bookmark3165"></a>ake this ordering more clear.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Within each entry’s subsequence, the order of the defects is the same as the order of the original defect sequence. If you actively care about the ordering, consider explicitly stating it in the query expression, to make it more readable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you run listing 11.17, you’ll see that Mary Malcop doesn’t appear in the output at all, because she doesn’t have any defects assigned to her. If you wanted to produce a full list of users and defects assigned to each of them, you’d need to use a group join like the one in listing 11.14.</font></p><img src="images/41.png"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Figure 11.9 Sequences used when grouping defects by assignee. Each entry of the result has a Key property and is also a sequence of defect entries.</font></p>
<p><a name="bookmark3166"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler always uses a method called GroupBy for grouping clauses. When the projection in a grouping clause is trivial—in other words, when each entry in the original sequence maps directly to the exact same object in a subsequence—the compiler uses a simple method call that only requires the grouping expression, so it knows how to map each element to a key. For instance, the query expression in listing 11.17 is translated into this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllDefects.Where(defect =&gt; defect.AssignedTo != null) .GroupBy(defect =&gt; defect.AssignedTo)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When the projection is nontrivial, a slightly more complicated version is used. Listing 11.18 gives an example of a projection so that we only capture the summary of each defect rather than the Defect object itself.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.18 Grouping defects by assignee—projection retains just the summary</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in SampleData.AllDefects where defect.AssignedTo != null group defect.Summary by defect.AssignedTo;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var entry in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(entry.Key.Name); foreach (var summary in entry)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot; {0}&quot;, summary);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark3167"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve highlighted the differences between listing 11.18 and listing 11.17 in bold. Having projected a defect to just its summary, the embedded sequence in each entry is just an IEnumerable&lt;string&gt;. In this case, the compiler uses an overload of GroupBy with another parameter to represent the projection. The query expression in listing 11.18 is translated into the following expression:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllDefects.Where(defect =&gt; defect.AssignedTo != null) .GroupBy(defect =&gt; defect.AssignedTo, defect =&gt; defect.Summary)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Grouping clauses are relatively simple but useful. Even in our defect-tracking system, you could easily imagine wanting to group defects by project, creator, severity, or status, as well as the assignee we’ve used for these examples.</font></p>
<p><a name="bookmark3168"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">So far, we’ve ended each query expression with a select or group ... by clause, and that’s been the end of the expression. But there are times when you want to do more with the results—and that’s where </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">query continuations</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> are used.</font></p>
<p><a name="bookmark315"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3169"></a>11.6.2 Query continuation<a name="bookmark3170"></a>s</font></p>
<p><a name="bookmark3171"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3172"></a>Query continuations provide a way of using the result of one query expression as the initial sequence of another. They apply to both group ... by and select cl<a name="bookmark3173"></a>auses, and the syntax is the same for both—you simply use the contextual keyword into and then provide the name of a new range variable. That range variable can then be used in the next part of the que<a name="bookmark3174"></a>ry expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The specification explains this in terms of a translation from one query expression to another, changing</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">first-query</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> into </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">identifier second-query-body</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">into</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">identifier</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> in </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">(first-query) second-query-body</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">An example will make this clearer. Let’s go back to our grouping of defects by assignee, but this time imagine we only want the count of the defects assigned to each</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">person. We can’t do that with the projection in the grouping clause, because that only applies to each individual defect. We want to project each group, which contains an assignee and the sequence of their defects, into a single element consisting of the assignee and the count of defects in the group, which is achieved using the code in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.19 Continuing a grouping with another projection</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in SampleData.AllDefects where defect.AssignedTo != null</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">group defect by defect.AssignedTo into grouped select new { Assignee = grouped.Key,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Count = grouped.Count() };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var entry in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">entry.Assignee.Name, entry.Count);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The changes t<a name="bookmark3175"></a>o the query expression are highlighted in bold. We can use the grouped range variable in the second part of the query, but the <a name="bookmark3176"></a>defect range variable is no longer available—you can think of it as being out of scope. Our projection simply creates an anonymous type with Assignee and Count properties, using the key of each group as the assignee, and counting the sequence of defects associated with each group. The results of listing 11.19 are as follows:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Darren Dahlia: 14 Tara Tutu: 5 Tim Trotter: 5 Deborah Denton: 9 Colin Carton: 2</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Following the specification, the query expression from listing 11.19 is translated into this one:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from grouped in (from defect in SampleData.AllDefects where defect.AssignedTo != null group defect by defect.AssignedTo) select new { Assignee = grouped.Key, Count = grouped.Count() }</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The rest of the translations are then performed, resulting in the following code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllDefects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Where(defect =&gt; defect.AssignedTo != null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.GroupBy(defect =&gt; defect.AssignedTo)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(grouped =&gt; new { Assignee = grouped.Key,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Count = grouped.Count() })</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">An alternative way of understanding continuations is to think of two separate statements. This isn’t as accurate in terms of the actual compiler translation, but I find it makes it easier to see what’s going on. In this case, the query expression (and assignment to the query variable) can be thought of as the following two statements:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var tmp = from defect in SampleData.AllDefects where defect.AssignedTo != null group defect by defect.AssignedTo;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from grouped in tmp</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select new { Assignee = grouped.Key,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Count = grouped.Count() };</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, if you find this easier to read, there’s nothing to stop you from breaking up the original expression into this form in your source code. Nothing will be evaluated until you start trying to step through the query results anyway, due to deferred execution.</font></p>
<p><a name="bookmark3177"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">join ... into ISN’T A CONTINUATION It’s easy to fall into the trap of thinking that wherever you see the contextual keyword into, you have a continuation.</font></p>
<p><a name="bookmark3178"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3179"></a><a name="bookmark3180"></a>This isn’t true for joins—the join .. . into clause (which is used for group joins) doesn’t form a continuation. The important difference is that with a group join, all the earlier range variables (apart from the one used to name the right side of the join) can still be used. Compare that with the queries we’re looking at in this section, where the continuation wipes the slate clean; the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only </font><font style="font-size:x-small;font-family:Times New Roman, serif;">range variable available afterward is the one declared by the continuation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s extend this example to see how multiple continuations can be used. Our results are currently unordered—let’s change that so we can see who has the most defects assigned to them first. We could use a let clause after the first continuation, but the following listing shows an alternative with a second continuation after our current expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 11.20 Query expression continuations from group and select</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in SampleData.AllDefects where defect.AssignedTo != null</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">group defect by defect.AssignedTo into grouped select new { Assignee = grouped.Key,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Count = grouped.Count() } into result orderby result.Count descending select result;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var entry in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">entry.Assignee.Name, entry.Count);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The changes between listing 11.19 and 11.20 are highlighted in bold. We haven’t had to change any of the output code, because we have the same type of sequence—we’ve just applied an ordering to it. This time the translated query expression is as follows:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllDefects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Where (defect =&gt; defect.AssignedTo != null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.GroupBy(defect =&gt; defect.AssignedTo)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(grouped =&gt; new { Assignee = grouped.Key,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Count = grouped.Count() }) .OrderByDescending(result =&gt; result.Count);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">By pure coincidence, this is remarkably similar to the first defect-tracking query we came across, in section 10.3.4. Our final select clause effectively does nothing, so the C# compiler ignores it. It’s required in the query expression, though, as all query expressions must end with either a select or a group ... by clause. There’s nothing to stop you from using a different projection or performing other operations with the continued query—joins, further groupings, and so forth. Just ke<a name="bookmark3181"></a>ep an eye on the readability of the query expression as it grows. Speaking of readability, there are options to consider when you’re writing LINQ queries.</font></p>
<p><a name="bookmark317"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3182"></a>11.7 Choosing between query expressions and dot <a name="bookmark3183"></a>notation</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As we've seen throughout this chapter, query expressions are transl<a name="bookmark3184"></a>ated into normal C# b<a name="bookmark3185"></a>efore being compiled any further. There isn’t an official name for a call to the LINQ query operators written using normal C# <a name="bookmark3186"></a>rather than as a query expression, but many developers now refer to this as </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">dot notation.<sup><a name="footnote75"></a><a href="#bookmark3187">75</a></font><font style="font-size:x-small;font-family:Times New Roman, serif;"></sup> Every query expression can be written in dot notation, but the reverse isn’t true: many LINQ operators don’t have a qu<a name="bookmark3188"></a>ery expression equivalent in C#. The big question is: when should you use which syntax?</font></p>
<p><a name="bookmark319"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3189"></a>11.7.1 Operations that require dot notation</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The most obvious situation where<a name="bookmark3190"></a> you’re forced to<a name="bookmark3191"></a> use dot notation is when you’re calling a method such as Reverse or ToDictionary that simply isn’t represented in query expression syntax at all. But even when you use a query operato<a name="bookmark3192"></a>r that’s supported by query expressions, it’s quite possible f<a name="bookmark3193"></a>or the particular overload you wa<a name="bookmark3194"></a>nt to be unavailable. For example, Enumerable.Where has an overload where the index into the parent sequence is supplied as another argument to the delegate. So, for example, to take every other item from a sequence you could use</font></p>
<p><a name="bookmark3195"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">sequence.Where((item, index) =&gt; index % 2 == 0)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s a similar overload for Select—so if you wanted to be able to get at the original index in a sequence after ordering, you could do something like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">sequence.Select((Item, Index) =&gt; new { Item, Index })</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.OrderBy(x =&gt; x.Item.Name)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This example shows another option you may wish to consider: if you’re going to use a lambda express<a name="bookmark3196"></a>io<a name="bookmark3197"></a>n parameter directly in an anonymous type, you could buck the normal convention of starting the parameter name with a lowercase letter, and then use a projection initializer to avoid writing new { Item = item, Index = index }, which can be distracting. Of course, you can ignore the convention about property names instead, and make your anonymous type have properties beginning with a lowercase letter (item and index, for example<a name="bookmark3198"></a>). All of this is entirely up to you—and it’s worth experimenting. Though consistenc<a name="bookmark3199"></a>y is usually important, it doesn’t matter too much here, as the impact of inconsistency is confined to the method in question: you’re not exposing these names in your public API or throughout t<a name="bookmark3200"></a>he rest of yo<a name="bookmark3201"></a>ur class.</font></p>
<p><a name="bookmark3202"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Many of the query operators also support custom comparisons—ordering and joining being the most obvious examples. These are unlikely to be required often, in my experience, but they’re occasionally invaluable.<a name="bookmark3203"></a> For example, if you want to perform a jo<a name="bookmark3204"></a>in on a person’s name in a case-insensitive manner, you can specify String-Compare<a name="bookmark3205"></a>r.OrdinalIgnoreCase (or a culture-specific comparer) as the final argument to a Join call. Again, if you feel that an operator </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">nearly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> does what you want but doesn’t quite cut it, check the documentation for other overloads.</font></p>
<p><a name="bookmark3206"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When you’re forced to use dot notation, the decision to use it is easy—but what about cases where a query expression </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be used?</font></p>
<p><a name="bookmark320"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3207"></a>11.7.2 Query expressions where dot notation may be simpler</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Some developers use query expressions everywhere they can get away with it; personally I look at what the query is doing and decide which approach will be more readable. For example, take this query expression, which is similar to the one we used near the start of the chapter:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var adults = from person in people where person.Age &gt;= 18 select person;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is three lines of code with a lot of baggage, even though all it’s doing is filtering. In this case I’d use dot notation:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var adults = people.Where(person =&gt; person.Age &gt;= 18);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I find that clearer—every part of it mentions something we’re actually interested in.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Another area where using dot notation throughout a query expression can give more clarity is when you’re forced to <a name="bookmark3208"></a>use it for part of the query anyway. For example, suppose we’re going to use the ToList () extension method to end up with a list of the names of adults. (I’m performing a projection as well in this case so that it’s a more balanced comparison.) Here’s the query expression:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var adultNames = (from person in people where person.Age &gt;= 18 select person.Name).ToList();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here’s the dot notation equivalent:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var adultNames = people.Where(person =&gt; person.Age &gt;= 18)</font></p>
<p><a name="bookmark3209"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(person =&gt; person.Name)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.ToList();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Something about the need for parentheses around the query expression in the first case makes it seem uglier </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">to me.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> This is very much a case of personal choice—this section is really just raising your awareness that there </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a choice, and that you can pick <a name="bookmark3210"></a>and choose. If you’re going to use LINQ to any significant extent, you re<a name="bookmark3211"></a>ally should be comfortable with both notations, and there’s no har<a name="bookmark3212"></a>m in switching style based on the query in question. As we’ve seen, the generated code is absolutely equivalent. None of this is to say that I dislike query expressions, of course.</font></p>
<p><a name="bookmark321"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3213"></a>11.7.3 Where query expressions shine</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Having explained where you might find dot notation beneficial, I should point out that when it c<a name="bookmark3214"></a>omes to any operations where the query expression would use transpa<a name="bookmark3215"></a>rent identifiers—particularly joins—dot notation starts to suffer in terms of readability. The beauty of transparent identifiers is that they’re transparent—so transparent that you can’t see them at all when you only have to look at the query expression! Even a simple let clause can be enough to swing the decision in favor of query expressions: introducing a new anonymous type just to propagate context through the query gets annoying quickly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The other area where query expressions win is in situations where multiple lambda expressions would be required, or even multi<a name="bookmark3216"></a>ple method calls. Again this includes joins, where you have to specify the key selector for each side of the join as well as the result selector. For example, here’s a cut-down version of an earlier query from where I introduced inner joins:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from defect in SampleData.AllDefects join subscription in SampleData.AllSubscriptions on defect.Project equals subscription.Project select new { defect.Summary, subscription.EmailAddress }</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In an IDE it’d be reasonable to put the whole join clause on one line, leading to fairly easy-to-read code. The dot notation equivalent is fairly horrible, though:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllDefects.Join(SampleData.AllSubscriptions, defect =&gt; defect.Project, subscription =&gt; subscription.Project,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(defect, subscription) =&gt; new { defect.Summary,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">subscription.EmailAddress })</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The last argument could all fit on one line in an IDE, but it’s still pretty ugly because the lambda expressions don’t have much context: you can’t immediately tell which argument means what. Named arguments in C# 4 can help there, but that adds even more bulk to the query.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Complex orderings can be similarly unpleasant in dot notation. Consider which you’d rather read—this orderby clause:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">orderby item.Rating descending, item.Price, item.Name </font><font style="font-size:x-small;font-family:Times New Roman, serif;">or three method calls:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.OrderByDescending(item =&gt; item.Rating)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.ThenBy(item =&gt; item.Price)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.ThenBy(item =&gt; item.Name)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Changing the priority of these orderings is simple in the query expression—just switch them around. In dot notation, you may also have to switch from OrderBy to ThenBy or vice versa.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just to reiterate, I’m not trying to press my own personal preferences onto your code. I simply want you to know what’s available, and think about the choices you make. Of course, this is only one aspect of writing readable code, but it’s a whole new area to consider in C#.</font></p>
<p><a name="bookmark322"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3217"></a>11.8 Summary</font></p>
<p><a name="bookmark3218"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In this chapter, we’ve looked at how LINQ to Objects and C# 3 interact, focusing on the way that query expressions are first translated into code that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">doesn’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> involve query expressions, then compiled in the usual way. We’ve seen how all query expressions form a series of sequences, applying a transformation of some description at each step. In many cases, these sequences are evaluated using deferred execution, fetching data only when it’s first required.</font></p>
<p><a name="bookmark3219"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3220"></a>Compared with all the other features of C# 3, query expressions look somewhat alien—more like SQL t<a name="bookmark3221"></a>han the C# we’re use<a name="bookmark3222"></a>d to. One of the reasons they look so odd is that they’re </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">declarative</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> instead of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">imperative</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—a query talks about the features of the end result rather than the exact steps required to achieve it. This goes hand in hand with a more functional way of thinking. It can take a while to click, and it’s not suitable for every <a name="bookmark3223"></a>situation, but where declarative syntax is appropriate it can vastly improve readability, as well as make code easier to test and also easier to parallelize.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Don’t be fooled into thinking that LINQ should only be used with databases. Plain in-memory manipulation of collections is common, and we’ve seen how well it’s supported by query expressions and the extension methods in Enumerable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In a real sense, you’ve now seen all the features introduced in C# 3! Although we haven’t looked at any other LINQ providers yet, we have a clearer understanding of what the compiler will do for us when we ask it to handle XML and SQL. The compiler itself doesn’t know the difference between LINQ to Objects, LINQ to SQL, or any of the other providers: it just follows the same rules blindly. In the next chapter we’ll see how these rules form the final piece of the LINQ jigsaw puzzle when they convert lambda expressions into expression trees so that the various clauses of query expressions can be executed on different platforms... as well as look at other examples of what LINQ can do.</font></p>
<p><a name="bookmark16"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark3224"></a>LINQ beyond collections</font></p>
<p><a name="bookmark3225"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;LINQ to SQL</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;IQueryable and expression tree queries</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;LINQ to XML</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Parallel LINQ</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Reactive extensions for .NET</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Writing your own operators</font></p>
<p><a name="bookmark3226"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Suppose an alien visited you and asked you to describe “culture.” How could you capture the diversity of human culture in a short space of time? You may decide to spend that time </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">showing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> him culture rather than just describing it in the abstract: a visit to a New Orleans jazz club, opera in La Scala, the Louvre gallery in Paris, a Shakespeare play in Stratford-upon-Avon, and so on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Would this alien know everything about culture afterward? Could he compose a tune, write a book, dance a ballet, craft a sculpture? Absolutely not. But he’d hopefully come away with a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">sense</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of culture—its richness and variety, its ability to light up people’s lives.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So it is with this chapter. You’ve now seen all of the features of C# 3, but without seeing more of LINQ you don’t have enough context to really appreciate them.</font></p>
<p><a name="bookmark3227"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When the first edition of this book was published, not many LINQ technologies were available—now there’s a glut of them, both from Microsoft and third parties. That in itself hasn’t surprised me—but I’ve been fascinated to see the different </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">nature</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of these technologies.</font></p>
<p><a name="bookmark3228"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re going to look at various ways in which LINQ manifests itself, with an example of each. I’ve chosen to demonstrate Microsoft technologies in the ma<a name="bookmark3229"></a>in, because they’re the most ty<a name="bookmark3230"></a>pical ones. This isn’t meant to imply that third parties aren’t welcome in the<a name="bookmark3231"></a> LINQ ecosystem: there are a number of projects, both commercial and open source, providing access to varied data sources and building extra features on top of existing providers. In contrast to the rest of this book, we’ll only skim the surface of each of the topics here—the point isn’t to learn the details, but to immerse yourself in the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">spirit</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of LINQ. To investigate any of these technologies further, I recommend that you get a dedicated book or read the relevant documentation carefully. I’ve resisted the temptation to say “there’s more to LINQ to [xxx] than this” at the end of each section, but please take it as read. Each technology has many capabilities beyond querying, but I’ve focused on the areas that are directly related to LINQ.</font></p>
<p><a name="bookmark3232"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s start off with the provider that generally got the most attention when LINQ was first introduced: LINQ to SQL.</font></p>
<p><a name="bookmark325"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3233"></a>12.1 Querying a database with LINQ to SQL</font></p>
<p><a name="bookmark3234"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m sure by now you’ve absorbed the message that LINQ to SQL converts query expression<a name="bookmark3235"></a>s into SQL, which is then executed on the database. It’s more than that—it’s a full ORM solution—but I’m going to concentrate on the query side of LINQ to SQL rather than go into concurrency handling and the other details that an ORM has to deal with. I’ll show you just enough so that you can experiment with it yourself—the database and <a name="bookmark3236"></a>code are available on<a name="bookmark3237"></a> the book’s website (<a href="http://csharpindepth.com">http://csharpindepth.com</a>). The database is in SQL Server 2005 format to make it easy to play with even if you don’t have the latest version of SQL Server installed, although obviously Microsoft has made sure that LINQ to SQL works against newer versions too.</font></p>
<p><a name="bookmark3238"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3239"></a>WHY LINQ TO SQL RATHER THAN THE ENTITY FRAMEWORK? Speaking of “newer versions,” you may be wondering why I’ve chosen to demonstrate LINQ to SQL instead of the Entity Framework, which is now Microsoft’s preferred solution (and also supports LINQ). The answer is merely simplicity: whereas the Entity Framework is undoubtedly more powerful than LINQ to SQL in various ways, it requires extra concepts that would take too much space to explain here.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m trying to give you a sense of the consistency (and occasional inconsistencies) that LINQ provides, and that’s as applicable to LINQ to SQL as to the Entity Framework.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before we start writing any queries, we need a database and a model to represent it in code.</font></p>
<p><a name="bookmark326"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3240"></a><a name="bookmark3241"></a>12.1.1 Getting started: the database and model</font></p>
<p><a name="bookmark3242"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3243"></a>LINQ to SQL needs m<a name="bookmark3244"></a>etadata about the database to know which classes correspond to which database tables, and so on. There are vario<a name="bookmark3245"></a>us ways of representing <a name="bookmark3246"></a>that metadata: I’m going to use the LINQ to SQL designer built into Visual Studio. You can design the entities first and ask LINQ to create the database, or design your database and let Visual Studio work out what the entities should look like. Personally I favor the second approach, but there are pros and cons for both ways.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CREATING THE <a name="bookmark3247"></a>DATABASE SCHEMA</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The mapping from the classes in chapter 11 to database tables is straightforward. Each table has an autoincrementing integer ID column with an appropriate name: ProjectID, DefectID, and so forth. The references between tables simply use the same name, so the Defect table has a ProjectID column, for instance, with a foreign key constraint. There are a few except<a name="bookmark3248"></a>ions to this simple set of rules:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;User is a reserved word in T-SQL, so the User class is mapped to the DefectUser table.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The enumerations (status, severity, and user type) don’t have tables: their values are simply mapped to tinyint columns in the Defect and DefectUser tables.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The Defect table has two links to the DefectUser table: one for the user who created the defect and one for the current assignee. These are represented with the CreatedByUserId and AssignedToUserId columns, respectively.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CREATING THE ENTITY CLASSES</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Once our tables are created,<a name="bookmark3249"></a> generating the entity classes from Visual Studio is easy. Simply open Server Explorer (View -&gt; Server Explorer) and <a name="bookmark3250"></a>add a data source to the SkeetySoftDefects database (right-click on Data Connections and select Add Connection). You should be able to see four tables: Defect, DefectUser, Project, and NotificationSubscription.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can then add a new item of type “LINQ to SQL classes” to the project. Thi<a name="bookmark3251"></a>s name will be the basis for a generated class representing the overall database model: I’ve used the name DefectModel, which leads to a class called DefectModelData-Context. The designer will open when you’ve created the new item. You can then drag the fo<a name="bookmark3252"></a>ur tables from Server Explorer into the desig<a name="bookmark3253"></a>ner, and it’ll figure out all the associations. After that, you can rearrange the diagram and adjust various properties of the entities. Here’s a list of what I changed:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;I renamed the DefectID property to ID to match our previous model.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;I renamed DefectUser to User (so although the table is still called DefectUser, we’ll generate a class called User, just like before).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;I changed the type of the Severity, Status, and Use<a name="bookmark3254"></a>rType properties to their enum equivalents (having copied those enumerations into the project).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;I renamed the parent and child properties used for the associations between Defect and DefectUser—the designer guessed suitable names for the other</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">associations, but had trouble here because there were two associations between the same pair of tables. I named the relationships AssignedTo/Assigned-Defects and CreatedBy/CreatedDefects.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 12.1 shows the designer diagram after all of these changes. As you can see, it looks much like the class diagram we saw in figure 11.3, except without the enumerations.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you look in the C# code generated by the designer (Defect-Model.designer.cs), you’ll find five partial classes: one for each of the entities, a<a name="bookmark3255"></a>nd the DefectModelDataContext class I mentioned earlier. The fact that they’re partial is useful: in this case I added extra constructors to match the ones we had for our original in-memory classes, so the code from chapter 11 to create the sample data could be reused without much extra work. For the sake of brevity I haven’t included the insertion code here, but if you look at PopulateDatabase.cs in the source code, you should be able to follow it easily enough. Of course, you don’t have to run this your-self—the downloadable database is already populated.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we have a schema in SQL, an entity model in C#, and some sample data, let’s get querying.</font></p><img src="images/42.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 12.1 The LINQ to SQL classes designer showing the rearranged and modified entities</font></p>
<p><a name="bookmark327"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3256"></a><a name="bookmark3257"></a>12.1.2 Initial queries</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m sure you’ve guessed what’s coming, but hopefully that won’t make it any less impressive. We’re going to execute query e<a name="bookmark3258"></a>xpressions against our data source, watching LINQ to SQL convert the query into SQL on the fly. For the sake of familiarity, we’ll use some of the same queries we saw executing against our in-memory collections in chapter 11.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">FIRST QUERY: FINDING DEFECTS ASSIGNED TO TIM</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ll skip over the trivial examples from early in the chapter, starting instead with the query from listing 11.7 that checks for open defects assigned to Tim. Here’s the query part of listing 11.7, for the sake of comparison:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User tim = SampleData.Users.TesterTim;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in SampleData.AllDefects where defect.Status != Status.Closed where defect.AssignedTo == tim select defect.Summary;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The full LINQ to SQL equivalent of listing 11.7 is shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.1 Querying the database to find all Tim’s open defects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using (var context = new DefectModelDataContext()) &nbsp;&nbsp;&nbsp;&lt;—i </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Creates context</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><sup>{<a name="bookmark3259"></a></sup> &nbsp;&nbsp;&nbsp;</font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">Erablw &nbsp;&nbsp;&nbsp;</font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">B </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to work with</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">context.Log = Console.Out; &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">console &nbsp;&nbsp;&nbsp;logging</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">User tim = context.Users &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">Queries &nbsp;&nbsp;&nbsp;for &nbsp;&nbsp;&nbsp;Tim</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Where(user =&gt; user.Name == &quot;Tim Trotter&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Single(); &nbsp;&nbsp;&nbsp;,</font></p>
<p><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">E </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Queries for Tim’s</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from defect in context.Defects &nbsp;&nbsp;&nbsp;&lt;|_J &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">open &nbsp;&nbsp;&nbsp;defects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">where defect.Status != Status.Closed where defect.AssignedTo == tim select defect.Summary;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var summary in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(summary);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark3260"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3261"></a>Lis<a name="bookmark3262"></a>ting 12.1 requires<a name="bookmark3263"></a> a certain amount of explanation, because it’s all new. First we create a new </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">data context</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to work <a name="bookmark3264"></a>with </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Data contexts are pre<a name="bookmark3265"></a>tty multifunctional, taking responsibilit<a name="bookmark3266"></a>y for con<a name="bookmark3267"></a>nection and transaction <a name="bookmark3268"></a>management, query translation, tracking changes in entities, and dealing with identity. For the purposes of this chapter, we can regard a data context as our point of contact with the database. We won’t be looking at the more advanced features here, but we take advantage of one useful capability: we tell the data context to write out all the SQL commands it executes to the console </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. The model-related properties<a name="bookmark3269"></a> used in the code for this section (Defects, Users, and so on) are all of type Table&lt;T&gt; for the relevant entity type. They act as the data sources for our queries.</font></p>
<p><a name="bookmark3270"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We can’t use SampleData.Users.TesterTim to identify Tim in the main query because that object doesn’t know the ID of the relevant row in the DefectUser table. Instead, we <a name="bookmark3271"></a>use a separate query to load Tim’s user entity ©. I happen to have used dot notation for this, but a query expression would’ve worked just as well. The Single method just returns a single result from a query, throwing an exception if there isn’t exactly one element. In a real-life situation, you may have the entity as a product of other operations such as logging in—and if you don’t have the full entity, you may have its ID, which can be used equally well within the main query. As an alternative in this case, we could’ve changed the open defects query to filter based on the assignee’s name. That wouldn’t have quite been in the spirit of the original query, though.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Within the query expression ©, the only difference between the in-memory query and the LINQ to SQL query is the data source—instead of using SampleData.AllDefects, we use context. Defects. The final results are the same (although the ordering isn’t guaranteed), but the work has been done on the database.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As we’ve asked the &nbsp;&nbsp;&nbsp;data context to log &nbsp;&nbsp;&nbsp;the generated SQL, &nbsp;&nbsp;&nbsp;we can see exactly what’s</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">going on when we run the code. &nbsp;&nbsp;&nbsp;The console output shows &nbsp;&nbsp;&nbsp;both of &nbsp;&nbsp;&nbsp;the &nbsp;&nbsp;&nbsp;queries &nbsp;&nbsp;&nbsp;exe</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">cuted on the database, along with the query parameter values:<sup><a name="footnote76"></a><a href="#bookmark3272">76</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SELECT [t0].[UserID], [t0].[Name], [t0].[UserType]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FROM [dbo].[DefectUser] AS [t0]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WHERE [t0].[Name] = @p0</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-- @p0: Input String (Size = 11; Prec = 0; Scale = 0) [Tim Trotter]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SELECT [t0].[Summary]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FROM [dbo].[Defect] AS [t0]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WHERE ([t0].[AssignedToUserID] = @p0) AND ([t0].[Status] &lt;&gt;&nbsp;@p1)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-- @p0: Input Int32 &nbsp;&nbsp;&nbsp;(Size = 0; &nbsp;&nbsp;&nbsp;Prec = &nbsp;&nbsp;&nbsp;0; Scale = 0) &nbsp;&nbsp;&nbsp;[2]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-- @p1: Input Int32 &nbsp;&nbsp;&nbsp;(Size = 0; &nbsp;&nbsp;&nbsp;Prec = &nbsp;&nbsp;&nbsp;0; Scale = 0) &nbsp;&nbsp;&nbsp;[4]</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how the first query fetches all of the properties of the user because we’re populating a whole entity—but the second query only fetches the summary, as that’s all we need. LINQ to SQL has also converted our two separate where clauses in the second query into a single filter on the database.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">LINQ to SQL is capable of translating a wide range of expressions. Let’s try a slightly more complicated query from chapter 11, just to see what SQL is generated.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">SQL GENERATION FOR A MORE COMPLEX QUERY: A LET CLAUSE</font></p>
<p><a name="bookmark3273"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Our next<a name="bookmark3274"></a> query shows what happens when we introduce a sort of temporary variable with a let clause. In chapter 11 we considered a bizarre situation, if you remember— pretending that calculating the length of a string took a long time. Again, the query expression is exactly the same as in listing 11.11, with the exception of the data source. Listing 12.2 shows the LINQ to SQL code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.2 Using a let clause in LINQ to SQL</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using (var context = new DefectModelDataContext())</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">context.Log = Console.Out;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from user in context.Users</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">let length = user.Name.Length orderby length</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select new { Name = user.Name, Length = length }; foreach (var entry in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, entry.Length, entry.Name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The generated SQL is close to the spirit of the sequences we saw in figure 11.5. The innermost sequence (the first one in that diagram) is the list of users; that’s transformed into a sequence of name/length pairs (as the nested select), and then the no-op projection is applied, with an ordering by length:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SELECT [t1].[Name], [t1].[value]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FROM (</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SELECT LEN([t0].[Name]) AS [value], [t0].[Name]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FROM [dbo].[DefectUser] AS [t0]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">) AS [t1]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ORDER BY [t1].[value]</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is a good example of where the generated SQL is wordier than it needs to be. Although we couldn’t reference the elements of the final output sequence when performing an ordering on the query expression, you can in SQL. This simpler query would’ve worked fine:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SELECT LEN([t0].[Name]) AS [value], [t0].[Name]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FROM [dbo].[DefectUser] AS [t0]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ORDER BY [value]</font></p>
<p><a name="bookmark3275"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, wha<a name="bookmark3276"></a>t’s important is what the query optimizer does on th<a name="bookmark3277"></a>e database—the execution plan displayed in SQL Server Management Studio Express is the same for both queries, so it doesn’t look like we’re losing out.</font></p>
<p><a name="bookmark3278"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The final set of LINQ to SQL queries we’re going to look at are all joins.</font></p>
<p><a name="bookmark328"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3279"></a>12.1.3 Queries involving joins</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll try both inner joins and group joins, using the examples of joining notification subscriptions against projects. I suspect you’re used to &nbsp;&nbsp;&nbsp;the &nbsp;&nbsp;&nbsp;drill &nbsp;&nbsp;&nbsp;now—the &nbsp;&nbsp;&nbsp;pattern &nbsp;&nbsp;&nbsp;of</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">the code is the same for each query, so from here on I’ll just show &nbsp;&nbsp;&nbsp;the query &nbsp;&nbsp;&nbsp;expres</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">sion and the generated SQL unless something else is going on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">EXPLICIT JOINS: MATCHING DEFECTS WITH NOTIFICATION SUBSCRIPTIONS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our first query is the simplest kind of join—an inner equijoin using a LINQ join clause:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Query expression (modified from listing 11.12) from defect in context.Defects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">join subscription in context.NotificationSubscriptions on defect.Project equals subscription.Project select new { defect.Summary, subscription.EmailAddress }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-- Generated SQL</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SELECT [t0].[Summary], [t1].[EmailAddress]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FROM [dbo].[Defect] AS [t0]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">INNER JOIN [dbo].[NotificationSubscription] AS [t1]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ON [t0].[ProjectID] = [t1].[ProjectID]</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Unsurprisingly, it uses an inner join in SQL. It’d be easy to guess at the generated SQL in this case. How about a group join, though? This is where things get slightly more hectic:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Query expression (modified from listing 11.13) from defect in context.Defects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">join subscription in context.NotificationSubscriptions on defect.Project equals subscription.Project into groupedSubscriptions select new { Defect = defect, Subscriptions = groupedSubscriptions }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-- Generated SQL</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SELECT [t0].[DefectID] AS [ID], [t0].[Created],</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[t0].[LastModified], [t0].[Summary], [t0].[Severity],</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[t0].[Status], [t0].[AssignedToUserID],</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[t0].[CreatedByUserID], [t0].[ProjectID],</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[t1].[NotificationSubscriptionID] ,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[t1].[ProjectID] AS [ProjectID2], [t1].[EmailAddress],</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(SELECT COUNT(*)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FROM [dbo].[NotificationSubscription] AS [t2]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WHERE [t0].[ProjectID] = [t2].[ProjectID]) AS [count]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FROM [dbo].[Defect] AS [t0]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">LEFT OUTER JOIN [dbo].[NotificationSubscription] AS [t1]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ON [t0].[ProjectID] = [t1].[ProjectID]</font></p>
<p><a name="bookmark3280"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ORDER BY [t0].[DefectID], [t1].[NotificationSubscriptionID]</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s a major change in the amount of<a name="bookmark3281"></a> SQL generated! There are two important things to notice. First, it uses a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">left outer join</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> instead of an inner join, so we’d still see a defe<a name="bookmark3282"></a>ct even if it didn’t have anyone subscribing to its project. If you want a left outer join but without the grouping, the conventional way of expressing this is to use a group join and then an extra from clause using the DefaultIfEmpty extension method on the embedded sequence. It looks odd, but it works well.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The second odd thing about the previous query is that it calculates the count for each group within the database. This is effectively a trick performed by LINQ to SQL to make sure that all the processing can be done on the server. A naive implementation would have to perform the grouping in memory, after fetching<a name="bookmark3283"></a> all the results. In some cases the provider could do tricks to avoid needing the count, simply spotting when the grouping ID changes, but there are issues with this approach for some queries. It’s possible that a later implementation of LINQ to SQL will be able to switch courses of action depending on the exact query.</font></p>
<p><a name="bookmark3284"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You don’t need to explicitly write a join in the query expression to see one in the SQL. Our final queries will show joins implicitly created through property access expressions.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IMPLICIT JOINS: SHOWING DEFECT SUMMARIES AND PROJECT NAMES</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s take a simple example. Suppose we want to list each defect, showing its summary and the name of the project it’s part of. The query expression is just a matter of a projection:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Query expression</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from defect in context.Defects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select new { defect.Summary, ProjectName = defect.Project.Name }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-- Generated SQL</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SELECT [t0].[Summary], [t1].[Name]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FROM [dbo].[Defect] AS [t0]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">INNER JOIN [dbo].[Project] AS [t1]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ON [t1].[ProjectID] = [t0].[ProjectID]</font></p>
<p><a name="bookmark3285"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3286"></a>Note how we’ve navigated from the defect to the project via a property—LINQ to SQL has converted that navigation into an inner <a name="bookmark3287"></a>join. It can use an inner join here because the schema has a non-nullable constraint on the ProjectID column of the Defect table—every defect has a project. Not every defect has an assignee, though—the AssignedToUserID field is nullable, so if we use the assignee in a projection instead, a left outer join is generated:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Query expression</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from defect in context.Defects</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select new { defect.Summary, Assignee = defect.AssignedTo.Name }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-- Generated SQL</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SELECT [t0].[Summary], [t1].[Name]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FROM [dbo].[Defect] AS [t0]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">LEFT OUTER JOIN [dbo].[DefectUser] AS [t1]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ON [t1].[UserID] = [t0].[AssignedToUserID]</font></p>
<p><a name="bookmark3288"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3289"></a>Of course, if you navigate via more properties, the joins get more and more complicated. I’m not going into the details here—the important thing is that LINQ to SQL has to do a lot of analysis of th<a name="bookmark3290"></a>e query expression to work out what SQL is required. In order to perform that analysis, it clearly needs to be able to look at the query we’ve specified. Let’s move away from LINQ to SQL specifically, and think in general terms about what LINQ pr<a name="bookmark3291"></a>oviders of this kind need to do. This will apply to any provider that needs to introspect the query, rather than just being handed a delegate. At long last, it’s time to see why expression trees were added as a feature of C# 3.</font></p>
<p><a name="bookmark330"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3292"></a>12.2 Translations using IQueryable and IQueryProvider</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this section we’re going to find out the basics of how LINQ to SQL manages to convert our query exp<a name="bookmark3293"></a>ressions into SQL. This is the starting point for implementing your own LINQ provider, should you wish to. (Please don’t underestimate the technical difficulties involved in doing so—but if you like a challenge, implementing a LINQ provider is certainly interesting.) This is the most theoretical section in the chapter, but it’s useful to have some insight as to how LINQ decides whether to use in-memory processing, a database, or some other query engine.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In all the query expressions we’ve seen in LINQ to SQL, the source has been a Table&lt;T&gt;. But if you look at Table&lt;T&gt;, you’ll see it doesn’t have a Where method, or Select, or Join, or any of the other standard query operators. Instead, it uses the same trick that LINQ to Objects does—just as the source in LINQ to Objects always implements IEnumerable&lt;T&gt; (possibly after a call to Cast or OfType) and then uses the extension methods in Enumerable, so Table<a name="bookmark3294"></a>&lt;T&gt; implements IQueryable&lt;T&gt; and then uses the extension methods in Queryable. We’ll see how LINQ builds up an expression tree and then allows a provider to execute it at the appropriate time. Let’s start by looking at what IQueryable&lt;T&gt; consists of.</font></p>
<p><a name="bookmark331"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3295"></a><a name="bookmark3296"></a>12.2.1 Introducing IQueryable&lt;T&gt; and related interfaces</font></p>
<p><a name="bookmark3297"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3298"></a><a name="bookmark3299"></a>If you look up IQueryable&lt;T&gt; in the documentation and see what members it contains directly (rather than inheriting), you may be disappointed. There <a name="bookmark3300"></a>aren’t any. Instead, it inherits from IEnumerable&lt;T&gt; and the nongeneric IQueryable, which in turn inherits from the nongeneric IEnumerable. So, IQueryable is where the new and exciting members are, right? Well, nearly. In fact, IQueryable just has three properties: QueryProvider, ElementType, and Expression. The QueryProvider property is of type IQueryProvider—yet another new interface to consider.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Lost? Perhaps figure 12.2 will help out—a class diagram of all the interfaces directly involved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The easiest way of thinking about IQueryable is that it represents a query that’ll yield a sequence of results when you execute it. The details of the query in LINQ terms are held in an expression tree, as returned by the Expression property of the IQueryable. Executing a query is performed by beginning to iterate through an IQueryable (in other words, calling th<a name="bookmark3301"></a>e GetEnumerator method and then MoveNext on the result) or by a call to the Execute method on an IQueryProvider, passing in an expression tree.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So, with at least some grasp of what IQueryable is for, what’s IQueryProvider? We can do more with a query than just execute it—we can als<a name="bookmark3302"></a>o use it to build a bigger query, which is the purpose of the sta<a name="bookmark3303"></a>ndard query operators in LINQ.<sup><a name="footnote77"></a><a href="#bookmark3304">77</a></sup> To build up a query, we need to use the CreateQuery method on the relevant IQueryProvider.<sup><a name="footnote78"></a><a href="#bookmark3305">78</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Think of a data source as a simple query (SELECT * FROM SomeTable in SQL, for instance)—calling Where, Select, OrderBy, and similar methods results in a different query, based on the first one. Given any IQueryable query, you can create a new query by performing the following steps:</font></p><img src="images/43.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 12.2 Class diagram based on the interfaces involved in IQueryable&lt;T&gt;</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;Ask the existing query for its query expression tree (using the Expression property).</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">2</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;Build a new expression tree that contains the original expression and the extra functionality you want (a filter, projection, or ordering, for instance).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">3 &nbsp;&nbsp;&nbsp;Ask the existing query for its query provider (using the Provider property).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">4 &nbsp;&nbsp;&nbsp;Call CreateQuery on the provider, passing in the new expression tree.</font></p>
<p><a name="bookmark3306"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Of those steps, the only tricky one is creating the new expression tree. Fortunately, there are a bunch of extension methods on the static Queryable class that do all that for us. Enough theory—let’s start implementing the interfaces so we can see all this in action.</font></p>
<p><a name="bookmark332"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3307"></a><a name="bookmark3308"></a>12.2.2 Faking it: interface implementations to log calls</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before you get too excited, we’re not going to build our own fully fledged query provider in this chapter. But if you understand everything in this section, you’ll be in a much better position to build one if you ever need to—and possibly more importantly, you’ll understand what’s going on when you issue LINQ to SQL queries. Most of the hard work of query providers goes on at the point of execution, where they need to parse an expression tree and convert it into the appropriate form for the target platform. We’re concentrating on the work that happens before that—how LINQ </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">prepares </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to execute a query.</font></p>
<p><a name="bookmark3309"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll write our own implementations of IQueryable and IQueryProvider, and then try to run a few queries against them. The interesting part isn’t the results—we won’t be doing anything useful with the queries when we execute them—but the series of calls <a name="bookmark3310"></a>made up to the point of execution. We’ll write types FakeQueryProvider and FakeQuery. The implementation of each interface method writes out the current expression involved, using a simple logging method (not shown here). Let’s look first at FakeQuery, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.3 A simple implementation of IQueryable that logs method calls</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class FakeQuery&lt;T&gt; : IQueryable&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Expression Expression { get; private set; } public IQueryProvider Provider { get; private set; } public Type ElementType { get; private set; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">internal FakeQuery(IQueryProvider provider,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression expression)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression = expression;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Provider = provider;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ElementType = typeof(T);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">internal FakeQuery() : this(new FakeQueryProvider(), null) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression = Expression.Constant(this);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IEnumerator&lt;T&gt; GetEnumerator()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Logger.Log(this, Expression);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return Enumerable.Empty&lt;T&gt;().GetEnumerator();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerator IEnumerable.GetEnumerator()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Logger.Log(this, Expression);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return Enumerable.Empty&lt;T&gt;().GetEnumerator();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override string ToString()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return &quot;FakeQuery&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The property members of IQueryable are implemented in FakeQuery with automatic properties O, which are set by the constructors. There are two constructors: a param-eterless one that’s used by our main program to create a plain source for the query, and one that’s called by FakeQueryP<a name="bookmark3311"></a>rovider with the current q<a name="bookmark3312"></a>uery expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The use of Expression.Constant(this) as the initial source expression Q is just a way of showing that the query initially represents the original object. (Imagine an implementation representing a table, for example—until you apply any query operators, the query would just return the whole table.) When the constant expression is logged, it uses the overridden ToString method, which is why we’ve given a short, constant description Q. This makes the final expression much cleaner than it would’ve been without the override. When we’re asked to iterate over the results of the query, we always just return an empty sequence G to make life easy. Production implementations would parse the expression here, or (more likely) call Execute on their query provider and just return the result.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see, not a lot is going on in FakeQuery, and the following listing shows that FakeQueryProvider is simple, too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.4 An implementation of IQueryProvider that uses FakeQuery</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class FakeQueryProvider : IQueryProvider {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IQueryable&lt;T&gt; CreateQuery&lt;T&gt;(Expression expression)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Logger.Log(this, expression);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new FakeQuery&lt;T&gt;(this, expression);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IQueryable CreateQuery(Expression expression)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Type queryType = typeof(FakeQuery&lt;&gt;).MakeGenericType (expression.Type); object[] constructorArgs = new object[] { this, expression }; return (IQueryable)Activator.CreateInstance (queryType, constructorArgs);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public T Execute&lt;T&gt;(Expression expression)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Logger.Log(this, expression); return default(T);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public object Execute(Expression expression)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Logger.Log(this, expression); return null;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s even less to talk about in terms of the implementation of FakeQueryProvider than there was for FakeQu<a name="bookmark3313"></a>ery&lt;T&gt;. The CreateQuery methods do no real processing but act as factory methods for the query. The only tricky bit is that the nongeneric overload still needs to provide the right type argument for FakeQuery&lt;T&gt; based on the Type property of the given expression. The Execute method overloads just return empty results after logging the call. This is where a lot of analysis would </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">normally</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be done, along with the actual call to the web service, database, or whatever the target platform is.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even though we’ve done no real work, when we start to use FakeQuery as the source in a query expression, interesting things start to happen. I’ve already let slip how we’re able to write query expressions without explicitly writing methods to handle the standard query operators: it’s all about extension methods, this time the ones in the Queryable class.</font></p>
<p><a name="bookmark333"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3314"></a><a name="bookmark3315"></a>12.2.3 Gluing expressions t<a name="bookmark3316"></a>ogether: the Queryable extension methods</font></p>
<p><a name="bookmark3317"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3318"></a>Just as the Enumerable type contains extension methods on IEnumerable&lt;T&gt; to implement the LINQ standard <a name="bookmark3319"></a>query operators, the Queryable type contains extension methods on IQueryable&lt;T&gt;. There are two big differences between the implementations in Enumerable and those in Queryable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First, the Enumerable methods all use delegates as their parameters—the Select method takes a Func&lt;TSource,TResult&gt;, for example. That’s fine for in-memory manipulation, but for LINQ providers that execute the query elsewhere, we need a format we can examine more closely—expression trees. For example, the corresponding overload of Select in Queryable takes a parameter of type Expression&lt;F<a name="bookmark3320"></a>unc &lt;TSource,TResult&gt;&gt;. The compiler doesn’t mind at all—after query translation, it has a lambda expr<a name="bookmark3321"></a>ession that it needs to pass as an argument to the method, an<a name="bookmark3322"></a>d lambda expressions can be converted to either delegate instances or expression trees.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is how LINQ to SQL can work so seamlessly. The four key elements involved are all new features of C# 3: lambda expressions, the translation of query expressions into normal expressions that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">use</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> lambda expressions, extension methods, and expression trees. Without all four, there’d be problems. If query expressions were always translated into delegates, for instance, they couldn’t be used with a provider such as LINQ to SQL, which requires expression trees. Figure 12.3 shows two possible paths taken by query expressions; they differ only in what interfaces their data source implements.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note how in figure 12.3 the early parts of the compilation process are independent of the data source. The same query expression is used, and it’s translated in exactly the same way. It’s only when the compiler looks at the translated query to find the appropriate Select and Where methods to use that the data source is truly important. At that point, the lambda expressions can be converted to either delegate instances or expression trees, potentially giving radically different implementations: typically inmemory for the left path, and SQL executing against a database in the right path.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just to hammer home a familiar point, the decision in figure 12.3<a name="bookmark3323"></a> of whether to use Enumerable or Queryable has no explicit support in the C# compiler. These aren't the only two possible paths, as we’ll see later with Parallel LINQ and Reactive LINQ. You can create your own interface and implement extension methods following the query pattern, or even create a type with appropriate instance methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The second big difference between Enumerable and Queryable is that the Enumerable extension methods do the actual wo<a name="bookmark3324"></a>rk associated with the corresponding query operator (or at least they build iterators that do that work). There’s code in Enumerable.Where to execute the specified filter and only yield appropriate elements as the result sequence, for example. By contrast, the query operator implementations</font></p><img src="images/44.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 12.3 A query taking two paths, depending on whether the data source implements </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IQueryable </font><font style="font-size:x-small;font-family:Times New Roman, serif;">or only </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">in Queryable do little: they just create a new query based on the parameters or call Execute on the query provider, as described at the end of section 12.2.1. In other words, they’re only used to build up queries and request that they be executed—they don’t contain the logic behind the operators. This means they’re suitable for any LINQ p<a name="bookmark3325"></a>rovider that uses expression trees—but they’re useless on their own. They’re the glue between your code and the details of the provider.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With the Queryable extension methods available and ready to use our IQueryable and IQueryProvider implementations, it’s finally time to see what happens when we use a query expression with our custom provider.</font></p>
<p><a name="bookmark334"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3326"></a>12.2.4 The fake query provider in action</font></p>
<p><a name="bookmark3327"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.5 shows a simple query expression, which (supposedly) finds all the strings in our fake source beginning with “abc” and projects the results into a sequence of the lengths of the matching strings. We iterate through the results, but don’t do anything with them, as we know already that they’ll be empty. Of course, we have no source data, and we haven’t written any code to do any real filtering—we’re just logging which calls are made by LINQ in the course of creating the query expression and iterating through the results.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.5 A simple query expression using the fake query classes</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from x in new FakeQuery&lt;string&gt;() where x.StartsWith(&quot;abc&quot;) select x.Length;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (int i in query) { }</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">What would you expect the results of running listing 12.5 to be? In particular, what would you like to be logged </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">last</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, at the point where we’d normally expect to do some real work with the expression tree? Here are the results, reformatted slightly for clarity:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FakeQueryProvider.CreateQuery</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression=FakeQuery.Where(x =&gt; x.StartsWith(&quot;abc&quot;)) FakeQueryProvider.CreateQuery</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression=FakeQuery.Where(x =&gt; x.StartsWith(&quot;abc&quot;))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(x =&gt; x.Length)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FakeQuery&lt;Int32&gt;.GetEnumerator</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression=FakeQuery.Where(x =&gt; x.StartsWith(&quot;abc&quot;))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(x =&gt; x.Length)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The two important things to note are that GetEnumerator is only called at the end, not on any intermediate queries: by the time GetEnumerator is called, we have all the information present in the original query expression. We haven’t manually had to keep track of earlier parts of the expression in each step—a single expression tree captures all the information so far.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Don’t be fooled by the concise output, by the way—the actual expression tree is deep and complicated, particularly due to the where clause including an extra method call. This expression tree is what LINQ to SQL would examine to work out what query to execute. LINQ providers </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> build up their own queries (in whatever form they may need) as calls to CreateQuery are made, but usually looking at the final tree when GetEnumerator is called is simpler, as all the necessary information is available in one place.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The final call logged by listing 12.5 was to FakeQuery.GetEnumerator, and you may be wondering why we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> need an Execute method on IQueryProvi<a name="bookmark3328"></a>der. Well, not all query expressions generate sequences—if you use an aggregation operator such as Sum, Count, or Average, we’re no longer <a name="bookmark3329"></a>really creating a source—we’re evaluating a result immediately. That’s when Execute is called, as shown by the following listing and its output.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.6 IQueryProvider.Execute</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from x in new FakeQuery&lt;string&gt;() where x.StartsWith(&quot;abc&quot;) select x.Length;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">double mean = query.Average();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Output</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FakeQueryProvider.CreateQuery</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression=FakeQuery.Where(x =&gt; x.StartsWith(&quot;abc&quot;)) FakeQueryProvider.CreateQuery</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression=FakeQuery.Where(x =&gt; x.StartsWith(&quot;abc&quot;))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(x =&gt; x.Length)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FakeQueryProvider.Execute</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression=FakeQuery.Where(x =&gt; x.StartsWith(&quot;abc&quot;))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(x =&gt; x.Length)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Average()</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The FakeQueryProvider can be quite useful when it comes to understanding what the C# compiler is doing behind the scenes with query expressions. It’ll show the transparent identifiers introduced within a query expression, along with the translated calls</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">to SelectMany, GroupJoin, and the like.</font></p>
<p><a name="bookmark335"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3330"></a>12.2.5 Wrapping up IQueryable</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We haven’t written any of the significant code that a real query provider would need in order to get useful work done, but hopefully our fake provider has given you insight into how LINQ providers are given the information from query expressions. It’s all built up by the Queryable extension methods, given an appropriate implementation ofIQueryable and IQueryProvider.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve gone into a bit more detail in this section than we will for the rest of the chapter, as it’s involved the foundations that underpin the LINQ to SQL code we saw earlier. Even though you’re unlikely to need to implement the query interfaces yourself, the steps involved in taking a C# query expression and (at execution time) running some SQL on a database are quite profound and lie at the heart of the big features of C# 3. Understanding why C# has gained these features will help keep you more in tune with the language.</font></p>
<p><a name="bookmark3331"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This is the end of our coverage of LINQ using expression trees. The rest of the chapter involves in-process queries using delegates—but as we’ll see, there can still be a great deal of variety and innovation in how LINQ can be used. Our first port of call is LINQ to XML, which is “merely” an XML API designed to integrate well with LINQ to Objects.</font></p>
<p><a name="bookmark337"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3332"></a><a name="bookmark3333"></a>12.3 LINQ-friendly APIs and LINQ to XML</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">LINQ to XML is by far the most pleasant XML API I’ve ever used. Whether you’re consuming existing XML, generating a new document, or a bit of both, it’s easy to use and understand. Part of that is completely independent of LINQ, but a lot of it’s due to how well it interacts with the rest of LINQ. As with section 12.1, I’ll give you just enough introductory information to understand the examples, and then see how LINQ to XML blends its own query operators with those in LINQ to Objects. By the end of the section you may have some ideas about how you can make your own APIs work in harmony with the framework.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">LINQ to XML live<a name="bookmark3334"></a>s in the System.Xml.Linq assembly, and most of the types are in the System.X<a name="bookmark3335"></a>ml.Linq namespace too.<sup><a name="footnote79"></a><a href="#bookmark3336">79</a></sup> Almost all of the types in that namespace have a prefix of X; so whereas the normal DOM API has an XmlElement type, the LINQ to XML equivalent is XElement. This makes it easy to spot when code is using LINQ to XML, even if you’re not immediately familiar with the exact type involved. Figure 12.4 shows the types you’ll use most often.</font></p>
<p><a name="bookmark3337"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Here’s a brief rundown of the types shown:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;XName is used for names of elem<a name="bookmark3338"></a>ents and attributes. Instances are usually created using an implicit conversion from a string (in which case no namespace is used) or vi<a name="bookmark3339"></a>a the + (XNamespace, string) o<a name="bookmark3340"></a>verload<a name="bookmark3341"></a>ed operator.</font></p>
<p><a name="bookmark3342"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;XNamespace represents an XML names<a name="bookmark3343"></a>pace—a URI, basically. Instances are usually created by the implicit conversion from string.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;XObject is the common ancestor of both XNode and XAttribute: unlike in the DOM API, an attribute isn’t a node in LINQ to XML. Methods returning child node<a name="bookmark3344"></a>s don’t include attri<a name="bookmark3345"></a>butes, for exam<a name="bookmark3346"></a>ple.</font></p>
<p><a name="bookmark3347"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3348"></a>■ &nbsp;&nbsp;&nbsp;XNode represents a node in the XML tree. It defines various members to manipulate and query the tree. There are various oth<a name="bookmark3349"></a>er classes derived <a name="bookmark3350"></a>from XNode that aren’t shown in figure 12.4, such as XComment and XDeclaration. These are used relatively infrequently—the most common node types are documents, elements, and text.</font></p>
<p><a name="bookmark3351"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;XAttribute is an attribute with a name and a value. The value is intrinsically text, but there are explicit conversions to many other data types, such as int and DateTi<a name="bookmark3352"></a>me.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;XContainer is a node in the XML tree that can have child content—it’s an element<a name="bookmark3353"></a> or a documen<a name="bookmark3354"></a>t, basically.</font></p>
<p><a name="bookmark3355"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3356"></a><a name="bookmark3357"></a>■ &nbsp;&nbsp;&nbsp;XText is a text node; a further derived type XCData is used to represent CDATA text nodes. (Roughly equivalent to a verbatim string literal—less escaping is required.) XText is rarely instantiated directly in user code; instead when a string is used as the content of an element or document, that’s converted into an XText<a name="bookmark3358"></a> instance.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;XElement is an element. This is the most com<a name="bookmark3359"></a>monly used class in LINQ to XML, along with XAttribute. Unlike in the DOM API, you can create an XElement without creating a document to contain it; unless you really </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">need</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a document object (for<a name="bookmark3360"></a> a custom XML <a name="bookmark3361"></a>declaration, perhap<a name="bookmark3362"></a>s), you can often just use ele<a name="bookmark3363"></a>ments.</font></p>
<p><a name="bookmark3364"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;XDocument is a document. Its root eleme<a name="bookmark3365"></a>nt is accessed using the Root property—this is the equivalent to XmlDocument.DocumentElement. As noted earlier, this often isn’t required.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">More types are available even within the document model, and a few other types for things such as loading and saving options—but these are the most important ones. Of the preceding types, the only ones you regularly need to reference explicitly are XElement and XAttribute. If you use namespaces, you’ll use XNamespace as well, but most of the rest of the types can be ignored the rest of the time. It’s amazing how much you can do with so few types. Speaking of amazing, I can’t resist showing you how the namespace support works in LINQ to XML. We’re not going to use namespaces anywhere else, but it’s a good example of how a well-designed set of conversions and operators can make life easier. It’ll also ease us into our first topic: constructing elements.</font></p><div><img src="images/45.png"/></div><br clear="all"/><div>
<p><a name="bookmark3366"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 12.4 Class diagram for LINQ to XML, showing the most commonly used types</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you only need to specify the name of an element or attribute without a namespace, you can just use a string. You won’t find any constructors for either type with parameters of type string though—they all accept an XName. An implicit conversion exists from string to XName, and also from string to XNamespace. Adding together a namespace and a string also gives you an XName. There’s a fine line between operator abuse and genius, but in this case LINQ to XML really makes it work. Here’s some code to create two elements—one within a namespace and one not:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XElement noNamespace = new XElement(&quot;no-namespace&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XNamespace ns = &quot;<a href="http://csharpindepth.com/sample/namespace">http://csharpindepth.com/sample/namespace</a>&quot;;</font></p>
<p><a name="bookmark3367"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XElement withNamespace = new XElement(ns + &quot;in-namespace&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This makes for readable code even when namespaces are involved—which comes as a welcome relief from some other APIs. But we’ve just created two empty elements. How do we give them some content?</font></p>
<p><a name="bookmark339"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3368"></a><a name="bookmark3369"></a>12.3.2 Declarative construction</font></p>
<p><a name="bookmark3370"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Normally in the DOM A<a name="bookmark3371"></a>PI, you create an el<a name="bookmark3372"></a>ement and then add content to it. We can do that in LINQ to XML as well, via the Add method inherited from XContainer—but that’s not the idiomatic LINQ to XML way of doing things.<sup><a name="footnote80"></a><a href="#bookmark3373">80</a></sup> It’s worth looking at the signature of XContainer.Add though, because it introduces us to the content model. You might’ve expected a signature of Add(XNode) or perhaps Add(XObject)—but in fact it’s just Add(object). The same pattern is used for the XElement (and XDocument) constructor signatures. After the name, you can specify nothing (to create an empty element), a single object (to create an element with a single child node), or an array of ob<a name="bookmark3374"></a>jects to create multiple child nodes. In the multiple children case, a parameter array is used (the params keyword in C#), which means the compiler will create the array for you—you can just <a name="bookmark3375"></a>keep listing arguments.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The use of plain object for the content type may sound crazy, but it’s incredibly useful. When you add content—whether it’s through a constructor or the Add method—<a name="bookmark3376"></a>the following points are considered.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Null references are ignored.</font></p>
<p><a name="bookmark3377"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;XNode and XAttri<a name="bookmark3378"></a>bute instances are added in <a name="bookmark3379"></a>a relatively straightforward manner; they’re cloned if they already have parents, but otherwise no conversion is required. (Some other sanity checks are performed, for instance to make sure you don’t have d<a name="bookmark3380"></a>uplicat<a name="bookmark3381"></a>e attributes in a single element.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Strin<a name="bookmark3382"></a>gs, numbers, dates, times, <a name="bookmark3383"></a>and so on are added by converting them into XText nodes using standard XML formatting.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;If the argument implements IEnumerable (and isn’t covered by anything else) then Add will iterate over its contents and add each value in turn, recursing where necessary.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Anything that d<a name="bookmark3384"></a>oesn't have special-case handling is converted into text by just calling ToString().</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This means that you often don’t need to prepare your content in a special way before adding it to an element—LINQ to XML just does the right thing for you. The details are explicitly documented, so you don’t need to worry about it being too magical— but it really works. Constructi<a name="bookmark3385"></a>ng nested elements leads to code that naturally resembles the hierarchical structure of the tree. This is best shown with an example. Here’s a snippet of LINQ to XML code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new XElement(&quot;root&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new XElement(&quot;child&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new XElement(&quot;grandchild&quot;, &quot;text&quot;)), new XElement(&quot;other-child&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">And here’s the XML of the created element—note the visual similarity between the code and the output: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;root&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;child&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;grandchild&gt;text&lt;/grandchild&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/child&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;other-child /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/root&gt;</font></p>
<p><a name="bookmark3386"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">So far, so good—but the important part <a name="bookmark3387"></a>for us is the fourth bullet in the earlier list, where sequences are processed recursively... because that lets you build an XML structure out of a LINQ query in a natural way. For example, the book’s website has some code to generate an RSS feed from its database. The statement to construct the XML document is 28 lines long—which I’d normally expect to be an abomination—but it’s remarkably pleasant to read.<sup><a name="footnote81"></a><a href="#bookmark3388">81</a></sup> That statement contains two LINQ queries—one to populate an attribute value, and the other to provide a sequence of elements, each representing a news item. As you read the code, it’s obvious what the resulting XML will look like.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To make this more concrete, let’s take two simple examples from the defect tracking system. I’ll demonstrate using the LINQ to Objects sample data, but we could use almost identical queries to work with another LINQ provider instead. First we’ll build an element containing all the users in the sy<a name="bookmark3389"></a>stem. In this case we just need a projection, so the following listing uses dot notation:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.7 Creating elements from the sample users</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var users = new XElement(&quot;users&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllUsers.Select(user =&gt; new XElement(&quot;user&quot;, new XAttribute(&quot;name&quot;, user.Name), new XAttribute(&quot;type&quot;, user.UserType)))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(users);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Output &lt;users&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;user name=&quot;Tim Trotter&quot; type=&quot;Tester&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;user name=&quot;Tara Tutu&quot; type=&quot;Tester&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;user name=&quot;Deborah Denton&quot; type=&quot;Developer&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;user name=&quot;Darren Dahlia&quot; type=&quot;Developer&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;user name=&quot;Mary Malcop&quot; type=&quot;Manager&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;user name=&quot;Colin Carton&quot; type=&quot;Customer&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/users&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If we want to make a slightly more complex query, it’s probably worth using a query expression. Listing 12.8 creates another list of users, but this time only the developers within SkeetySoft. For a bit of variety, this time each developer’s name is a text node within an element instead of an attribute value:</font></p><img src="images/46.png"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var developers = new XElement(&quot;developers&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from user in SampleData.AllUsers</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">where user.UserType == UserType.Developer</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">select new XElement(&quot;developer&quot;, user.Name)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(developers);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Output &lt;developers&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;developer&gt;Deborah Denton&lt;/developer&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;developer&gt;Darren Dahlia&lt;/developer&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/developers&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This sort of thing can be applied to all the sample data, leaving a document structure like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;defect-system&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;projects&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;project name=&quot;...&quot; id=&quot;...&quot;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;subscription email=&quot;...&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/project&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/projects&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;users&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;user name=&quot;...&quot; id=&quot;...&quot; type=&quot;...&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/users&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;defects&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;defect id=&quot;...&quot; summary=&quot;...&quot; created=&quot;...&quot; project=&quot;...&quot; assigned-to=&quot;...&quot; created-by=&quot;...&quot; status=&quot;...&quot; severity=&quot;...&quot; last-modified=&quot;...&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/defects&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/defect-system&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can see the code to generate all of this in XmlSampleData.cs in the downloadable solution. It demonstrates an alternative to the one-huge-statement approach: each of the elements under the top level is created separately, then glued together like this:</font></p>
<p><a name="bookmark3390"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XElement root = new XElement(&quot;defect-system&quot;, projects, users, defects);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll use this XML to demonstrate our next LINQ integration point: queries. Let’s start with the query methods available on a single node.</font></p>
<p><a name="bookmark340"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3391"></a>12.3.3 Queries on single nodes</font></p>
<p><a name="bookmark3392"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3393"></a>You may be e<a name="bookmark3394"></a>xpecting me to reveal that XElement implements IEnumerable and that LINQ queries come for free. It’s not </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">quite</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that simple, because there are so many different things that an XElement could iterate through. XElement contai<a name="bookmark3395"></a>ns a number of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">axis methods</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that are used as query sources. If you’re familiar with XPath, the idea of an axis will no doubt be familiar to you. Here are the axis methods used directly for querying a single <a name="bookmark3396"></a>node, each of which returns an appropriate IEn<a name="bookmark3397"></a>umerable&lt;T&gt;:</font></p>
<p><a name="bookmark3398"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;AncestorsAndSelf</font></p><div>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Ancestors</font></p>
<p><a name="bookmark3399"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Annotations</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Descendants</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Attributes</font></p>
<p><a name="bookmark3400"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;DescendantsAndSelf</font></p>
<p><a name="bookmark3401"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3402"></a><a name="bookmark3403"></a>■ &nbsp;&nbsp;&nbsp;DescendantNodes &nbsp;&nbsp;&nbsp;■ &nbsp;&nbsp;&nbsp;DescendantNodesAn<a name="bookmark3404"></a>dSelf</font></p>
<p><a name="bookmark3405"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3406"></a>■ &nbsp;&nbsp;&nbsp;Elements &nbsp;&nbsp;&nbsp;■ &nbsp;&nbsp;&nbsp;ElementsAfterSelf</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;ElementsBeforeSelf &nbsp;&nbsp;&nbsp;■ &nbsp;&nbsp;&nbsp;Nodes</font></p>
<p><a name="bookmark3407"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">All of these are fairly self-explanatory (and the MSDN documentation provides more details). There are useful overloads to retrieve only nodes with an appropriate name: calling Descendants(&quot;user&quot;) on an XElement will return all user elements underneath the element you call it on, for instance.</font></p>
<p><a name="bookmark3408"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In addition to these calls returning sequences, some methods return a single result—Attribute and Element are the most important, returning the named attribute and the first child eleme<a name="bookmark3409"></a>nt with the specified<a name="bookmark3410"></a> name, respe<a name="bookmark3411"></a>ctively. Additionally, there are explicit conversions from an XAtt<a name="bookmark3412"></a>ribute or XElement to any number of other types, such as int, string, and DateTime. These are important for both filtering and <a name="bookmark3413"></a>projecting results. Each conversion to a non-nullable value type also has a conversion to its nullable equivalent—these (and the conversion to string) return a null value if you invoke them on a null reference. This null propagation means you don’t have to check for the presence or absence of attributes or elements within the query— you can use the query results instead.</font></p>
<p><a name="bookmark3414"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">What does this have to do with LI<a name="bookmark3415"></a>NQ? Well, the fact that multiple search results are returned in terms of IEnumerable&lt;T&gt; means you can use the normal LINQ to Objects methods after finding some elements. The following listing shows an example of finding the names and types of the users, this time starting off with the sample data in XML.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.9 Displaying the users within an XML structure</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XElement root = XmlSampleData.GetElement();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = root.Element(&quot;users&quot;).Elements().Select(user =&gt; new {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Name = (string) user.Attribute(&quot;name&quot;),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">UserType = (string) user.Attribute(&quot;type&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">});</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var user in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine (&quot;{0}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;user.Name, &nbsp;&nbsp;&nbsp;user.UserType);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">After creating the data at the start, we navigate down to the users element, and ask it for its direct child elements. This two-step fetch could be shortened to just root.Descendants (&quot;user&quot;), but it’s good to know a<a name="bookmark3416"></a>bout the more rigid navigation so you can use it where necessary. It’s also more robust in the face of changes to the document structure, such as another (unrelated) user element being added elsewhere in the document.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The rest of the query expression is merely a projection of an XElement into an anonymous type. I’ll admit that we’re cheating slightly with the user type: we’ve kept it as a string instead of calling Enum.Parse to convert it into a proper UserType value. The latter approach works perfectly well—but it’s quite longwinded when you only</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">need the string form, and the code becomes hard to format sensibly within the strict limits of the printed page.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s nothing particularly special here—returning query results as sequences is fairly common, after all. It’s worth noting how seamlessly we can go from domain-specific query operators to general-purpose ones. That’s not the end of the story though—LINQ to XML has some extra extension methods to add as well.</font></p>
<p><a name="bookmark341"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3417"></a>12.3.4 Flattened query operators</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen how the result of one part of a query is often a sequence—and in LINQ to XML it’s often a sequence of elements. What if you wanted to then perform an XML-specific query on each of those elements? To present a somewhat contrived example, we can find all the projects in our sample data with root.Element(&quot;projects&quot;) . Elements(), but how can we find the subscription ele<a name="bookmark3418"></a>ments within them? We need to apply another query to each element, and then flatten the results. (Again, we could use root.Descendants(&quot;subscription&quot;)—but imagine a more complex document model where that wouldn’t work.)</font></p>
<p><a name="bookmark3419"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This may sound familiar, and it is—LINQ to Objects already provides the Select-Many operator (represented by multiple from clauses in a query expression) to do this. So we could write our query as</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from project in root.Element(&quot;projects&quot;).Elements() from subscription in project.Elements(&quot;subscription&quot;) select subscription</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As there are no elements within a project other than subscription, we could just use the overload of Elements that doesn’t specify a name. I find it clearer to specify the element name in this case, but it’s often just a matter of taste. (The same argument could be made for calling Element(&quot;projects&quot;) .Elements( &quot;project&quot;) to start with, admittedly.) Here’s the same query written using dot notation and an overload of SelectMany that only returns the flattened sequence, without performing any further projections:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">root.Element(&quot;projects&quot;).Elements()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.SelectMany(project =&gt; project.Elements(&quot;subscription&quot;))</font></p>
<p><a name="bookmark3420"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Neither of these queries are completely unreadable by any means, but they’re not ideal. LINQ to XML<a name="bookmark3421"></a> provides a number of extension methods (in the System. Xml.Linq.Extensions class) which either act on a specific sequence type or are generic with a constrained type argument, to cop<a name="bookmark3422"></a>e with the lack of generic interface covariance prior to C# 4. There’s InDocumentOrder, which does exactly what it sounds like—and most of the axis methods mentioned in section 12.4.3 are also available as extension methods. This means that we can convert our query into this simpler form:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">root.Element(&quot;projects&quot;).Elements().Elements(&quot;subscription&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This sort of construction makes it easy to write XPath-like q<a name="bookmark3423"></a>ueries in LINQ to XML without everything just being a string. If you want to use XPath, that’s available too via more extension methods—but personally I’ve found that the query methods have served me well more often than not. This also supports mixing the query with the operators of LINQ to Objects. For example, to find all the subscriptions for projects with a name including “Media,” you could use</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">root.Element(&quot;projects&quot;).Elements()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Where(project =&gt; ((string) project.Attribute(&quot;name&quot;))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Contains(&quot;Media&quot;))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Elements(&quot;subscription&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before we move on to Parallel LINQ, let’s think about how the design of LINQ to XML merits the “LINQ” part of its title—and how you could potentially apply the same techniques to your own API.</font></p>
<p><a name="bookmark342"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3424"></a><a name="bookmark3425"></a>12.3.5 Working in harmony with LINQ</font></p>
<p><a name="bookmark3426"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Some of the design decisions in LINQ to XML seem odd if you take them in isolation as part of an XML API, but in the context of LINQ they make perfect sense. The designers clearly imagined how their types could be used within LINQ queries, and how t<a name="bookmark3427"></a>hey could interact with other data sources. If you’re writing your own data access API, in whatever context that might be, it’s worth taking the same things into account. If someone uses your methods in the middle of a query expression, are they left with something useful? Will they be able to use some of your query methods, then some from LINQ to Objects, then some more of yours in one fluent expression?</font></p>
<p><a name="bookmark3428"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen three ways in which LINQ to XML has accommodated the rest of LINQ:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It’s good at </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">consuming</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> sequences with its approach to construction. LINQ is deliberately declarative, and LINQ to XML supports this with a declarative way of creating XML structures.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">returns</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> sequences from its query methods. This is probably the most obvious step that data access APIs would already take: returning query results as IEnumerable&lt;T&gt; or a class implementing it is pretty much a no-brainer.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">extends</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the set of queries you can perform on sequences of XML types: this makes it feel like a unified querying API, even though some of it’s XML-specific.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may be able to think of other ways in which your own libraries can play nicely with LINQ: these aren’t the only options you should consider, but they’re a good starting point. Above all, I’d urge you to put yourself in the shoes of a developer wanting to use your API within code that’s already using LINQ. What might such a developer want to achieve? Can LINQ and your API be mixed easily, or are they really aiming for different goals?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re roughly halfway through our whirlwind tour of different approaches to LINQ. Our next stop is in some ways reassuring and in some ways terrifying: we’re back to querying simple sequences, but this time in parallel...</font></p>
<p><a name="bookmark344"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3429"></a><a name="bookmark3430"></a>12.4 &nbsp;&nbsp;&nbsp;Replacing LINQ to Objects with Parallel LINQ</font></p>
<p><a name="bookmark3431"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve been following Parallel LINQ for a long time. I first came across it when Joe Duffy introduced it on his blog in September 2006 (see <a href="http://mng.bz/vYCO">http://mng.bz/vYCO</a>). The first Community Technology Preview (CTP) was released in November 2007, and the overall feature<a name="bookmark3432"></a> set has evolved over time too. It’s now part of a wider effort called Par<a name="bookmark3433"></a>allel Extensions, which is part <a name="bookmark3434"></a>of .NET 4, aiming to provide higher level building blocks for concurrent programming than the relatively small set of primitives we’ve had to work with u<a name="bookmark3435"></a>ntil now. There’s a lot more to Parallel Extensions than Parallel LINQ—or </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">PLINQ</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> , as it’s often known—but we’ll only be looking at the LINQ aspect here.</font></p>
<p><a name="bookmark3436"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The idea behind Parallel LINQ is that you should be able to take a LINQ to Objects query that’s taking a long time and make it run faster by using multiple threads to take advantage of multiple cores—with as few changes to the query as possible. As with anything to do with concurrency, it’s not quite as simple as that, but you may be surprised at just what can be achieved. Of course, we’re still trying to think bigger than individual LINQ technologies—we’re thinking about the different models of interaction involved, rather than the precise details. But if you’re interested in concurrency, I’d heartily recommend that you dive into Parallel Extensions—it’s one of the most promising approaches to parallelism that I’ve come across recently.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m going to use a single example for this section: rendering a Mandelbrot set image (see <a href="http://mng.bz/D6YL">http://mng.bz/D6YL</a>). Let’s start off by trying to get it right with a single thread before moving into trickier territory.</font></p>
<p><a name="bookmark345"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3437"></a><a name="bookmark3438"></a>12.4.1 &nbsp;&nbsp;&nbsp;Plotting the Mandelbrot set with a single thread</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before any mathematicians attack me, I should point out that I’m using the term </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Mandelbrot set</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> loosely here. The details aren’t really important—but these aspects are</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;We’re trying to create a rectangular image, given various options such as width, height, origin and search depth.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;For each pixel in the image, we’re going to calculate a byte value that will end up as the index into a 256-entry palette.</font></p>
<p><a name="bookmark3439"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The calculation of one pixel value doesn’t rely on any other results.</font></p>
<p><a name="bookmark3440"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The last point is absolutely crucial—it means this task is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">embarrassingly parallel.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> In other words, there’s nothing in the task itself that makes it hard to parallelize. We still need a mechanism for distributing the workload across threads and then gathering the resu<a name="bookmark3441"></a>lts together, <a name="bookmark3442"></a>but the rest should be easy. PLINQ will be responsible for the distribution and collation (with a little help and care); we just need to express what we want to do. For the purposes of demonstrating multiple approaches, I’ve put together an abstract base class that’s responsible for setting things up, running the query, and displaying the results, along with a method to compute the color of an individual pixel. An abstract method is responsible for creating a byte array of values, which are then converted into the image. The first row of pixels comes first, left to right, then the second row, and so on. Each example here is just an implementation of this method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 12.5 Mandelbrot image generated on a single thread</font></p>
<p><a name="bookmark3443"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I should note that using LINQ really isn’t an ideal solution here—there are various inefficiencies in the way that I’m doing things. Don’t focus on that side of things: concentrate on the idea that we have an embarrassingly parallel query, and we want to execute it across multiple cores. The following listing shows the single-threaded version in all its simple glory:</font></p><div><img src="images/47.png"/></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.10 Single-threaded Mandelbrot generation query</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from row in Enumerable.Range(0, Height)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from column in Enumerable.Range(0, Width) select ComputeIndex(row, column);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return query.ToArray();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We iterate over every row and ever<a name="bookmark3444"></a>y column within each row, computing the index of the relevant pixel. Calling ToArray () evaluates the resulting sequence, converting it into an array. Figure 12.5 shows the beautiful results.</font></p>
<p><a name="bookmark3445"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3446"></a><a name="bookmark3447"></a>This took about 5.5 seconds to generate on my dual-core laptop; the ComputeIndex method performs more iterations than we really need, in order to make the timing differences more obvious.<sup><a name="footnote82"></a><a href="#bookmark3448">82</a></sup> Now that we have a benchmark in terms of both timing and what the results should look like, let’s try to parallelize the query.</font></p>
<p><a name="bookmark346"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3449"></a>12.4.2 Introducing ParallelEnumerable, ParallelQuery, and AsParallel</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Parallel LINQ brings with it several new types... b<a name="bookmark3450"></a>ut in many cases, you’ll never see their names mentioned. They live in the System.Linq namespace, so you don’t even need to change using directives. ParallelEnumerable is a static class, similar to Enumerable— it mostly contains extension methods, the majority of which extend ParallelQuery.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This latter type has both a nongeneric and a generic form (Par<a name="bookmark3451"></a>allelQuery and Paral-lelQuery&lt;TSource&gt;) but most of the time you’ll use the generic form, just as IEnumera-ble&lt;T&gt; is more widely used than IEnumerable. &nbsp;&nbsp;&nbsp;Additionally,<a name="bookmark3452"></a> &nbsp;&nbsp;&nbsp;there’s</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">OrderedParallelQuery&lt;TSource&gt;, which is the &nbsp;&nbsp;&nbsp;parallel equivalent &nbsp;&nbsp;&nbsp;of &nbsp;&nbsp;&nbsp;IOrdered-</font></p><div><img src="images/48.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 12.6 Class diagram for Parallel LINQ, including relationship to normal LINQ interfaces</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Enumerable&lt;T&gt;. The relationships between all of these types are shown in figure 12.6.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see, ParallelQuery&lt;TSource&gt; implements IEnumerable&lt;TSource&gt;, so once you’ve constructed a query appropriately, you can iterate through the results in the normal way. Once you have a parallel query, the &nbsp;&nbsp;&nbsp;extension methods &nbsp;&nbsp;&nbsp;in &nbsp;&nbsp;&nbsp;Parallel-</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Enumerable take precedence over the ones in Enumerable (because Parallel-Query&lt;T&gt; is more specific than IEnumerable&lt;T&gt;; see section 10.2.3 if you need a reminder of the rules)—which is how the parallelism is maintained throughou<a name="bookmark3453"></a>t a query. There’s a parallel equivalent to all the LINQ standard query operators— although you should be careful if you’ve created any of yo<a name="bookmark3454"></a>ur own extension methods. You’ll still be able to call them, but they’ll force the query to be single-threaded from that point onward.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So how do you get a parallel query to start with? By calling AsParallel—an extension method in ParallelEnumerable, but which extends IEnumerable&lt;T&gt;. So we can parallelize our Mandelbrot query incredibly simply, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.11 First attempt at a multithreaded Mandelbrot generation query</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from row in Enumerable.Range(0, Height)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.AsParallel()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from column in Enumerable.Range(0, Width) select ComputeIndex(row, column);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return query.ToArray();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Job done? Well, not quite. This query </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> run in parallel—but the results aren’t quite what we need: it doesn’t maintain the order in which we process the rows. Instead of our beautiful Mandelbrot image, we get something like figure 12.7... although the exact details change every time, of course.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Oops. On the bright side, this rendered in about 3.2 seconds, so my machine was clearly making use of its second core. On the other hand, getting the right answer is pretty important.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You <a name="bookmark3455"></a>may be surprised to hear that this is a deliberate </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">feature</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of Parallel LINQ. Ordering a parallel query requires more coordination between the threads, and the</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 12.7 Mandelbrot image generated using an unordered query, resulting in some sections being incorrectly placed</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">whole pur<a name="bookmark3456"></a>pose of parallelization is to improve performance—so PLINQ defaults to an unordered query. It’s a bit of a nuisance in our case though.</font></p><div><img src="images/49.png"/></div><br clear="all"/>
<p><a name="bookmark347"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3457"></a>12.4.3 Tweaking parallel queries</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Fortunately, there’s a way out of this—you jus<a name="bookmark3458"></a>t need to force the query to be treated as ordered, which is available via the AsOrdered extension method. Listing 12.12 shows the fixed code, which produces the original image. It’s slightly slower than the unordered query, but still significantly faster than the single-threaded version.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.12 Multithreaded Mandelbrot query maintaining ordering</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from row in Enumerable.Range(0, Height)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.AsParallel().AsOrdered()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from column in Enumerable.Range(0, Width) select ComputeIndex(row, column);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return query.ToArray();</font></p>
<p><a name="bookmark3459"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The nuances of ordering are beyond the scope of this book, but I recommend that you read this blog post, <a href="http://blogs.msdn.com/pfxteam/archive/2008/06/11/8592301.aspx%3e">http://blogs.msdn.com/pfxteam/archive/2008/06/11/</a> <a href="http://blogs.msdn.com/pfxteam/archive/2008/06/11/8592301.aspx%3e">8592301.aspx&gt;</a>, which goes into the gory details. A number of other methods can be used to alter how the query behaves:</font></p>
<p><a name="bookmark3460"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3461"></a>■ &nbsp;&nbsp;&nbsp;AsUnordered—Makes an ordered query unordered; if you only need results to be ordered for the first part of a query, this allows later stages to be executed more efficiently.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;WithCancellation—Specifies a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">cancellation token</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be used with this query. Cancellation tokens are used throughout Parallel Extensions to allow tasks to be cancelled in a safe, con<a name="bookmark3462"></a>trolled manner.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;WithDegreeOfPar<a name="bookmark3463"></a>allelism—Allows you to specify the maximum number of concurrent tasks used to execute the query. You could use this to limit the <a name="bookmark3464"></a>number of threads used if you wanted to avoid swamping the machine,<a name="bookmark3465"></a> or to increase the numbe<a name="bookmark3466"></a>r of threads used for a query which wasn’t CPU-bound.</font></p>
<p><a name="bookmark3467"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;WithExecutionMode —Can be used to force the query to execute in parallel, even if Parallel LINQ thinks it’d execute faster as a single-threaded q<a name="bookmark3468"></a>uery.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;WithMergeOptions—Allows you to tweak how the results are buffered: disabling buffering gives the shortest time before the first result is returned, but also lower throughput; full buffering gives the highest throughput, but no results are returned before the query has executed completely. The default is a compromise between the two.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The important point is that aside from ordering, these shouldn’t affect the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">results</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the query. You can design your query and test it in LINQ to Objects, then parallelize it, work out your ordering requirements, and tweak it if necessary to perform just how you want it to. If you showed the final query to someone who knew LINQ but not PLINQ, you’d only have to explain the PLINQ-specific method calls—the rest of the query would be familiar. Have you ever seen such an easy way to achieve concurrency? (The rest of Parallel Extensions is aimed at achieving simplicity where possible, too.)</font></p>
<p><a name="bookmark3469"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">PLAY WITH THE CODE YOURSELF A couple of further points are demonstrated in the downloadable source code: if you parallelize across the whole query of pixels rather than just the rows, then an unordered query looks even weirder; and there’s a ParallelEnumerable.Range method that gives PLINQ a bit more information than calling Enumerable.Range(...).AsParallel(). I used AsParallel() in this section, as that’s the more general way of parallelising a query: most queries don’t start with a range.</font></p>
<p><a name="bookmark3470"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Changing the in-process query model from single-threaded to parallel is quite a small conceptual leap, really. In our next section we’ll turn the model on its head.</font></p>
<p><a name="bookmark349"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3471"></a>12.5 Inverting the query model with LINQ to Rx</font></p>
<p><a name="bookmark3472"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3473"></a><a name="bookmark3474"></a>All of the LINQ libraries we’ve seen so far have one thing in common: you pull data from them using IEnumerable&lt;T&gt;. At first sight, that seems so obvious th<a name="bookmark3475"></a>at it’s not worth saying—wh<a name="bookmark3476"></a>at would be the alternative? Well, how about if you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">push</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the data instead of pulling it? Instead of the data consumer being in control, the provider can be in the driving seat, letting the data consumer </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">react</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> when new data is available. Don’t worry too much if all this sounds dauntingly different: you actually know about the fundamental concept already, in the form of events. If you’re comfortable with the idea of subscribing to an event, reacting to it, and unsubscribing later, that’s a good starting point.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Reactive Extensions for .NET is a Microsoft project on DevLabs (see <a href="http://mng.bz/R7ip">http://</a> <a href="http://mng.bz/R7ip">mng.bz/R7ip </a>and<a name="bookmark3477"></a> <a href="http://mng.bz/HCLP">http://mng.bz/</a>HCLP); versions are available for .NE<a name="bookmark3478"></a>T 3.5 SP1, .NET 4, Silverlight 3 and 4, and there’s even a version targeting JavaScript. You may hear it going by various names, but </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Rx</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">LINQ to Rx</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> are the most common abbreviations, and they’re the ones I’ll use here. Its scope is more than just the reactive side of <a name="bookmark3479"></a>things we’re loo<a name="bookmark3480"></a>king at here—in particular, there’s an interesting assembly called System.Interactive that contains various extra LINQ<a name="bookmark3481"></a> to Objects methods; the push operations are implemented within System.Reactive. Even within the push model we’ll barely be scratching the surface here. I know this is true for everything we’ve covered in this chapter, but I think it’s particularly applicable in this section: not only is there a lot to learn about the library it<a name="bookmark3482"></a>self, but it’s a whole different way of thinking. There are loads of videos on Channel 9 (see <a href="http://mng.bz/QoXE">http://mng.bz/QoXE</a>)—some are based on the mathematical aspects, whereas others are more practical. In this section I’ll be emphasizing the way that the LINQ concepts can be applied to this push model for data flow.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Enough of the introduction... let’s meet the two interfaces that form the basis of LINQ to Rx.</font></p>
<p><a name="bookmark350"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3483"></a><a name="bookmark3484"></a><a name="bookmark3485"></a>12.5.1 IObservable&lt;T&gt; and IObserver&lt;T&gt;</font></p>
<p><a name="bookmark3486"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The data model of LINQ to Rx is the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">mathematical dual</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the normal IEnumerable&lt;T&gt; model.<sup><a name="footnote83"></a><a href="#bookmark3487">83</a></sup> When you iterate over a pull collection, you <a name="bookmark3488"></a>effectively start off by saying, “Please give me an iterator” (the call to GetEnumerator) and then repeatedly say “Is there another item? If so, I'd like it now” (via calls to MoveNext and Current). <a name="bookmark3489"></a>LINQ to Rx reverses this. Instead of requesting an iterator, you provide an observer. Then, instead of requesting the next item, your code is told when one is ready—or when an error occurs, or the end of the data is reached. Here are the declarations of the two interfaces involved:</font></p>
<p><a name="bookmark3490"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public interface IObservable&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IDisposable Subscribe (IObserver&lt;T&gt; observer);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark3491"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public interface IObserver&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void OnNext (T <a name="bookmark3492"></a>value); void OnComplete<a name="bookmark3493"></a>d();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void OnException (Exception error);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark3494"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">These interfaces are actually part of .NET 4 (in the System namespace), even though the rest of LINQ to Rx is in a separate download. In fact, the<a name="bookmark3495"></a>y’re IObservable&lt;out T&gt; and IObserver<a name="bookmark3496"></a>&lt;in T&gt; in .NET 4, expressing the covariance of IObservable and the contravariance of IObserver. We’ll learn more about generic variance in the next chapter, but I’m presenting the interfaces here as if they were invariant for the sake of simplicity. One concept at a time! Figure 12.8 shows the duality in terms of how data flows in each model.</font></p><img src="images/50.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 12.8 Sequence diagram showing the duality of </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;T&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IObservable&lt;T&gt;</font></p>
<p><a name="bookmark3497"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I suspect I’m not alone in finding the push model harder to think about, as it has the natural ability to work asynchronously—but look at how much simpler it is than the pull model, in terms of the flow diagram. This is partly due to the multiple method approach of the pull model: if IEnumerator&lt;T&gt; just had a method with a signature of bool TryGetNext (out T item), it’d be somewhat simpler.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Earlier I mentioned that LINQ to Rx is similar to the events we’re already familiar with. C<a name="bookmark3498"></a>alling Subscribe on an observable is like using += with an event to register a handler. The disposable value returned by Subscribe remembers the observer you passed in: disposing of it is like using -= with the same handler. In many cases you really don’t need to unsubscribe from the observable; it’s really available in case you need to unsubscribe halfway through a sequence—the equivalent of breaking out of a foreach loop early. Failing to dispose of an IDisposable value may feel like anathema to you, but it’s often safe in LINQ to Rx. None of the examples in this chapter will use the return value of Subscribe.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s all there is to IObservable&lt;T&gt;—but what about the observer itself? Why does<a name="bookmark3499"></a> it have t<a name="bookmark3500"></a>hree methods? Consider the normal pull model where for any Move-Next/Current pair of calls, three things can happen:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;We may be at the end of the sequence, in which case MoveNext returns false.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;We may not have reached the end of the sequence, in which case MoveNext returns true, and Current returns the new value.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;An error may occur—we could fail to read t<a name="bookmark3501"></a>he next line from a network connection, for example. In this case, an exception would be thrown.</font></p>
<p><a name="bookmark3502"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The IObserver&lt;T&gt; interface represents each of these options as a separate method. Typically an observer will have its OnNext method called repeatedly, and then finally OnCompleted—unless there’s an error of some kind, in which case OnError will be called instead. After the sequence has completed or encountered an error, no further method calls will be made. You rarely need to implement IObserver&lt;T&gt; directly, though. There are many extension methods on IObservable&lt;T&gt;, including overloads for Subscribe. These allow you to subscribe to an observable by just providing appropriate delegates: usually you provide a delegate to be executed for each item, and then optionally one to be executed on completion, on error, or both.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With that bit of theory out of the way, we can see some actual code using LINQ to Rx.</font></p>
<p><a name="bookmark351"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3503"></a>12.5.2 Starting simply (again)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re going to demonstrate LINQ to Rx in the same way we started off with <a name="bookmark3504"></a>LINQ t<a name="bookmark3505"></a>o Objects—using a range. Instead of Enumerable.Range, we’ll use Observable.Range, which creates an observable range. Each time an observer subscribes to the range, the numbers are emitted to that observer using OnNext, followed by OnCompleted. We’ll start off as simply as we can, just printing out each value as we receive it, and a confirmation message at the end or if an error occurs. The following listing shows that this is actually less code than you’d need for the pull model.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.13 First contact with IObservable&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var observable = Observable.Range(0, 10);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">observable.Subscribe(x =&gt; Console.WriteLine(&quot;Received {0}&quot;, x), e =&gt; Console.WriteLine(&quot;Error: &nbsp;&nbsp;&nbsp;{0}&quot;, e),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">() =&gt; Console.WriteLine(&quot;Finished&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this case it’s hard to see how we could get an error, but I’ve included the error notification delegate for completeness. The results are as you’d expect:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Received 0 Received 1</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Received 9 Finished</font></p>
<p><a name="bookmark3506"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The observable return<a name="bookmark3507"></a>ed by the Range method is known as a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">cold observable</font><font style="font-size:x-small;font-family:Times New Roman, serif;">: it lies dormant until an observer subscribes to it, at which point it’ll emit the values to that individual observer. If you subscribe with another observer, that will see another copy of the range. This isn’t quite the same as a normal event such as a button click, where several observers could be subscribed to the same actual sequence of values—and the values may be effectively yielded whether there are any observers or not. (You can click a button even if there aren’t <a name="bookmark3508"></a>any event handlers attached, after all.) Sequences like this are known as </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">hot observables.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> It’s important to know which type you’re dealing with, even though the same set of operations apply to both kinds.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve done the simplest thing possible, let’s try some familiar LINQ operators.</font></p>
<p><a name="bookmark3509"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3510"></a>By now I'm sure you’re familiar with the pattern—there are various extension methods in a static class (called Observable, somewhat predictably) that perform appropriate transformations. We’ll look at just a few of the available operators, and think a little about what’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> available, and why it’s not.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">FILTERING AND PROJECTING</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s jump straight into a query expression that takes a sequence of numbers, filters out the odd ones, and squares anything that’s left. We subscribe Console.WriteLine to the final result of the query, so that any items produced will be displayed. The following listing shows the code—look at how the query expression could easily be a LINQ to Objects query.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.14 Filtering and projecting in LINQ to Rx</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var numbers = Observable.Range(0, 10); var query = from number in numbers where number % 2 == 0 select number * number; query.Subscribe(Console.WriteLine);</font></p>
<p><a name="bookmark3511"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">For simplicity’s sake, I haven’t added handlers for completion or error—and using the conversion from the Console .WriteLine method group to an Action&lt;int&gt; keeps the code nice and short. This produces the same results it would in LINQ to Objects: 0, 4, 16 and so on. Let’s move on to grouping.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">GROUPING</font></p>
<p><a name="bookmark3512"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">A group by query expression in LINQ to Rx produces a new IGroupedObservable&lt;T&gt; for each group—although what you then </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> with the groupi<a name="bookmark3513"></a>ng isn’t always obvious. For example, it’s not uncommon to have a nested subscription so that each time a new group is produced, you subscribe an observer to that group. The results </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">within</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> each group are produced as they’re received by the grouping construct—effectively it acts as a sort of redirection choice, like an usher at a play examining each person’s ticket as they arrive, and directing them to the relevant section of the theatre. By contrast, LINQ to Objects collects a whole group together before returning it—which means it has to read to the end of the sequence, buffering all the results.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The following listing shows an example of this nested subscription, and also demonstrates how group results are emitted.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.15 Grouping numbers mod 3</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var numbers = Observable.Range(0, 10); var query = from number in numbers</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">group number by number % 3; query.Subscribe(group =&gt; group.Subscribe</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(x =&gt; Console.WriteLine(&quot;Value: &nbsp;&nbsp;&nbsp;{0}; &nbsp;&nbsp;&nbsp;Group: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;x, &nbsp;&nbsp;&nbsp;group.Key)));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The best way to understand this is probably to remember that dealing with groups in LINQ to Objects often involves having a nested foreach loop—so we have nested</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">subscriptions in LINQ to Rx. When in doubt, try to find the duality between the two data models. In LINQ to Objects we’d normally process each whole group in turn, whereas the order in LINQ to Rx means the output of listing 12.15 looks like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Value: 0; Group: 0 Value: 1; Group: 1 Value: 2; Group: 2 Value: 3; Group: 0 Value: 4; Group: 1 Value: 5; Group: 2 Value: 6; Group: 0 Value: 7; Group: 1 Value: 8; Group: 2 Value: 9; Group: 0</font></p>
<p><a name="bookmark3514"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This makes perfect sense when you think of the push model—and in some cases it means that operations that would’ve required a lot of data buffering in LINQ to Objects can be implemented in LINQ to Rx much more efficiently. As a final example, let’s look at another operator that uses multiple sequences.</font></p>
<p><a name="bookmark3515"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">FLATTENING</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">LINQ to Rx supplies a few overloads of SelectMany and the idea is still the same as in LINQ to Objects: each item in the original sequence produces a new sequence, and the result is the combination of all these new sequences, flattened. The following listing shows this in action—it’s a little like listing 11.16, when we first introduced</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">SelectMany in LINQ to Objects.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.16 SelectMany producing multiple ranges</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var query = from x in Observable.Range(1, 3) from y in Observable.Range(1, x) select new { x, y }; query.Subscribe(Console.WriteLine);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here are the results, which should be reasonably predictable:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark3516">{ &nbsp;&nbsp;&nbsp;x &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;1, &nbsp;&nbsp;&nbsp;y &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;}</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark3517">{ &nbsp;&nbsp;&nbsp;x &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;2, &nbsp;&nbsp;&nbsp;y &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;}</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark3518">{ &nbsp;&nbsp;&nbsp;x &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;2, &nbsp;&nbsp;&nbsp;y &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;}</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark3519">{ &nbsp;&nbsp;&nbsp;x &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;3, &nbsp;&nbsp;&nbsp;y &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;}</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark3520">{ &nbsp;&nbsp;&nbsp;x &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;3, &nbsp;&nbsp;&nbsp;y &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;}</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark3521">{ &nbsp;&nbsp;&nbsp;x &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;3, &nbsp;&nbsp;&nbsp;y &nbsp;&nbsp;&nbsp;= &nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;}</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this case, the results are deterministic, but th<a name="bookmark3522"></a>at’s only because by default, Observable.Range emits items on the current thread. It’s entirely possible to have multiple sequences being produced on multiple threads. For fun, you might wa<a name="bookmark3523"></a>nt to change the sec<a name="bookmark3524"></a>ond call to Observable.Range to specify Scheduler.ThreadPool as a third argument. At that point, while each of the inner sequences comes out in order with respect to itself, those separate sequences can be mixed up amongst each other. Imagine a sports stadium with one official firing a starting pistol for several different races in quick succession: even if you know the winner of each race, you don’t know which race will finish first.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Apologies if this makes you want to go and lie down. If it’s any consolation, it gives me the same feeling. I do find it fascinating at the same time though.</font></p>
<p><a name="bookmark3525"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">WHAT’S IN AND WHAT’S OUT?</font></p>
<p><a name="bookmark3526"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We already know that a let clause works byjust calling Select, so that’s okay—but not all LINQ to Objects operators are implemented in LINQ to Rx. The missing operators are generally the ones that would have to b<a name="bookmark3527"></a>uffer all their output and return a new observable. For example, there’s no Reverse method, and no OrderBy. C# is quite happy with that—it just won’t let you use an orderby clause in a query expression based on observables. There’s<a name="bookmark3528"></a> a Join method, but that doesn’t deal with observables directly—it handles </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">join plans.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> This is part of the Rx implementation of the join-calculus, and well beyond the scope of this book. Likewise there’s no GroupJoin method, so join.. .into isn’t supported.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For the various LINQ standard query operators that aren’t covered by the query expression syntax—and to see the range of extra methods it makes available—see the System.Reactive documentation. Although you may start off being disappointed about the familiar functionality from LINQ to Objects that’s missing in LINQ to Rx (usually because it just doesn’t make sense), you may be surprised by how rich the set of available methods really is. Many of the new methods are then ported to LINQ to Objects in the System. Interactive assembly.</font></p>
<p><a name="bookmark353"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3529"></a>12.5.4 What’s the point?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m well aware that I haven’t provided any compelling reasons to use LINQ to Rx yet. This is deliberate, as I don’t intend to show a full, useful example—it’s incidental to the point of this chapter, and would take too much space. But Rx provides an elegant way of thinking about all kinds of asynchronous processes—nor<a name="bookmark3530"></a>mal .NET events (w<a name="bookmark3531"></a>hich can be viewed as an observable using Observable.FromEvent), asynchronous I/O, a<a name="bookmark3532"></a>nd calls to web services, for example. It provides a way of managing the complexity and concurrency in an efficient manner. There’s no doubt that it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> harder to get your head around than LINQ to Objects, but if you’re in the kind of situation where it’d be useful, you’re already facing a mountain of complexity.</font></p>
<p><a name="bookmark3533"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">LINQ to Rx is a relatively young project, with the first release appearing on Dev-Labs in November 2009. If you’ve found this short introduction interesting, you should definitely take a closer look. The reason I wanted to cover Rx in this book, despite not being able to do it any sort of justice, is because it shows why LINQ was designed the way it was. Although there are conversion me<a name="bookmark3534"></a>thods available between IEnumerable&lt;T&gt; and IObservable&lt;T&gt;, there’s no inheritance relationship—if the language had made any requirement that the types involved in LINQ had to be pull sequences, there would’ve been no query expression support for Rx at all. It would’ve been even more disastrous if extension methods had been limited to IEnumerable&lt;T&gt; in some way. Likewise, we’ve seen that not all the normal LINQ operators are appli<a name="bookmark3535"></a>cable to Rx—which is why it’s important that the language specifies query translations in terms of a pattern that should be supported as far as it makes sense for the given provider. I hope you have a sense that even though the push and pull models are very different to work with, LINQ acts as a sort of unifying force where possible.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may be relieved to hear that our last topic is a lot simpler—it’s back on the home ground of LINQ to Objects, but this time we’re writing our own extension methods.</font></p>
<p><a name="bookmark355"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3536"></a><a name="bookmark3537"></a>12.6 Extending LINQ to Objects</font></p>
<p><a name="bookmark3538"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One of the nice things about LINQ is that it’s extensible. Not only can you come up with your own query providers and data models, you can also add to existing ones. In my ex<a name="bookmark3539"></a>perience, the most common situation where this is useful is with LINQ to Objects. If you nee<a name="bookmark3540"></a>d a particular type of query that isn’t directly supported (or is awkward or inefficient with the standard query operators), you can write your own. Of course, writing a general-purpose generic method can be more challenging than just solving your immediate problem, but if you find yours<a name="bookmark3541"></a>elf writing similar code a few times, it’s worth considering whether you could refactor it into a new operator.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Personally I enjoy writing query operators. There are interesting technical cha<a name="bookmark3542"></a>llenges, but it rarely requires a huge amount of code—and the results can be elegant. In this section we’ll look at some of the ways you can make your custom operators behave efficiently and predictably, followed by a full sample for selecting a random element from a sequence.</font></p>
<p><a name="bookmark356"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3543"></a><a name="bookmark3544"></a>12.6.1 Design and implementation guidelines</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Most of these may seem fairly obvious, but this section can form a useful checklist when you write an operator.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">UNIT TESTS</font></p>
<p><a name="bookmark3545"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3546"></a>It’s generally pretty easy to write a good set of unit tests for operators, although you may be surprised at how many you end up with for what originally appears to be simple code. Don’t forget<a name="bookmark3547"></a> to test corner cases such as empty sequences as well as invalid arguments. MoreLINQ has some helper methods in its unit test project that you may wish to use for your own tests.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ARGUMENT CHECKING</font></p>
<p><a name="bookmark3548"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3549"></a>Good methods check their arguments... but there’s a problem when it comes to LINQ operators. <a name="bookmark3550"></a>Many operators return another sequence, as we’ve already seen—and iterator blocks are the easiest way to implement this functionality. But you should really perform the argument checking as soon as your method is called, rather than waiting until the caller decides to iterate over the results. If you’re going to use an iterator block, split your method into two: perform argument checking in a public method and then call a private method to do the iteration.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">OPTIMIZATION</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IEnumerable&lt;T&gt; itself is fairly weak in terms of the operations it supports, but the execution-time type of a sequence you’re working on may have considerably more</font></p>
<p><a name="bookmark3551"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">functionality. For example, the Count() operator will always work, but it’ll generally be an O(n) operation. If you call it on an implementation of ICollection&lt;T&gt;, though, it can use the Count property directly—which <a name="bookmark3552"></a>will generally be O(1). In .NET 4, this optimization is extended to cover ICollection as well. Likewise retrieving a specific element by index is <a name="bookmark3553"></a>slow in the general case, but can be efficient if the sequence implements IList&lt;T&gt;. If your operator can benefit from these optimizations, you can have different execution paths depending on the execution-time type. To test the slow path in unit tests, you can always call Select (x =&gt; x) on a List&lt;T&gt; to retrieve a nonlist sequence. LinkedList&lt;T&gt; can test the case where you want an ICollection&lt;T&gt; that doesn’t implement IList&lt;T&gt;.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">DOCUMENTATION</font></p>
<p><a name="bookmark3554"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s important to document what your code will do with its inputs, and also the expected performance of the operator. This is particularly important ifyour method needs to work with multiple s<a name="bookmark3555"></a>equences: which will be evaluated first, <a name="bookmark3556"></a>and how far? Does your c<a name="bookmark3557"></a>ode stream its data, buffer it, or a mixture? Does it use deferred or immediate execution? Can any parameters be null, and if so, does that have a special meaning?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ITERATE ONCE WHERE POSSIBLE</font></p>
<p><a name="bookmark3558"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">IEnumerable&lt;T&gt; will let you iterate over it multiple times—you can have multiple iterators active at the same time over the same sequence, potentially. But this is rarely a good idea within an operator. Wherever possible, it’s wise to iterate over your input sequence<a name="bookmark3559"></a>s just once. This will mean your code will work even for nonrepeatable sequences, such as lines read from a network stream. If you do need to read the sequence multiple times (and you don’t want to buffer the whole sequence yourself like Reverse does), you should draw particular attention to this in the documentation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">REMEMBER TO DISpOSE OF ITERATORS</font></p>
<p><a name="bookmark3560"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In most cases, you can use a foreach statement to iterate over your data source. But it’s sometimes useful to treat the first item differently, in which case using an iterator direct<a name="bookmark3561"></a>ly can lead to the simplest code. In that situation, remember to include a using block for the iterator. We’re not used to disposing of iterators ourselves because normally foreach does it for us, which can make it hard to spot the bug.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CUSTOM COMpARISONS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Many LINQ operators have overloads<a name="bookmark3562"></a> that allow you to specify an appropriate IEqualityComparer&lt;T&gt; or IComparer&lt;T&gt;. If you’re building a general-purpose library for others (potentially dev<a name="bookmark3563"></a>elopers who you aren’t in contact with), it may be worth providing similar overloads yourself. On the other hand, if you’re the sole user, or it’s just going to be members of your team, you can do this on a need-to-implement basis. It’s easy though: typically the si<a name="bookmark3564"></a>mpler overloads just call a<a name="bookmark3565"></a> more complex one, passing EqualityComparer&lt;T&gt;.Default or Comparer&lt;T&gt;.Default as the comparison.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that I’ve talked the talk, let’s check whether I can actually walk the walk.</font></p>
<p><a name="bookmark3566"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The idea of our extension method is simple: given a sequence and an instance of Random, return a random element from the sequence. You could add an overload that didn’t require the instance of Random, but I pre<a name="bookmark3567"></a>fer to make the dependency on a random number generator explicit. Randomness is a tricky topic for various reasons; rather than discuss it here, I’ve included an article on the book’s website (see <a href="http://mng.bz/h483">http://</a> <a href="http://mng.bz/h483">mng.bz/h483</a>). Also for reasons of space, I haven’t included the XML documentation or unit tests in listing 12.17, but of course they’re in the downloadable code.</font></p>
<p><a name="bookmark3568"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.17 Extension method to choose a random element from a sequence</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static T RandomElement&lt;T&gt;(this IEnumerable&lt;T&gt; source,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Random random)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (source == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new ArgumentNullException(&quot;source&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (random == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new ArgumentNullException(&quot;random&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ICollection collection = source as ICollection; if (collection != null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int count = collection.Count; if (count == 0)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new InvalidOperationException(&quot;Sequence was empty.&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int index = random.Next(count); return source.ElementAt(index);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">using (IEnumerator&lt;T&gt; iterator = source.GetEnumerator())</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (!iterator.MoveNext())</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new InvalidOperationException(&quot;Sequence was empty.&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int countSoFar = 1;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T current = iterator.Current; while (iterator.MoveNext())</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">countSoFar++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (random.Next(countSoFar) == 0)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">current = iterator.Current;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return current;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 12.17 doesn’t show the technique of splitting an extension method into argument validation and then implementation, because it doesn’t use an iterator block. Look back at our implementation of the Where operator in section 10.3.7 for an example of this. No custom comparisons are required either—but apart from that, every item on our checklist is appropriate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First we validate our arguments in the obvious way O. In chapter 15 we’ll learn an alternative way of expressing preconditions using Code Contracts, but for now I’ve kept with normal exceptions. Things get more interesting at Q—we handle the case where the so<a name="bookmark3569"></a>urce sequence implements ICollection.</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup><a name="footnote84"></a><a href="#bookmark3570">84</a></font><font style="font-size:small;font-family:Times New Roman, serif;"></sup> This allows us to take the count cheaply, and then generate just a single random number to work out which element to pick. We don’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">explicitly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> handle the case where the source sequence implements IList&lt;T&gt;—instead, we rely on ElementAt to do that for us (as it’s documented to do).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If we’re dealing with a noncollection sequence (such as the result of another query operator), we want to avoid taking the count and then picking an element: that would require us to either buffer the contents of the sequence or iterate over it twice. Instead we step through it once, explicitly fetching the iterator G so that we can test for an empty sequence easily. The clever bit</font><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup><a name="footnote85"></a><a href="#bookmark3571">85</a></font><font style="font-size:small;font-family:Times New Roman, serif;"></sup> is at Q—we replace our current idea of a random element with the element from the iterator with a probability of 1/ n, where </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">n</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is the number of elements we’ve seen so far. So there’s a 1/2 chance of replacing the first element with the second, a 1/3 chance of replacing the result after two elements with the third element, and so on. The final result is that each element in the sequence has an equal chance of being picked, and we’ve managed to iterate just once.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course the important point isn’t what this particular method does—it’s the potential issues we had to think about as we implemented it. Once you know what to look for, it really doesn’t take much effort to implement a robust method like this, and your personal toolbox will grow over time.</font></p>
<p><a name="bookmark359"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3572"></a>12.7 Summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Phew! This chapter has been the exact opposite of most of the rest of the book. Instead of focusing on a single topic in great detail, we’ve covered a range of LINQ technologies, but at a shallow level.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I wouldn’t expect you to feel particularly familiar with any one of the specific technologies we’ve looked at here, but I hope you have a deeper understanding of why LINQ is important. It’s not about XML, or in-memory queries, SQL queries, observables, or enumerators—it’s about consistency of expression, and giving the C# compiler the opportunity to validate your queries to at least some extent, regardless of their final execution platform.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You should now appreciate why expression trees are so important that they’re among the few </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">framework</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> elements that the C# compiler has direct intimate knowledge of (along with strings, IDisposable, IEnumerable&lt;T&gt;, and Nullable&lt;T&gt;, for example). They’re passports for behavior, allowing it to cross the border of the local machine, expressing logic in whatever foreign tongue is catered for by a LINQ provider.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s notjust expression trees—we’ve also relied on the query expression translation employed by the compiler, and the way that lambda expressions can be converted to both delegates and expression trees. Extension methods are also important, as without them each provider would have to give implementations of all the relevant methods. If you look back at all the new features of C#, you’ll find few that don’t contribute significantly to LINQ in some way or other. That’s part of the reason for this chapter’s existence: to show the connections between all the features.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I shouldn’t wax lyrical for too long, though—as well as the upsides of LINQ, we’ve seen a few gotchas. LINQ won’t always allow us to express everything we need in a query, nor does it hide </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the details of the underlying data source. When it comes to database LINQ providers, the impedance mismatches that have caused developers so much trouble in the past are still with us: we can reduce their impact with ORM systems and the like, but without a proper understanding of the query being executed on your behalf, you’re likely to run into significant issues. In particular, don’t think of LINQ as a way of removing your need to understand SQL—just think of it as a way of hiding the SQL when you’re not interested in the details. Likewise, in order to plan an effective parallel query, you’ve got to know where ordering matters and where it doesn’t, and perhaps help the framework along a bit by giving it more tuning information.</font></p>
<p><a name="bookmark3573"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Since .NET 3.5 came out, I’ve been delighted to see how wholeheartedly the community has embraced it. In that case I have the benefit of hindsight. I have little idea of how developers will take to the features of C# 4... but let’s dive into them in the final part of the book.</font></p>
<p><a name="bookmark3574"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Part 4</font></p>
<p><a name="bookmark3575"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">C# 4: playing nicely with others</font></p>
<p><a name="bookmark18"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"><sub>C</sub></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">.A#</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> 4 is a funny beast. It doesn’t have the “several, almost unrelated, major new features” feeling of C# 2, nor the “all in the cause of LINQ” feeling of C# 3. Instead, the new features of C# 4 fall somewhere between the two. Interoperability is a major theme, but equally many of the features are useful even if you never need to work with other environments.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">My personal favorite features from C# 4 are optional parameters and named arguments. They’re relatively simple, but can be put to good use in many places, improving the readability of code and generally making life more pleasant. Do you waste time working out which argument means what? Put some names on them. Are you tired of writing endless overloads to avoid callers having to specify everything? Make some parameters optional.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you work with COM, C# 4 will be a breath of fresh air for you. To start with, the features I just described make some APIs much simpler to work with, where the component designers have pretty much assumed that you’ll be working with a language supporting optional parameters and named arguments. Beyond that there’s a better deployment story, support for named indexers, and a helpful shortcut to avoid having to pass arguments by reference everywhere. The biggest feature of C# 4—dynamic typing—also makes COM integration easier.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll look at all of these areas in chapter 13, along with the brain-busting topic of generic variance applied to interfaces and delegates. Don’t worry: we’ll take that reasonably slowly, and the best part is that most of the time you don’t need to know the details... itjust makes code work where you might’ve expected it to in C# 3 anyway!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 14 covers dynamic typing and the Dynamic Language Runtime (DLR). This is an enormous topic; I’ve concentrated on how the C# language implements dynamic typing, but we’ll also look at a few examples of interoperating with dynamic languages such as IronPython, and provide examples of how a type can dynamically respond to method calls, property accesses, and so on. It’s worth applying a little perspective here: the fact that this is a major feature doesn’t mean that you should expect to see dynamic expressions cropping up all over your codebase. This won’t be as pervasive as LINQ, for example—but when you do want dynamic typing, you’ll find it well-implemented in C# 4.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Chapter 15 takes us in a slightly different direction; Code Contracts aren’t implemented as a language feature of C# 4, but they still change how idiomatic C# 4 may be written. The core types used by Code Contracts are part of .NET 4, but they do little by themselves: the supporting tools really make the contracts come alive. Applying contracts to your code—in terms of preconditions, postconditions, assertions, and invariants—allows you to express elements of behavior that previously would’ve been left to documentation. How far you take Code Contracts is up to you, but it’s one of the most exciting and potentially cross-cutting pieces of technology in .NET 4.</font></p>
<p><a name="bookmark3576"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Minor changes to simplify code</font></p>
<p><a name="bookmark19"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3577"></a>This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Optional parameters</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Named arguments</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Streamlining ref parameters in COM</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Embedding COM primary interop assemblies</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Calling named indexers declared in COM</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Generic variance for interfaces and delegates</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Changes in locking and field-like events</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just as in previous versions, C# 4 has a few minor features that don’t merit individual chapters to themselves. In fact, there’s only one really </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">big</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> feature in C# 4— dynamic typing—which we’ll cover in the next chapter. The changes we’ll cover here just make C# that little bit more pleasant to work with, particularly if you work with COM on a regular basis. These features generally make code clearer, remove drudgery from COM calls, or simplify deployment.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Will any of those make your heart race with excitement? It’s unlikely. They’re nice features all the same, and some of them may be widely applicable. Let’s start by looking at how we call methods.</font></p>
<p><a name="bookmark363"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3578"></a>13.1 &nbsp;&nbsp;&nbsp;Optional parameters and named arguments</font></p>
<p><a name="bookmark3579"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3580"></a><a name="bookmark3581"></a>These are perhaps the Batman and Robin<sup><a name="footnote86"></a><a href="#bookmark3582">86</a></sup> features of C# 4. They’re distinct, but usually seen together. I’m going to keep them apart for the moment so we can examine each in turn, but then we’ll use them together for some more interesting examples.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">PARAMETERS AND ARGUMENTS This section obviously talks about parameters and arguments a lot. In casual conversation, the two terms are often used interchangeably, but I’m going to use them in line with their formal<a name="bookmark3583"></a> definitions. Just to remind you, a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">parameter</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (also known as a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">formal parameter</font><font style="font-size:x-small;font-family:Times New Roman, serif;">) is the variable that’s part of the method or indexer declaration. An </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">argument</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is an expression used when calling the method or indexer. So, for example, consider this snippet: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Foo(int x, int y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Do something with x and y</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int a = 10;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(a, 20);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here the parameters are x and y, and the arguments are a and 2 0.</font></p>
<p><a name="bookmark3584"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll start by looking at optional parameters.</font></p>
<p><a name="bookmark364"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3585"></a><a name="bookmark3586"></a>13.1.1 &nbsp;&nbsp;&nbsp;Optional parameters</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Visual Basic has had optional parameters for ages, and they’ve been in the CLR from .NET 1.0. The concept is as obvious as it sounds: some parameters are optional, so their values don’t have to be explicitly specified by the caller. Any pa<a name="bookmark3587"></a>rameter that hasn’t been specified as an argument by the caller is given a default value.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">MOTIVATION</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Optional parameters are usually used when there are several values required for an operation, where the<a name="bookmark3588"></a> same values are used a lot of the time. For example, suppose you wanted to read a text file; you might want to pr<a name="bookmark3589"></a>ovide a method that allows the caller to specif<a name="bookmark3590"></a>y the name of the file and the encoding to use. The encoding is almost always UTF-8, though, so it’s nice to be able to use that automatically if it’s all you need.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">His<a name="bookmark3591"></a>torically the idiomatic way of allowing this in C# has been to use method overloading: declare one method with all the possible parameters, and others that call that method, passing in default values where appropriate. For instance, you might create methods like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IList&lt;Customer&gt; LoadCustomers(string filename,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Encoding encoding)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.. &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">&lt;— Do real work here</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public IList&lt;Customer&gt; LoadCustomers(string filename)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return LoadCustomers(filename, Encoding.UTF8); &lt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">- Default to UTF-8</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark3592"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This works fine for a single parameter, but it becomes trickier when there are multiple options. Each extra option doubles the number of possible overloads, and if two of them are of the same type, you can have problems due to trying to declare multiple methods with the same signature. Often the same set of overlo<a name="bookmark3593"></a>ads is also required for multiple parameter types. For example, the XmlReader.Create () method can create an XmlReader from a Stream, a TextRea<a name="bookmark3594"></a>der, or a string—but it also provides the option of specifying an XmlReaderSettings and other arguments. Due to this duplication, there are 12 overloads for the method. This could be significantly reduced with optional parameters. Let’s see how it’s done.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">DECLARING OPTIONAL PARAMETERS AND OMITTING THEM WHEN SUPPLYING AR<a name="bookmark3595"></a>GUMENTS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Making a parameter optional is as simple as supplying a default value for it, using what looks like a variable initializer. Figure 13.1 shows a method with thr<a name="bookmark3596"></a>ee parameters: two are optional, one is required.</font></p><div><img src="images/51.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 13.1 Declaring optional parameters</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All the method does is print out the arguments, but that’s enough to see what's going on. The following listing gives the full code and calls the method three times, specifying a different number of arguments for each call.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.1 Declaring a method with optional parameters and calling</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Dump(int x, int y = 20, int z = 30)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;x={0} y={1} z={2}&quot;, x, y, z);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dump(1, 2, 3);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dump(1, 2);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dump(1);</font></p>
<p><a name="bookmark3597"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">optional parameters</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> are the ones with default values specified O. If the caller doesn’t specify y, its initial value will be 20, and likewise z has a default value of 30. The first call </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">C</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> explicitly specifies all the arguments; the remaining calls (© and E) omit one or two arguments respectively, so the default values are used. When there’s one argument missing, the compiler assumes that the final parameter has been omit-ted—then the penultimate one, and so on. The output is therefore</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x=1 y=2 z=3 x=1 y=2 z=30 x=1 y=20 z=30</font></p>
<p><a name="bookmark3598"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Note that although the compiler </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use some clever analysis of the types of the optional parameters and the arguments to work out what’s been left out, it doesn’t: it</font></p>
<p><a name="bookmark3599"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">assumes that you’re supplying arguments in the same order as the parameters.<sup>2</sup> This means that the following code is invalid:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void TwoOptionalParameters(int x = 10,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string y = &quot;default&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;x={0} y={1}&quot;, x, y);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TwoOptionalParameters(&quot;second parameter&quot;); &nbsp;&nbsp;&nbsp;&lt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">- Error!</font></p>
<p><a name="bookmark3600"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This tries to call the TwoOptionalParameters method specifying a string for the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">first </font><font style="font-size:x-small;font-family:Times New Roman, serif;">argument. There’s no overload with a first parameter that’s convertible from <a name="bookmark3601"></a>a string, so the compiler issues an error. This is a good thing—overload resolution is tricky enough (particularly when generic type inference gets involved) without the compiler trying all kinds of different permutations to find something you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">might</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be trying to call. If you want to omit the value for one optional parameter but specify a later one, you need to use named arguments.</font></p>
<p><a name="bookmark3602"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">RESTRICTIONS ON OPTIONAL PARAMETERS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are a few rules fo<a name="bookmark3603"></a>r optional parameters. All optional para<a name="bookmark3604"></a>meters must come after requi<a name="bookmark3605"></a>red parameters. The exception to this is a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">parameter array</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (as declared with the params modifier), which still has to come at the end of a parameter list, but can come after optional parameters. A parameter array can’t be declared as an optional parameter—if the caller doesn’t specify an<a name="bookmark3606"></a>y values <a name="bookmark3607"></a>for it, an empty array will be used instead. Optional parameters can’t have ref or out modifiers either.</font></p>
<p><a name="bookmark3608"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3609"></a>A<a name="bookmark3610"></a>n optiona<a name="bookmark3611"></a>l parameter can be of any typ<a name="bookmark3612"></a>e, but there are restrictions <a name="bookmark3613"></a>on the<a name="bookmark3614"></a> default value specified. You can always use constants: numeric and string literals, null, cons<a name="bookmark3615"></a>t members, enum members, and the default(T) operator. Additionally, for value types, you can<a name="bookmark3616"></a> call the parameterless constructor, although this is equivale<a name="bookmark3617"></a>nt to using the default (...) operator anyway. There has to be an implicit conversion from the specified value to the parameter type, but this must </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be a user-defined conversion. Table 13.1 shows some examples of valid parameter lists.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table 13.1 Valid method parameter lists using optional parameters</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Declaration</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Notes</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(int x, int y = 10)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(decimal x = 10)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(string name = &quot;default&quot;) Foo(DateTime dt = new DateTime()) Foo(DateTime dt = default(DateTime))</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Numeric literal used for default value</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Implicit built-in conversion from </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">decimal</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">String literal used for default value Zero value of </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Alternative syntax for the zero value</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup>2</sup> Unless you’re using named arguments, of course—we’ll learn about those soon.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table 13.1 Valid method parameter lists using optional parameters </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">(continued)</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Declaration</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Notes</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo&lt;T&gt;(T value = default(T))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(int? x = null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(int x, int y = 10, params int[] z)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Default value operator works with type parameters</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Nullable conversion</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Parameter array after optional parameters</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">By contrast, table 13.2 shows some invalid parameter lists and explains why they’re not allowed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table 13.2 Invalid method parameter lists using optional parameters</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Declaration (invalid)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Notes</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(int x = 0, int y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(DateTime dt = DateTime.Now) Foo(XName name = &quot;default&quot;) Foo(params string[] names = null) Foo(ref string name = &quot;default&quot;)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Required non-params parameter can't come after an optional parameter</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Default values must be constants</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Conversion from </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XName </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is user-defined</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Parameter arrays can't be optional</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ref</font><font style="font-size:x-small;font-family:Times New Roman, serif;">/</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">out </font><font style="font-size:x-small;font-family:Times New Roman, serif;">parameters can't be optional</font></p></td></tr>
</table>
<p><a name="bookmark3618"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The fact that the default value has to be constant is a pain in two different ways. One of them is familiar from a slightly different context, as we’ll see now.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">VERSIONING AND OpTIONAL pARAMETERS</font></p>
<p><a name="bookmark3619"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3620"></a>The restrictions on default values for optional parameters may remind you of the restrictions on const fields or attribute values, and they behave very similarly. In both cases, when the compiler references the value, it copies it directly into the output. The generated IL acts exactly as if your original source code had contained<a name="bookmark3621"></a> the default value. This means if you ever </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">change</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the default value without recompiling everything that references it, the old callers will still be using the old default value. To make this concrete, imagine this set of steps:</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;">1</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;Create a class library (Library.dll) with a class like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class LibraryDemo {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static void PrintValue(int value = 10)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Console.WriteLine(value);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2 &nbsp;&nbsp;&nbsp;Create a console application (Application.exe) that references the class library:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class Program {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">LibraryDemo.PrintValue();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">3 &nbsp;&nbsp;&nbsp;Run the application—it’ll print 10, predictably.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">4 &nbsp;&nbsp;&nbsp;Change the declaration of PrintValue as follows, then recompile </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">just</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the class library:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static void PrintValue(int value = 20)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">5 &nbsp;&nbsp;&nbsp;Rerun the application—it’ll still print 10. The value has been compiled directly into the executable.</font></p>
<p><a name="bookmark3622"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">6 &nbsp;&nbsp;&nbsp;Recompile the application and rerun it—this time it’ll print 20.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This versioning issue can cause bugs that are hard to track down, because all the code </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">looks</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> correct. Essentially, you’re restricted to using genuine constants that should never change as default values for optional parameters.<sup><a name="footnote87"></a><a href="#bookmark3623">87</a></sup> There’s one benefit of this setup: it gives the caller a guarantee that the value it knew about at compile-time is the one that’ll be used. Developers may feel more comfortable with that than with a dynamically computed value, or one that depends on the version of the library used at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, this also means you can’t use any values that can’t be expressed as constants anyway—you can’t create a method with a default value of “the current time,” for example.</font></p>
<p><a name="bookmark3624"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">MAKING DEFAULTS MORE FLEXIBLE WITH NULLITY</font></p>
<p><a name="bookmark3625"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Fortunately, there’s a way round this. Essentially you introduce a magic value to represent the default, and then replace that magic value with the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">real</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> default within the method itself. If <a name="bookmark3626"></a>the phrase </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">magic value</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> bothers you, I’m not surprised—except we’re going to use null for the magic value, which already represents the absence of a normal value. If the parameter type w<a name="bookmark3627"></a>ould normally be a value type, we simply make it the corresponding nullable value type, at which point we can still specify that the default value is null.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As an example of this, let’s look at a similar situation to the one I used to introduce the whole topic: allowing the caller to supply an appropriate text encoding to a met<a name="bookmark3628"></a>hod, but defaulting to UTF-8. We can’t specify the default encoding as Encoding. UTF8 as that’s not a constant value, but we can treat a null parameter value as “use the default.” To demon<a name="bookmark3629"></a>strate how we can handle value types, we’ll make the method append a timestamp to a text file with a message. We’ll default the encoding to UTF-8 and the timestamp to the current time. Listing 13.2 shows the complete code and a few examples of using it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.2 Using null default values to handle nonconstant situations</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void AppendTimestamp(string filename,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string message,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Encoding encoding = null, DateTime? timestamp = null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Encoding realEncoding = encoding ?? Encoding.UTF8;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime realTimestamp = timestamp ?? DateTime.Now; using (TextWriter writer = new StreamWriter(filename,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">realEncoding)) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">writer.WriteLine(&quot;{0:s}: &nbsp;&nbsp;&nbsp;{1}&quot;, &nbsp;&nbsp;&nbsp;realTimestamp, message);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">AppendTimestamp(&quot;utf8.txt&quot;, &quot;First message&quot;); AppendTimestamp(&quot;ascii.txt&quot;, &quot;ASCII&quot;, Encoding.ASCII); AppendTimestamp(&quot;utf8.txt&quot;, &quot;Message in the future&quot;, null, new DateTime(2030, 1, 1));</font></p>
<p><a name="bookmark3630"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">List<a name="bookmark3631"></a>ing 13.2 shows a few nice features of this approach. First, we’ve solved the versioning problem. The default values for the optional parameters are null O, but the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">effective</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> values are “the UTF-8 encoding” and “the current date and time.” Neither of these could be expressed as constants, and should we ever wish to change the effective default—for example to use the current UTC time instead of the local time—we could do so without having to recompile everything that c<a name="bookmark3632"></a>alled AppendTimestamp. Of course, changing the effective default changes the behavior of the method—you need to take the same sort of care over this as you would with any other code change. At this point, you (as the library author) are in charge of the versioning story—you’re taking responsibility for not breaking clients, effectively. At least it’s more familiar territory: <a name="bookmark3633"></a>you know that all callers will experience the same behav<a name="bookmark3634"></a>ior, regardless of recompilation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve also introduced an extra level of flexibility. Not only do optional parameters mean we can make the calls shorter, but having a specific “use the default” value means that should we ever wish to, we can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">explicitly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> make a call allowing the method to choose the appropriate value. At the moment, this is the only way we know to specify the timestamp explicitly without also providing an encoding ©, but that’ll change when we look at named arguments.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The optional parameter values are simple to deal with thanks to the null coalescing operator Q. I’ve used separate variables for the sake of printed formatting, but in real code you’d probably use the same expressions directly in the calls to the Stream-Writer constructor and the WriteLine method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two downsides to this approach: first, it means that if a caller </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">accidentally </font><font style="font-size:x-small;font-family:Times New Roman, serif;">passes in null due to a bug, it’ll get the default value instead of an exception. In cases where you’re using a nullable value type and callers will either explicitly use null or have a non-nullable argument, that’s not much of a problem—but for reference types it could be an issue.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">On a related note, it requires that you don’t want to use null as a “real” value.<sup><a name="footnote88"></a><a href="#bookmark3635">88</a></sup> There are occasions where you want </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">null</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to mean </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">null</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—and if you don’t want that to be the default value, you’ll have to find a different constant or just leave the parameter as a required one. But in other cases where there isn’t an obvious constant value that’ll clearly </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be the right default, I’d recommend this approach to optional parameters as one that’s easy to follow consistently and removes some of the normal difficulties.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll need to look at how optional parameters affect overload resolution, but it makes sense to wait until we’ve seen how named arguments work. Speaking of which...</font></p>
<p><a name="bookmark365"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3636"></a>13.1.2 Named arguments</font></p>
<p><a name="bookmark3637"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The basic idea of named arguments is that when you specify an argument value, you can also specify the name of the parameter it’s supplying the value for. The compiler then makes sure that there </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a parameter of the right nam<a name="bookmark3638"></a>e, and uses the value for that parameter. Even on its own, this can increase readability in some cases. In reality, named arguments are most useful in cases where optional parameters are also likely to appear, but we’ll look at the simple situation first.</font></p>
<p><a name="bookmark3639"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">INDEXERS, OPTIONAL PARAMETERS, AND NAMED ARGUM<a name="bookmark3640"></a>ENTS You </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">optional parameters and named arguments with indexers as well as methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But this is only useful for indexers with more than one parameter: you can’t access an indexer without specifying at least one argument anyway. Given this limitation, I don’t expect to see the feature used much with indexers, and I haven’t demonstrated it in the book. It works exactly as you’d expect it to, though.</font></p>
<p><a name="bookmark3641"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m sure we’ve all seen code that looks something like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MessageBox.Show(&quot;Please do not press this button again&quot;, // text &quot;Ouch!&quot;); // title</font></p>
<p><a name="bookmark3642"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve actually chosen a pretty tame example; it can get a lot worse when there are loads of arguments, especially if a lot of them are the same type. But this is still realistic: even with just two parameters, I’d find myself guessing which argument meant what based on the text when reading this code, unless it had comments like the ones I have here. There’s a problem though: comments can lie about the co<a name="bookmark3643"></a>de they describe. Nothing is checking them at all. Named arguments ask the compiler to help.</font></p>
<p><a name="bookmark3644"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">SYNTAX</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All we need to do to the previous examp<a name="bookmark3645"></a>le is prefix each argument with the name of the corresponding parameter and a colon:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MessageBox.Show(text: &nbsp;&nbsp;&nbsp;&quot;Please &nbsp;&nbsp;&nbsp;do &nbsp;&nbsp;&nbsp;not press this button again&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">caption: &nbsp;&nbsp;&nbsp;&quot;Ouch!&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Admittedly we now don’t get to choose the name we find most meaningful (I prefer title to caption) but at least we’ll know if we get something wrong. Of course, the most common way in which we could get something wrong here is to get the arguments the wrong way around. Without named arguments, this would be a problem: we’d end up with the pieces of text switched in the message box. With named arguments, the ordering becomes largely irrelevant. We can rewrite the previous code like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MessageBox.Show(caption: &nbsp;&nbsp;&nbsp;&quot;Ouch!&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">text: &nbsp;&nbsp;&nbsp;&quot;Please &nbsp;&nbsp;&nbsp;do &nbsp;&nbsp;&nbsp;not &nbsp;&nbsp;&nbsp;press &nbsp;&nbsp;&nbsp;this button again&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’d still have the right text in the right place, because the compiler would work out what we meant based on the names. For another example, look at the StreamWriter constructor call we used in listing 13.2. The second argument is just true—what does this mean? Is it going to force a stream flush after every write? Include a byte order mark? Append to an existing file instead of creating a new one? Here’s the equivalent call using named arguments:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new StreamWriter(path: filename, append: true, encoding: realEncoding)</font></p>
<p><a name="bookmark3646"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In both<a name="bookmark3647"></a> of the examples, we’ve seen how named arguments effectively attach se<a name="bookmark3648"></a>mantic </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">meaning</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to values. In the never-ending quest to make our code communicate better with humans as well as computers, this is a definite step forward. I’m not suggesting that named arguments should be used when the meaning is already obvious, of course. Like all features, it should be used with discretion and thought.</font></p>
<p><a name="bookmark3649"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3650"></a>NAMED ARGUMENTS<a name="bookmark3651"></a> WITH out AND ref If you want to specify the name of an argument for a ref or out parameter, you put the ref or out modifier after the name, and before the argument. So using int .TryParse as an example, you might have code like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int number;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool success = int.TryParse(&quot;10&quot;, result: out number);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To explore some other aspects of the syntax, the following listing shows a method with three integer parameters, just like the one we used to start looking at optional parameters.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.3 Simple examples of using named arguments</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Dump(int x, int y, int z)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;x={0} y={1} z={2}&quot;, x, y, z);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark3652">Dump(1, &nbsp;&nbsp;&nbsp;2, &nbsp;&nbsp;&nbsp;3);</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dump(x: &nbsp;&nbsp;&nbsp;1, &nbsp;&nbsp;&nbsp;y: &nbsp;&nbsp;&nbsp;2, &nbsp;&nbsp;&nbsp;z: 3);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dump(z: &nbsp;&nbsp;&nbsp;3, &nbsp;&nbsp;&nbsp;y: &nbsp;&nbsp;&nbsp;2, &nbsp;&nbsp;&nbsp;x: 1);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark3653">Dump(1, &nbsp;&nbsp;&nbsp;y: &nbsp;&nbsp;&nbsp;2, &nbsp;&nbsp;&nbsp;z: &nbsp;&nbsp;&nbsp;3);</a></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a href="#bookmark3654">Dump(1, &nbsp;&nbsp;&nbsp;z: &nbsp;&nbsp;&nbsp;3, &nbsp;&nbsp;&nbsp;y: &nbsp;&nbsp;&nbsp;2);</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The output is the same for each call in listing 13.3: &nbsp;&nbsp;&nbsp;</font><font style="font-size:xx-small;font-family:Courier New, monospace;font-weight:bold;"><sub>static void</sub> Dump(int x, int y, int z)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">x=1, y=2, z=3. We’ve effectively made the same method call in five different ways. It’s worth noting that there are no tricks in the method declaration O: you can use named arguments with any method that has parameters. First we call the method in the normal way, without using any new features ©. This is a sort of control point to make sure that the other calls really are equivalent. We then make two calls to the method using just named arguments ©. The second of these calls reverses the order of the arguments, but the result is still the same, because the arguments are matched up with the parameters by name, not position. Finally there are two calls using a mixture of named arguments and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">positional arguments</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> ©. A positional argument is one that isn’t named—so every argument in valid C# 3 code is a positional argument from the point of view of C# 4. Figure 13.2 shows how the final line of code works.</font></p><div><img src="images/52.png"/></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All named arguments have to come after positional arguments—you can’t switch between the styles. Positional arguments </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> refer to the corresponding parameter in the method declaration—you can’t make positional arguments skip a parameter by specifying it later with a named argument. This means that these method calls would both be invalid:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Dump(z: 3, 1, y: 2) —Positional arguments must come before named ones.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Dump(2, x: 1, z: 3)—x has already been specified by the first positional argument, so we can’t specify it again with a named argument.</font></p>
<p><a name="bookmark3655"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3656"></a>Now, although in </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">this particular case</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the method calls have been equivalent, that’s not </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the case. Let’s look at why reordering arguments might change behavior.</font></p>
<p><a name="bookmark3657"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">ARGUMENT EVALUATION ORDER</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re used to C# evaluating its arguments in the order they’re specified—which, until C# 4, has always been the order in which the parameters have been declared too. In C# 4, only the first part is still true: the arguments are still evaluated in the order they’re written, even if that’s not the same as the order in which they’re declared as parameters. This matters if evalua<a name="bookmark3658"></a>ting the arguments has side effects. It’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">usually</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> worth trying to avoid having side effects in arguments, but there are cases where it can make the code clearer. A more realistic rule is to try to avoid side effects that might interfere with each other. For the sake of demonstrating execution order, we’ll break both of these rules. Please don’t treat this as a recommendation that you do the same thing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First we’ll create a relatively harmless example, introducing a method that logs its input and returns it—a sort of logging echo. We’ll use the return values of three calls to this to call the Dump method (which isn’t shown, as it hasn’t changed). Listing 13.4 shows two calls to Dump that result in slightly different output.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.4 Logging argument evaluation</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static int Log(int value)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Log: &nbsp;&nbsp;&nbsp;{0}&quot;, &nbsp;&nbsp;&nbsp;value);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return value;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dump(x: Log(1), y: Log(2), z: Log(3));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dump(z: Log(3), x: Log(1), y: Log(2));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The results of running listing 13.4 show what happens:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Log: 1 Log: 2 Log: 3 x=1 y=2 z=3 Log: 3 Log: 1 Log: 2 x=1 y=2 z=3</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In both cases, the parameters in the Dump method are still 1, 2, and 3, in that order. But we can see that although they were evaluated in that order in the first call (which was equivalent to just using positional arguments), the second call evaluated the value used for the z parameter first. We can make the effect even more significant by using side effects that change the results of the argument evaluation, as shown in the following listing, again using the same Dump method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.5 Abusing argument evaluation order</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int i = 0;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dump(x: ++i, y: ++i, z: + + i); i = 0;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dump(z: ++i, x: ++i, y: + + i);</font></p>
<p><a name="bookmark3659"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3660"></a>The results of listing 13.5 may be best expresse<a name="bookmark3661"></a>d in terms of the blood spatter pattern at a murder scene, after someone maintaining code like this has gone after the original author with an axe. Yes, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">technically speaking</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the last line prints out x=2 y=3 z=1 but I’m sure you see what I’m getting at. Just say “<a name="bookmark3662"></a>no” to code like this. By all means, reorder your arguments for the sake of readability: you may think that laying out a call to MessageBox.Show with the title coming above the text in the code itself reflects the onscreen layout more closely, for example. If you want to rely on a pa<a name="bookmark3663"></a>rticular evaluation order for the arguments, though, introduce some local variables to execute the relevant code in separate statements. The compiler won’t care either way—it’ll follow the rules of the spec—but this r<a name="bookmark3664"></a>educes the risk of a “harmless refactoring” that inadvertently introduces a subtle bug.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To return to cheerier matters, let’s combine the two features (optional parameters and named arguments) and see how much tidier the code can be.</font></p>
<p><a name="bookmark366"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3665"></a>13.1.3 Putting the two together</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The two features work in tandem with no extra effort required on your part. It’s not uncommon to have a bunch of parameters where there are obvious defaults, but where it’s hard to predict which ones a caller will want to specify explicitly. Figure 13.3 shows just about every combination: a required parameter, two optional parameters, a positional</font></p><div><img src="images/53.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 13.3 Mixing named arguments and optional parameters</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">argument, a named argument, and a missing argument for an optional parameter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Going back to an earlier example, in listing 13.2 we wanted to append a timestamp to a file using the default encoding of UTF-8, but with a particular timestamp. Back then we just used null for the encoding argument, but now we can write the same code more simply, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.6 Combining named and optional arguments</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void AppendTimestamp(string filename,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string message,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Encoding encoding = null, DateTime? timestamp = null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">&lt;- Same implementation as before</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p><div>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Named</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">timestamp</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">argument</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">AppendTimestamp(&quot;utf8.txt&quot;, &quot;Message in the future&quot;, </font><font style="font-size:x-small;font-family:Courier New, monospace;font-style:italic;">timestamp:</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"> new DateTime(2030, 1, 1));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this fairly simple situation, the benefit isn’t particularly huge, but in cases where you want to omit three or four arguments but specify the final one, it’s a real blessing.</font></p>
<p><a name="bookmark3666"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen how optional parameters reduce the need for huge long lists of overloads, but one specific pattern where this is worth mentioning is with respect to immutability.</font></p>
<p><a name="bookmark3667"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">IMMUTABILITY AND OBJECT INITIALIZATION</font></p>
<p><a name="bookmark3668"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One aspect of C# 4 that disappoints me somewhat is that it hasn’t done much </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">explicitly </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to m<a name="bookmark3669"></a>ake immutability easier. Immutable types are a core part of functional programming, and C# has been gradu<a name="bookmark3670"></a>ally supporting the functio<a name="bookmark3671"></a>nal style more and more... except<a name="bookmark3672"></a> for immutability. Object and collection initializers make it easy to work with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">mutable</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> types, but imm<a name="bookmark3673"></a>utable types have been left out in the cold. (Automatically implemented properties fall into this category too.) Fortunately, though they’re not particularly designed to aid immutability, named arguments and optional parameters allow you to<a name="bookmark3674"></a> write object initializer-like code that just calls a constructor or other factory method. For instance, suppose we were creating a Message class, which required a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">from</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> address, a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">to</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> address, and a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">body</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, with the subject and attachment being optional.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">(We’ll stick with single recipients in order to keep the example as sim<a name="bookmark3675"></a>ple as possible.) We </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> create a mutable type with appropriate writable properties, and construct instances like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Message message = new Message {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">From = &quot;<a href="mailto:skeet@pobox.com">skeet@pobox.com</a>&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">To = &quot;<a href="mailto:csharp-in-depth-readers@everywhere.com">csharp-in-depth-readers@everywhere.com</a>&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Body = &quot;Hope you like the second edition&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Subject = &quot;A quick message&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That has two problems: first, it doesn’t enforce the required data to be provided. We could force those to be supplied to the constructor, but then (before C# 4) it wouldn’t be obvious which argument meant what:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Message message = new Message(</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;<a href="mailto:skeet@pobox.com">skeet@pobox.com</a>&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;<a href="mailto:csharp-in-depth-readers@everywhere.com">csharp-in-depth-readers@everywhere.com</a>&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Hope you like the second edition&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Subject = &quot;A quick message&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The second problem is that this initialization pattern simply doesn’t work for immutable types. The compiler has to call a property setter </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">after</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> it has initialized the object. But we can use optional parameters and named arguments to come up with something that has the nice fea<a name="bookmark3676"></a>tures of the first form (only s<a name="bookmark3677"></a>pecifying what you’re interested in and supplying names) without losing the validation of which aspects of the message are required or the benefits of immutability. The following listing shows a possible constructor signature and the construction step for the same message as before.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.7 Constructing an immutable message using C# 4</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public Message(string from, string to,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string body, string subject = null, byte[] attachment = null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">&lt;- Normal initialization code goes here</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Message message = new Message( from: &nbsp;&nbsp;&nbsp;&quot;<a href="mailto:skeet@pobox.com">skeet@pobox.com</a>&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">to: &nbsp;&nbsp;&nbsp;&quot;<a href="mailto:csharp-in-depth-readers@everywhere.com">csharp-in-depth-readers@everywhere.com</a>&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">body: &nbsp;&nbsp;&nbsp;&quot;Hope &nbsp;&nbsp;&nbsp;you &nbsp;&nbsp;&nbsp;like &nbsp;&nbsp;&nbsp;the &nbsp;&nbsp;&nbsp;second &nbsp;&nbsp;&nbsp;edition&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">subject: &nbsp;&nbsp;&nbsp;&quot;A &nbsp;&nbsp;&nbsp;quick &nbsp;&nbsp;&nbsp;message&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I really like this in terms of readability and general cleanliness. You don’t need hundreds of constructor overloads to choose from, just one with some of the parameters being optional. The same syntax will also work with static creation methods, unlike object initializers. The only downside is that it really relies on your code being consumed by a language that supports optional parameters and named arguments;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">otherwise callers will be forced to write ugly code to specify values for all the optional parameters. Obviously there’s more to immutability than getting values to the initialization code, but this is a welcome step in the right direction nonetheless.</font></p>
<p><a name="bookmark3678"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are a couple of final points to make around these features before we move on to COM, both around the details of how the compiler handles our code and the difficulty of good API design.</font></p>
<p><a name="bookmark3679"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">OVERLOAD RESOLUTION</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Clearly both named arguments and optional parameters affect how the compiler resolves overloads—if there are multiple method signatures available with the same name, which<a name="bookmark3680"></a> should it pick? Optional parameters can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">increase</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the number of applicable methods (if some methods have more parameters than the number of specified arguments) and named arguments can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">decrease</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the number of applicable methods (by ruling out methods that don’t have the appropriate parameter names).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For the most part, the changes are intuitive: to check whether any particular method is applicable, the compiler tries to build a list of the arguments it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">would</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> pass in, using the positional &nbsp;&nbsp;&nbsp;arguments in order, &nbsp;&nbsp;&nbsp;then &nbsp;&nbsp;&nbsp;matching &nbsp;&nbsp;&nbsp;the &nbsp;&nbsp;&nbsp;named arguments up</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">with the remaining parameters. If a required parameter &nbsp;&nbsp;&nbsp;hasn’t &nbsp;&nbsp;&nbsp;been specified &nbsp;&nbsp;&nbsp;or if a</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">named argument doesn’t match any remaining parameters, the method isn’t applicable. The specification gives more detail around this in section 7.5.3, but there are two situations I’d like to draw particular attention to.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First, if two methods are both applicable and one of them has been given </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of its arguments explicitly whereas the other uses an optional parameter filled in with a default value, the method that doesn’t use any default values will win. But this </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">doesn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;">extend to just comparing the number of default values used—it’s a strict “does it use default values or not” divide. For example, consider the following:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Foo(int x &nbsp;&nbsp;&nbsp;= 10) &nbsp;&nbsp;&nbsp;{}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Foo(int x &nbsp;&nbsp;&nbsp;= 10, int &nbsp;&nbsp;&nbsp;y = 20) &nbsp;&nbsp;&nbsp;{}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(1);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(y: 2);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Foo(1, 2);</font></p>
<p><a name="bookmark3681"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In the first call </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, both methods are applicable because of their optional parameters. But the compiler can’t work out which one you meant to call: it’ll raise an error. In the second call </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, both methods are still applicable, but the first overload is used because it can be applied without using any default values, whereas the second overload uses the default value for y. For both the third and fourth calls, only the second overload is applicable. The third call </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">names the y argument, and the fourth call </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">has two arguments; both of these mean the first overload isn’t applicable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">OVERLOADS AND INHERITANCE DON’T ALWAYS MIX NICELY All of this is assuming that the compiler has gone as far as finding multiple overloads to choose between. If some methods are declared in a base type, but there are applicable methods in a more derived type, the latter will win. This has always been the <a name="bookmark3682"></a>case, and it can cause some surprising results (see <a href="http://mng.bz/aEmE">http://mng.bz/aEmE</a>)... but now optional parameters mean there may be more applicable methods than you’d expect.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I advise you to avoid overloading a base class method within a derived class unless you get a huge benefit.</font></p>
<p><a name="bookmark3683"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3684"></a>The second point is that sometimes named arguments can be an alternative to casting in order to help the compiler resolve o<a name="bookmark3685"></a>verloads. Sometimes a call can be ambiguous because the arguments can be converted to the parameter types in two different methods, but neither method is better than the other in all respects. For instance, consider the following method signatures and a call:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Method(int x, &nbsp;&nbsp;&nbsp;object &nbsp;&nbsp;&nbsp;y) &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Method(object &nbsp;&nbsp;&nbsp;a, int &nbsp;&nbsp;&nbsp;b) &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;}</font></p>
<p><a name="bookmark3686"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Method(10, 10); &nbsp;&nbsp;&nbsp;&lt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">- Ambiguous call</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Both methods are applicable, and neither is better than the other. There are two ways to resolve this, assuming you can’t change the method names to make them unambiguous that way. (That’s my preferred approach.<a name="bookmark3687"></a> Make each method name more informat<a name="bookmark3688"></a>ive and specific, and the general readability of the code c<a name="bookmark3689"></a>an go up.) You can either cast one of the arguments explicitly, or use named arguments to resolve the ambiguity:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Method(int x, &nbsp;&nbsp;&nbsp;object &nbsp;&nbsp;&nbsp;y) &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Method(object &nbsp;&nbsp;&nbsp;a, int &nbsp;&nbsp;&nbsp;b) &nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Method(10, (object) 10); Method(x: 10, y: 10);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course this only works if the parameters have different names in the different methods—but it’s a handy trick to know. Sometimes the cast will give more readable code; sometimes the name will. It’s just an extra weapon in the fight for clear code. It does have a downside, along with named arguments in general: it’s another thing to be careful about when you change a method.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">THE SILENT HORROR OF CH<a name="bookmark3690"></a>ANGING NAMES</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In the past, parameter names haven’t mattered much if you’ve only been usin<a name="bookmark3691"></a>g C#. Other languages may have cared, but in C# the only ti<a name="bookmark3692"></a>mes that parameter names were important were when you were looking at IntelliSense and when you were looking at the method code itself. Now, the parameter names of a method are effectively part of the A<a name="bookmark3693"></a>PI even if you’re only using C#. If you change them at a later date, code can break—anything that was using a named argument to refer to one of your parameters will fail to compile if you decide to change it. This may not be much of <a name="bookmark3694"></a>an issue if your code is only consumed by itself anyway, but if you’re writing a public API, be aware that changing a parameter name is a big deal. It always has been really, but if everything calling the code was written in C#, we’ve been able to ignore that until now.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Renaming parameters is bad; switching the names around is worse. That way the calling code may still compile, but with a different meaning. A particularly evil form of</font></p>
<p><a name="bookmark3695"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">this is to override a method and switch the parameter names in the overridden version. The co<a name="bookmark3696"></a>mpiler will always look at the deepest override it knows about, based on the static type of the expression used as the target of the method call. You don’t want to get into a situation where calling the same method implementation with the same argument list results in different behavior based on the static type of a variable.</font></p>
<p><a name="bookmark3697"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">SUMMARY</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Named arguments and optional parameters are possibly two of the simplest-sounding features of C# 4—and yet they still have a fair amount of complexity, as we’ve seen. The basic ideas are easily expressed and understood—and the good news is that most of the time that’s all you need to care about. You can take advantage of optional parameters to reduce the numb<a name="bookmark3698"></a>er of overloads you write, and named arguments can make code much more readable when several easily confusable arguments are used.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The trickiest bit is probably deciding which default values to use, bearing in mind potential versioning issues. Likewise it’s now more obvious than before that parameter names matter, and you need to be careful when overriding existing methods, to avoid being evil to your callers.</font></p>
<p><a name="bookmark3699"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Speaking of evil, let’s move on to the new features relating to COM. I’m only kidding... mostly, anyway.</font></p>
<p><a name="bookmark368"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3700"></a><a name="bookmark3701"></a>13.2 &nbsp;&nbsp;&nbsp;Improvements for COM interoperability</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I readily admit to being far from a COM expert. When I tried to use it before .NET came along, I always ran into issues that were no doubt partially caused by my lack of knowledge and partially caused by the components I was working with being po<a name="bookmark3702"></a>orly designed or implemented. The overall impression of COM as a sort of black magic has lingered, though. I’ve been reliably informed that there’s a lot to like about it, but unfortunately I haven’t found myself going back to learn it in detail—and there seems to be a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">lot</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of detail to study.</font></p>
<p><a name="bookmark3703"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3704"></a>THIS SECTION IS MICROSOFT-SPECIFIC The changes for COM interoperability won’t ma<a name="bookmark3705"></a>ke sense for all C# compilers, and a compiler can still be deemed compliant with the specification without implementing these features.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">.NET has made COM somewhat friendlier in ge<a name="bookmark3706"></a>neral, but until now there have been distinct advantages to using it from Visual Basic instead of C#. The playing field has been leveled significantly <a name="bookmark3707"></a>by C# 4, as we’ll see in this section. For the sake of familiarity, I’m going to use Word f<a name="bookmark3708"></a>or the example in this chapter, and Excel in the next chapter. There’s nothing Office-specific about the new &nbsp;&nbsp;&nbsp;features, though; you should &nbsp;&nbsp;&nbsp;find</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">the experience of working with COM to be nicer in &nbsp;&nbsp;&nbsp;C# 4 whatever you’re doing.</font></p>
<p><a name="bookmark369"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3709"></a>13.2.1 &nbsp;&nbsp;&nbsp;The horrors of automating Word before C# 4</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our example is going to be simple—it’s just going &nbsp;&nbsp;&nbsp;to start Word, create a document</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">with a single paragraph of text, save it, and then exit. Sounds easy, right? If only that were so. Listing 13.8 shows the code required before C# 4.</font></p>
<p><a name="bookmark3710"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.8 Creating and saving a document in C# 3</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object missing = Type.Missing ;</font></p>
<p><a name="bookmark3711"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Application app = new Application { Visible = true }; app.Documents.Add(ref missing, ref missing, ref missing, ref missing);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Document doc = app.ActiveDocument;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Paragraph para = doc.Paragraphs.Add(ref missing); para.Range.Text = &quot;Thank goodness for C# 4&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object filename = &quot;demo.doc&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object format = WdSaveFormat.wdFormatDocument97; doc.SaveAs(ref filename, ref format,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ref missing, &nbsp;&nbsp;&nbsp;ref &nbsp;&nbsp;&nbsp;missing, &nbsp;&nbsp;&nbsp;ref &nbsp;&nbsp;&nbsp;missing,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ref missing, &nbsp;&nbsp;&nbsp;ref &nbsp;&nbsp;&nbsp;missing, &nbsp;&nbsp;&nbsp;ref &nbsp;&nbsp;&nbsp;missing,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ref missing, &nbsp;&nbsp;&nbsp;ref &nbsp;&nbsp;&nbsp;missing, &nbsp;&nbsp;&nbsp;ref &nbsp;&nbsp;&nbsp;missing,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ref missing, &nbsp;&nbsp;&nbsp;ref &nbsp;&nbsp;&nbsp;missing, &nbsp;&nbsp;&nbsp;ref &nbsp;&nbsp;&nbsp;missing,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ref missing, &nbsp;&nbsp;&nbsp;ref &nbsp;&nbsp;&nbsp;missing);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">doc.Close(ref missing, ref missing, ref missing); app.Application.Quit(ref missing, ref missing, ref missing);</font></p>
<p><a name="bookmark3712"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Each step in this code sounds simple: first we create an instance of the COM type O and make it visible using an object initializer expression; then we create and fill in a new document ©. The mechanism for inserting some text into a document isn’t quite as straightforward as we might expect, but it’s worth remembering that a Word document can have a fairly complex structure: this isn’t as bad as it might be. A couple of the method calls here have optional by-reference parameters; we’re not interested in them, so we pass a local variable by reference with a value of Type.Missing. If you’ve ever done any COM work before, you’re probably very familiar with this pattern.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Next comes the really nasty bit: saving the document ©. Yes, the SaveAs method really does have 16 parameters, of which we’re only using<a name="bookmark3713"></a> 2. Even those 2 need to be passe<a name="bookmark3714"></a>d by reference, which means creating local variables for them. In terms of readability, this is a complete nightmare. Don’t worry—we’ll soon sort it out.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Finally we close the document and the application E. Aside from the fact that both calls have three optional parameters that we don’t care about, there’s nothing interesting here.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s start off by using the features we’ve already seen in this chapter—they can cut the example down significantly on their own.</font></p>
<p><a name="bookmark370"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3715"></a>13.2.2 The revenge of optional parameters and named arguments</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First things first: let’s get rid of all those arguments corresponding to optional parameters we’re not interested in. That also means we don’t need the missing variable. That still leaves us with 2 parameters out of a possible 16 for the SaveAs method. At the moment it’s obvious which is which based on the local variable names—but what if we have them the wrong way around? All the parameters are weakly typed, so we’re really going on guesswork. We can easily give the arguments names to clarify the call.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If we wanted to use one of the later parameters we’d have to specify the name anyway, just to skip the ones we’re not interested in.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The following listing shows the code—it looks a lot cleaner already.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.9 Automating Word using normal C# 4 features</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Application app = new Application { Visible = true }; app.Documents.Add();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Document doc = app.ActiveDocument;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Paragraph para = doc.Paragraphs.Add(); para.Range.Text = &quot;Thank goodness for C# 4&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object filename = &quot;demo.doc&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object format = WdSaveFormat.wdFormatDocument97; doc.SaveAs(FileName: ref filename, FileFormat: ref format);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">doc.Close();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">app.Application.Quit();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s much better—although it’s still ugly to have to create local variables for the SaveAs arguments we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> specifying. Also, if you’ve been reading carefully, you may be concerned about the optional parameters we’ve removed. They were ref parame-ters—but optional—which isn’t a combination C# supports normally. What’s going on?</font></p>
<p><a name="bookmark371"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3716"></a><a name="bookmark3717"></a>13.2.3 When is a ref parameter not a ref parameter?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# normally takes a pretty strict line on ref parameters. You have to mark the argument with ref as well as the parameter, to show that you understand what’s going on; that your variable may have its value changed by the method you’re calling. That’s all fine in normal code, but COM APIs often use ref parameters for almost </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">everything</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for perceived performance reasons. They usually don’t actually modify the variable you pass in. Passing arguments by reference is slightly painfu<a name="bookmark3718"></a>l in C#. Not only do you have to specify the ref modifier, you also must have a variable. You can’t just pass </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">values</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> by reference.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In C# 4 the compiler makes this a lot easier by letting you pass an argument by value into a COM method, even if it’s for a ref parameter. Consider a call like this, where argument might happen to be a variable of type string, but the parameter is declared as ref object:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">comObject.SomeMethod(argument);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler emits code which is equivalent to this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object tmp = argument; comObject.SomeMethod(ref tmp);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note that any changes made by SomeMethod are discarded, so the call really does behave as if you were passing argument by valu<a name="bookmark3719"></a>e. This same process is used for optional ref parameters: each involves a local variable initialized to Type .Missing and passed by referen<a name="bookmark3720"></a>ce into the COM method. If you decompile the slimlined C# code, you’ll see that the IL emitted is actually pretty bulky with all of those extra variables.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We can now apply the finishing touches to our Word example, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.10 Passing arguments by value in COM methods</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Application app = new Application { Visible = true }; app.Documents.Add();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Document doc = app.ActiveDocument;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Paragraph para = doc.Paragraphs.Add(); para.Range.Text = &quot;Thank goodness for C# 4&quot;; doc.SaveAs(FileName: &quot;test.doc&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FileFormat: WdSaveFormat.wdFormatDocument97); doc.Close(); app.Application.Quit();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see, the final result is much cleaner code than we started with. With an API like Word, you still need to work through a somewhat bewildering set of methods, properties, and events in the core types such as Application and Document, but at least your code will be a lot easier to read.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s one final aspect to the COM support we need to look at in terms of changes to the source code involved, before we see the deployment improvements available.</font></p>
<p><a name="bookmark372"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3721"></a><a name="bookmark3722"></a>13.2.4 Calling named indexers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Several aspects of C# 4 involve providing support for fea<a name="bookmark3723"></a>tures <a name="bookmark3724"></a>that Visual Basic <a name="bookmark3725"></a>has enjoyed for a long time—and this is another <a name="bookmark3726"></a>one. The CLR, COM, and Visual Basic all permit nondefault properties with parameters—</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">named indexers</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in C# terms. Until version 4, C# has not only forbidden you to declare your own named indexers—it hasn’t provided a way of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">accessing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> them using property syntax eith<a name="bookmark3727"></a>er. The only indexer you can use from C# is the one declared as the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">default property</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for the type. This hasn’t been a great issue for .NET components written in Visual Basic, as named indexers are generally discouraged. But COM components such as those for Office use them more heavily. C# 4 allows you to call named indexers in a more natural fashion, but you still can’t declare them for your own C# types.</font></p>
<p><a name="bookmark3728"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">TERMINOLOGY CLASHES AGAIN I’ve used the term </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">indexer</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> throughout this section to <a name="bookmark3729"></a>describe what in VB terms would be known as a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">parameterized property.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The CLI specification calls it an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">indexed property.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Whatever the terminology, it’s declared as a property in the IL, and it has parameters. <a name="bookmark3730"></a>The normal indexer (as far as C# is concerned) is defined by the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">default member</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (or </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">default property) </font><font style="font-size:x-small;font-family:Times New Roman, serif;">for t<a name="bookmark3731"></a>he type—for example, the default member of StringBuilder is the Chars property (which has an Int32 parameter). When I talk about named indexers here, I’m talking about ones that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">aren’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the default for the type, so you have to refer to them by name.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll use Word for the example again, this time showing the different meani<a name="bookmark3732"></a>ngs for words. The _Application type in Word defines an indexer called SynonymInfo with a declaration like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Synonymlnfo SynonymInfo[string Word,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ref object Languageld = Type.Missing]</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s not valid C# syntax, because you can’t declare a named indexer—but hopefully it’s obvious what it means. The name of the indexer is Synonymlnfo. It </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">returns</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a reference to a Synonymlnfo object and has two parameters, one of which is optional. (The fact that the name of the indexer and the name of the return type are the same in this case is entirely coincidental.) The Synonymlnfo can be used to find meanings for the word and synonyms for each meaning. The following listing shows three different ways of using the indexer to display the number of meanings for three different words.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.11 Displaying synonym counts using a named indexer</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void ShowInfo(SynonymInfo info)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0} has {1} meanings&quot;, info.Word, info.MeaningCount);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Application app = new Application { Visible = false }; object missing = Type.Missing;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ShowInfo(app.get_SynonymInfo(&quot;painful&quot;, ref missing)); ShowInfo(app.SynonymInfo[&quot;nice&quot;, WdLanguageID.wdEnglishUS]); ShowInfo(app.SynonymInfo[Word: &nbsp;&nbsp;&nbsp;&quot;features&quot;]);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">app.Application.Quit();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even without named indexers, the previous features we’ve seen would’ve helped alleviate the pain of </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">; we could’ve called app.get_SynonymInfo(&quot;better&quot;) and taken advantage of optional parameters, for example. But <a name="bookmark3733"></a>you can see from </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">C </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">that the indexer syntax looks less awkward than the get_ call. You could argue that this should be a method call anyway, or that there should be a parameterless SynonymInfo property that returns a collection with an appropri<a name="bookmark3734"></a>ate default indexer. That’s one case of the general argu<a name="bookmark3735"></a>ment given by the C# designers for not implementing </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">full</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> support for named indexers, including declaring them within C#. But the point is that it already is an indexer in Word, so it’s nice to be able to use it that way.<sup><a name="footnote89"></a><a href="#bookmark3736">89</a></sup> </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">C </font><font style="font-size:x-small;font-family:Times New Roman, serif;">uses the implicit ref parameter feature from section 13.2.3, and </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">© </font><font style="font-size:x-small;font-family:Times New Roman, serif;">omits the optional parameter and names the remaining argument just for kicks.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s one slight twist to optional parameters and indexers: if </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the parameters are optional, and you don’t want to specify any arguments, you have to omit the square brackets. So instead of writing foo .Indexer[] you’d just use foo .Indexer. All of this applies both for getting from the indexer and setting to it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far, so good—but writing the code is only part of the battle. You usually need to be able to deploy it onto other machines as well. Again, C# 4 makes this task easier.</font></p>
<p><a name="bookmark373"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3737"></a><a name="bookmark3738"></a>13.2.5 Linking primary interop assemblies</font></p>
<p><a name="bookmark3739"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When you build against a COM type, you use an assembly generated for the component library. Usually you use a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">primary interop assembly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> or PIA, which is the canonical interop assembly for a COM libr<a name="bookmark3740"></a>ary, signed b<a name="bookmark3741"></a>y the publisher. You can generate these using the Type Library Importer tool (tlbimp) for your own COM libraries. PIAs make life easier in terms of having one true way of accessing the COM types, but they’re a pain in other ways. They can be quite large, and the whole PIA needs to be present even if you’re<a name="bookmark3742"></a> only using a small subset of the functionality. Also, you need to have the same version of the PIA on the deployment machi<a name="bookmark3743"></a>ne as the one you compiled against. Th<a name="bookmark3744"></a>is can be awkward in situations where licensing issues prevent you from redistributing the PIA itself, relying on the right version being installed already. If there are a number of versions available but they all expose the functionality you need, you might have to ship different versions of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">your</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> code to make the referenc<a name="bookmark3745"></a>es work.</font></p>
<p><a name="bookmark3746"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3747"></a><a name="bookmark3748"></a><a name="bookmark3749"></a><a name="bookmark3750"></a>C# 4 allows a very different approach. Instead of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">referencing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a PIA like any other assembly, you can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">link</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> it. In Visual Studio 2010 this is an option in the properties of the assembly <a name="bookmark3751"></a>refer<a name="bookmark3752"></a>ence, as shown in <a name="bookmark3753"></a>figure 13.4.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Command line fans can use the /l (or /link) option instead of /r (or /reference) to link instead of reference:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">csc /l:Path\To\PIA.dll MyCode.cs</font></p>
<p><a name="bookmark3754"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">When you link a PIA, the compiler embeds just the bits it needs from the PIA directly into your own assembly. It only takes the types it needs, and only the members within those types. For example, the compiler creates these types for the code we’ve written in this chapter:</font></p><img src="images/54.png"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Figure 13.4 Linking PIAs in Visual Studio 2010</font></p>
<p><a name="bookmark3755"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a name="bookmark3756"></a>namespace Microsoft.Office.Interop.Word {</font></p>
<p><a name="bookmark3757"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ComImport, TypeIdentifier, CompilerGenerated, Guid(&quot;...&quot;)] public interface _Application</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ComImport, TypeIdentifier, CompilerGenerated, Guid(&quot;...&quot;)] public interface _Document</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ComImport, CompilerGenerated, TypeIdentifier, Guid(&quot;...&quot;)] public interface Application : _Application</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ComImport, Guid(&quot;...&quot;), TypeIdentifier, CompilerGenerated] public interface Document : _Document</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ComImport, TypeIdentifier, CompilerGenerated, Guid(&quot;...&quot;)] public interface Documents : IEnumerable</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[TypeIdentifier(&quot;...&quot;, &quot;WdSaveFormat&quot;), CompilerGenerated] public enum WdSaveFormat</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">And if you look in the _Application interface, it looks like this:</font></p>
<p><a name="bookmark3758"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ComImport, TypeIdentifier, CompilerGenerated, Guid(&quot;...&quot;)] public interface _Application {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void _VtblGap 1_4();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Documents Documents { &nbsp;&nbsp;&nbsp;[... ] get; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void _VtblGap2_1();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Document ActiveDocument { &nbsp;&nbsp;&nbsp;[...] get; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve omitted the GUIDs and t<a name="bookmark3759"></a>he property attributes here just for the sake of space, but you can always use Reflector to look at the embedded types. These are just int<a name="bookmark3760"></a>erfaces and enums—there’s no implementation. Whereas<a name="bookmark3761"></a> a normal PIA has a CoClass representing the actual implementation (but proxying everything to the real COM type of course), when the compiler needs to create an instance of a COM type via a linked PIA, it creates the instance using the GUID associated with the type. For example, the line in our Word demo that creates an instance of Application is translated into this code when linking is enabled:<sup><a name="footnote90"></a><a href="#bookmark3762">90</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Application application =<a name="bookmark3763"></a> (Application) Activator.CreateInstance( Type.GetTypeFromCLSID (new Guid(&quot;...&quot;)));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 13.5 shows how this works at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are various benefits to embedding type libraries:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Deployment is easier: the original PIA isn’t needed, so you don’t have to rely on the right version being present already or ship the PIA yourself.</font></p>
<p><a name="bookmark3764"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Versioning is simpler: so long as you only use members from the version of the COM library that’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">actually</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> installed, it doesn’t matter if you compile against an earlier o<a name="bookmark3765"></a>r later PIA.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Variants are treated as dynamic types, reducing the amount of casting required.</font></p><img src="images/55.png"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Figure 13.5 Comparing referencing and linking</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Don’t worry about the last point for now—I need to explain dynamic typing before it’ll make much sense. All will be revealed in the next chapter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see, Microsoft has really taken COM interoperability seriously for C# 4, making the whole development process less painful. Of course the degree of pain has always been variable depending on the COM library you’re developing against—some will benefit more than others from the new features.</font></p>
<p><a name="bookmark3766"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3767"></a><a name="bookmark3768"></a><a name="bookmark3769"></a>Our next feature is entirely separate from COM, named arguments, and optional parameters, but again it eases development a bit.</font></p>
<p><a name="bookmark375"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3770"></a>13.3 Generic variance for interfaces and delegates</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may remember that in chapter 3 I mentioned that the CLR had some support for variance in generic types, but that C# hadn’t exposed that support yet. That’s changed with C# 4. C# has gained the syntax required to declare generic variance, and the compiler now knows about the possible conversions for interfaces and delegates.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This isn’t a life-changing feature—it’s more a case of flattening some speed bumps you may have hit occasionally. It doesn’t even remove all the bumps; there are various limitations, mostly in the name of keeping generics absolutely type-safe. But it’s still a nice feature to have up your sleeve.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just in case you need a reminder of what variance is all about, let’s start with a recap of the two basic forms it comes in.</font></p>
<p><a name="bookmark376"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3771"></a>13.3.1 Types of variance: covariance and contravariance</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In essence, variance i<a name="bookmark3772"></a>s about being able to use an object of one type as if it <a name="bookmark3773"></a>were another, in a type-safe way. We’re used to variance in terms of normal inheritance: if a method has a declared return type of Stream, you can return a MemoryStream from the implementation, for example. Generic variance is the same concept, but applied to generics—wh<a name="bookmark3774"></a>ere it becomes a bit more complicated. The variance is applied to the type parameters within the interfaces and delegate types. That’s the bit you need to concentrate on.</font></p>
<p><a name="bookmark3775"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Ultimately, it doesn’t matter whether you remember the terminology I’m going to use in this section. It’ll be useful while you’re reading the chapter, but you’re unlikely to find yourself needing it in conversation. The concepts are far more important.</font></p>
<p><a name="bookmark3776"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two types of variance: </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">covariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">contravariance.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> They’re essentially the same idea, but used in the context of values moving in different directions. We’ll start with covariance, which is generally easier to understand.</font></p>
<p><a name="bookmark3777"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">COVARIANCE: VALUES COMING OUT OF AN API</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Covariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is all about values being returned from an operation back to the caller. Let’s imagine a very simple generic interface representing the factory pattern. It has a single method, CreateInstance, which will return an instance of the appropriate type. Here’s the code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">interface IFactory&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T CreateInstance();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark3778"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now, T onl<a name="bookmark3779"></a>y occurs once i<a name="bookmark3780"></a>n the interface (aside from the name). It’s only used as the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">return value</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—it’s the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">output</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the method. That means it makes sense to be able to treat a factory of a specific type as a factory of a more general type. To put it in real-world terms, you can think of a pizza factory as a food factory.</font></p>
<p><a name="bookmark3781"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">CONTRAVARIANCE: VALUES GOING INTO AN API</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Contravariance</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is the opposite way around. It’s about values being passed </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">into</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the API by the caller: the API is consuming the values instead of producing them. Let’s imagine another simple interface—one that can pretty-print a particular document type to the console. Again, there’s just one method, this time called Print:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">interface IPrettyPrinter&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Print(T document);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark3782"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This time T only occurs in the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">input</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> positions in the interface, as a parameter. To put this into concrete terms again, if we had an implementation of IPrettyPrinter &lt;SourceCode&gt;, we should be able to use it as an IPrettyPrinter&lt;CSharpCode&gt;.</font></p>
<p><a name="bookmark3783"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">INVARIANCE: VALUES GOING BOTH WAYS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So if covariance applies when values only come </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">out</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of an API, and contravariance applies when values only go </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">into</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the API, what h<a name="bookmark3784"></a>appens when a value goes both ways? In short: nothing. That type would be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">invariant.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Here’s an interface representing a type that can serialize and deserialize a data type:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">interface IStorage&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">byte[] Serialize(T value);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T Deserialize(byte[] data);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This time, if we have an instance of IStorage&lt;T&gt; for a particular type T, we can’t treat it as an implementation of the interface for either a more or less specific type. If we</font></p>
<p><a name="bookmark3785"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">tried to use it in a covariant way (for example, using an IStorage&lt;Customer&gt; as an IStorage&lt;Person&gt;), we might make a call to Serialize with an object that it can’t handle. Similarly if we tried to use it in a contravariant way, we might get an unexpected type out when we deserialized some data.</font></p>
<p><a name="bookmark3786"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">If it helps, you can think invariance as being like ref parameters: to pass a variable by reference, it has to be </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the same type as the parameter itself, because the value goes into the method and effectively comes out again too.</font></p>
<p><a name="bookmark377"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3787"></a>13.3.2 Using variance in interfaces</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 4 allows you<a name="bookmark3788"></a> to specify in the declaration of a generi<a name="bookmark3789"></a>c interface or delegate that a type param<a name="bookmark3790"></a>eter can be used covariantly by using the out modifier, or contravariantly using the in modifier. Onc<a name="bookmark3791"></a>e the type has been declared, the relevant types of conversion are available implicitly. This works exactly the same way in both interfaces and delegates, but I’ll show them separately for clarity. Let’s start with interfaces, as they may be a bit more familiar—and we’ve used them already to describe variance.</font></p>
<p><a name="bookmark3792"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">VARIANT CONVERSIONS ARE REFERENCE CON<a name="bookmark3793"></a>VERSIONS </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Any conversion using variance or covariance is a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">reference conversion,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which means that the same reference is returned after the conversion. It doesn’t create a new object; it just treats the existing reference as if it matched the target type. This is the same as casting between reference types in a hierarchy: if you cast a Stream to MemoryStream (or use the implicit conversion the other way) there’s still just one object.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The nature of these conversion<a name="bookmark3794"></a>s introduces some limitations, as we’ll see later, but it means they’re efficient, and makes the behavior easier to understand in terms of object identity.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This time we’ll use familiar interfaces to demonstrate the ideas, with some simple user-defined types for the type arguments.</font></p>
<p><a name="bookmark3795"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">EXPRESSING VARIANCE WITH IN AND OUT</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There <a name="bookmark3796"></a>are two interfaces that demonstrate <a name="bookmark3797"></a>variance particularly effectively: IEnumera-ble&lt;T&gt; is covariant in T, and IComparer&lt;T&gt; is contravariant in T. Here are their new type declarations in .NET 4:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public interface IEnumerable&lt;out T&gt; public interface IComparer&lt;in T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s easy enough to remember—if a type parameter is only used for output, you can use out; if it’s only used for input, you can use in. The compiler doesn’t know whether you can remember which form is called covariance and which is called contravariance!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Unfortunately the framework doesn’t contain many inheritance hierarchies that would help us demonstrate variance particularly clearly, so I’ll fall back to the standard object-oriented example of shapes. The downloadable source code includes the definitions for IShape, Circle, and Square, which are fairly obvious. The interface exposes properties for the bounding box of the shape and its area. I’m going to use two lists a lot in the following examples, so I’ll show their construction code just for reference:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Circle&gt; circles = new List&lt;Circle&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Circle(new Point(0, 0), 15), new Circle(new Point(10, 5), 20),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Square&gt; squares = new List&lt;Square&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Square(new Point(5, 10), 5), new Square(new Point(-10, 0), 2)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The only important point concerns the types of the variables—they’re declared as List&lt;Circle&gt; and List&lt;Square&gt; rather than List&lt;IShape&gt;. This can often be use-ful—if we were to access the list of circles elsewhere, we might want to get at circle-specific members without having to cast, for example. The actual values involved in the construction code are entirely irrelevant; I’ll use the names circles and squares elsewhere to refer to the same lists, but without duplicating the code.<sup><a name="footnote91"></a><a href="#bookmark3798">91</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">USING INTERFACE COVARIANCE</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To demonstrate covariance, we’ll try to build a list of shapes from a list of circles and a list of squares. The following listing shows two different approaches, neither of which would’ve worked in C# 3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.12 Building a list of general shapes from lists of circles and squares</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;IShape&gt; shapesByAdding = new List&lt;IShape&gt;(); shapesByAdding.AddRange(circles); shapesByAdding.AddRange(squares);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;IShape&gt; concat = circles.Concat&lt;IShape&gt;(squares)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.ToList();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Effectively, listing 13.12 shows covariance in four places, each converting a sequence of circles or squares into a sequence of general shapes, as far as <a name="bookmark3799"></a>the type system is concerned. First we create a new List&lt;IShape&gt; and call AddRange to add the circle and square lists to it </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. (We could’ve passed one of them into the constructor instead, then just called AddRange once.) The parameter for List&lt;T&gt;.AddRange is of type IEnumerable&lt;T&gt;, so in this case we’re treating each list as an IEnumerable &lt;IShape&gt;—something that wouldn’t have been possible before. AddRange </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have been written as a generic method with its own type parameter, but it wasn’t—doing this would’ve made some optimizations hard or impossible.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Another way of creating a list that contains the <a name="bookmark3800"></a>data in two existing sequences is to use LINQ </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. We can’t directly call circles .Concat (squares), as it would confuse the</font></p>
<p><a name="bookmark3801"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3802"></a>type inference mechanism, but by specifying the type argument explicitly, all is well. Both circles and squares are implicitly converted to IEnumerable&lt;IShape&gt; via covariance. This conversion isn’t actually changing the value—just how the compiler </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">treats </font><font style="font-size:x-small;font-family:Times New Roman, serif;">the value. It isn’t building a separate cop<a name="bookmark3803"></a>y, which is the important point. Covariance is particularly important in LINQ to Objects, as so much of the API is expressed in terms of IEnumerable&lt;T&gt;—contravariance isn’t as important, as fewer of the types involved are contravariant.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In C# 3 there would certainly have been other ways to approach the same problem. We could’ve built List&lt;IShape&gt; instances instead of Lis<a name="bookmark3804"></a>t&lt;Circle&gt; and List&lt;Square&gt; for the original shapes; we could’ve used the LINQ Cast operator to convert the specific lists to more general ones; we could’ve written our own lis<a name="bookmark3805"></a>t class with a generic AddRange method. None of these would’ve been as convenient or as efficient as the alternatives offered here.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">USING INTERFACE CONTRAVARIANCE</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll use the same shape types to demonstrate contravariance. This time we’ll only use the list of circles, but a comparer that’s able to compare </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">any</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> two shapes by just comparing the areas. We couldn’t do this before C# 4 because an IComparer&lt;IShape&gt; couldn’t be used as an IComparer&lt;Circle&gt;, but the following listing shows contravari-ance coming to the rescue.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.13 Sorting circles using a general-purpose comparer and contravariance</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class AreaComparer : IComparer&lt;IShape&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int Compare(IShape x, IShape y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return x.Area.CompareTo(y.Area);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark3806"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IComparer&lt;IShape&gt; areaComparer = new AreaComparer();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">circles.Sort(areaComparer);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s nothing complicated here. Our AreaComparer class </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is about as simple as an implementation of IComparer&lt;T&gt; can be; it doesn’t need any state, for example. There’d normally be some null handling in the Compare method, but that’s not necessary to demonstrate variance.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Once we have an IComparer&lt;IShape&gt;, we’re using it to sort a list of circles </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">C</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. The argument to circles.Sort needs to be an IComparer&lt;Circle&gt;, but contravariance allows us to convert our comparer implicitly. It’s as simple as that.</font></p>
<p><a name="bookmark3807"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SURPRISE, SURPRISE </font><font style="font-size:x-small;font-family:Times New Roman, serif;">If someone had presented you with this code as if it were C# 3, you might’ve looked at it and expected it to work. It seems obvious that it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">should</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be able to work, and this is a common feeling; the invariance in C# 2 and 3 often is an unwelcome surprise. The new abilities of C# 4 in this area aren’t introducing new concepts you’d never have thought of before; they just allow you more flexibility.</font></p>
<p><a name="bookmark3808"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">These have both been simple examples using single-method interfaces, but the same principles apply for more complex APIs. Of course, the more complex the interface is, the more likely that a type parameter will be used for both input and output, which would make it invariant. We’ll come back to some tricky examples later, but first we’ll look at delegates.</font></p>
<p><a name="bookmark378"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3809"></a><a name="bookmark3810"></a>13.3.3 Using variance in delegates</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve seen how to use variance with interfaces, applying the same knowledge to delegates is easy. We’ll use some familiar types again:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate T Func&lt;out T&gt;() delegate void Action&lt;in T&gt;(T obj)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">These are really equivalent to the IFactory&lt;T&gt; and IPrettyPrinter&lt;T&gt; interfaces we started off with. Using lambda expressions, we can demonstrate both of these easily, and even chain the two together. The following listing shows an example using our shape types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.14 Using variance with simple Func&lt;T&gt; and Action&lt;T&gt; delegates</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;Square&gt; squareFactory = () =&gt; new Square(new Point(5, 5), 10); Func&lt;IShape&gt; shapeFactory = squareFactory;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Action&lt;IShape&gt; shapePrinter = shape =&gt; Console.WriteLine(shape.Area); Action&lt;Square&gt; squarePrinter = shapePrinter;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">squarePrinter(squareFactory()); shapePrinter(shapeFactory());</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Hopefully by now the code will need little explanation. Our square factory always produces a square at the same position, with sides of length 10. Covariance allows us to treat a square factory as a general shape factory O with no fuss. We then create a general-purpose action that prints out the area of whatever shape is given to it. This time we use a contravariant conversion to treat the action as one that can be applied to any square ©. Finally, we feed the square action with the result of calling the square factory, and the shape action with the result of calling the shape factory. Both print 100, as we’d expect.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course we’ve only used delegates with a single type parameter here. What happens if we use delegates or interfaces with multiple type parameters? What about type arguments that are themselves generic delegate types? Well, it can all get quite complicated.</font></p>
<p><a name="bookmark379"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3811"></a>13.3.4 Complex situations</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before I try to make your head spin, I should provide a lit<a name="bookmark3812"></a>tle comfort. Although we’ll be doing some weird and wonderful things, the compiler <a name="bookmark3813"></a>will stop you from making mistakes. You may still get confused by the error messages if you’ve used several type parameters in funky ways, but once you have it compiling you should be safe.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Complexity is possible in both the delegate and interface forms of variance, although the delegate version is usually more concise to work with. Let’s start off with a relatively simple example.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SIMULTANEOUS COVARIANCE AND CONTRAVARIANCE WITH Converter&lt;TInput, TOutput<a name="bookmark3814"></a>&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Converter&lt;TInput, TOu<a name="bookmark3815"></a>tput&gt; delegate type has been around since .NET 2.0. It’s effectively Func&lt;T, TResult&gt; but with a clearer expected purpose. In .NET 4, this becomes Converter&lt;in TInput, out TOutput&gt;, which shows which type parameter has which kind of variance. The following listing shows a few combinations of variance using a simple converter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.15 Demonstrating covariance and contravariance with a single type</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Converter&lt;object, string&gt; converter = x =&gt; x.ToString();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Converter&lt;Button, string&gt; contravariance = converter;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Converter&lt;object, object&gt; covariance = converter;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Converter&lt;Button, object&gt; both = converter;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 13.15 shows the variance conversions available on a delegate of type Converter&lt;object, string&gt;: a delegate that takes any object and produces a string. First we implement the delegate using a simple lambda expression that calls ToString </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. As it happens, we never actually </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">call</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the delegate, so we could’ve just used a null reference, but I think it’s easier to think about variance if you can pin down a concrete action that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">would</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> happen if you called it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The next two lines are relatively straightforward, so long as you only concentrate on one type parameter at a time. The TInput type parameter is only used in an input position, so it makes sense that you can use it contravariantly, using a Converter &lt;object, string&gt; as a Converter&lt;Button, string&gt;. In other words, if you can pass </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">any</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> object reference into the converter, you can certainly hand it a Button reference. Likewise the TOutput type parameter is only used in an output position (the return type) so it makes sense to use that covariantly: if the converter always returns a string reference, you can safely use it where you only need to guarantee that it’ll return an object reference.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The final line </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is just a logical extension of this idea. It uses both contravariance and covariance in the same conversion, to end up with a converter that only accepts buttons and only declares that it’ll return an object referen<a name="bookmark3816"></a>ce. Note that you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> convert this back to the original conversion type without a cast—we’ve essentially relaxed the guarantees at every point, and you can’t tighten them up again implicitly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s up the ante a little, and see just how complex things can get if you try hard enough.</font></p>
<p><a name="bookmark3817"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">HIGHER-ORDER FUNCTION INSANITY</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The really weird stuff starts happening when you combine variant types together. I’m not going to go into a lot of detail here—I just want you to appreciate the potential for complexity. Let’s look at four delegate declarations:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate Func&lt;T&gt; FuncFunc&lt;out T&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate void ActionAction&lt;out T&gt;(Action&lt;T&gt; action); delegate void ActionFunc&lt;in T&gt;(Func&lt;T&gt; function); delegate Action&lt;T&gt; FuncAction&lt;in T&gt;();</font></p>
<p><a name="bookmark3818"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3819"></a>Each of these declarations is equivalent to nesting one of the standard delegates inside another. For example, FuncAction&lt;T&gt; is equivalent to Func&lt;Action&lt;T&gt;&gt;. Both represent a function that will return an Action which can be passed a T. But should this be covariant or contravariant? Well, the function is going to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">return</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> something to do with T, so it sounds covariant—but that something then </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">takes</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a T so it sounds contravariant. The answer is that the delegate </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> contravariant in T, which is why it’s declared with the in modifier.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As a quick rul<a name="bookmark3820"></a>e of thumb, you can think of nested contravariance as reversing the previous variance, whereas covariance doesn’t—so whereas Action&lt;Action&lt;T&gt;&gt; is covariant in T, Action&lt;Action&lt;Action&lt;T&gt;&gt;&gt; is contravariant. Compare that with Func&lt;T&gt; variance, where you can write Func&lt;Func&lt;Func&lt;...Func&lt;T&gt;...&gt;&gt;&gt; with as many levels of nesting as you like and still get covariance.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just to give a similar example using interfaces, let’s imagine we have something that can compare sequences. If it can compare two sequences of arbitrary objects, it can certainly compare two sequences of strings—but not vice versa. Converting this to code (without implementing the interface!), we can see this as</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IComparer&lt;IEnumerable&lt;object&gt;&gt; objectsComparer = ...; IComparer&lt;IEnumerable&lt;string&gt;&gt; stringsComparer = objectsComparer;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This conversion is legal: IEnumerable&lt;string&gt; is a “smaller” type than IEnumerable &lt;object&gt; due to the covariance of IEnumerable&lt;T&gt;; the contravariance of IComparer &lt;T&gt; then allows the conversion from a comparer of a “bigger” type to a comparer of a smaller type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course we’ve only used delegates and interfaces with<a name="bookmark3821"></a> a single type parameter in this section—it can all apply to multiple type parameters too. Don’t worry, though: you’re unlikely to need this sort of brain-busting variance very often, and when you do you have the compiler to help you. I really just wanted to make you aware of the possibilities.</font></p>
<p><a name="bookmark3822"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3823"></a>On the flip side, there are some things you may expect to be able to do, but which aren’t supported.</font></p>
<p><a name="bookmark380"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3824"></a>13.3.5 Restrictions and notes</font></p>
<p><a name="bookmark3825"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The<a name="bookmark3826"></a> variance support provided by C# 4 is mostly limite<a name="bookmark3827"></a>d by what’s provided by the CLR. It’d be hard for the language to support conversions that were prohibited by the underlying platform. This can lead to a few surprises.</font></p>
<p><a name="bookmark3828"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">NO VARIANCE FOR TYPE PARAMETERS IN CLASSES</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Only interfaces and delegates can have variant type parameters. Even if you have a class that only uses the type parameter for input (or only uses it f<a name="bookmark3829"></a>or output), you can’t specify the in or out modifiers. For example Comparer&lt;T&gt;, the common</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">implementation of IComparer&lt;T&gt;, is invariant—there’s no conversion from Comparer&lt;IShape&gt; to Comparer&lt;Circle&gt;.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Aside from any implementation difficulties that this<a name="bookmark3830"></a> might’ve incurred, I’d say it makes a certain amount of sense concept<a name="bookmark3831"></a>ually. Interfaces represent a way of looking at an object from a particular perspective, whereas classes are more ro<a name="bookmark3832"></a>oted in the object’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">actual</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type. This argument is weakened somewhat by inheritance letting you treat an object as an instance of any of the classes in its inheritance hierarchy, admittedly. Either way, the CLR doesn’t allow it.</font></p>
<p><a name="bookmark3833"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">VARIANCE ONLY SUPPORTS REFERENCE CONVERSIONS</font></p>
<p><a name="bookmark3834"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You can’t use variance between two arbitrary type arguments just because there’s a conversion between them. It has to be a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">refe<a name="bookmark3835"></a>rence conversion</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Basically that limits it to conversio<a name="bookmark3836"></a>ns which operate on reference types and which don’t affect the binary representation of the reference. This is so that the CLR can know that operations will be type-safe without having to inject any actu<a name="bookmark3837"></a>al conversion code anywhere. As I mentioned in section 13.3.2, variant conversions are themselves reference conversions, so there wouldn’t be anywhere for the extra code to go anyway.</font></p>
<p><a name="bookmark3838"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In particular, this restriction prohibits any conversions of value types and user-defined conversions. For example, the following conversions are all invalid:</font></p>
<p><a name="bookmark3839"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;IEnumerable&lt;int&gt; to IEnumerable&lt;object&gt;—Boxing conversion</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;IEnumerable&lt;short&gt; to IEnumerable&lt;int&gt;—Value type conversion</font></p>
<p><a name="bookmark3840"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;IEnumerable&lt;string&gt; to IEnumerable&lt;XName&gt;—User-defined conversion</font></p>
<p><a name="bookmark3841"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3842"></a>User-defined conversions aren’t likely to be a problem as they’re relatively rare, but you may find the restriction around value types a pain.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">OUT PARAMETERS AREN’T OUTPUT POSITIONS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This one came as a surprise to me, although it makes sense in retrospect. Consider a delegate with the following definition:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">delegate bool TryParser&lt;T&gt;(string input, out T value)</font></p>
<p><a name="bookmark3843"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You might expect that you co<a name="bookmark3844"></a>uld make T covariant—after all, it’s only used in an output position... or is it? The <a name="bookmark3845"></a>CLR doesn’t really know about out parameters. As far as it’s concerned, they’re just ref parameters with an [Out] attribute applie<a name="bookmark3846"></a>d to them. C# attaches special meaning to the attribute in terms of definite assignment, but the CLR doesn’t. However, ref parameters mean data going both ways, so if you have a ref parameter of type T, that means T is invariant.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In fact, even if the CLR did support out parameters natively, it still wouldn’t be safe, because it can be used in an input position within the method itself: after you’ve written to the variable, you can read from it as well. It’d be okay if o<a name="bookmark3847"></a>ut parameters were treated as “copy value at return time,” but it essentially aliases the argument and parameter—which would cause problems if they weren’t exactly the same type. It’s slightly fiddly to demonstrate, but there’s an example on the book’s website.</font></p>
<p><a name="bookmark3848"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Delegates and interfaces using out parameters are rare, so this may never affect you anyway, but it’s worth knowing about just in case.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">VARIANCE HAS TO BE EXpLICIT</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When I introduced the syntax for expressing variance—applying the in or out modifiers to typ<a name="bookmark3849"></a>e parameters—you may have wondered why we needed to bother at all. The compiler is able to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">check</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that wha<a name="bookmark3850"></a>tever variance you try to apply is valid—so why doesn’t itjust apply it automatically ?</font></p>
<p><a name="bookmark3851"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> do that—at least i<a name="bookmark3852"></a>n many cases—but I’m glad it doesn’t. Normally you can add methods to an interface and only affect implementations rather than callers. But if you’ve declared that a type parameter is variant and you then want to add a method which breaks that va<a name="bookmark3853"></a>riance, all the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">callers</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> are affected too. I can see this causing a lot of confusion. Variance requires some thought about what you might want to do in the futu<a name="bookmark3854"></a>re, and forcing developers to explicitly include the modifier encourages them to plan carefully before committing to variance.</font></p>
<p><a name="bookmark3855"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s less of an argument for this explicit nature when it comes to delegates: any change to the signature that would affect the variance<a name="bookmark3856"></a> would probably break existing uses anyway. But there’s a lot to be said for consistency—it would feel odd if you had to specify the variance in interfaces but not in delegate declarations.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">BEWARE OF BREAKING CHANGES</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Whenever new conversions become available, there’s t<a name="bookmark3857"></a>he ris<a name="bookmark3858"></a>k of your current code breaking. For instance, if you rely on the results of the is or as operators </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> allowing for variance, your code will behave differ<a name="bookmark3859"></a>ently when running under .NET 4. Likewise there are cases where overload resolution will choose a different method due to there being more applicable options now. This is another reason for variance to be explicitly specified: it reduces the risk of breaking your code.</font></p>
<p><a name="bookmark3860"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">These situations should be quite rare, and the benefit fro<a name="bookmark3861"></a>m variance is more significant than the potential drawbacks. Y<a name="bookmark3862"></a>ou </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have unit tests to catch subtle changes, right? In all seriousness, the C# team takes code breakage very seriously, but sometimes there’s no way of introducing a new feature without breaking code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">MULTICAST DELEGATES AND VARIANCE DON’T MIX</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Normally, generics make sure that unless you have casts involved, you won’t run into type-safety issues at execution time. Unfortunately, there’s a nasty situation with variant delegate types when it comes to combining them together. This is best demonstrated in code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;string&gt; stringFunc = () =&gt; &quot;&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;object&gt; objectFunc = () =&gt; new object();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;object&gt; combined = objectFunc + stringFunc;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This compiles with no problem, because there’s a covariant reference conversion from an expression of type Func&lt;string&gt; to F<a name="bookmark3863"></a>unc&lt;object&gt;. But the object itself is still a Func&lt;string&gt;—and the Delegate.Combine method that actually does the work requires its arguments to be the same type—otherwise it doesn’t know what type of</font></p>
<p><a name="bookmark3864"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">Download from Wow! eBook &lt;<a href="http://www.wowebook.com">www.wowebook.com</a>&gt;</font></p>
<p><a name="bookmark3865"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">delegate it’s meant to create. The preceding code will throw an ArgumentException at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This problem was found relatively late in the .NET 4 release cycle, but Microsoft is aware of it and there is hope that it may<a name="bookmark3866"></a> be fixed for the majority of cases in a future release. Until then, there’s a workaround: you can create a new delegate object of the correct type based on the variant one, and combine that with another delegate of the same type. For example, we can modify the preceding code slightly to make it work:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;string&gt; stringFunc = () =&gt; &quot;&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;object&gt; defensiveCopy = new Func&lt;object&gt;(stringFunc);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;object&gt; objectFunc = () =&gt; new object();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Func&lt;object&gt; combined = objectFunc + defensiveCopy;</font></p>
<p><a name="bookmark3867"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3868"></a>Fortunately this is rarely an issue in my experience.</font></p>
<p><a name="bookmark3869"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">NO CALLER-SPECIFIED OR PARTIAL VARIANCE</font></p>
<p><a name="bookmark3870"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3871"></a>This is really a matter of interest and comparison rather than anything else, but it’s worth noting that C#’s variance is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> different to Java’s system. Java’s generic variance manages to be extremely flexible by approaching it from the other side: instead of the type itself declaring the variance, code </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">using</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the type can express the variance it needs.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WANT TO KNOW MORE? </font><font style="font-size:x-small;font-family:Times New Roman, serif;">This book isn’t about Java generics, but if this litt<a name="bookmark3872"></a>le teaser has piqued your interest, you may want to check out Angelika Langer’s Java Generics FAQ (<a href="http://mng.bz/3qgO">http://mng.bz/3qgO</a>). Be warned: it’s a huge and complex topic!</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For example, the List&lt;T&gt; interface in Java is roughly equivalent to IList&lt;T&gt; in C#. It contains methods to both add items and fetch them, so clearly in C# it’s invariant— but in Java you can decorate the type at the calling code to explain what variance you want. The compiler then stops you from using the members that go against that variance. For example, the following code would be perfectly valid:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Shape&gt; shapes1 = new ArrayList&lt;Shape&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;? super Square&gt; squares = shapes1; squares.add(new Square(10, 10, 20, 20));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;Circle&gt; circles = new ArrayList&lt;Circle&gt;(); circles.add(new Circle(10, 10, 20));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;? extends Shape&gt; shapes2 = circles; Shape shape = shapes2.get(0);</font></p>
<p><a name="bookmark3873"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">For the most part, I prefer generics in C# to Java, and type erasure in particular can be a pain in many cases. But I find this treatment of variance really interesting. I don’t expect to see anything similar in future versions of C#—so think carefully about how you can split your interfaces to allow for flexibility, but without introducing more complexity than is really warranted.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just before I close the chapter, there are two almost trivial changes to cover—how the C# compiler handles lock statements and field-like events.</font></p>
<p><a name="bookmark382"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3874"></a>13.4 Teeny tiny changes to locking and field-like events</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I don’t want to make too much of these changes: chances are they’ll never affect you. But if you’re ever looking at compiled code and wondering why it looks the way it does, it’s helpful to know what’s going on.</font></p>
<p><a name="bookmark383"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3875"></a>13.4.1 Robust locking</font></p>
<p><a name="bookmark3876"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s consider a simple piece of C# code that uses a lock. The details of what happens inside the block aren’t important, but I’ve included a single statement just for the sake of clarity:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">lock (listLock)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">list.Add(&quot;item&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Prior to C# 4—and including C# 4 if you’re targeting anything earlier than .NET 4— that would effectively be compiled into this code:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object tmp =<a name="bookmark3877"></a> listLock;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Monitor.Enter(tmp); try</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">list.Add(&quot;item&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">finally</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Monitor.Exit(tmp);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark3878"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">nearly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> okay—in particular, <a name="bookmark3879"></a>it avoids a couple of problems. We want to make sure that we release the same monitor we acquire, so first we copy the reference into a temporary local variable O. This also means that the locking expression is only evaluated once. Next we acquire the lock </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">before</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the try block.<a name="bookmark3880"></a> This is so <a name="bookmark3881"></a>that we don’t try to release the lock in the finally block if the thread is aborted without successfully acquiring it in the first place. That leads to a different problem: now if the thread is aborted </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">after</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the lock is acquired but </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">before</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> we enter th<a name="bookmark3882"></a>e try block, we won’t have released the lock. That could feasibly lead to a deadlock—anot<a name="bookmark3883"></a>her thread could be waiting eternally for this one to release the lock. Though the CLR has historically tried hard to stop this from happening, it’s not quite impossible.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">What we want is some way of atomically acquiring the lock and knowing that it was acquired. Fortunately that’s exposed in .NET 4 via a new overload to Monitor.Enter, which the C# 4 compiler uses in this way:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">bool acquired = false; object tmp = listLock; try</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Monitor.Enter(tmp, ref acquired); list.Add(&quot;item&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">finally {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (acquired)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Monitor.Release(tmp);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now the lock will be released if and only if we successfully acquired it in the first place, consistently. It should be noted that in some cases a deadlock isn’t the worst result (see <a href="http://mng.bz/Qy7p">http://mng.bz/Qy7p</a>): occasionally it’s more dangerous for an application to continue at all than for it to simply halt. But it’d be ridiculous to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">rely</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> on the deadlock condition; better to avoid aborting threads if at all possible. (Aborting the currently executing thread <a name="bookmark3884"></a>is somewhat be<a name="bookmark3885"></a>tter, as you’re in more control—this is what Response. Redirect does in AS<a name="bookmark3886"></a>P.NET, for example—but I’d still generally suggest finding better forms of flow control.)</font></p>
<p><a name="bookmark3887"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s one last tweak to cover before we move on to the really big feature of C# 4.</font></p>
<p><a name="bookmark384"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3888"></a>13.4.2 Changes to field-like events</font></p>
<p><a name="bookmark3889"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Finally, there are two changes to the way </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">field-like events</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> are implements in C# 4 that are worth mentionin<a name="bookmark3890"></a>g briefly. They’re unlikely to affect you, although they’re </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">potentially </font><font style="font-size:x-small;font-family:Times New Roman, serif;">breaking ch<a name="bookmark3891"></a>anges. Just to recap, field-like event<a name="bookmark3892"></a>s are events that are declared as if they’re fields, with no explicit add/remove blocks, like this:</font></p>
<p><a name="bookmark3893"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public event EventHandler Click;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">First, the way that thread safety is achiev<a name="bookmark3894"></a>ed has been ch<a name="bookmark3895"></a>anged: before C# 4, field-like events resulted in code that would lock on either this (for instance events) or the declaring type (for static events). As of C# 4, the compiler achieves thread-saf<a name="bookmark3896"></a>e, atomic subscription and unsubscription using Interlocked.CompareExchange&lt;T&gt;. Unlike the previous change to the lock statement, this applies even when targeting earlier versions of the .NET framework.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Second, the meaning of the event’s name </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">within the declaring class</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> has changed. Previously, if you subscribed to (or unsubscribed from) the event within the class that contained the declaration—such as <a name="bookmark3897"></a>with Click += DefaultClickHandler;—that would go straight to the backing field, skipping the add/remove implementation completely. Now, it doesn’t—when you’re using += or -=, the name of the event refers to the event itself, no<a name="bookmark3898"></a>t the backing <a name="bookmark3899"></a>field. When the name is used for any other purpose (typically assignment or invocation), it still refers directly to the backing field.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">These are both sensible changes that make everything neat<a name="bookmark3900"></a>er, although you probably wouldn’t have noticed them in daily use. Chris Burrows goes into the topic in detail in his blog; if you want to know more (see <a href="http://mng.bz/Kyr4">http://mng.bz/Kyr4</a>).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This has been a bit of a pick-and-mix chapter, with various distinct areas. Having said that, COM greatly benefits from named arguments and optional parameters, so there’s some overlap between them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I suspect it’ll take a while for C# developers to get the hang of how best to use the ne<a name="bookmark3901"></a>w features for parameters and arguments. Overloading still provides extra portability for languages that don’t support optional parameters, and named arguments may look strange in some situations until you get used to them. The benefits can be significant, though, as I demonstrated with the example of building instances of immutable types. You’ll need to take some care when assigning default values to optional parameters, but I hope that you’ll find the suggestion of using null as a “default default value” to be a useful and flexible one that effectively sidesteps some of the limitations and pitfalls you might otherwise encounter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Working with COM has come a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">long</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> way for C# 4. I still prefer to use purely managed solutions where they’re available, but at least the code calling into COM is a lot more readable now, as well as having a better deployment story. We haven't seen all of the improvements to COM interop yet, as the dynamic typing features we’ll see in the next chapter impact on COM too, but even without taking that into account we’ve seen a short sample become a lot more pleasant just by applying a few simple steps.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our last major topic was the generic variance now available for interfaces and delegates. Sometimes you may end up using variance without even knowing it, and I think most developers are more likely to use the variance declared in the framework interfaces and delegates rather than creating their own. I apologise if it occasionally became tricky, but it’s good to <a name="bookmark3902"></a>knowjust what’s out there. If it’s any consolation to you, C# team member Eric Lippert has publicly acknowledged in a blog post (see <a href="http://mng.bz/79d8">http://</a> <a href="http://mng.bz/79d8">mng.bz/79d8</a>) that higher-order functions make even </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">his</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> head hurt, so we’re in good company. Eric’s post is one in a long series about variance (see <a href="http://mng.bz/94H3">http://<a name="bookmark3903"></a>mng.bz/94H3</a>), which is as much as anything a dialogue about the design decisions involved. If you haven’t had enough of variance by now, it’s an excellent read.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For the sake of completeness we also took a quick peek at the changes to how the C# compiler handles locking and field-like events.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This chapter dealt with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">relatively</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> small changes to C#. Chapter 14 deals with something far more fundamental: the ability to use C# in a dynamic manner.</font></p>
<p><a name="bookmark20"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark3904"></a>Dynamic binding in a static language</font></p>
<p><a name="bookmark3905"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;What it means to be dynamic</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;How to use dynamic typing in C# 4</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Examples with COM, Python, and reflection</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;How dynamic typing is implemented</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Reacting dynamically</font></p>
<p><a name="bookmark3906"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">C# has always been a statically typed language, with no exceptions. <a name="bookmark3907"></a>There have been a few areas where the compiler has looked for particular names rather<a name="bookmark3908"></a> than interfaces, such as finding appropriate Add methods for collection initializers, bu<a name="bookmark3909"></a>t there’s been nothing truly dynamic in the language beyond normal polymorphism. That changes with C# 4—at least partia<a name="bookmark3910"></a>lly. The simplest way of explaining it is that there’s a new static type called dynamic, which you can try to do almost anything with at compile time and let the framework sort it out at execution time. Of course there’s more to it than that, but that’s the executive summary.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Given that C# is still a statically typed language everywhere that you’re </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not </font><font style="font-size:x-small;font-family:Times New Roman, serif;">using dynamic, I don’t expect fans of dynamic programming to suddenly become</font></p>
<p><a name="bookmark3911"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">C# advocates. That’s not the main point of the feature: it’s lar<a name="bookmark3912"></a>gely about interoperability. As dynamic languages such as IronRuby and IronPython join the .NET ecosystem, it’d be crazy not to be able to call into C# <a name="bookmark3913"></a>code from IronPython and vice versa. Likewise, developing against <a name="bookmark3914"></a>weakly typed COM APIs has always been awkward in C#, with an abundance of casts cluttering the code. Dynamic typing addresses all of these concerns.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One word of warning—I’ll be repeating this throughout the chapter—it’s worth being careful with dynamic typing. It’s fun to explore, and it’s been well implemented, but I still recommend that you think carefully before using it heavily. Just like any other new feature, weigh the pros and cons rather than rushin<a name="bookmark3915"></a>g into itjust be<a name="bookmark3916"></a>cause it’s neat (which it undoubtedly is). The framework does a fine job of optimizing dynamic code, but it’ll be slower than static code in most cases. More importantly, you lose a lot of compile-time safety. Whereas unit testing will help you find a lot of the mistakes that can crop up when the compiler isn’t able to help you much, I still prefer the immediate feedback of the compiler telling me if I’m trying to use a method that doesn’t exist or can’t be called with a given set of arguments.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">On the other hand, there are situations where the level of safety given to you by the compiler isn’t very strong to start with. For example, there are far more things that can go wrong with code that uses reflection than just the errors a compiler can spot. If you’re trying to invoke a method given its name, does that method exist? Is it accessible to your code? Are you providing appropriate arguments? The compiler can’t help you with any of that. The equivalent dynamic code still can’t spot those errors at compile time, but at least the code may be considerably easier to read and understand. It’s all a matter of using the most appropriate approach for the particular problem you’re working on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Dynamic behavior can be useful in situations where you’re naturally dealing with dynamic environments or data, but if you’re really looking to write large chunks of your code dynamically, I suggest you use a language <a name="bookmark3917"></a>where that’s the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">normal</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> style instead of the exception. C# is still obviously a language that was </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">designed</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for static typing: languages that have been dynamic from the start often have various features to help you work more productively with dynamic behavior. Now that you can easily call into such languages from C#, you can fairly easily separate out the parts of your code that benefit from a largely dynamic style from those where static typing works better.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I don’t want to put too much of a damper on things: where dynamic typing </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> useful, it can be a lot simpler than the alternatives. In this chapter we’ll look at the basic rules of dynamic typing in C# 4, and then dive into some example<a name="bookmark3918"></a>s: using COM dynamically, calling into some IronPython code, and making reflection a lot simpler. You can do all of this without knowing details, but after we have the flavor of dynamic typing, we’ll look at what’s go<a name="bookmark3919"></a>ing on under the hood. In particular, we’ll discuss the Dynamic Language Runtime and what the C# compiler does when it encounters dynamic code. Finally, we’ll see how you can make your own types respond dynamically to methods calls, property accesses, and the like. First, let’s take a step back.</font></p>
<p><a name="bookmark388"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3920"></a>14.1 &nbsp;&nbsp;&nbsp;What? When? Why? How?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before we get to any code showing off this new feature of C# 4, it’s worth getting a better handle on why it was introduced in the first place. I don’t know any other languages that have gone from being purely static to partially dynamic; this is a significant step in C#’s evolution, whether you use it often or only occasionally.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll start by taking a fresh look at what </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">dynamic</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">static</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> mean, consider some of the major use cases for dynamic typing in C#, and then delve into how it’s implemented in C# 4.</font></p>
<p><a name="bookmark389"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3921"></a>14.1.1 &nbsp;&nbsp;&nbsp;What is dynamic typing?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In chapter 2, I discussed the characteristics of a type system and described how C# has previ<a name="bookmark3922"></a>ously been a statically typed language. The compiler knows the type of expressions in the code, and knows the members available on any type. It applies a fairly complex set of rules to det<a name="bookmark3923"></a>ermine which exact member should be used when. This includes overload resol<a name="bookmark3924"></a>ution; the o<a name="bookmark3925"></a>nly choice left until later is t<a name="bookmark3926"></a>o pick the implementation of virtual methods depending on the execution-time t<a name="bookmark3927"></a>ype of the object. The process of working out which memb<a name="bookmark3928"></a>er to use is called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">binding</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and in a statically typed language it occurs at compile time.</font></p>
<p><a name="bookmark3929"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In a dynamicall<a name="bookmark3930"></a>y typed language, all of this binding <a name="bookmark3931"></a>occurs at execution time. A compiler or parser can check that the code is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">syntactically</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> correct, but it can’t check that the methods you <a name="bookmark3932"></a>call and the properties you access are actually present. It’s a bit like a word processor with no dictionary: it may be able to c<a name="bookmark3933"></a>heck your punctuation, but not your spelling. (If you’re to have any sort of confidence in your code, you really need a good set of unit tests.) Some dynamic languages are alwa<a name="bookmark3934"></a>ys interpreted, with no compiler involved at all. Others<a name="bookmark3935"></a> provide both an interprete<a name="bookmark3936"></a>r and a compiler, to allow rapid development with a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">REPL:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a read, evaluate, print loop.</font></p>
<p><a name="bookmark3937"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3938"></a>REPL AND C# Strictly speaking, REPL isn’t solely associated with dynamic languages. Some statically typed languages have </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">interpreters</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that actu<a name="bookmark3939"></a>ally co<a name="bookmark3940"></a>mpile on the fly. Notably, F# comes with a tool called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">F# Interactive</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which does exactly this. But interpreters are much more common for dynamic languages than static ones.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# does have<a name="bookmark3941"></a> similar tools: the expression evaluator underlying the Watch and Imm<a name="bookmark3942"></a>ediate windows in Visual Studio can be considered a form of REPL, and Mono has a C# Shell (see <a href="http://mng.bz/nek9">http://mng.bz/nek9</a>).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth noting that the new dynamic features of C# 4 do </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> include interpreti<a name="bookmark3943"></a>ng C<a name="bookmark3944"></a># source code at execution time: there’s no direct equivalent of the JavaScript eval function, for exampl<a name="bookmark3945"></a>e. To execute code based on <a name="bookmark3946"></a>data in strings, you need to use eith<a name="bookmark3947"></a>er the CodeDOM API (and CSharpCodeProvider in particular) or simple reflection to invoke individual members.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, the same kind of work has to be done at </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">some</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> point in time no matter what approach you’re taking. By asking the compiler to do more work before execution, static systems usually perform better than dynamic ones. Given the downsides we’ve</font></p>
<p><a name="bookmark3948"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">mentioned so far, you might be wondering why anyone would want to bother with dynamic typing in the first place.</font></p>
<p><a name="bookmark390"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3949"></a>14.1.2 When is dynamic typing useful, and why?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Dynamic typing has two important points in its favor. First, if you know the name of a member you want to call, the arguments you want to call it with, and the object you want to call it on, that’s all you need. That may sound like all the information you could have anyway, but the C# compiler would normally want to know more. Crucially, in order to identify the member exactly (modulo overriding), it’d need to know the type of the object you’re calling it on, and the types of the arguments. Sometimes you just don’t know those types at compile time, even though you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> know enough to be sure that the member will be present and correct when the code actually runs.</font></p>
<p><a name="bookmark3950"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3951"></a>For example, if you know that the object you’re using has a Length property you want to use, it doesn’t matter whether it’s a String, a StringBuilder, an Array, a Stream, or any of the other types with that property. You don’t need that property to be defined by some common base cl<a name="bookmark3952"></a>ass or interface—which can be useful if there isn’t such a type. This is called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">duck typing,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> from the notion that “if it walks like a duck and quacks like a duck, I’d call it a duck.”<sup><a name="footnote92"></a><a href="#bookmark3953">92</a></sup> Even when there </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a type that offers everything you need, it can sometimes be irritating to tell the compiler exactly whi<a name="bookmark3954"></a>ch type you’re talking about. This is particularly relevant when using Microsoft Office APIs via COM. Many methods and properties are declared to just return VARIANT, which means that C# code using these calls is often peppered with casts. Duck typing allows you to omit all of these casts, so long as you’re confident about what you’re doing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The second important feature of dynamic typing is the ability of an object to respond to a call by analyzing the name and arguments provided to it. It can behave as if the member had been declared by the type in the normal way, even if the member names couldn’t possibly be known until execution time. For example, consider the following call:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">books.FindByAuthor(&quot;Joshua Bloch&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Normally this would require the FindByAuthor member to be declared by the designer of the type involved. In a dynamic data layer, there can be a single smart piece of code to analyse calls like this. It can detect that there’s an Author property in the associated data (whether that’s from a database, XML document, hardcoded data, or anything else) and act accordingly: in this case, it would decide that you want to perform a query using the specified argument as the author. In some ways, this is just a more complex way of writing something like:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">books.Find(&quot;Author&quot;, &quot;Joshua Bloch&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But the first snippet feels more appropriate: the calling code knows the Author part statically, even if the receiving code doesn’t. This approach can be used to mimic <a name="bookmark3955"></a>domain-specific languages (DSLs) in some situations. It can also be used to create a natural API for exploring data structures such as XML trees.</font></p>
<p><a name="bookmark3956"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Another<a name="bookmark3957"></a> feature of programming with dynamic languages </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">tends</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be an experimental style of programming using an appropriate interpreter, as I mentio<a name="bookmark3958"></a>ned earlier. This isn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">directly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> relevant to C# 4, but the fact that C# 4 can interoperate richly with dynamic languages running on the DLR (Dynamic Language Runtime) means that if you’re dealing with a problem that would benefit from this style, you’ll be able to use the results directly from C# instead of having to port it to C# afterward.</font></p>
<p><a name="bookmark3959"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3960"></a>We’ll look at these scenarios in more depth when we’ve learned the basics of C# 4’s dynamic abilities, so we can see more concrete examples. It’s worth briefly pointing out that if these benefits </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">don’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> apply to you, dynamic typing is more likely to be a hindrance than a help. Many developers won’t need to use dynamic typing much in their day-to-day coding, and even when it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> required, it may only be for a small part of the code. Just like any feature, it can be overused; in my view it’s usually worth thinking carefully about whether any alternative designs would allow static typing to solve the same problem elegantly. But I’m biased due to having a background in statically typed languages—it’s worth reading books on dynamically typed languages such as Python and Ruby to see a wider variety of benefits than the ones I present in this chapter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You’re probably getting anxious to see some real code by now, so we’ll just take a moment to get a brief overview of what’s going on, and then dive into some examples.</font></p>
<p><a name="bookmark391"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3961"></a><a name="bookmark3962"></a>14.1.3 How does C# 4 provide dynamic typing?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 4 introduces a new type called dynamic. The compiler treats this type differently than any normal CLR type.<sup><a name="footnote93"></a><a href="#bookmark3963">93</a></sup> Any expression that uses a dynamic value causes the compiler to change its behavior in a radical way. Instead of trying to work out </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> what the code means, binding each member access appropriately, performing overload resolution, and so on, the compiler just parses the source code to work out what </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">kind</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of operation you’re trying to perform, its name, what arguments are involved, and any other relevant information. Instead of emitting IL to execute the code directly, the compiler generates code that calls into the Dynamic Language Runtime with all the required information. The rest of the work is then performed at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In many ways this is similar to the different kinds of code generated by lambda expression conversions. These can either just result in code to perform the required actions (when converting to a delegate type) or result in code that builds a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">description </font><font style="font-size:x-small;font-family:Times New Roman, serif;">of the required a<a name="bookmark3964"></a>ctions (when converting to an expression tree). We’ll see later that expression trees are extremely important in the DLR, and in many cases the C# compiler will use expression trees to des<a name="bookmark3965"></a>cribe the code. (In the simplest cases where there’s nothing but a member invocation, there’s no need for an expression tree.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When the DLR comes to bind the relevant call at execution time, it goes through a complicated process to determine what should happen. This not only has to take in the normal C# rules for method overloads and so on, but also the possibility that the object itself will want to be part of the decision, as we saw in our FindByAuthor example earlier.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Most of this happens under the hood—the source code you write to use dynamic typing can be really simple.</font></p>
<p><a name="bookmark393"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3966"></a>14.2 The five-minute guide to dynamic</font></p>
<p><a name="bookmark3967"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Do you remember how many new bits of syntax were involved when you learned abou<a name="bookmark3968"></a>t LINQ? Well dynamic typing is just the opposite: there’s a single contextual keyword, dynamic, which you can use in most places where you’d use a type name. That’s all the new syntax that’s required, and the main rules about dynamic are easily expressed, if you don’t mind a bit of hand-waving to start with:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;An implicit conversion exists from almost any CLR type to dynamic.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;An implicit conversion exists from any expression of type dynamic to almost any CLR type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Expressions that use a value of type dynamic are usually evaluated dynamically.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The static type of a dynamically evaluated expression is usually deemed to be</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">dynamic.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The detailed rules are more complicated, as we’ll see in section 14.4, but for the moment let’s stick with the simplified version. The following listing provides a complete example demonstrating each point.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.1 Using dynamic to iterate through a list, concatenating strings</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic items = new List&lt;string&gt; { &quot;First&quot;, &quot;Second&quot;, &quot;Third&quot; }; dynamic valueToAdd = &quot;!&quot;; foreach (dynamic item in items)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string result = item + valueToAdd;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(result);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The result of listing 14.1 shouldn’t come as much of a surprise: it writes out “First!”, “Second!”, and “Third!”. We could easily have specified the types of the items and valueToAdd variables explicitly in this case, and it would all have worked in the normal way—but imagine that the variables are getting their values from other data sources instead of having them hardcoded. What would happen if we wanted to add an integer instead of a string? The next listing is just a slight variation, but note that we haven’t changed the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">declaration</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of valueToAdd; just the assignment expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.2 Adding integers to strings dynamically</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic items = new List&lt;string&gt; { &quot;First&quot;, &quot;Second&quot;, &quot;Third&quot; }; dynamic valueToAdd = 2;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (dynamic item in items)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string result = item + valueToAdd; Console.WriteLine(result);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This time the first result is “First2”—which is hopefully what you’d expect. Using static typing, we’d have to explicitly change the declaration of valueToAdd from string to int. The addition operator is still building a string, though. What if we changed the items to be integers as well? Let’s try that one simple change, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.3 Adding integers to integers</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic items = new List&lt;int&gt; {1, 2, 3};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic valueToAdd = 2; foreach (dynamic item in items)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string result = item + valueToAdd; Console.WriteLine(result);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Disaster! We’re still trying to convert the result of the addition to a string. The only conversions that are allowed are the same ones that are present in C# normally, so there’s no conversion from int to string. The result is an exception (at execution time, of course):</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Unhandled Exception:</font></p>
<p><a name="bookmark3969"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Microsoft.CSharp.RuntimeBinder.RuntimeBinderException:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Cannot implicitly convert type 'int' to 'string'</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">at CallSite.Target(Closure , CallSite , Object ) at System.Dynamic.UpdateDelegates.UpdateAndExecute1[T0,TRet]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(CallSite site, T0 arg0)</font></p>
<p><a name="bookmark3970"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3971"></a>Unless you’re perfect, you’re likely to encounter RuntimeBinderExcep<a name="bookmark3972"></a>tion a lot when you start using dynamic typing. It’s the new NullReferenceException, in some ways: you’re bound to come acro<a name="bookmark3973"></a>ss it, but with any luck it’ll be in the context of unit tests rather than customer bug reports. Anyway, we can fix it by changing the type of result to dynamic, so that the conversion isn’t required anyway. Come to think of it, why bother with the result variable in the first place? Let’s just call Console.WriteLine immediately. The following listing shows the changes.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.4 Adding integers to integers—but without the exception</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic items = new List&lt;int&gt; { 1, 2, 3 }; dynamic valueToAdd = 2; foreach (dynamic item in items)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(item + valueToAdd);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now this prints 3, 4, 5 as we’d expect. Changing the input data would now not only change the operator that was chosen at execution time—it would also change which</font></p>
<p><a name="bookmark3974"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3975"></a><a name="bookmark3976"></a>overload of Console.WriteLine was called. With the original data, it would call Console.WriteLine(string); with the updated variables, it would call Console. WriteLine (int). The data could even contain a mixture of values, making the exact call change on every iteration!</font></p>
<p><a name="bookmark3977"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You can use dynamic as the declared type for fields, parameters, and return typ<a name="bookmark3978"></a>es as well. This is in stark contrast to the use of var, which is restricted to local variables.</font></p>
<p><a name="bookmark3979"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3980"></a>DIFFERENCES BETWEEN var AND dynamic In many of the examples so far, when we’ve really known the types at compile time, we could’ve used var to declare the variables. At first glance, the two features look very similar. In both cases it looks like we’re declaring a variable without specifying its type— but using dynamic we’re explicitly setting the type to be dynamic. You can only use var when the compiler is able to infer the type you mean </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">statically</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and the type system really does remain entirely static.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, if you use var for a variable that’s initialized with an expression of type dynamic, the variable ends up being (statically) typed to be dynamic too. Given the confusion this could cause, I strongly recommend against it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler is smart about the information it records, and the code that the<a name="bookmark3981"></a>n </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">uses </font><font style="font-size:x-small;font-family:Times New Roman, serif;">that information at execution time is clever too: basically it’s a mini C# compiler in its own right. It uses whatever static type information was known at compile time to make the code behave as intuitively as possible. Other than a few details of what you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> do with dynamic typing, that’s all you really need to know in order to start using it in your own code. Later on we’ll come back to those restrictions, as well as details of what the compiler is actually doing—but first let’s see dynamic typing doing something genuinely </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">useful</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><a name="bookmark395"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3982"></a>14.3 Examples of dynamic typing</font></p>
<p><a name="bookmark3983"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark3984"></a>Dynamic<a name="bookmark3985"></a> typing is a bit like unsafe code, or interoperability with native code using P/Invoke. Many developers will have no need for it, or use it once in a blue moon. For other developers—particularly those dealing with Microsoft Office—it’ll give a huge productivity boost, either by making their existing code simpler or by allowing radically different approaches to their problems.</font></p>
<p><a name="bookmark3986"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This section isn’t meant to be exhaustive by any means, and I look forward to seeing innovati<a name="bookmark3987"></a>ve uses of dynamic typing from C# in the co<a name="bookmark3988"></a>ming years. Will unit testing and mocking take a big step forward with new frameworks? Will we see dynamic web service clients, accessing RESTful services with simple member access? I’m not going to make any predictions, other than that it’ll be an interesting area to keep can eye on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re going to look at three examples here: working with Excel, calling into Python, and using normal managed .NET types in a more flexible way.</font></p>
<p><a name="bookmark396"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark3989"></a>14.3.1 COM in general, and Microsoft Office in particular</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve already seen most of the new features C# 4 brings to COM interop, but there was one that we couldn’t cover in chapter 13 because we hadn’t seen dynamic typing</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">yet. If <a name="bookmark3990"></a>you choose to embed the interop types you’re using int<a name="bookmark3991"></a>o the assembly (by using the /l compiler switch, or setting the Embed Interop Types property to true) then anything in the API that would otherwise be declared as object is cha<a name="bookmark3992"></a>nged to dynamic. This makes it <a name="bookmark3993"></a>much easier to work with som<a name="bookmark3994"></a>ewhat weakly typed APIs such as those exposed by Office. (Although the object model in Office is reasonably strong in itself, many properties are exposed as </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">variants</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> because they can deal with numbers, strings, dates, and so on.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Again, I’ll just show you a short example here—one that does even less than the Word example in chapter 13. The dynamic aspect is easy to understand fro<a name="bookmark3995"></a>m this one scenario. We’re going to set the first 20 cells of the top row of a new Excel worksheet to the numbers 1 to 20. The following listing shows an initial, statically typed piece of code to achieve this.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.5 Setting a range of values with static typing</font></p>
<p><a name="bookmark3996"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var app = Application { Visible = true }; app.Workbooks.Add();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Works<a name="bookmark3997"></a>heet worksheet = (Worksheet) app.ActiveSheet;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Range start = (Range) worksheet.Cells[1, 1];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Range end = (Range) worksheet.Cells[1, 20];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">worksheet.Range[start, end].Value = Enumerable.Range(1, 20)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.ToArray();</font></p>
<p><a name="bookmark3998"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">This time we’ve imported the Microsoft. Office. Interop .Excel namespace—so the Application type refers to Excel, not Word. We’re still using the new features of C# 4, by not specifying an argument for the optional parameter in the Workbooks.Add() call while we’re setting things up O and also by using a named indexer Q. When Excel is up and running, we work out the start and end cells of our overall range. In this case they’re both on the same row, but we could’ve created a rectangular range instead by selecting two opposite corners. We </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have created the range in a single call to Range[&quot;A1:T1&quot; ] but I personally find it easier to work with numbers consistently. Cell names like B3 are great for humans, but harder to use in a progr<a name="bookmark3999"></a>am.</font></p>
<p><a name="bookmark4000"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Once we have the range, we set all the values in it by setting the Value property with an array of integers G. We can use a one-dimensional array, as we’re only setting a single row; to set a range spanning multiple rows we’d need to use a rectangular array. This all wo<a name="bookmark4001"></a>rks, but we’ve had to <a name="bookmark4002"></a>use three casts in six lines of code. The indexer we call via Cells and the ActiveSheet property are both declared to return object normally. (Various parameters are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> declared as typ<a name="bookmark4003"></a>e object, but that doesn’t <a name="bookmark4004"></a>matter as much because there’s an implicit conversion from any nonpointer type to object—only coming the other way requires the cast.) For simplicity’s sake I haven’t closed Excel at the end of the listing—it’s easier to just see the open worksheet than to save it to a file in code, close the application, and then load up the file separately to check that it’s worked.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With the primary interop assembly set to e<a name="bookmark4005"></a>mbed the required types into our own binary, all of these examples become dynamic. With the implicit conversion from dynamic to other types, we canjust remove all the casts, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.6 Using implicit conversions from dynamic in Excel</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var app = new Application { Visible = true }; app.Workbooks.Add();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Worksheet worksheet = app.ActiveSheet;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Range start = worksheet.Cells[1, 1];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Range end = worksheet.Cells[1, 20];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">worksheet.Range[start, end].Value = Enumerable.Range(1, 20)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.ToArray();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is exactly the same code as listing 14.5 but without the casts. But it’s worth noting that the conversions are still checked at execution time. If we changed the declaration of start to be Worksheet, the conversion would fail and an exception would be thrown. Of course, you don’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to perform the conversion. You </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> just leave everything as dynamic, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.7 Using dynamic everywhere</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var app = new Application { Visible = true }; app.Workbooks.Add();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic worksheet = app.ActiveSheet; dynamic start = worksheet.Cells[1, 1]; dynamic end = worksheet.Cells[1, 20];</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">worksheet.Range[start, end].Value = Enumerable.Range(1, 20)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.ToArray();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Which is clearer? I’m an old-fashioned static typing fan, so I prefer the previous version. It states the types I expect on each line, so if there are any problems, I get to find out immediately rather than waitin<a name="bookmark4006"></a>g until I try to use a value in a way that may not be supported. In terms of productivity when initially developing, there are pros and cons both ways. Using dynamic, I don’t need to work out which particular type I really expect; I can just use the value and so long as all the n<a name="bookmark4007"></a>ecessary operations are supported, I’m okay. On the <a name="bookmark4008"></a>other hand, using static typing I can see what’s available at every stage via IntelliSense. We’re still using dynamic typing to provide the implicit conversion to Worksheet and Range—we’re just using it for one step at a time rather than wholesale. The change from static typing to dynamic may not look like much to start with because the example is relatively simple—but as the complexity of the code increases, so does the readability benefit of removing all those casts.</font></p>
<p><a name="bookmark4009"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In some ways this has all been a blast from the past—COM is a relatively old technology. Now we’re going to jump to interoperating with something much more recent: IronPython.</font></p>
<p><a name="bookmark397"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4010"></a><a name="bookmark4011"></a>14.3.2 Dynamic languages such as IronPython</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In this section I’m only going to use IronPython as an example, but of course that’s not the only dynamic language available for the DLR. It’s arguably the most mature, but there are already<a name="bookmark4012"></a> alternatives such as IronRuby and IronScheme. <a name="bookmark4013"></a>One of the stated aims of the DLR is to make it easier for budding language designers to create a working language that has good interoperability with other DLR languages and the traditional .NET languages such as C#, as well as access to the huge .NET framework libraries.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">WHY WOULD I WANT TO USE IRONPYTHON FROM C#?</font></p>
<p><a name="bookmark4014"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are many reasons you might want to interoperate with a dynamic language, just as it’s been beneficial to interoperate with other managed languages from .NET's infancy. It’s clearly useful for a VB developer to be able to use a class library written in C# and vice ve<a name="bookmark4015"></a>rsa—so why would the same not be true of dynamic languages? I asked Michael Foord, the author of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Iron Python in Action,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to come up with a few ideas for using IronPython within a C# application. Here’s his list:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;User scripting</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Writing a layer of your applicati<a name="bookmark4016"></a>on in IronPython</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Using Python as a configuratio<a name="bookmark4017"></a>n language</font></p>
<p><a name="bookmark4018"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4019"></a>■ &nbsp;&nbsp;&nbsp;Using Python as a rules engine with rules stored as text (even in a database)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Using a library that’s avai<a name="bookmark4020"></a>lable in Python, but has no similar .<a name="bookmark4021"></a>NET equivalent</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Putting a live interpreter into your application for debugging</font></p>
<p><a name="bookmark4022"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’re still skeptical, you might want to consider that embeddin<a name="bookmark4023"></a>g a scripting language in a mainstream application is far from uncommon—Sid Meier’s Civilization IV computer game<sup><a name="footnote94"></a><a href="#bookmark4024">94</a></sup> is scriptable with Python. This isn’t just an afterthought for modifications, either—a lot of the core gameplay is written in Python. Once they’d built the engine, the developers found it to be a more powerful development environment than they’d originally imagined.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For this chapter, I’m going to pick the single example of using Python as a configuration language. Just as with the COM example, I’m going to keep it simple, but hopefully it’ll provide enough of a starting point for you to experiment more with it if you’re interested.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">GETTING STARTED: EMBEDDING “HELLO, WORLD”</font></p>
<p><a name="bookmark4025"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4026"></a>There are various types available if you want to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">host</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> or </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">embed</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> another language within a C# application, depending on the leve<a name="bookmark4027"></a>l of flexibility and control you want to achieve. We’re only going to use ScriptEngine and ScriptScope, because our requirements are primitive. In our example, we know we’re always going to use Python, so we can ask the IronPython framework to cr<a name="bookmark4028"></a>eate a ScriptEngine directly; in more general situations you can use a ScriptRuntime to pick language implementations dynamica<a name="bookmark4029"></a>lly by name. More <a name="bookmark4030"></a>demanding scenarios may require you to work with ScriptHost and ScriptSource, as well as using more of the features of the other types, too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Not content with merely printing “hello, world” once, our initial example will do so </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">twice,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> first by using text passed directly into the engine as a string, and then by loading a file called HelloWorld.py. Listing 14.8 shows everything you need.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.8 Printing “hello, world” twice using Python embedded in C#</font></p>
<p><a name="bookmark4031"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a name="bookmark4032"></a>ScriptEngine engine = Python.CreateEngine(); engine.Execute(&quot;print 'hello, world'&quot;); engine.ExecuteFile(&quot;HelloWorld.py&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may find this listing either quite dull or very exciting, both for the same reason. It’s simple to understand, requiring little explanation. It does little, in terms of actual output... and yet the fact that it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> so easy to embed Python code into C# is a cause for celebration. True, our level of interaction is somewhat minimal so far—but it really couldn’t be much easier than this.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">PYTHON’S MANY STRING LITERAL FORMS The Python file contains a single line: print &quot;hello, world&quot;—note the <a name="bookmark4033"></a>double quotes in the file compared with the single quotes in the string literal we passed into engine.Execute(). Either would’ve been fine in ei<a name="bookmark4034"></a>ther source. Python has various string literal representations, including triple single quotes or triple double quotes for mul<a name="bookmark4035"></a>tiline literals. I only mention this because it’s useful not to have to escape double quotes any time you want to put Python code into a C# string literal.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The next type we need is ScriptScope, which will be crucial to our configuration script.</font></p>
<p><a name="bookmark4036"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">STORING AND RETRIEVING INFORMATION FROM A SCRIpTSCOpE</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The <a name="bookmark4037"></a>execution methods we’ve used both have overloads with a second parameter—a scope. In its simplest terms, this can be regarded as a dictionary of names and values. Scripting languages often allow variables to be assigned without any explicit declaration, and when this is done in the to<a name="bookmark4038"></a>p level of a program (instead of in a function or class), this usually affects a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">global scope.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> When a ScriptScope instance is passed into an execution method, that is used as the global scope for the script you’ve asked the engine to execute. The script can retrieve existing values from the scope and create new values, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.9 Passing information between a host and a script using ScriptScope</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string python = @&quot; text = 'hello' output = input + 1</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ScriptEngine engine = Python.CreateEngine(); ScriptScope scope = engine.CreateScope(); scope.SetVariable(&quot;input&quot;, 10); engine.Execute(python, scope);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(scope.GetVariable(&quot;text&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(scope.GetVariable(&quot;input&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(scope.GetVariable(&quot;output&quot;)),</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve embedded the Python source code into the C# code as a verbatim string literal </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">rather than putting it in a file, so that it’s easier to see all the code in one place. I don’t <a name="bookmark4039"></a>recomme<a name="bookmark4040"></a>nd that you do t<a name="bookmark4041"></a>his in production code, partly because Python is sensitive to whitespace—reformatting the code in a seemingly harmless way can make it fail completely at execution t<a name="bookmark4042"></a>ime.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The SetVariable and GetVariable methods simply put values into the scope Q and fetch them out again G in the obvious way. They’re declared in terms of object rather than dynamic, a<a name="bookmark4043"></a>s you might’ve expected. B<a name="bookmark4044"></a>ut GetVariable also allows you to specify a type argument, which acts as a conversion request. This isn’t quite the s<a name="bookmark4045"></a>ame as just casting the result of the non<a name="bookmark4046"></a>generic method, as the latter just unboxes the value—which means you need to cast it to exactly the right type. For example, we can put an integer into the scope, but retrieve it as a double:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">scope.SetVariable(&quot;num&quot;, 20)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">double x = scope.GetVariable&lt;double&gt;(&quot;num&quot;) double y = (double) scope.GetVariable(&quot;num&quot;);</font></p>
<p><a name="bookmark4047"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4048"></a>The first call succeeds: we’re explicitly telling GetVariable what type we want O, so it knows to coerce the value appropriately. The second call Q will throw an Invalid-CastException, just as it would in any other situation where you try to unbox a value using the wrong type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The scope can also hold functions, which we can retrieve and then call dynamically, passing arguments and returning values. The easiest way of doing this is to use the dynamic type, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.10 Calling a function declared in a ScriptScope</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string python = @&quot; def sayHello(user):</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">print 'Hello %(name)s' % {'name' : user}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ScriptEngine engine = Python.CreateEngine();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ScriptScope scope = engine.CreateScope(); engine.Execute(python, scope);</font></p>
<p><a name="bookmark4049"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic function = scope.GetVariable(&quot;sayHello&quot;); function(&quot;Jon&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Configuration files may not often need this ability, but it can be<a name="bookmark4050"></a> useful in other situations. For example, you could easily use Python to script a graph-drawing program by providing a function to be called on each input point. A simple example of this can be found on the book’s website at <a href="http://mng.bz/6yGi">http://mng.bz/6yGi</a>. There are a <a name="bookmark4051"></a>number of situations in which it’s useful to have some sort of expression evalu<a name="bookmark4052"></a>ator running user code entered at execution time, such as evaluating business rules for discounts, shipping costs, and so on. It c<a name="bookmark4053"></a>an be useful<a name="bookmark4054"></a> to be able to change these rules in text form without having to recompile or redeploy binaries. Listing 14.10 is quite tame—another example in the downloadable source code weaves in and out of the two languages rather more tortuously, showing that the calls can go both ways: from C# to IronPython as we’ve seen, and from IronPython to C#.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">PUTTING IT ALL TOGETHER</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we can get values into our scope, we’re essentially done. We could potentially wrap the scope in another object providing access via an indexer—or even access the values dynamically using the techniques shown in section 14.5. The application code might look something like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static Configuration LoadConfiguration()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ScriptEngine engine = Python.CreateEngine();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ScriptScope scope = engine.CreateScope(); engine.ExecuteFile(&quot;configuration.py&quot;, scope); return Configuration.FromScriptScope(scope);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark4055"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The exact form of the Configuration type will depend on your application, but it’s unlikely to be terribly exciting code. I’ve provided a sample dynamic implementation in the full source, which allows you to retrieve values as properties and call functions directly too. Of course we’re not limited to just using primitive types in our configuration: the Python code could be arbitrarily complex, building collections, wiring up components and servi<a name="bookmark4056"></a>ces, and so forth. It coul<a name="bookmark4057"></a>d perform a lot of the roles of a normal Dependency Injection or Inversion of Control container.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The important thing is that<a name="bookmark4058"></a> we now <a name="bookmark4059"></a>have a configuration file which is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">active</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> instead of the traditional passive XML and .ini files. Of course, you could’ve embedded your own programming language into previous configuration files, but the result would probably have been less powerful, and would’ve taken a lot more effort to implement. As an example of where this could be useful in a simpler situation than full dependency injection, you might want to configure the number of threads to use for some background processing component in your application. You might normally use as many threads as you have processors in the system, but occasionally reduce it in order to help another application run smoothly on the same system. The configuration file would simply change from something like this</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">agentThreads = System.Environment.ProcessorCount agentThreadName = 'Processing agent'</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">to this</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">agentThreads = 1</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">agentThreadName = 'Processing agent (single thread only)'</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This change wouldn’t require the application to be rebuilt or redeployed—just edit the file and re<a name="bookmark4060"></a>start the application. <a name="bookmark4061"></a>Particularly smart applications could even choose to reconfigure themselves on the fly. (I’ve usually found that this ability is more painful to implement than the extra value it br<a name="bookmark4062"></a>ings, but in certain places it can make a big difference. The ability to change logging levels either for a particular bit of code or even just a specific user who’s having difficulties can make debugging much easier.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Other than executing functions, we haven’t really looked at using Python in a particularly dynamic way. The full power of Python is available, and u<a name="bookmark4063"></a>sing the dynamic type in your C# code you can take advantage of metaprogramming and all the other</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">dynamic features. The C# compiler is responsible for representing your code in an appropriate fashion, and the script engine is responsible for taking that code and working out what it means for Python. Just don’t feel you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be doing anything particularly clever for it to be worth embedding the script engine in your application. It’s a simple step toward a more powerful application.</font></p>
<p><a name="bookmark4064"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><a name="bookmark4065"></a>HOW MUCH POWER DO YOU WANT TO GIVE TO YOUR SCRIPT AUTHORS? </font><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’re executing arbitrary code, particularly code entered by external users of the system, you should think seriously about security, and possibly run the script in some sort of sandboxed environment. Discussion of this topic is outside the scope of this book, but it needs to be considered carefully.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far our examples have been interoperating with other systems. Dynamic typing can make sense even within a purely managed system, though. Let’s visit a few examples.</font></p>
<p><a name="bookmark398"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4066"></a>14.3.3 Dynamic typing in purely managed code</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You’ve almost certainly used something </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">like</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> dynamic typi<a name="bookmark4067"></a>ng in the past, even if it wasn’t your own code that had to do the work. Data binding is the simplest example of this—any time you specify something like ListControl.DisplayMember, you’re asking the framework <a name="bookmark4068"></a>to find a property at execution time based on its name. If you’ve ever used reflection directly in your own code, you’re again using information that’s only available at execution time.</font></p>
<p><a name="bookmark4069"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In my experience, reflection is <a name="bookmark4070"></a>error prone, and even when it works you may need to put in extra effort to optimize it. In some cases, dynamic typing can completely replace that reflection-based code; it may be faster too depending on exactly what you were doing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s particularly tricky to use generic types and methods from reflection. For instance, if you have an object which you know implements IList&lt;T&gt; for some type argument T, it can be difficult to work out exactly what T is. If the only reason for discovering T is to then call another generic method, you really want to just ask the compiler to call whatever it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">would</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have called if you knew the actual type. Of course, that’s exactly what dynamic typing does. I’ll use this scenario as our first example.</font></p>
<p><a name="bookmark4071"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">EXECUTION-TIME TYPE INFERENCE</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you want to do more than just call a single method, it’s often best to wrap all the additional work in a generic method. You can then call the generic method dynamically, but write all the rest of the code using static typing. Listing 14.11 shows a simple example of this. We’re going to pretend we’ve been given a list of some type and a new element by some other part of the system. We’ve been promised that they’re compatible, but we don’t know their types statically. The<a name="bookmark4072"></a>re are various reasons this could hap-pen—this could be the result of deserialization elsewhere, for example. Anyway, our code is meant to add the new element to the end of the list, but only if there are fewer than 10 elements in the list at the moment. The method returns whether or not the element was actually added. Obviously in real life the business logic would be more complicated, but the point is that we’d really like to be able to use the strong types for</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">these operations. The following listing shows the statically typed method, and the dynamic call into it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.11 Using dynamic type inference</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static bool AddConditionallyImpl&lt;T&gt;(IList&lt;T&gt; list, T item) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (list.Count &lt;&nbsp;10)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">list.Add(item); return true;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return false;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static bool AddConditionally(dynamic list, dynamic item) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return AddConditionallyImpl(list, item);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object list = new List&lt;string&gt; { &quot;x&quot;, &nbsp;&nbsp;&nbsp;&quot;y&quot; &nbsp;&nbsp;&nbsp;};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object item = &quot;z&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">AddConditionally(list, item);</font></p>
<p><a name="bookmark4073"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The public method has dynamic parameters: in previous versions of C# it would perhaps have taken IEnumerable and Object, relying on complicated checks with reflection to work out the type of the list and then invoke the generic method with reflection. With dynamic typing, we can just call a strongly typed implementation O using the dynamic arguments Q, isolating the dynamic access to the single call in the wrapper method. Of course the call could still fail—but we’ve been saved the effort of trying to determine the appropriate type argument.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We could also expose the strongly typed method publicly to avoid the dynamic<a name="bookmark4074"></a> typing for callers who knew their list types statically. It’d be worth keeping the names different in that case, to avoid accidentally calling the dynamic version due to a slight mistake with the static types of the arguments. (It’s also a lot easier to make the right call within the dynamic version when the names are different!)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As another example of dynamic t<a name="bookmark4075"></a>yping in purely managed code, I’ve already bemoaned the lack of generic operator support in C#. There’s no concept of specifying a constraint saying “T must have an operator that allows me to add two values of type T together.” We used this in our initial demonstration of dy<a name="bookmark4076"></a>namic typing, so mentioning it here should come as no surprise. Let’s take the Sum query operator from LINQ and make it dynamic.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">COMpENSATING FOR THE LACK OF GENERIC OpERATORS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Have you ever looked at the list of overloads for Enumerable .Sum? It’s pretty long. Admittedly half of the overloads are due to a projection, but even so there are 10 overloads, each of which just takes a sequence of elements and adds them together... and that doesn’t even cover summing unsigned values, or bytes or shorts. Why don’t we use dynamic typing to try to do it all in one method?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even though we’ll use dynamic typing internally, the method shown in listing 14.12 is statically typed—though we could’ve declared it as a nongeneric method summing an IEnumerable&lt;dynamic&gt;, that doesn’t work well due to the limitations of covariance. I’ve named the method DynamicSum rather than Sum to avoid clashing with the methods in Enumerable. The compiler will pick a nongeneric overload over a generic one where both signatures have the same parameter types, and it’s simpler to avoid the collision in the first place.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.12 Summing an arbitrary sequence of elements dynamically</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static T DynamicSum&lt;T&gt;(this IEnumerable&lt;T&gt; source)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic total = default(T);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (T element in source)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">total = (T) (total + element);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return total;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">byte[] bytes = new byte[] { 1, 2, 3 };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(bytes.DynamicSum());</font></p>
<p><a name="bookmark4077"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The code is mostly straightforward: it looks almost exactly the same as any of the implementations of the normal Sum overloads would. I’ve omitted checking whether source is null just for brevity, but most of the rest is simple enough. There are a couple of interesting points.</font></p>
<p><a name="bookmark4078"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">First, we use default(T) to initialize total, which is declared as dynamic so that we get the desired dynamic behavior O. We have to start off with an initial value somehow: we could try to use the first value in the sequence, but then we’d be stuck if the sequence were empty. For non-nullable value types, default(T) is almost always an appropriate value anyway: it’s a natural z<a name="bookmark4079"></a>ero. For reference types, we’ll end up adding the first element of the sequence to null, which may or may not be appropriate. For nullable value types, we’ll end up trying to add the first element to the null value for that type, which certainly <a name="bookmark4080"></a></font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">won’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be appropriate.</font></p>
<p><a name="bookmark4081"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Second, we’re casting the result of the addition back to T, even though it’s then being assigned to a dynamic variable. This may seem odd, but you need to think about the results of summing two bytes together: the C# c<a name="bookmark4082"></a>ompiler would normally promote each operand to int before performing the addition. Without the cast, the total variable would end up storing an int value, which would then cause an exception when the return statement attempted to convert it back to byte.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Both of these points lead to deeper questions, but that’s not the point of this section. I’ve written up a more detailed investigation of dynamic summation on the book’s website (see <a href="http://mng.bz/0N37">http://mng.bz/0N37</a>). Just to prove that it’s capable of more than arit<a name="bookmark4083"></a>hmetic on normal numbers, listing 14.13 shows an example of summing TimeSpan values.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.13 Summing a list of TimeSpan elements dynamically</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var times = new List&lt;TimeSpan&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">2.Hours(), 25.Minutes(), 30.Seconds(),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">45.Seconds(), 40.Minutes()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(times.DynamicSum());</font></p>
<p><a name="bookmark4084"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The TimeSpan values are created using extension methods for convenience, but the summation is entirely dynamic, resulting in a total span of 3 hours, 6 minutes, and 15 seconds.</font></p>
<p><a name="bookmark4085"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">DUCK TYPING</font></p>
<p><a name="bookmark4086"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Sometimes you know that a member with a particular name will be available at execution time, but you can’t tell the compiler exactly which member you’re talking about because it’ll depend on the type. In some ways this is a more general example of the same problem that we’ve just solved, except using normal methods and properties instead of operators.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There is a differe<a name="bookmark4087"></a>nce: usually you’d try to capture the commonality in an interface or abstract base class. You can’t do this with operators, but it’s the normal approach for methods a<a name="bookmark4088"></a>nd properties. Unfortunately it doesn’t always work—particularly if multiple libraries are involved. The .NET framework is mostly consistent here, but we’ve already seen one example where it doesn’t quite work. In chapter 12 we looked at the optimizations available for counting a sequence, and saw that both ICollection and ICollection&lt;T&gt; have a Count property—but they have no common ancestor interface with that property, so you have to ha<a name="bookmark4089"></a>ndle them separately.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Duck typing lets you just access Count without performing the type checking yourself, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.14 Accessing a Count property with duck typing</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void PrintCount(IEnumerable collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic d = collection; int count = d.Count;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(count);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintCount(new BitArray(10));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintCount(new HashSet&lt;int&gt; { 3, 5 });</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintCount(new List&lt;int&gt; { 1, 2, 3 });</font></p>
<p><a name="bookmark4090"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Our method is restricted to implementations of IEnumerable for the same reason that collection initializers are: it’s a pretty good indication that the Count property we end up using is an appropriate one. The test collections are a BitArray (which only implements ICollection), a HashSet&lt;int&gt; (which only implements ICollection&lt;int&gt;), and a List&lt;int&gt; (which implements both). In all cases, the correct property is found at execution time.</font></p>
<p><a name="bookmark4091"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">EXPLICIT INTERFACE IMPLEMENTATION AND DYNAMIC DON’T MIX WELL </font><font style="font-size:x-small;font-family:Times New Roman, serif;">When I first tried to test this code, I used an int [] —which is implicitly convertible to both of the interfaces involved. I was therefore surprised when the Print-Count method failed at execution time... until I thought about it more closely.</font></p>
<p><a name="bookmark4092"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The execution-time binding is performed using the actual type of the object, which in this case is an int[]. Array types don’t publicly expose a Count property—they use explicit interface implementation for that. You can only use Count when you view an array object in a particular way.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is just one example where dynamic typing can behave in a way which is logical but can be unexpected unless you’re careful. I’m collecting an ongoing list of such oddities on the website (see <a href="http://mng.bz/5y7M">http://mng.bz/5y7M</a>); please let me know if you find any new ones.</font></p>
<p><a name="bookmark4093"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re going to stick with the example of retrieving the count of items, but this time we’ll look at how execution-time overload resolution can offer an alternative to explicit type testing.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">MULTIpLE DISpATCH</font></p>
<p><a name="bookmark4094"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">With static typing, C# uses </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">single dispatch:</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> at execution, the exact method call<a name="bookmark4095"></a>ed only depend<a name="bookmark4096"></a>s on the actual type of the target of the method call, through overriding. Overloading is decided at compile time. Occasionally </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">multiple dispatch</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is useful to find the most specialized implementation of a method based on the execution-time types of the arguments—again, this is what dynamic typing provides. The following listin<a name="bookmark4097"></a>g demonstrates how multiple dispatch would allow for a more varied and more robust implementation of optimised counting.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.15 Counting different types efficiently using multiple dispatch</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static int CountImpl&lt;T&gt;(ICollection&lt;T&gt; collection) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return collection.Count;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static int CountImpl(ICollection collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return collection.Count;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static int CountImpl(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return text.Length;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static int CountImpl(IEnumerable collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int count = 0;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (object item in collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">count++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return count;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static void PrintCount(IEnumerable collection)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic d = collection;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int count = Countlmpl(d);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(count);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintCount(new BitArray(5));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintCount(new HashSet&lt;int&gt; { 1, 2 });</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintCount(&quot;ABC&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">PrintCount(&quot;ABCDEF&quot;.Where(c =&gt; c &gt;&nbsp;'B'));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We know that at least one overload of Countlmpl will be appropriate at execution time as the parameter for PrintCount is of type IEnumerable. We rely on dynamic typing to perform the same job as the explicit “if it’s an ICollection&lt;T&gt;, use this implementation; if it’s an ICollection, use this implementation” steps we used when picking a random element in listing 12.17. As an example of how this is more than just using the Count property if it’s available, I’ve included an optimization for strings, where we can use the Length property to obtain the right result quickly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even using multiple dispatch here, we could still run into problems at execution time: what if the actual type implemented both ICollection&lt;string&gt; and ICollection&lt;int&gt; via explicit interface implementation? There would be two possible results based on whic<a name="bookmark4098"></a>h Count implementation was picked. In this case, the binding <a name="bookmark4099"></a>would be ambiguous, leading to an exception. Fortunately such pathological cases are likely to be rare.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">These are just a few examples of areas where you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">might</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> want to use dynamic typing even if you’re not trying to interoperate with anything else. As I mentioned at the <a name="bookmark4100"></a>start of this section, it’ll be worth keeping an eye on how the development community uses dynamic typin<a name="bookmark4101"></a>g within C#. I expect to see some innovative approaches, ranging from the utterly evil to the insanely brilliant.<sup><a name="footnote95"></a><a href="#bookmark4102">95</a></sup> Next we’re going to delve into how all these effects are achieved, before we finish off the chapter by implementing our own dynamic behavior.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I<a name="bookmark4103"></a> should warn you that things are about to get tricky. In fact, it’s all extremely elegant, but it’s complicated because programming languages provide a rich set of operations, and representing all the necessary information about those operations as data and then acting on it appropriately is a complex job. The good news is that you don’t need to understand it all intimately. As ever, you’ll get more out of dynamic typing the more familiar you are with the machinery behind it, but even if you just use the techniques<a name="bookmark4104"></a> we’ve seen so far, there may be situations where it makes you a lot more productive.</font></p>
<p><a name="bookmark400"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4105"></a>14.4 Looking behind the scenes</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Despite the warning of the previous paragraph, I’m won’t go into </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">huge</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> amounts of detail about the inner workings of dynamic typing. There would be a lot of ground to cover, both in terms of the framework and language changes. It’s not often that I shy away from the nitty-gritty of specifications, but in this case I truly believe there’s not much to be gained from learning it all. I’ll cover th<a name="bookmark4106"></a>e most important (and interesting) points, and I can thoroughly recommend Sam Ng’s blog (<a href="http://mng.bz/ulV1">http://mng.bz/ulV1</a>), the C# language specification, and the DLR project page (see <a href="http://mng.bz/0M6A">http://mng.bz/0M6A</a>) for more information if you need to dig into a particular scenario.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our eventual goal is to understand what the C# compiler is doing—the code it emits to achieve dynamic binding at execution time. Unfortunately, none of the generated code will make any sense until we see the mechanism that underpins it all—the DLR. You might like to think of a statically typed program as a conventional stage play with a fixed script, and a dynamically typed program as more like an improvisation show. The DLR takes the place of the actors’ brains frantically coming up with something to say in response to audience suggestions. Let’s meet our quick-thinking star performer.</font></p>
<p><a name="bookmark401"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4107"></a><a name="bookmark4108"></a>14.4.1 Introducing the Dynamic Language Runtime</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve been bandying the acronym </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">DLR</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> around for a while now, occasionally expanding it to Dynamic Language Runtime but never explaining what it is. This has been deliberate: I’ve been trying to get across the nature of dynamic typing and how it affects developers, rather than the details of the implementation. But that excuse was never going to last until the end of the cha<a name="bookmark4109"></a>pter, so here we are. In its barest terms, the Dynamic Language Runtime is a library which all dynamic languages and the C# compiler use to execute code dynamically.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Amazingly enough, it really is just a library. Despite its name, it isn’<a name="bookmark4110"></a>t at the same level a<a name="bookmark4111"></a>s the CLR (Co<a name="bookmark4112"></a>mmon Language Ru<a name="bookmark4113"></a>ntime)—it doesn’t deal in JIT compilation, native API marshalling, garbage collection, and so forth.<a name="bookmark4114"></a> But it builds on a lot of the work in .NET 2.<a name="bookmark4115"></a>0 and 3.5, particularly the DynamicMethod and Expression types. The expression tree API has been expanded in .NET 4 to allow the DLR to express more concepts, too. Figure 14.1 shows how it all fits together.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In addition to the DLR, figure 14.1 shows another library that may be new to you. One of the assemblies in the Binders part of the diagram is Micrsoft.CSharp. It contains a number of types that are referenced by the C# compiler when you use dynamic in your code. Confusingly, this doesn’t include <a name="bookmark4116"></a>the existing Microsoft.CSharp. Compiler and Microsoft.CSharp.CodeDomProvider. (They’re not even in the same assembly as each other!) We’ll see exactly what the new types are used for in section 14.4.2, where we decompile some code written using dynamic.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One other important aspect diff<a name="bookmark4117"></a>erentiates the DLR from the rest of the .NET framework: it’s provided as open source. The complete code lives in a CodePlex project (<a href="http://dlr.codeplex.com">http://dlr.codeplex.com</a>), so you can download it and see the inner workings. One</font></p><img src="images/56.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 14.1 How the components of .NET 4 fit together, allowing static and dynamic languages to execute on the same underlying platform</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">of the<a name="bookmark4118"></a> benefits of this approach is that the DLR hasn’t had to be reimplemented for Mono (<a href="http://mono-project.com">http://mono-project.com</a>): the same code runs on both .NET and its crossplatform cousin.</font></p>
<p><a name="bookmark4119"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Although the DLR doesn’t handle native code directly, you ca<a name="bookmark4120"></a>n think of it as doing a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">similar</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> job to the CLR in one sense: just as the CLR converts IL (Intermediate Language) into<a name="bookmark4121"></a> native code, the DLR converts code represented using binders, call sites, meta-objects, and various other concepts into expression trees which can then be compiled down into IL and eventually native code by the CLR. Figure 14.2 shows a simplified view of the lifecycle of a single evaluation of a dynamic expression.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As you can see, one of the important aspects of the DLR is a multilevel cache. This is crucial for performance reasons, but to understand that and the other concepts we’ve already mentioned, we’ll need to dive one layer lower.</font></p>
<p><a name="bookmark402"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4122"></a>14.4.2 DLR core concepts</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We can summarize the purpose of the DLR in </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> general terms as taking a high-level representation of code and executing that code, based on various pieces of information that may only be known at execution time. In this section I’m going to introduce a lot of terminology to describe how the DLR works, but it’s all contributing to that common aim.</font></p><img src="images/57.png"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Figure 14.2 Lifecycle of a dynamic expression</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CALL SITES</font></p>
<p><a name="bookmark4123"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The first concept we need is a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">call site.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> This is sort of the atom of the DLR—the smallest piece of code that can be considered as a single executable unit. One expression may contain a lot of call sites, but the behavior is built up in the natural way, evaluating one call site at a time. For the rest of the discussion, we’ll only consider a single call site. It’s going to be useful to have a small example of a call site to refer to, so here’s a simple one, where d is of course a variable of type dynamic:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">d.Foo(10);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The cal<a name="bookmark4124"></a>l site is represented in code as a System.Runtime.CompilerServices.Call-Site&lt;T&gt;. We’ll see a full example of how call sites are created and used in the next section, when we look at what the C# compiler does at compile time, but here’s an example of the code which might be called to create the site for the previous snippet:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CallSite&lt;Action&lt;CallSite, object, int&gt;&gt;.Create(Binder.InvokeMember( CSharpBinderFlags.ResultDiscarded, &quot;Foo&quot;, null, typeof(Test), new CSharpArgumentInfo[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.Constant |</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CSharpArgumentInfoFlags.UseCompileTimeType, null) }));</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So now that we have a call site, can we execute the code? Not quite.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">RECEIVERS AND BINDERS</font></p>
<p><a name="bookmark4125"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">As well as a call site, we need something to decide what<a name="bookmark4126"></a> it means and how to execute it. In the DLR, two entities can decide this: the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">receiver</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of a call and the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">binder.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> The receiver of a call is simply the object that a member is called on. In our sample call site, the receiver is the object that d refers to at execution time. The binder will depend on the calling language, and is part of the call site—in this case, we can see that the C# compiler emits code to create a binder using Binder.InvokeMember. The Binder class in this case is Microsoft.C<a name="bookmark4127"></a>Sharp.RuntimeBinder.Binder, so it really is C#-specific. The C# binder is also C<a name="bookmark4128"></a>OM-aware, and will perform appropriate COM binding if the receiver is an IDispatch object.</font></p>
<p><a name="bookmark4129"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The DLR always gives precedence to the receiver: if it’s a dynamic object that knows how to handle the call, then it’ll use whatever execution path the object provides. An object can advertise itself as being dynamic by implementing the new IDynamicMeta-ObjectProvider int<a name="bookmark4130"></a>erface. The name is a mouthful, but it only contains a single member: GetMetaObject. You’ll need to be an expression tree ninja to implement it correctly, as well as knowing the DLR quite well. But in the right hands this can be a powerful tool, giving you lower-level interaction with the DLR and it<a name="bookmark4131"></a>s execution cache. If you need to implement dynamic behavior in a high-performance fashion, it’s worth the investment of learning the details. There are two public implementations of IDynamicMetaObjectProvider included in the framework to make it easy to implement dynamic behavior in situations where performance isn’t quite as critical. We’ll look at all of this in more detail in section 14.5, but for now you just need to be aware of the interface itself, and that it represents the ability of an object to react dynamically.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If the receiver isn’t dynamic, the binder gets to decide how the code should be executed. In our code, it would apply C#-specific rules to the code and work out what to do. If you were creating your own dynamic language, you could implement your own binder to decide how it should behave in general (when the object doesn’t override the behavior). This lies well beyond the scope of this book, but it’s an interesting topic in and of itself: one of the aims of the DLR is to make it easier to implement your own languages.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">RULES AND CACHES</font></p>
<p><a name="bookmark4132"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The decision for how to execute a call is represented as a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">rule.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Fundamentally this consists of two elements of logic: th<a name="bookmark4133"></a>e circumstances under which the call site should behave this way, and the behavior itself. The first part is really for optimization. Suppose you have a call site that represents addition of two dynamic values, and the first time it’s evaluated, both values are of type byte. The binder has gone to a fair amount of effort to work out that this means both operands should be promoted to int, and the result should be the sum of those integers. It can reuse that operation any time the operands turn out to both be byte. Checking a set of previous results for validity can save a lot of time. The rule I’ve used as an example (the operand types must be exactly the same as the ones I’ve just seen) is a common one, but the DLR supports other rules too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The second part of a rule is the code to use when the rule matches, and it’s <a name="bookmark4134"></a>represented as an expression tree. It </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have been stored just as a compiled delegate to call—but keeping the expression tree representation means the cache can optimize heavily.<a name="bookmark4135"></a> There are thr<a name="bookmark4136"></a>ee levels of cache in the</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">DLR: L0, L1, and L2. The caches</font></p><div><img src="images/58.png"/></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">. &nbsp;&nbsp;&nbsp;Figure &nbsp;&nbsp;&nbsp;14.3 &nbsp;&nbsp;&nbsp;Relationships &nbsp;&nbsp;&nbsp;between dynamic caches and</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">store information in different ways, </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><sub>call sites</sub></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">and with a different scope. Each</font></p>
<p><a name="bookmark4137"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">call site has its own L0 and L1 caches, but an L2 cache may be shared between several similar call sites, as shown in figure 14.3.</font></p>
<p><a name="bookmark4138"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4139"></a>The set of call sites that share an L2 cache is determined by their binders—each binder <a name="bookmark4140"></a>has an L2 cache associated with it. The compiler (or whatever is creating the call sites) decides how many binders it wants to use. It can only use a binder for multiple call sites that represent very similar code: where if the context is the same at execution time, the call sites should execute in the same way. In fact, the C# compiler doesn’t use this facility—it creates a new binder for every call site,<sup><a name="footnote96"></a><a href="#bookmark4141">96</a></sup> so there’s not much difference between the L1 and L2 caches for C# developers. Genuinely dynamic languages such as IronRuby and IronPyt<a name="bookmark4142"></a>hon make more use of it, though.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The caches themselves are executable, which takes a while to understand. The C# compiler generates code to si<a name="bookmark4143"></a>mply execute the call site’s L0 cache (which is a delegate accessed through the Target property). That’s it! The L0 cache has a single rule, which it checks when it’s called. If the rule matches, it executes the associated behavior. If the rule doesn't match (or if this is the first call, so it doesn’t have even one rule), it calls into the L1 cache, which in turn calls into the L2 cache. If the L2 cache can’t find any matching rules, it asks the receiver or the binder to resolve the call. The results are then put into the cache for next time. In the case of our earlier snippet, the execution part would look something like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">callSite.Target(callSite, d, 10);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The L1 and L2 caches look through their rules in a fairly standard way—each has a collection of rules, and each rule is asked whether or not it matches. The L0 cache is somewhat different. The two parts of its behavior (checking its rule and dele<a name="bookmark4144"></a>gating to the L1 cache) are combined into a single method which is then JIT compiled. Updating the L0 cache consists of rebuilding the method from the new rule.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The result of all of this is that typical call sites which see similar context repeatedly are very fast; the dispatch mechanism is about as lean as you could make it if you hand-coded the tests yourself. Of course this has to be weighed against the cost of all the dynamic code generation involved, but the multilevel cache is complicated precisely because it tries to achieve a balance across various different scenarios.</font></p>
<p><a name="bookmark4145"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we know a bit about the machinery in the DLR, we’ll be able to understand what the C# compiler does for us in order to set it all in motion.</font></p>
<p><a name="bookmark403"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4146"></a>14.4.3 How the C# compiler handles dynamic</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The main jobs of the C# compiler when it comes to dynamic code are to work out when dynamic behavior is required, and to capture all the necessary context so that the binder and receiver have enough information to resolve the call at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IF IT USES DYNAMIC, IT’S DYNAMIC!</font></p>
<p><a name="bookmark4147"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One situation is obviously dynamic: when the target of a member call is dynamic. The compiler has no way of knowing h<a name="bookmark4148"></a>ow that’ll be resolved. It may be a truly dynamic object that’ll perfor<a name="bookmark4149"></a>m the resolution itself, or it may end up with the C# binder resolving it with reflection later. Either way, there’s simply no opportunity for the call to be resolved statically.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">But when the dynamic value is being used as an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">argument</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for the call, there are some situations where you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">m<a name="bookmark4150"></a>ight</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> expect the call to be resolved statically—particularly if there’s a suitable overload that has a parameter type of dynamic. The rule is that if any part of a call is dynamic, the call becomes dynamic and will resolve the overload with the execution-time type of the dynamic value. The following listing demonstrates this using a method with two overloads, and invoking it in a number of different ways.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.16 Experimenting with method overloading and dynamic values</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Execute(string x)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;String overload&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Execute(dynamic x)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Dynamic overload&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic text = &quot;text&quot;; Execute(text); dynamic number = 10; Execute(number);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Both calls to Execute are bound dynamically. At execution time, they’re r<a name="bookmark4151"></a>esolved using the types of the actual values, namely, string and int. The parameter of type dynamic is treated as if it were declared with type object everywhere except within the method itself—if you look at the compiled code, you’ll see it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a parameter of type object, just with an extra attribute applied. This also means you can’t have two methods whose signatures differ just by dynamic/object parameter types.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s an example of resolving method calls, but there are plenty of other expressions to consider. Sometimes the situation isn’t quite as straightforward as I’ve led you to believe...</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IT’S DYNAMIC... EXCEpT WHEN IT ISN’T</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When I introduced dynamic in section 14.2 I had to be careful not to generalize too far, because there are exceptions to almost every rule. Although you should know about these, you don’t need to worry about them—they’re unlikely to cause you any problems. Let’s get them out of the way quickly.</font></p>
<p><a name="bookmark4152"></a><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Conversions between CLR types and dynamic</font></p>
<p><a name="bookmark4153"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The conversions between CLR types and dynamic are restricted in the same way that you can’<a name="bookmark4154"></a>t convert from </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">every</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> CLR type to object; the exceptions are types such as pointers and System.TypedReference. Given that dynamic is just object at the CLR level, it’s not surprising that these types are excluded.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may have also noticed that I wrote about a conversion “from an expression of type dynamic” to a CLR type, not a conversion from the dynamic type itself. This subtlety helps during type inference and other situations that need to consider implicit conversions between types: in general, life gets unpleasant when there are two types with implicit conversions both ways. It basically limits the situations in which the conversion is considered—for example, consider this implicitly typed array:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic d = 0;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string x = &quot;text&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var array = new[] { d, x };</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">What should the inferred type of array be? If there were an implicit conversion from dynamic to str<a name="bookmark4155"></a>ing, then it could be either string [] or dynamic [], so you’d end up with am<a name="bookmark4156"></a>biguity and a compile-time error. But as the conversion only exists from a dynamic </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">expression,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the compiler sees a conversion from string to dynamic but not the other way, and array is of type dynamic []. It’s probably best not to worry about this subtlety unless you’re trying to work through a particular scenario with the specification beside you.</font></p>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Expressions using dynamic aren't always evaluated dynamically</font></p>
<p><a name="bookmark4157"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are some cases where the CLR is quite capable of evaluating an expression using the normal static execution paths, even if one of the subexpressions is dynamic. For example, consider the as operator:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic d = GetValueDynamically(); string x = d as string;</font></p>
<p><a name="bookmark4158"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s nothing that can happen dynamically here—either the value of d is a reference to a string or it isn’t. User-defined conversions aren’t applied when the as operator is used, so the C# compiler can use exactly the same IL that it would if the variable were of type object.</font></p>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Dynamically evaluated expressions aren’t always of type dynamic</font></p>
<p><a name="bookmark4159"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In some cases, the compiler doesn’t know exactly how it’s going to evaluate an expression, but it knows the exact type of the result (assuming an exception isn’t thrown). For example, consider making a constructor call using a dynamic value as an argument:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic d = GetValueDynamically();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SomeType x = new SomeType(d);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The constructor call itself has to be evaluated dynamically—there may be several overloads to be resolved at execution time—but the result is always going to be a SomeType reference. The assignment to x can therefore happen without a dynamic conversion.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are a few other cases like this: using a dynamic array index into a statically typed array can only result in a value of the array element type, for example. But you shouldn’t assume it’ll always happen where you might expect it to: you could have several overloads of a method, all of which have the same static return type, but the type of that method invocation expression will still be dynamic.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s enough about when dynamic evaluation </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">doesn’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> happen, or doesn’t result in a dynamic value—let’s get back to the situations where it does, and see what the C# compiler does to make it all work.</font></p>
<p><a name="bookmark4160"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">CREATING CALL SITES AND BINDERS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You don’t need to know the exact details of what the compiler does with dynamic expressions in order to use them, but it can be instruct<a name="bookmark4161"></a>ive to see what the compiled code looks like. In particular, if you need to decompile your code for any other reason, it means you won’t be surprised by <a name="bookmark4162"></a>what the dynamic parts look like. My tool of choice for<a name="bookmark4163"></a> this kind of work is Reflector (see <a href="http://mng.bz/pMXJ">http://mng.bz/pMXJ</a>), but you could use ildasm if you wanted to read the IL directly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re only going to look at a single example—I’m sure I could fill a whole chapter by looking at implementation details, but the idea is only to give you the gist of what the compiler is up to. If you find this example interesting, you may want to experiment <a name="bookmark4164"></a>more on your own. Just remember that the exact details are implementation-specific; they may change in future compiler versions, so long as the behavior is equivalent. Here’s t<a name="bookmark4165"></a>he sample snippet, which exists in a Main method in the normal manner for Snippy:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string text = &quot;text to cut&quot;; dynamic startIndex = 2;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string substring = text.Substring(startIndex);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Pretty simple, right? It actually contains two dynamic operations—one to call Substring, and one (implicit) to dynamically convert the result (which is just dynamic at compile time) to a string. Listing 14.17 shows the decompiled code for the Snippet class.<sup><a name="footnote97"></a><a href="#bookmark4166">97</a></sup> I’ve omitted the class declaration itself and the implicit parameterless constructor to save space—and I’ve reformatted the code with significantly reduced whitespace for the same reason.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.17 The results of compiling dynamic code</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[CompilerGenerated]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static class &lt;Main&gt;o_SiteContainer0 {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static &nbsp;&nbsp;&nbsp;CallSite&lt;Func&lt;CallSite, &nbsp;&nbsp;&nbsp;object, &nbsp;&nbsp;&nbsp;string&gt;&gt; &nbsp;&nbsp;&nbsp;&lt;&gt;p_Site1;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static &nbsp;&nbsp;&nbsp;CallSite&lt;Func&lt;CallSite, &nbsp;&nbsp;&nbsp;string, &nbsp;&nbsp;&nbsp;object, &nbsp;&nbsp;&nbsp;object&gt;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;&gt;p_Site2;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static void Main() { string text = &nbsp;&nbsp;&nbsp;&quot;text to cut&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object startIndex = 2;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (&lt;Main&gt;o_SiteContainer0.&lt;&gt;p_Site1 == null) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Main&gt;o_SiteContainer0.&lt;&gt;p_Site1 =</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CallSite&lt;Func&lt;CallSite, object, string&gt;&gt;.Create( new CSharpConvertBinder(typeof(string),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CSharpConversionKind.ImplicitConversion, false));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (&lt;Main&gt;o_SiteContainer0.&lt;&gt;p_Site2 == null) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Main&gt;o_SiteContainer0.&lt;&gt;p_Site2 =</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CallSite&lt;Func&lt;CallSite, string, object, object&gt;&gt;.Create( new CSharpInvokeMemberBinder(CSharpCallFlags.None, &quot;Substring&quot;, typeof(Snippet), null, new CSharpArgumentInfo[] { new CSharpArgumentInfo(</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CSharpArgumentInfoFlags.UseCompileTimeType, null), new CSharpArgumentInfo(</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CSharpArgumentInfoFlags.None, null) }));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string substring =</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Main&gt;o_SiteContainer0.&lt;&gt;p_Site1.Target.Invoke(</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Main&gt;o_SiteContainer0.&lt;&gt;p_Site1,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Main&gt;o_SiteContainer0.&lt;&gt;p_Site2.Target.Invoke(</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;Main&gt;o_SiteContainer0.&lt;&gt;p_Site2, text, startIndex));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I don’t know about you, but I’m glad that I never have to write or encounter code like that, other than for the purpose of learning about exactly what’s going<a name="bookmark4167"></a> on. There’s not<a name="bookmark4168"></a>hing new about that, thoug<a name="bookmark4169"></a>h—the generated code for iterator blocks, expression trees, and anonymous <a name="bookmark4170"></a>functions can be pretty grueso<a name="bookmark4171"></a>me too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A nested static class is used to store all the call sites </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">for the method, as they only need to be created once. (If they were created each time, the cache would be useless!<a name="bookmark4172"></a>) It’s possible that the call sites </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be created more than once due to multithreading, but if that happens it’s j<a name="bookmark4173"></a>ust slightly inefficient—and it means the lazy creation is achieved with no locking at all. It doesn’t really matter if one call site instance is repla<a name="bookmark4174"></a>ced with another. Each method using dynamic binding has a separate site container: this </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">has</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be the case for generic methods, as the call site needs to vary based on the type arguments. Another compiler implementation could choose to use one site container for all the nongeneric methods, one for all generic methods with a single type parameter, and so on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">After the call sites are created (© and ©) they’re simply invoked. The Substring call is invoked first (read the code from the innermost part of the statement outward) and then the conversion is invoked on the result Q. At this point we have a statically typed value again, so we can assign it to the substring variable.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I'd like to highlight one more aspect of the code: the way that some static type information is preserved in the call site. The type information itself is present in the delegate signature used for the type argument of the call site (Func&lt;Call<a name="bookmark4175"></a>Site, string, object, object&gt;) and a flag in the corresponding CSharpArgumentInfo indicates that this type information should be used in the binder Q. (Even though this is the target of the method, it’s represented as an argument; instance methods are treated as static methods with an implicit first parameter of this.) This is a crucial part of making the binder behave as if it were just recompiling your code at execution time. Let’s look at why this is so important.</font></p>
<p><a name="bookmark404"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4176"></a>14.4.4 The C# compiler gets even smarter</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 4 lets you straddle the static/dynamic boundary not just by having some of your code bound statically and some bound dynamically, but also by combining the two ideas within a single binding. It remembers everything it needs to know within the call site, then cleverly merges this information with the types of the dynamic values at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">PRESERVING COMPILER BEHAVIOR AT EXECUTION TIME</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The ideal model for working out how the binder should behave is to imagine that instead of having a dynamic val<a name="bookmark4177"></a>ue in your source code, you have a value of exactly the right type: the type of the actual value at execution time.<sup><a name="footnote98"></a><a href="#bookmark4178">98</a></sup> This </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> applies to dynamic values within the expression: any types<a name="bookmark4179"></a> that are known at compile time are still used for lookups such as member resolution. I’ll give two examples of where this makes a difference. The following listing shows a simple overloaded method in a single type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.18 Dynamic overload resolution within a single type</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Execute(dynamic x, string y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;dynamic, string&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Execute(dynamic x, object y) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;dynamic, object&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object text = &quot;text&quot;; dynamic d = 10;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Execute(d, text);</font></p>
<p><a name="bookmark4180"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The important variable here is text. Its </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">compile-time</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type is object, but at </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">execution time </font><font style="font-size:x-small;font-family:Times New Roman, serif;">its value is a string reference. The call to Execute is dynamic because w<a name="bookmark4181"></a>e’re using the dynamic variable d as one of the arguments, but the overload resolution uses the static type of text, so the result is “dynamic, object”. If the text variable had been declared as dynamic as well, it would’ve used the other overload.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The next listing is similar, but this time it’s the receiver of the call that matters.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.19 Dynamic overload resolution within a class hierarchy</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Base {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void Execute(object x)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;object&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Derived : Base {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void Execute(string x)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;string&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Base receiver = new Derived(); dynamic d = &quot;text&quot;; receiver.Execute(d);</font></p>
<p><a name="bookmark4182"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In listing 14.19, the type of receiver is Derived at execution time, so you might’ve expected the overload introduced in Derived to be called. But the compile-time type of receiver is Base, and so the binder restricts the set of methods it considers to just the ones that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">would</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have been available if we’d been binding the method statically. Despite all of these decisions that have to be taken later, some compile-time checks are available, even for code that’ll be fully bound at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">COMPILE-TIME ERRORS FOR DYNAMIC CODE</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As I said near th<a name="bookmark4183"></a>e start of this chapter, one of the disadvantages of dynamic typing is that some errors that would normally be detected by the compiler are delayed until execution time, at which point an exception is thrown. There are many situations where the compiler has to just hope you know what you’re doing, but where it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can </font><font style="font-size:x-small;font-family:Times New Roman, serif;">help you, it will. The simplest example of this is when you try to call a method with a statically typed receiver (or a static method) and none of the overloads can possibly be valid, whatever type the dynamic value has at execution time. The following listing shows three examples of invalid calls, two of which are caught by the compiler.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.20 Catching errors in dynamic calls at compile time</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string text = &quot;cut me up&quot;; dynamic guid = Guid.NewGuid();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">text.Substring(guid); text.Substring(&quot;x&quot;, guid); text.Substring(guid, guid, guid);</font></p>
<p><a name="bookmark4184"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4185"></a>Here we have three calls to string. Substring. The compiler knows the exact set of possible overloads, because it knows the type of text statically. It doesn’t complain at the first call, because it can’t tell what type guid will be—if it turns out to be an integer, all will be well. But the final two lines throw up errors: there are no overloads that take a string as the first argument, and there are no overloads with three parameters. The compiler can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">guarantee</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that these would fail at execution time, so it’s reasonable for it to fail at compile time instead.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A slightly trickier example is with type inference. If a dynamic value is used to infer a type argument in a call to a generic method, then the actual type argument won’t be known until execution time and no validation can occur beforehand. But any type argument that would be inferred without using </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">any</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> dynamic values can cause type inference to fail at compile time. The following listing shows an example of this.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.21 Generic type inference with mixed static and dynamic values</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Execute&lt;T&gt;(T first, T second, string other) where T : struct {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic guid = Guid.NewGuid();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Execute(10, 0, guid);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Execute(10, false, guid);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Execute(&quot;hello&quot;, &quot;hello&quot;, guid);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Again, the first call compiles, but would fail at execution time. The second call won’t compile because T can’t be both int and bool, and there are no conversions between the two of them. The third call won’t compile because T is inferred to be string, which violates the constraint that it must be a value type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler is conservative: it’ll only fail with an error if it can tell that some code can’t possibly succeed, and it only performs relatively simple tests on this front. There are some situations where it may be obvious (and provable) to a human that the code won’t work, but where the compiler allows the cod<a name="bookmark4186"></a>e through. Of course, if a particular line of code will never work, then a single unit test that executes it will fail, so the simplistic nature of the compiler’s checking doesn’t matter if you have good code coverage. Think of it as a bonus in the cases where it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> spot a problem.</font></p>
<p><a name="bookmark4187"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4188"></a>That covers the most important points in terms of what the compiler </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> do for you. But you can’t use dynamic absolutely everywhere. There are limitations, some of which are painful, but most of which are quite obscure.</font></p>
<p><a name="bookmark405"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4189"></a>14.4.5 Restrictions on dynamic code</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">mostly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use dynamic wherever you’d normally use a type name, and then write normal C#. But there are a few exceptions. This isn’t an exhaustive list, but it covers the cases you’re most likely to run into.</font></p>
<p><a name="bookmark4190"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">EXTENSION METHODS AREN’T RESOLVED DYNAMICALLY</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler emits </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">some</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the context of the call into the call site, as we’ve already seen. In particular, the site knows the static ty<a name="bookmark4191"></a>pes that the compiler was aware of. But it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">doesn’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> currently know which using directives occurred in the source file containing the call. That means it doesn’t know which extension methods are available at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This doesn’t just mean that you can’t call extension methods </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">on</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> dynamic values—it means you can’t pass them into extension methods as arguments either. There are two workarounds, both of which are helpfully suggested by the compiler. If you actually know which overload you want, you can cast the dynamic value to t<a name="bookmark4192"></a>he right type within the method call. Otherwise, assuming you know which st<a name="bookmark4193"></a>atic class contains the extension method, you can just call it as a normal static method. The following listing shows an example of a failing call and both workarounds.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.22 Calling extension methods with dynamic arguments</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic size = 5;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var numbers = Enumerable.Range(10, 10); var error = numbers.Take(size); var workaround1 = numbers.Take((int) size); var workaround2 = Enumerable.Take(numbers, size);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Both approaches will work if you want to call the extensi<a name="bookmark4194"></a>on method with the dynamic value as the implicit this value, too—although the cast becomes pretty ugly in that case.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DELEGATE CONVERSION RESTRICTIONS WITH DYNAMIC</font></p>
<p><a name="bookmark4195"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The compiler has to know t<a name="bookmark4196"></a>he exact delegate (or exp<a name="bookmark4197"></a>ression) type involved when converting a lambda expression, an anonymous method, or a method group. You can’t assign any of these to a plain Delegate or object variable without casting, and the same is true for dynamic. But a cast is enough to keep the compiler happy. This could be useful in some situations if you want to execute the delegate dynamically later. You can also use a delegate with a dynamic type as one of its parameters if that’s useful. Listing 14.23 shows some examples that’ll compile, and some that won’t.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.23 Dynamic types and lambda expressions</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic badMethodGroup = Console.WriteLine;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic goodMethodGroup = (Action&lt;string&gt;) Console.WriteLine; dynamic badLambda = y =&gt; y + 1;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic goodLambda = (Func&lt;int, int&gt;) (y =&gt; y + 1);</font></p>
<p><a name="bookmark4198"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic veryDynamic = (Func&lt;dynamic, dynamic&gt;) (d =&gt; d.SomeMethod());</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note that because of the way overload resolution works, this means you can’t use lambda expressions in dynamically bound calls at all without casting—even if the only method that could possibly be invoked has a known delegate type at compile time. For example, this code won’t compile: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">void Method(Action&lt;string&gt; action, string value)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">action(value);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic text = &quot;error&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Method(x =&gt; Console.WriteLine(x), text);</font></p>
<p><a name="bookmark4199"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth pointing out that all is not lost<a name="bookmark4200"></a> in terms of LINQ and dynamic interacting. You can have a strongly typed collection with an element type of dynamic, at which point you<a name="bookmark4201"></a> can still use extension methods, lambda expressions, and even query expressions. The collection can contain objects of different types, and they’ll behave appropriately at execution time, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.24 Querying a collection of dynamic elements</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var list = new List&lt;dynamic&gt; { 50, 5m, 5d }; var query = from number in list where number &gt;&nbsp;4 select (number / 20) * 10;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach (var item in query)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(item);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This prints 20, 2.50, and 2.5. I deliberately divided by 20 and then multiplied by 10 to show the difference between decimal and double: the decimal type keeps track of precision without normalizing, which is why 2.50 is displayed instead of 2.5. The first value is an integer, so integer division is used; hence the value of 20 instead of 25.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CONSTRUCTORS AND STATIC <a name="bookmark4202"></a>METHODS</font></p>
<p><a name="bookmark4203"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You can call constructors and static methods dynamically in the sense that you can specify dynamic arguments, but you can’t resolve a constructor or static method against a dynamic type. There’s just no way of specifying which type you mean.</font></p>
<p><a name="bookmark4204"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4205"></a>If you run into a situation where you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">want</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to be able to do this dynamically in some way, try<a name="bookmark4206"></a> to think of ways to use instance methods instead—for instance, by creating a factory type. You <a name="bookmark4207"></a>may find that <a name="bookmark4208"></a>you can get the dynamic behavior you want using simple polymorphism or interfaces, but within static typing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">TYPE DECLARATIONS AND GENERIC TYPE PARAMETERS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can’t declare that a type<a name="bookmark4209"></a> has a base class of dynamic. You also can’t use dynamic in a type parameter constraint, or as part <a name="bookmark4210"></a>of the set of interfaces that your type implements. You </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use it as a type argument for a base class, or when you’r<a name="bookmark4211"></a>e specifying an interface for a variable declaration. So, for example, these declarations are invalid:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;class BaseTypeOfDynamic : dynamic</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ class DynamicTypeConstraint&lt;T&gt; where T : dynamic</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ class DynamicTypeConstraint&lt;T&gt; where T : List&lt;dynamic&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;class DynamicInterface : IEnumerable&lt;dynamic&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;class GenericDynamicBaseClass : List&lt;dynamic&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;IEnumerable&lt;dynamic&gt; variable;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Most of these restrictions around generics are the result of the dynamic type not really existing as a .NET type. The CLR doesn’t know about it—any uses in your code are translated into objects with the DynamicAttribute applied appropriately. (For types such as List&lt;dynamic&gt; or Dictionary&lt;string, dynamic&gt;, t<a name="bookmark4212"></a>he attribute indicates exactly which parts of the type are dynamic.) DynamicAt<a name="bookmark4213"></a>tribute is only <a name="bookmark4214"></a>applied when the dynamic nature needs to be represented in metadata; local variables don’t require the attribute, as nothing needs to inspect them after compilation to spot their dynamic nature.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All the dynamic behavior is achieved through compiler cleverness in deciding how the source code should be translated, and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">library</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> cleverness at execution time. This equivalence between dynamic and <a name="bookmark4215"></a>object is evident in various places, but it’s perhaps most obvious if you look at typeof(dynamic) and typeof(object), which return the same reference. In general, if you find you can’t do what you want to with the dynamic type, remember what it looks like to the CLR and see if that explains the problem. It may not suggest a solution, but at least you’ll get better at predicting what’ll work ahead of time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s all the detail I’m going to give about how C# 4 treats dynamic, but there’s another aspect of the dynamic typing picture which we really need to look at to get a well-rounded view of the topic: reacting dynamically. It’s one thing to be able to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">call </font><font style="font-size:x-small;font-family:Times New Roman, serif;">code dynamically, but it’s another to be able to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">respond</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> dynamically to those calls.</font></p>
<p><a name="bookmark4216"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, if you’re just calling into third-party code dynamically—or even using techniques such as multiple dispatch shown earlier—you don’t need to worry about this. I understand if you feel you’ve already had your fill of dynamic typing, at least for the moment; we’ve already covered an awful lot of ground. You can safely skip the next section and come back to it another time—nothing in the rest of the book relies on it. On the other hand, it’s kind of fun.</font></p>
<p><a name="bookmark407"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4217"></a>14.5 Implementing dynamic behavior</font></p>
<p><a name="bookmark4218"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The C# language doesn’t offer any specific help in implementing dynamic behavior, but the framework does. A type has to implement IDynamicMetaObjectProvider in order to react dynamically, but there are two built-in implementations that can take a lot of the work away in many cases. We’ll look at both of these, as well as a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">very</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> simple implementation of IDynamicMetaObjectProvider, just to show you what’s involved. These three approaches are really different, and we’ll start with the simplest of them: ExpandoObject.</font></p>
<p><a name="bookmark408"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4219"></a><a name="bookmark4220"></a>14.5.1 Using ExpandoObject</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Sys tem .Dynamic.ExpandoObject looks like a funny beast at first glance. Its single public constructor has no parameters. It has no public methods, unless you count the</font></p>
<p><a name="bookmark4221"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">explicit<a name="bookmark4222"></a> implementation of various interf<a name="bookmark4223"></a>aces—crucially IDynamicMetaObject-Provider and IDictionary&lt;string, object&gt;. (The other interfaces it implements are all due to IDictionary&lt;, &gt;&nbsp;extending other interfaces.) Oh, and it’s sealed—so it’s not a matter of deriving from it to implement useful behavior. No, ExpandoObject is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">only</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> useful if you refer to it via dynamic or one of the interfaces it implements.</font></p>
<p><a name="bookmark4224"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">SETTING AND RETRIEVING INDIVIDUAL PROPERTIES</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The dictionary interface gives a hint as to its purpose—it’s basically a way of storing objects via names. But those names can also be used as properties via dynamic typing. The following listing shows this working both ways.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.25 Storing and retrieving values with ExpandoObject</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic expando = new ExpandoObject();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IDictionary&lt;string, object&gt; dictionary = expando; expando.First = &quot;value set dynamically&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(dictionary[&quot;First&quot;]);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dictionary[&quot;Second&quot;] = &quot;value set with dictionary&quot;; Console.WriteLine(expando.Second);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.25 just uses strings as the values for convenience—you can use any obj<a name="bookmark4225"></a>ect, as you’d expect with an IDictionary&lt;string, object&gt;. If you specify a delegate as the value, you can then call the delegate as if it were a method on the expando, as shown in listing 14.26.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.26 Faking methods on an ExpandoObject with delegates</font></p>
<p><a name="bookmark4226"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic expando = new ExpandoObject(); expando.AddOne = (Func&lt;int, int&gt;) (x =&gt; x + 1); Console.Write(expando.Add0ne(10)) ;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although this looks like a method access, you can also think of it as a property access which returns a delegate, and then an invocation of the delegate. If you created a statically typed class with an AddOne property of type Func&lt;int, int&gt;, you could use exactly the same syntax. The C# generated to call AddOne does in fact use an “invoke member” operation rather than trying to access it as a property and then invoke it, but ExpandoObject knows what to do. You can also access the property to retrieve the delegate if you want to.</font></p>
<p><a name="bookmark4227"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s move on to a slightly larger example—although we’re still not going to do anything particularly tricky.</font></p>
<p><a name="bookmark4228"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">CREATING A DOM TREE</font></p>
<p><a name="bookmark4229"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4230"></a><a name="bookmark4231"></a>We’re going to create a tree of expandos that mirrors an XML DOM tree. This is a pretty crude implementation, designed for simplicity of demonstration rather than real-world use. In particular, it’s going to assume we don’t have any XML namespaces to worry abou<a name="bookmark4232"></a>t. Each node in the tree has two name/valu<a name="bookmark4233"></a>e pairs that’ll always be present: XElement, which stores the original LINQ to XML element used to create the node, and ToXml, which stores a delegate which just returns the node as an XML string. You could just call node.XElement.ToString(), but this way gives another</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">example of how delegates work <a name="bookmark4234"></a>with ExpandoObject. One point to mention is that I used ToXml instead of ToString, as setting the ToString property on an exp<a name="bookmark4235"></a>ando </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">doesn’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> override the normal T<a name="bookmark4236"></a>oString method. This could lead to confusing bugs, so I opted for the different name instead.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The interesting part isn’t the fix<a name="bookmark4237"></a>ed names; it’s the ones tha<a name="bookmark4238"></a>t depend on the real XML. I’m going t<a name="bookmark4239"></a>o ignore attributes completely, but any </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">elements</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in the original XML that are children of the original element are accessible via properties of the same name. For instance, consider the following XML:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;root&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;branch&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;leaf /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/branch&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/root&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Assuming a dynamic variable called root representing the root element, we could access the leaf node with two simple property accesses, which can occur in a single statement:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic leaf = root.branch.leaf;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If an element occurs more than once within a parent, the property just refers to the first element with that name. To make the other elements accessible, each element will also be exposed via a property using the element name with a suffix of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">List</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which returns a List&lt;dynamic&gt; containing each of the elements with that name in document order. In other words, the access could also be represented as root. branchList[0].leaf, or perhaps root.branchList[0].leafList[0]. Note that the indexer here is being applied to the list—you can’t define your own indexer behavior for expandos.</font></p>
<p><a name="bookmark4240"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The implementation of all of this is actually remarkably simple, with a single recursive method doing all the work, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.27 Implementing a simplistic XML DOM conversion with ExpandoObject</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static dynamic CreateDynamicXml(XElement element)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic expando = new ExpandoObject(); expando.XElement = element;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">expando.ToXml = (Func&lt;string&gt;)element.ToString;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IDictionary&lt;string, object&gt; dictionary = expando; foreach (XElement subElement in element.Elements())</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic subNode = CreateDynamicXml(subElement); string name = subElement.Name.LocalName; string listName = name + &quot;List&quot;; if (dictionary.ContainsKey(name))</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">((List&lt;dynamic&gt;) dictionary[listName]).Add(subNode);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">else {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dictionary[name] = subNode; dictionary[listName] = new List&lt;dynamic&gt; { subNode };</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return expando;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Without the list handling, listing 14.27 would’ve been even simpler. We set the XElement and ToXml properties dynamically (© and ©), but we can’t do that for the elements or their lists, because we don’t know the names at compile time.<sup><a name="footnote99"></a><a href="#bookmark4241">99</a></sup> We use the dictionary representation instead (E and E), which also allows us to check for repeated elements easily. You can’t tell whether an expando contains a value for a particular key just by accessing it as a property: any attempt to access a property that hasn’t already been defined results in an exception. The recursive handling of subelements is as straightforward in dynamic code as it’d be in statically typed code: we just call the method recursively E with each subelement, using its result to populate the appropriate properties.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re going to need some XML to use as an example, but it’s helpful to picture it graphically as well as in its raw format. We’ll use a simple structure representing books. Each book has a single name represented as an attribute, and may have multiple authors, each with their own element. Figure 14.4 shows the whole file as a tree, and the text appears afterward.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;books&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;book name=&quot;Mortal Engines&quot;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;author name=&quot;Philip Reeve&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/book&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;book name=&quot;The Talisman&quot;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;author name=&quot;Stephen King&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;author name=&quot;Peter Straub&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/book&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;book name=&quot;Rose&quot;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;author name=&quot;Holly Webb&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;excerpt&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Rose was remembering the illustrations from Morally Instructive Tales for the Nursery.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/excerpt&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/book&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/book&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.28 shows a brief example of how the expando code can be used with this XML document, including the ToXml and XElement properties. The books.xml file contains the XML document shown in the figure.</font></p><img src="images/59.png"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Figure 14.4 Tree structure of sample XML file</font></p>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">^^L</font><font style="font-size:x-small;font-family:Times New Roman, serif;">istin</font><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">^^</font><font style="font-size:x-small;font-family:Times New Roman, serif;">4.2</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">^^U</font><font style="font-size:x-small;font-family:Times New Roman, serif;">sin</font><font style="font-size:large;font-family:Times New Roman, serif;font-weight:bold;">^^d</font><font style="font-size:x-small;font-family:Times New Roman, serif;">ynami</font><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">^D</font><font style="font-size:x-small;font-family:Times New Roman, serif;">O^^create</font><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">^</font><font style="font-size:x-small;font-family:Times New Roman, serif;">fro</font><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">^^</font><font style="font-size:x-small;font-family:Times New Roman, serif;">?Xpando</font><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">^^</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XDocument doc = XDocument.Load(&quot;books.xml&quot;); dynamic root = CreateDynamicXml(doc.Root);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(root.book.author.ToXml()); Console.WriteLine(root.bookList[2].excerpt.XElement.Value);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.28 should hold no surprises, unless you’re unfamiliar with the XElement. Value property, which simply returns the text within an element. The output of the listing is as we’d expect:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;author name=&quot;Philip Reeve&quot; /&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Rose was remembering the illustrations from Morally Instructive Tales for the Nursery.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is all good, but there are a few issues with our DOM. In particular:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It doesn’t handle attributes at all.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;We need two properties for each element name, due to the need to represent lists.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;It’d be nice to override ToString() instead of adding an extra property.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The result is mutable—there’s nothing to stop code from adding its own properties afterward.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Although the expando is mutable, it won’t reflect any changes to the underlying XElement (which is also mutable).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;There are many opportunities for naming clashes, such as a node containing elements Foo and FooList, or elements called XElement or ToXml.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;We populate the entire tree up-front, which is a lot of work if we only need a few nodes.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Fixing these issues requires more control than just being able to set properties. Enter</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">DynamicObject.</font></p>
<p><a name="bookmark409"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4242"></a><a name="bookmark4243"></a>14.5.2 Using DynamicObject</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">DynamicObject is a more powerful way of interacting with the DLR than using ExpandoObject, but it’s a lot simpler than implementing IDynamicMetaObject-Provider. Although it’s not </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">actually</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> an abstract class, you really need to derive from it to do anything useful—and the only constructor is protected, so it might as well be abstract for all practical purposes. There are four kinds of method that you might wish to override:</font></p>
<p><a name="bookmark4244"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4245"></a>■ &nbsp;&nbsp;&nbsp;TryXXX () invocation meth<a name="bookmark4246"></a>ods, representing dynamic calls to the object</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;GetDynamicMemberNa<a name="bookmark4247"></a>mes(), which can<a name="bookmark4248"></a> return a list of t<a name="bookmark4249"></a>he available members</font></p>
<p><a name="bookmark4250"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4251"></a>■ &nbsp;&nbsp;&nbsp;The normal Equals (), GetHashCode(), and ToString() methods, which can be overridden as usual</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;GetMetaObject (), which returns the metaobject used by the DLR</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll look at all but the last of these to improve our XML DOM representation, and we’ll discuss metaobjects in the next section when we implement IDynamicMeta-ObjectProvider from scratch. In addition, it can be useful to create new members in your derived type, even if callers are likely to use instances as dynamic values. Before we take any of these steps, we’ll need a class to hold all these members.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">GETTING STARTED</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As we’re deriving from DynamicObject instead of just calling methods on it, we need to start with a class declaration. The following listing shows the basic skeleton that we’ll be fleshing out.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.29 Skeleton of DynamicXElement</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class DynamicXElement : DynamicObject</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private readonly XElement element; private DynamicXElement(XElement element)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">this.element = element;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static dynamic CreateInstance(XElement element)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new DynamicXElement(element);</font></p>
<p><a name="bookmark4252"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The DynamicXElement class just wraps an XElement </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. This will be all the state we have, which is a significant design decision in itself. When we created an ExpandoObject earlier, we recursed into its structure and populated a whole mirrored tree. We really had to do that, because we couldn’t intercept property accesses with custom code later on. Obviously this is more expensive than the DynamicXElement approach, where we’ll only ever wrap the elements of the tree when we actually have to. Additionally, it means that any changes to the XElement after we’ve created the expando are effectively lost: if you add more subelements, for example, they won’t appear as properties because they weren’t present when we took the snapshot. The lightweight wrapping approach is always “live”—any changes you make in the tree will be visible through the wrapper.</font></p>
<p><a name="bookmark4253"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">disadvantage</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of this is that we no longer provide the same idea of identity that we had before. With the expando, the expression root.book.author would evaluate to the same reference if we used it twice. Using DynamicXElement, each time the expression is evaluated it’ll create ne<a name="bookmark4254"></a>w instances to wrap the subelements. We </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could </font><font style="font-size:x-small;font-family:Times New Roman, serif;">implement some sort of smart caching to get around this, but it could end up getting very complicated, very quickly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve chosen to m<a name="bookmark4255"></a>ake the constructor of DynamicXElement private </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and provide a public static method to create instances </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">E</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. The method has a return type of dynamic, because that’s how we expect developers to use the class. A slight alternative would’ve been to create a separate public static c<a name="bookmark4256"></a>lass with an extension method to XElement, and keep DynamicXElement itself internal. The class itself is an implementation detail: there’s not much point in using it unless you’re working dynamically.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With our skeleton in place, we can start adding features. We’ll start with really simple stuff: adding methods and indexers as if this were just a normal class.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DYNAMICOBJECT SUPPORT FOR SIMPLE MEMBERS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When we created our expando, there were two members we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> added: the ToXml method and the XElement property. This time we don’t need a new method to convert the object to a string representation: we can override the normal ToString() method. We can also provide the XElement property as if we were writing any other class. One of the nice things about DynamicObject is that when some behavior doesn’t need to be truly dynamic, you don’t have to implement it dynamically. Before the associated metaobject uses any of the TryXXX methods, it checks whether the member already exists as a straightforward CLR member. If it does, that member will be called. This makes life significantly simpler.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re going to have two indexers in DynamicXElement as well, to provide access to attributes and replace our element lists. The following listing shows the new code to be added to the class.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.30 Adding nondynamic members to DynamicXElement</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override string ToString()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return element.ToString();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public XElement XElement {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get { return element; }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public XAttribute this[XName name]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get { return element.Attribute(name); }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public dynamic this[int index]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">get {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XElement parent = element.Parent; if (parent == null) &nbsp;&nbsp;&nbsp;<sup>—</sup></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (index != 0)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new ArgumentOutOfRangeException();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return this;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XElement sibling = parent.Elements(element.Name)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.ElementAt(index); return element == sibling ? this</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">: new DynamicXElement(sibling);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s a fair amount of code in listing 14.30, but most of it is straightforward. We override ToString() </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">by just proxying the call to the XElement, and if we wanted to implement value equality we could do something similar for Equals () and GetHash-Code(). The property returning the underlying element </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and the indexer for attributes </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">are also simple, although it’s worth noting that we only need to use an XName for the parameter to the attribute indexer: if you provide a string at execution time, DynamicObject will take care of calling the implicit conversion to XName for you.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The trickiest part of the code is understanding what the indexer with the int parameter </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is meant to be doing. It’s probably easiest to explain this in terms of expected usage. The idea is to avoid having the extra list property by making an element act as both a single element and a list of child elements of the same name. Figure 14.5 shows our sample XML with a few expressions to reach different nodes within it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Once you understand what the indexer is meant to do, the implementation is fairly simple, complicated only by the possibility that we could already be at the top of the</font></p><img src="images/60.png"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Figure 14.5 Selecting data using DynamicXElement</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">tree Q. Otherwise we just have to ask the element for all its siblings, then pick the one we’ve been asked for ©.</font></p>
<p><a name="bookmark4257"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we haven’t done anything dynamic except in terms of the return type of CreateInstance()—none of our examples will work, because we haven’t written the code to fetch subelements. Let’s fix that now.</font></p>
<p><a name="bookmark4258"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">OVERRIDING TRYXXX METHODS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In DynamicObject, you respond to calls dynamically by overriding one of the TryXXX methods. There are 12 of them, representing different types of operation, as shown in table 14.1.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Table 14.1 Virtual TryXXX methods in DynamicObject</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Name</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Type of call represented (where Q is the dynamic object)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryBinaryOperation</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryConvert</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryCreateInstance</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryDeleteIndex</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryDeleteMember</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryGetIndex</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Binary operation, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x + y </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Conversions, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(Target) x </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Object creation expressions: no equivalent in C# Indexer removal operation: no equivalent in C# Property removal operation: no equivalent in C# Indexer getter, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x[10]</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Table 14.1 Virtual TryXXX methods in DynamicObject </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">(continued)</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Name</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Type of call represented (where Q is the dynamic object)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryGetMember</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryInvoke</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryInvokeMember</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TrySetIndex</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TrySetMember</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryUnaryOperation</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Property getter, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Property</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Direct invocation effectively treating x like a delegate, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x(10) </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Invocation of a member, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Method()</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Indexer setter, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x[10] = 20 </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Property setter, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Property = 10 </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Unary operation, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">!x or -x</font></p></td></tr>
</table>
<p><a name="bookmark4259"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Each of these methods has a Boolean return <a name="bookmark4260"></a>type to indicate whether the binding was successful. Each takes an appropriate binder as the first parameter, and if the operation logically has arguments (for instance, the arguments to a method, or the indexes for an indexer) these are represented as an object [ ]. Finally, if the operation might have a return value (which includes everything except the set and delete operations), then there’s an out parameter of type object to capture that value. The exact type of the binder depends on the operation: there’s a different bind<a name="bookmark4261"></a>er type for each of the operations. For example, the full signature of TryInvokeMember is</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public virtual bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You only need to override the methods representing operations you support dynamically. In our case, we have dynamic read-only properties (for the elements) so we need to override </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TryGetMember()</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, as shown in the following listing.</font></p>
<p><a name="bookmark4262"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4263"></a>Listing 14.31 Implementing a dynamic property with TryGetMember()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override bool TryGetMember(GetMemberBinder binder,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">out object result)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XElement subElement = element.Element(binder.Name); if (subElement != null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">result = new DynamicXElement(subElement); return true;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return base.TryGetMember(binder, out result);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The implementation in listing 14.31 is simple. The binder contains the name of the requested property, so we look for the appropriate subelement in the tree </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. If there is one, we create a new DynamicXElement with it, assign that to the output parameter result, and return true to indicate that the call was bound successfully </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. If there was no subelement with the right name, we just call the base implementation of Try-GetMember () </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">E</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. The base implementation of each of the TryXXX methods just returns false and sets the output parameter to null if there is one. We could easily have done this explicitly, but we’d have had two separate statements: one to set the output parameter and one to return false. If you prefer the slightly longer code, there’s no reason not to write it—the base implementations are just slightly convenient in terms of doing everything required to indicate that the binding failed.</font></p>
<p><a name="bookmark4264"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’ve side-stepped one bit of complexity: the binder has another property (Ign<a name="bookmark4265"></a>ore-Case) which indicates whet<a name="bookmark4266"></a>her the property should be bound in a case-insensitive way. For example, Visual Basic is case-insensitive, so its binder implementation would return true for this property, whereas C#’s would return false. In our situation, it’s slightly awkward. Not only would it be more work for TryGetMember to find the element in a case-insensitive manner (“more work” is always unpleasant, but it’s not a good reason not to implement it), but there’s the more philosophical problem of what happens when you then use the indexer (by number) to select siblings. Should the object remember whether it’s case-sensitive, and select siblings in the same way later on? You could easily get into situations where the behavior is ha<a name="bookmark4267"></a>rd both to predict and explain in documentation. This sort of impedance mis<a name="bookmark4268"></a>match is likely to happen in other, similar situations too. If you a<a name="bookmark4269"></a>im for perfection, you’re likely to tie yourself up in knots. Ins<a name="bookmark4270"></a>tead, find a pragmatic<a name="bookmark4271"></a> solution that y<a name="bookmark4272"></a>ou’re confident you can implement and maintain, and then document the restrictions.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With all this in place, we can test DynamicXElement as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.32 Testing DynamicXElement</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XDocument doc = XDocument.Load(&quot;books.xml&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic root = DynamicXElement.CreateInstance(doc.Root);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(root.book[2][&quot;name&quot;]);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(root.book[1].author[1]);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(root.book);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We could add more complexity to our class, of course. We could add a Parent property to go back up the tree, or we might want to change to access subelements using method calls and make property access represent attributes. The principle would be exactly the same: where you know the name in advance, implement it as a normal class member. If you need it to be dynamic, override the appropriate DynamicObject method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s one more piece of polish to apply to DynamicXElement before we leave it. It’s time to advertise what we’ve got to offer.</font></p>
<p><a name="bookmark4273"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">OVERRIDING GETDYNAMICMEMBERNAMES</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Some languages, such as Python, <a name="bookmark4274"></a>allow you to ask an object what names it knows about. For example, you <a name="bookmark4275"></a>can use the dir function in Python to output a list. This information is u<a name="bookmark4276"></a>seful in a REPL environment, and it can also be handy when you’re debugging in an IDE. T<a name="bookmark4277"></a>he DLR makes this information available through the <a name="bookmark4278"></a>GetDynamicMember-Names() method of both DynamicObject and DynamicMetaObject (we’ll meet the latter in a minute). All we have to do is override this method, provide a sequence of the dynamic member names, and we make our object’s properties more discoverable. Listing 14.33 shows the implementation for DynamicXElement.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.33 Implementing GetDynamicMemberNames in DynamicXElement</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override IEnumerable&lt;string&gt; GetDynamicMemberNames()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return element.Elements()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Select(x =&gt; x.Name.LocalName)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.Distinct()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">.OrderBy(x =&gt; x);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark4279"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4280"></a>As you can see, all we need is a simple LINQ query. That won't </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> be the case, but I suspect many dynamic implementations will be able to use LINQ in this way. In this case we need to make sure that we don’t return the same value more than once if there’s more than one element with any particular na<a name="bookmark4281"></a>me, and I’ve sorted the results just f<a name="bookmark4282"></a>or consistency. In the Visual Studio 2010 debugger, you can expand the Dynamic View of a dynamic object and see the property names and values, as shown in figure 14.6.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can drill down through the dynamic object, showing the dynamic view at each level. For figure 14.6 I’ve drilled down from the document, to the first book, to the author. The dynamic view of the author shows that there’s no further information in the hierarchy.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve now finished our DynamicXElement class, as far as we’re going to take it in this book. I believe that DynamicObject hits a sweet spot between control and simplicity: it’s fairly easy to get it right, but it has far fewer restrictions than ExpandoObject. But if you really need total control over binding, you’ll need to implement IDynamic-MetaObjectProvider directly.</font></p>
<p><a name="bookmark410"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4283"></a>14.5.3 Implementing IDynamicMetaObjectProvider</font></p>
<p><a name="bookmark4284"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I won't go into a lot of detail here, but I really wanted to at least show one example of low-level<a name="bookmark4285"></a> dynamic behavior. The tough bit of implementing IDynamicMetaObjectProvider isn’t the interface itself—it's creating the DynamicMetaObject to return</font></p><img src="images/61.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 14.6 Visual Studio 2010 displaying dynamic properties of a </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DynamicXElement</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">from the interface’s sole method. DynamicMetaObject is a bit like DynamicObject in that it contains a lot of methods, and you override individual ones to affect the behavior; where we’ve previously overridd<a name="bookmark4286"></a>en DynamicObject.TryGetMember, you’d override DynamicMetaObject.BindGetMember. But within the overridden methods, i<a name="bookmark4287"></a>nstead of taking the required action directly, the idea is to build up an expression tree </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">describing </font><font style="font-size:x-small;font-family:Times New Roman, serif;">the required action, and the circumstances in which that action should be taken. That extra level of indirection is why it’s a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">metaobject.</font></p>
<p><a name="bookmark4288"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m going to leap straight into an example, and then leap out with only a brief explanation. I really want to get across the differenc<a name="bookmark4289"></a>e in level of interaction here—it’s a bit like tinkering with the guts of the JIT compiler. Most C# developers won’t need to know the details, and if you do need to do this, it probably means you’re trying to write a library that responds dynamically but has to perform well too. Alternatively, it may mean that you’re trying to build your own dynamic language. If that’s the case, then good luck—and please find a more comprehensive resource than this meager example.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The example isn’t meant to be clever: it’s a Rumpelstiltskin type. We’re going to create an instance of Rumpelstiltskin with a given name (stored in a perfectly ordinary string variable) and call methods on the object until we call a method with the right name. The object will write out appropriate responses based on our guesses.<sup>9</sup> Just to make this concrete, the following listing shows the code we’re eventually going to run.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.34 The final aim: calling methods dynamically until we hit the right name</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic x = new Rumpelstiltskin(&quot;Hermione&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Harry();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Ron();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">x.Hermione();</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I haven’t called the object Rumpelstiltskin—that would be too obvious. Instead, I’ve used some other magicians—even though none of them is particularly famous for alchemy. The aim is for the first two method calls to result in denials, and the third to admit defeat. We’ll also make our method calls return a Boolean value to indicate whether the guess was successful, but for brevity we’re not using the result here.</font></p>
<p><a name="bookmark4290"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s look at the Rumpelstiltskin type itself first. Don’t forget that this </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">isn’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the metaobject—that’ll come later. Listing 14.35 shows the complete code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.35 The Rumpelstiltskin type, without its metaobject code</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public sealed class Rumpelstiltskin : IDynamicMetaObjectProvider</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private readonly string name; public Rumpelstiltskin(string name) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">this.name = name;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public DynamicMetaObject GetMetaObject(Expression expression)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return new MetaRumpelstiltskin(expression, this);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private object RespondToWrongGuess(string guess)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;No, I'm not {0}! (I'm {1}.)&quot;, guess, name);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return false;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private object RespondToRightGuess()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Curses! Foiled again!&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return true;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are three aspects to this class. There’s construction </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which is perfectly ordinary. There’s the implementation of IDynamicMetaObjectProvider’s sole method </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, an<a name="bookmark4291"></a>d then there are two methods we’ll use to perform the real work </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">E</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. The metaobject constructed at </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">needs to know which instance it’s responding to, and the expression tree used to refer to the instance within the calling code. <a name="bookmark4292"></a>We’re given the expression tree as a parameter, we know our own instance via the this reference, so we just pass those on in the constructor.</font></p>
<p><a name="bookmark4293"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4294"></a>WHY DO THE METHODS RETURN object? You may be wondering why the methods are declared to return object rather than bool. My original implementation actually had void methods—but unfortunately dynamic method invocations are expected to return something, an<a name="bookmark4295"></a>d the binder always expects object in my experience. (There’s a ReturnType property you can check.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That makes a call to a void method throw an exception at execution time— and the same is true for a bool method: we need to perform the boxing ourselves to make the types match up properly. We could build the boxing into the <a name="bookmark4296"></a>expression tree, but that’s more painful than just changing the return type of the method. These are the kinds of subtleties you’ll need to deal with if you ever implement IDynamicMetaObjectProvider in real life.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Strictly s<a name="bookmark4297"></a>peaking,<a name="bookmark4298"></a> we don’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">need</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the two response methods. When we build up the behavior to react to the incoming method calls, we </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> express that logic directly in an expression tree. But it’d be relatively painful to do so, compared with just returning an expression tree that calls the right method. More to the point, though it wouldn’t actually be too hard in this case, i<a name="bookmark4299"></a>n other situations it could be much worse. We’re effectively going to create a bridge betwee<a name="bookmark4300"></a>n the static and dynamic worlds, responding to dynamic method calls by redirecting them to static ones with appropriate arguments. This leads to simpler code in the <a name="bookmark4301"></a>metaobject. Speaking of which, let’s finally look at the code <a name="bookmark4302"></a>for MetaRumpelstiltskin—it’s in listing 14.36, and it’s actually a private nested class inside Rumpelstiltskin.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 14.36 The real dynamic guts of Rumpelstiltskin—its metaobject</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private class MetaRumpelstiltskin : DynamicMetaObject</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static readonly MethodInfo RightGuessMethod =</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">typeof(Rumpelstiltskin).GetMethod(&quot;RespondToRightGuess&quot;, BindingFlags.Instance | BindingFlags.NonPublic);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static readonly MethodInfo WrongGuessMethod =</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">typeof(Rumpelstiltskin).GetMethod(&quot;RespondToWrongGuess&quot;, BindingFlags.Instance | BindingFlags.NonPublic);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">internal MetaRumpelstiltskin</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(Expression expression, Rumpelstiltskin creator)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">: base(expression, BindingRestrictions.Empty, creator)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override DynamicMetaObject BindInvokeMember</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(InvokeMemberBinder binder, DynamicMetaObject[] args)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Rumpelstiltskin targetObject = (Rumpelstiltskin) base.Value; Expression self = Expression.Convert(base.Expression, typeof(Rumpelstiltskin));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression targetBehavior; if (binder.Name == targetObject.name)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">targetBehavior = Expression.Call(self, RightGuessMethod);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">else</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">targetBehavior = Expression.Call(self, WrongGuessMethod, Expression.Constant(binder.Name));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var restrictions = BindingRestrictions.GetInstanceRestriction (self, targetObject); return new DynamicMetaObject(targetBehavior, restrictions);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark4303"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">As I type this, I can almost see your eyes glazing over due to listing 14.36. It’s dense code, and it looks like an awful lot of work to get a simple job done. Just remember: you’re unlikely to ever need to do this, so just relax and let the general flavor of the code sink in while the details wash over you.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The first half of the code is genuinely easy. We stash the MethodInfo for the two response methods in static variables </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(they don’t change for different instances) and declare a constructor that does nothing but pass its parameters up to the base class </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. All of the real work is done in BindInvokeMember </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which has to work out two things: how the object should react to the method call, and the circumstances in which that decision is valid.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We want to react by calling either RespondToRightGuess or RespondToWrongGuess based on whether the name of the method call is the same as the name of the object. The metaobject knows what the real instance is because we passed it into the</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">constructor—we access it again using the Value property, and remember it using the targetObject variable Q. We also need the expression tree that was originally used to create the metaobject, so that we can bind the <a name="bookmark4304"></a>appropriate method call entirely within expression trees. The Expression.Convert method is the expression tree equivalent of the cast in the previous line.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Once we know the real object, we can check its name against <a name="bookmark4305"></a>the method call that we’re binding, which is available via the InvokeMemberBin<a name="bookmark4306"></a>der.Name property. We build a call to the appropriate method using Expression.Call, passing in the name of the method as an argument in the case where the guess was wrong Q. Again, I’d like to stress that at this point we’re not actually calling the method—we’re describing the method call.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The restrictions in this case are simple: this call will always be bound in the same way if it’s calling the same argument, but it’d be bound differently if it were called on a different object, because it could have a different name. GetInstanceRestriction returns an appropriate restriction; if we wanted to always behave the same way regardless of which instance the method was called on, we might use GetTypeRestriction instead, to indicate that the call would be handled the same way for any instance of Rumpelstiltskin. The full source code includes an alternative implementation that does exactly this, by always passing in the actual method name, putting the condition testing inside the normal method.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Finally, we create a new DynamicMetaObject representing the results of the binding G. It’s fairly confusing for the result to be of the same type as the object that’s working out the binding, but that’s how the DLR works.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">At this point, we’re done—cross your fingers, run the code, and see if it works... then debug it a few times to work out exactly what’s wrong, if you’re anything like me. As I’ve said, this isn’t something that most developers will need to take on—it’s a bit like LINQ, in that far more people will use LINQ than implement their own IQueryable-based LINQ provider. It’s useful to get a peek at how it all works instead of treating it as magic, but most of the time you can just sit back and enjoy the hard work of the DLR team.</font></p>
<p><a name="bookmark412"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4307"></a>14.6 Summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It feels like we’ve come a long way from mainstream, statically typed C#. We’ve looked at some situations where dynamic typing can be useful, how C# 4 makes it possible (both in terms of the code you write and how it works under the surface), and how to respond dynamically to calls. Along the way, we’ve seen a bit of COM, a bit of Python, some reflection, and learned a little about the Dynamic Language Runtime.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This has </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> been a complete guide to how the DLR works, or even how C# operates with it. The truth is, this is a deep topic with many dark corners. In reality, many of the problems are obscure enough that you won’t bump into them—and most developers won’t even use the simple scenarios often. I’m sure whole books will be written about the DLR, but I hope I’ve given enough detail here to let 99 percent of C#</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">developers get on with their jobs without needing any more information. If you want to know more, the documentation on the DLR website is a good starting point (see <a href="http://mng.bz/0M6A">http://mng.bz/0M6A</a>).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you never use the dynamic type, you can pretty much ignore dynamic typing entirely. I recommend that you do exactly that for the majority of your code—in particular, I wouldn’t use it as a crutch to avoid creating appropriate interfaces, base classes, and so on. Where you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> need dynamic typing, I’d use it as sparingly as possible: don’t take the attitude, “I’m using dynamic in this method, so I might as well make </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">everything</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> dynamic.”</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I don’t want to sound too negative. If you find yourself in a situation where dynamic typing is helpful, I’m sure you’ll be thankful that it’s present in C# 4. Even if you never need it for production code, I’d encourage you to give it a try for the fun of it—I’ve found it fascinating to delve into. You may also find the DLR useful without really using dynamic typing: most of our Python example didn’t use any features of dynamic typing, but it used the DLR to execute the Python script containing the configuration data.</font></p>
<p><a name="bookmark4308"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4309"></a>Between this chapter and the previous one, we’ve now covered all the new features of C# 4 as a language. But part of th<a name="bookmark4310"></a>e aim of this book is to help developers evolve their ideas of idiomatic C#. Microsoft is introducing a new set of types and tools with .NET 4 that have the potential to change the way we write code in terms of robustness and clarity, just as LINQ has changed our perspective on working with collections. If you’re fed up with wondering exactly what a method requires in the way of argu-ments—or what it might return to you—then Code Contracts is for you.</font></p>
<p><a name="bookmark21"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark4311"></a>Letting your code speak more clearly with Code Contracts</font></p>
<p><a name="bookmark4312"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;The objectives of Code Contracts</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Writing contracts in your code</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Binary rewriting</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Static checking</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Contract documentation</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;Applying contracts</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This book is about C#, the language. I haven’t attempted to cover the whole of the .NET framework or even just the Base Class Library (BCL). Apart from when we were looking at different LINQ providers in chapter 12, I’ve been rigidly focused on explaining the features introduced in each version of C#. This chapter is somewhat different. It’s not about a new ability of the language itself, but a combination of tools and types (collectively called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Code Contracts</font><font style="font-size:x-small;font-family:Times New Roman, serif;">) that can radically change your</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">code’s appearance and how much information it conveys. If this were a book about the English language, this would be a chapter on poetry. Even though poems use the same words as prose, they look and feel different. You need to read them in a particular way to understand what they’re trying to express, but they can convey a lot of meaning in a powerful way.</font></p>
<p><a name="bookmark4313"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now I’m aw<a name="bookmark4314"></a>are that this all sounds melodramatic, and t<a name="bookmark4315"></a>he difference made by Code Contracts isn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">quite</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as striking as reading Shakespeare, but it’s pretty special nonetheless. I </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">hope</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that contracts take off <a name="bookmark4316"></a>to such an extent that within a few years, any book that attempts to convey idiomatic C# without demonstrating them would be seen as hideously outdated. Obviously I don’t want this book to be viewed in that light, so I've stretched my objective of being language focused <a name="bookmark4317"></a>to include thi<a name="bookmark4318"></a>s chapter.</font></p>
<p><a name="bookmark4319"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Contrac<a name="bookmark4320"></a>ts allow developers to express requirements and promises between APIs. Guarantees that have previously been given in documentation can now be stated once in code and automatically checked at execution time. Of course you’ve always been able to write assertions and argument validation in the past, but Code Contracts makes the whole process a lot smoother, with features such as contract inheritance and automatic documentation generation. Additionally, if you’re using Visual Studio Premium or <a name="bookmark4321"></a>Ultimate, the contracts can be used to check your code for correctness at compile time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although this isn’t part of C# 4 itself, it has the same ubiquitous nature as language constructs. Whereas specific APIs for web services, database access, UI development, and so on are only relevant in certain situations, contracts are almost universally useful. When you treat the <a name="bookmark4322"></a>contracts as part<a name="bookmark4323"></a> of the task of designing a type, you’ll find you not only communicate your intentions more clearly with other developers, but you understand your code’s boundaries better yourself.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One of the consequences of this being a nonspecific technology is that it isn’t suited to full business-related examples. As such, most of the code samples in this chapter are short and don’t do anything useful in themselves. You may find it helpful to keep in mind a bit of code that you’re working on at the moment. Take a look at both the code and documentation for a method, and ask yourself what it’s trying to say. What does it need in order to do its job correctly? What will the results of that job be? At a larger level, what can you always say about the state of your object? Combining my examples of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">how</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to express contracts with your own real-world code may make the chapter more meaningful for you.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re going to start off by looking at how contracts have been expressed relatively informally before now, and then see how Code Contracts treats the same ideas. Once we have the hang of what contracts are for, we’ll look at what the tools can do to enforce them both at compile time and execution time. Finally, I’ll attempt to give some practical advice. There are lots of different ways of using contracts, and the tools provide a huge range of options. You’ll have to think about what’s right for your particular context, but I hope I’ll get you thinking along the right lines.</font></p>
<p><a name="bookmark414"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4324"></a>15.1 Life before Code Contracts</font></p>
<p><a name="bookmark4325"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4326"></a><a name="bookmark4327"></a>The i<a name="bookmark4328"></a>dea of contracts isn’t new. Bertrand Meyer made it a key part of the design of the Eiffel programming language in the 1980s, and <a name="bookmark4329"></a>it’s been<a name="bookmark4330"></a> gradually becoming more mainstream ever since. A lot of computer science research has gone into </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">formal specification and verification,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> which allows a program to be checked for correctness at compile time, but that isn’t the only benefit of contracts.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">At the heart of programming by contract is the idea of separating the requirements and guarantees of an API fr<a name="bookmark4331"></a>om the implementation. It’s no coincidence that this sounds like the use of interfaces, but contracts allow a much richer expression of behavior. You may be thinking that there’s nothing new about the idea of specifying what a method<a name="bookmark4332"></a> will do, and what it requires of its inputs. We do that all the time with doc<a name="bookmark4333"></a>umentation. There’s nothing new about the idea of checking this at execution time, either. Of course, sometimes the two might get slightly out of sync, but we usually seem to get by.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Suppose we were to write a method that counted the number of whitespace characters in a given string. The following listing shows one possible implementation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.1 Simple method with argument validation and documentation</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// &lt;summary&gt;Counts the number of whitespace characters /// in &lt;paramref name=&quot;text&quot;/&gt;.&lt;/summary&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// &lt;param name=&quot;text&quot;&gt;String to examine. Must not be null.&lt;/param&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// &lt;paramref name=&quot;text&quot;/&gt; is null.&lt;/exception&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// &lt;returns&gt;The number of whitespace characters.&lt;/returns&gt; static int CountWhitespace(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (text == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new ArgumentNullException(&quot;text&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return text.Count(char.IsWhiteSpace);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark4334"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.1 has more XML docu<a name="bookmark4335"></a>mentation than I usually provide, I’ll admit. I rarely bother documenting exceptions that are obvious from the text: in this case we’ve already stated that text can’t be null, so why add the extra f<a name="bookmark4336"></a>luff? Likewise I’m sometimes sloppy when it comes to providing proper parameter references and the like. I’m somewhat pickier for public APIs, but not to the point of perfectionism. I strongly suspect I’m not alone in this. If you pay as much attention to the documentation of your methods as the implementation, my guess is that you’re in a tiny minority.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’re being pretty rigorous in the implementation, validating that the parameter isn’t null. The fact that it’s taking up four out of the five lines is unfortunate, but avoidable. I've found it handy to have a generic extension method with a reference type constraint that lets me write validation like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">text.ThrowIfNull(&quot;text&quot;)</font></p>
<p><a name="bookmark4337"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s annoying to have to restate the name of the parameter (and I usually have an overload allowing me to omit <a name="bookmark4338"></a>it when I don’t care) <a name="bookmark4339"></a>but at least it’s compact. Some people object to this as an abuse of extension methods, but I find it useful. In particular it’s more compact than writing something like ExceptionUtils.ThrowIfNull(text, &quot;text&quot;): the name of the class here is pure cruft; it doesn’t help us understand the code at all. Arg<a name="bookmark4340"></a>uably in this case you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> just let Enumerable .Count throw Argument-NullException, but then the reported parameter name would be source instead of text, which isn’t ideal. It’s also generally preferable to explicitly perform validation before doing anything else: it makes it a lot easie<a name="bookmark4341"></a>r to guarantee that calling a method with invalid arguments won’t have any side effects beyond<a name="bookmark4342"></a> the exception being thrown.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">An alternative to this would be to us<a name="bookmark4343"></a>e Debug.Assert(text != null), which performs the same c<a name="bookmark4344"></a>hecking for debug builds but won’t (by default) catch bad arguments in a release build. Finally, you c<a name="bookmark4345"></a>ould use exactly the same code, but put it all on one line, possibly omitting the braces. Personally I don’t favor that style, but it’s an alternative to consider.</font></p>
<p><a name="bookmark4346"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Even with all this bulk around what’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">effectively</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a single-line implementation, we haven’t said all we could. We know that the return value will always be greater than or equal to 0. (You can’t create strings with lengths great<a name="bookmark4347"></a>er than int.MaxValue.) We could communicate that by making the return value uint instead, but unsigned type<a name="bookmark4348"></a>s aren’t used particularly commonly in .NET, partly because they’re not CLS-compliant. It’s reasonably obvious to a human that this will be the case, but not to a machine. It’s also tricky to verify that claim a<a name="bookmark4349"></a>t execution time in the general case, unless you rig<a name="bookmark4350"></a>orously stick to a single exit point per method, which I find detrimental to readability in many situations.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Why would a machine care whether the return value was nonnegative? Well, suppose we then wanted to feed that into another method for some reason, and that method required the argument to be nonnegative. Wouldn’t it be nice if something could check that we met that requirement—and also check at execution time that the first method really </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">did</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> return a nonnegative value? Enter Code Contracts.</font></p>
<p><a name="bookmark415"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4351"></a>15.2 Introducing Code Contracts</font></p>
<p><a name="bookmark4352"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Code<a name="bookmark4353"></a> Contracts has its roots in a research l<a name="bookmark4354"></a>anguage developed by Microsoft called Spec# (see <a href="http://mng.bz/4147">http://mng.bz/4147</a>). Like CQ (the research language that spawned LINQ), this is a C#-like language with a twist. In this case, the main twist is contracts, which are expressed in a declarative manner. For example, in Spec#, expressing the contract that a parameter has to be non-null is a simple matter of changing the declared type of the parameter:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static int CountWhitespace(string! text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return text.Count(char.IsWhiteSpace);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark4355"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Spec# features compile-time<a name="bookmark4356"></a> support for non-nullable reference types as well as a sophisticated program verifier.</font></p>
<p><a name="bookmark4357"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Code <a name="bookmark4358"></a>Contracts attempts to cover the same sort of ground, but purely with a library and tools. This approach has the advantage of giving all the benefits to all languages immediately, but doesn’t yield quite as concise code. Contracts are expressed at a per-type and<a name="bookmark4359"></a> a per-me<a name="bookmark4360"></a>mber level as calls to methods in the System.Diagnostics. Contracts.Contract class. Unless I specify otherwise, every contract-related method in this section is in the Con<a name="bookmark4361"></a>tract class.</font></p>
<p><a name="bookmark4362"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4363"></a><a name="bookmark4364"></a>A tool called ccrewrite—also known as the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">binary rewriter</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—then executes as part of the build<sup><a name="footnote100"></a><a href="#bookmark4365">100</a></sup> to make sure that the contr<a name="bookmark4366"></a>acts are enforced according to your project settings. A closely related tool is ccrefgen, which generates </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">contract reference assemblies </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to be distributed alongside the implementation assemblies, giving contract information to clients even if the contract checks have been removed from <a name="bookmark4367"></a>the implementation. Another tool called ccc<a name="bookmark4368"></a>heck—also known as the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">static checker</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—is available if you’re using Visual Studio 2010 Premium or Ultimate edition. The aim of the checker is to prove that your code will satisfy your contracts at compile time, rather than just checking what’s actually happening at execution time. F<a name="bookmark4369"></a>inally, you can probably guess what ccdocgen is for: it generates XML documentation for the contracts specified in the code.</font></p>
<p><a name="bookmark4370"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The Code Contract tools aren’t<a name="bookmark4371"></a> included in Visual Studio 2010 or .NET 4, but the core types are exp<a name="bookmark4372"></a>osed in mscorlib. You need to download the tools from the Code Contracts DevLabs page (<a href="http://mng.bz/CN2k">http://mng.bz/CN2k</a>); after installation your Visual Studio project properties page should have a Code Contracts tab, as shown<sup><a name="footnote101"></a><a href="#bookmark4373">101</a></sup> in figure 15.1. The contracts can be broadly divided into five main categories. We’ll look at each category briefly so we know what’s available, and then see what the tools are capable of once we’ve defined our contracts.</font></p>
<p><a name="bookmark416"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4374"></a><a name="bookmark4375"></a>15.2.1 Preconditions</font></p>
<p><a name="bookmark4376"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4377"></a>Preconditions make requirements of the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">caller</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of a method rather than expressing anything about the behavior of the method itself in normal conditions. We all know that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">our</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> code works perfectly but no one else’s can be trusted, so preconditions are the most common form of contract-like code in existing programs. That’s exactly what we have in our whitespace-counting sample: we require that the text parameter be nonnull. Preconditions are expressed with the Requires method. There are four forms of this—each takes a condition, but there’s<a name="bookmark4378"></a> also an optional message and an exception type can be expressed as a type argument.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As we’re putting a burden on the caller, the condition has to be expressed in terms that the caller is in charge of or can at least check. Code Contracts will warn you if a</font></p><img src="images/62.png"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Figure 15.1 Code Contracts project property page in Visual Studio 2010</font></p>
<p><a name="bookmark4379"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">member’s precondition depends on a piece of state with less visibility than the mem-ber—it wouldn’t be fair to the caller.<sup><a name="footnote102"></a><a href="#bookmark4380">102</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you<a name="bookmark4381"></a> don’t specify a type argument, a contract<a name="bookmark4382"></a> failure will throw a Contract-Exception—if none of the contract failure handlers involved terminate the process first. The execution-time behavior of contracts is complicated, but we’ll look at it in the next section. For now, we’re just seeing what the contracts look like. Here’s our whitespace counter with a simple precondition:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">static int CountWhitespace(string text)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">{</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Contract.Requires(text != null); return text.Count(char.IsWhiteSpace);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">}</font></p>
<p><a name="bookmark4383"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">If we wanted to still throw ArgumentNullException, we could use the generic form of Requires, which specifies which exception to throw:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">static int CountWhitespace(string text)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Requires&lt;ArgumentNullException&gt;(text != null, &quot;text&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return text.Count(char.IsWhiteSpace);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This time we specify the message ex<a name="bookmark4384"></a>plicitly, because we want the exception thrown to have the right value for its ParamName property.</font></p>
<p><a name="bookmark4385"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">For other contract types, you don’t need to make the decision between the default behavior and a specific exception type, because they involve failures in </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">your</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> code rather than the caller’s. Let’s move on to the opposite of preconditions: postconditions.</font></p>
<p><a name="bookmark417"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4386"></a>15.2.2 Postconditions</font></p>
<p><a name="bookmark4387"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Whereas preconditions express constraints on the input to <a name="bookmark4388"></a>a method (potentially including the original state of the target object), p<a name="bookmark4389"></a>ostcond<a name="bookmark4390"></a>itions express constraints on the output of<a name="bookmark4391"></a> a method: its return value, any out or ref parameter values, and any mutated state (whether in the t<a name="bookmark4392"></a>arget object or one of the parameters). Postconditions are expressed with the Ensures method. For example, we can easily express that our whitespace counter will never return a negative value,<sup><a name="footnote103"></a><a href="#bookmark4393">103</a></sup> as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.2 Expressing a simple postcondition for a return value</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static int CountWhitespace(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Requires(text != null, &quot;text&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Ensures(Contract.Result&lt;int&gt;() &gt;= 0);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return text.Count(char.IsWhiteSpace);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may be surprised to see that the postcondition comes </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">before</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the actual implementation. On the face of it, that makes no sense—it can’t possibly check the return value before it’s calculated. This is where<a name="bookmark4394"></a> there’s an important difference between Code Contracts and any manual assertions we could’ve implemented before. Previously, the implementation code and the checks were intermingled—there was no difference between them, essentially. Code Co<a name="bookmark4395"></a>ntracts are all about </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">expressing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the checks, not executing them. The binary rewriter takes care of actually validating the contract at execution time if necessary, or removing the checks entirely otherwise.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All preconditions and postconditions are expressed before the main implementation in Code Cont<a name="bookmark4396"></a>racts. The tools assum<a name="bookmark4397"></a>e that anything that <a name="bookmark4398"></a>comes after the last reference to Contract (apart from calls to Assert and Assume, which we’ll meet in a minute) is part of the implementation, but anything up to that point is purely contractual and has no impact on the real work of the method. If you mistakenly put a postconditi<a name="bookmark4399"></a>on at the end of the method, Code Contracts will complain of a “malformed contract.”</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Normally to express a pos<a name="bookmark4400"></a>tcondition on a return value, you’d set the candidate return value in a local variable, test that its value was appropriate, and then return it.</font></p>
<p><a name="bookmark4401"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Obviously we can’t do that when the contract is expres<a name="bookmark4402"></a>sed before the implementation, so the Result&lt;T&gt; method acts as a sort of placeholder: when the tools see a call to it, they know it means “the return value when we really get there.”</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Two similar methods exist for situations where y<a name="bookmark4403"></a>ou want to refer to state that changes during the cour<a name="bookmark4404"></a>se of execution. The OldValue method refers to the original state, and ValueAtReturn refers to the final state. The rewritten code will capture any original state it needs to after the preconditions are checked. Listing 15.3 shows an example of using all three of these methods in a single contract. The implementation is buggy, but the postcondition protects the caller by alerting them to the problem.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.3 A complicated postcondition involving a return value, old and new state</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static bool TryParsePreserveValue(string text, ref int value) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Ensures(Contract.Result&lt;bool&gt;() || &nbsp;&nbsp;&nbsp;&lt;—<sup>1</sup></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.OldValue(value) == Contract.ValueAtReturn(out value)); return int.TryParse(text, out value);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark4405"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The idea behind the method in listing 15.3 is for it to act like int.TryParse, but instead of taking an out parameter to receive the result, it takes a ref parameter. If parsing fails, the value should stay as it was before—this makes it easy to use a default value. In other words, either our return value should be true (successful parse) </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">or</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the value should be the same at the end as it was at the start. Unfortunately, our implementation doesn’t obey this properly—it uses the parameter as an argument to int .TryParse, which will overwrite the value with 0 if parsing fails.<sup><a name="footnote104"></a><a href="#bookmark4406">104</a></sup> The postcondition will spot this and blow up appropriately rather than letting the caller continue assuming that the implementation was correct.</font></p>
<p><a name="bookmark4407"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">One final feature of postconditions is exception handling. Any contract expressed using Ensures is only relevant when the method completes normally. You can specify any postconditions for exceptional situations using EnsuresOnThrow&lt;T&gt;, where T is an exception type. This allows you to have different postconditions for different scenarios, although this isn’t typically needed.</font></p>
<p><a name="bookmark418"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4408"></a>15.2.3 Invariants</font></p>
<p><a name="bookmark4409"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we haven’t actually used any state in our tests, although we certainly could have—it’s entirely reasonable to depend on the initial state of an object in a precondition, and a method that mutates an object may want to express the intended result as a postconditio<a name="bookmark4410"></a>n.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Invariants are slightly different: they’re contracts about the state of the object which should apply at all times that the state is visible. In other words, it’s okay to change an invariant while a public method in the class is running, but at the end of the method the invariant should be satisfied again. In Code Contracts, invariants ar<a name="bookmark4411"></a>e expressed through an extra method d<a name="bookmark4412"></a>ecorated with the Contra<a name="bookmark4413"></a>ctInvariantMethod attribute. The method is conventionally na<a name="bookmark4414"></a>med ObjectInvariant, but it doesn’t have to be. Inside the method, you call Invariant to check the invariants. When invariants are enabled, they are run at the end of every public method.<sup>6</sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Despite the name, invariants aren’t always about a value remaining the same. They’re about a fixed condition always holding. For example, you might have a string variable which is modified over the lifetime of an object, but which should never be null. You </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> express that fact everywhere that the field was modified, but it’d be easy to make a mistake. An invariant allows you to apply the check automatically at predictable places.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As another example, suppose we were writing a card game. Cards can move between the deck, a player’s hand, and the discard pile—but cards are never duplicated or lost. We can express this reasonably cheaply as an object invariant by counting the cards in each location. Here’s the skeleton of a possible CardGame class, including its invariant:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public sealed class CardGame {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private readonly Stack&lt;Card&gt; deck =</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new Stack&lt;Card&gt;(Card.CreateFullDeck()); private readonly Stack&lt;Card&gt; discardPile = new Stack&lt;Card&gt;(); private readonly List&lt;Player&gt; players = new List&lt;Player&gt;();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void DealCard(Player player) { ... }</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ContractInvariantMethod] private void ObjectInvariant()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Invariant(deck.Count + discardPile.Count +</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">players.Sum(p =&gt; p.CardCount) == Card.FullDeckSize);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For such a short piece of code, there’s a lot to talk about. The obvious point is that the invariant method is a void, parameterless method decorated with the required attribute to make it an object invariant. It’s also private: even in nonsealed classes, the invariant method must be private. Derived classes need to be able to call the invariant implicitly, but the binary rewriter takes c<a name="bookmark4415"></a>are of that for you by turning it into a protected method with an unspeakable name.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth noting that the invariant I've expressed isn’t foolproof by any means. We’re only checking how many cards there are, not that they’re all different. A method to deal a card could easily break a more strict invariant but pass this one. But by making the invariant cheap to execute, we can keep it enabled in more situations without worrying about losing too much performance.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All the work is done in the evaluation of the argument to Invariant. An invariant method can only contain calls to Invariant, with n<a name="bookmark4416"></a>o loops, local variables, and so on. This is important for the sake of the static checker, which tries to understand what your invariants really mean in order to prove that they’re maintained. If it gets really difficult to express an invariant inline in a single expression, you can always create another method or property to call, but this will leave the static checker with less chance of helping you.</font></p>
<p><a name="bookmark4417"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two methods to help express con<a name="bookmark4418"></a>tracts (including preconditions and postconditions) more simply: ForAll and Exists, which take predicates to check for a range of items. For example, if you wanted to express an invariant that a collection didn’t contain any null elements, you could use either of the following equivalent contracts:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Invariant(Contract.ForAll(collection, item =&gt; item != null)); Contract.Invariant(!Contract.Exists(collection, item =&gt; item == null));</font></p>
<p><a name="bookmark4419"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4420"></a><a name="bookmark4421"></a>Sometimes, there are conditions that you want to check during the execution of the method. These aren’t contracts in the same sense as preconditions, postconditions, and invariants, but they’re still validating the logic of the method.</font></p>
<p><a name="bookmark419"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4422"></a>15.2.4 Assertions and assumptions</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we’ve been performing sanity checking before or after executing the useful work of a method. That’s fine in many cases, particularly for short methods, but sometimes it’s nice to be able to put a stake in the ground about what’s goin<a name="bookmark4423"></a>g on halfwa<a name="bookmark4424"></a>y through a method.<sup>7</sup> Code Contracts <a name="bookmark4425"></a>provides two methods for this: Assert and Assume. If you’re not using the static checker, you don’t need to know the dif<a name="bookmark4426"></a>ference between them, and they both act in a similar way to the familiar Debug. Assert method, checking that a condition is true at execution time, assuming assertions are enabled.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The static checker treats the two somewhat differently. It tries to prove that an assertion is correct, but makes no such attempt for an assumption: it believes that you know what you’re claiming. In both cases, it’ll add the condition to its set of known facts from that point onward. If you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use Assert instead of Assume, it’s a more powerful method—but Assume is useful if you want to effectively let the static checker know something it can’t prove. Listing 15.4 shows an example of this, providing a method to simulate rolling a pair of dice.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.4 Making assumptions and assertions when rolling dice</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static int RollDice(Random rng)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Ensures(Contract.Result&lt;int&gt;() &gt;= 2); Contract.Ensures(Contract.Result&lt;int&gt;() &lt;= 12);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (rng == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">rng = new Random();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Assert(rng != null);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int firstRoll = rng.Next(1, 7);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Assume(firstRoll &gt;= 1)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Assume(firstRoll &lt;= 6) int secondRoll = rng.Next(1, 7)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Assume(secondRoll &gt;= 1);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Assume(secondRoll &lt;= 6);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return firstRoll + secondRoll;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.4 provides a method that can roll a pair of pseudorandom six-sided dice, either based on a new instance of Random with a time-based seed or an existing instance. First we express a postcondition </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">which states that the outcome of rolling the two dice will be between 2 and 12 inclusive. By the end of the method, the static checker should be able to prove that this is the case.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">After we’ve possibly created a new instance of Random, we know that the rng variable won’t be null, so we’re safe to call methods on it. We’re so sure of this that we assert it—we think the static checker will be able to prove it </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Usually assertions would be more complicated, of course: we’d be asking the checker to prove something that wasn’t obvious, both for our own peace of mind and for the benefit of anyone reading the code later.</font></p>
<p><a name="bookmark4427"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we definitely have a reference to a random-number generator, we can roll the dice. Let’s assume the static checker doesn’t know what Random.Next does,<sup><a name="footnote105"></a><a href="#bookmark4428">105</a></sup> so we tell it what it can assume about the output </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">E</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Based on those assumptions, the static checker will try to check our postconditions. Note that each of the conditions we’ve specified (for each of the dice rolls and for our postcondition) is split into two parts: one for the minimum value, and one for the maximum. Th<a name="bookmark4429"></a>e static checker is able to understand individual contracts more easily than compound ones using the &amp;&amp;&nbsp;operator. Not only is it able to prove more results this way, but the error messages are clearer too, as it can point out exactly which condition may be violated.</font></p>
<p><a name="bookmark420"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4430"></a>15.2.5 Legacy contracts</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The final type of contract is really another kind of precondition—and we’ve already seen an<a name="bookmark4431"></a> example of it, way back before we started using the contracts library. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Legacy contracts</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> are the preconditions we expressed with if/throw statements in our original code. Legacy contracts have to be expressed simply, using jus<a name="bookmark4432"></a>t conditions with throw statements. There can’t be any assignments or any other </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">impure</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> code.</font></p>
<p><a name="bookmark4433"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4434"></a><a name="bookmark4435"></a><a name="bookmark4436"></a><a name="bookmark4437"></a>PURITY You can call other code from all contracts, but only if it’s </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">pure.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> This means it can’t have any side effects. You can use the [Pure] attribute to mark your own methods as being pure, and you can call existing pure methods defined on other types. The Code Contracts documentation lists the framework methods<a name="bookmark4438"></a> that are assumed to <a name="bookmark4439"></a>be pure—most nota<a name="bookmark4440"></a>bly anything in System.String, and the Pre<a name="bookmark4441"></a>dicate&lt;T&gt; and Comparison&lt;T&gt; delegates. The contract reference assemblies shipped with Code Contracts also decorate other aspects of the framework, such as the Enumerable .Sum me<a name="bookmark4442"></a>thod we called in the previous section. Operators and property getters are also assumed to be pure.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As I mentioned when we discussed postconditions, the Code Contracts tools assume that anything after the last reference to Contract is part of the functional part of the method implementation. Our original code didn’t have any co<a name="bookmark4443"></a>de calling Contract at all, so we need to give the tools a clue using EndContractBlock, as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.5 Signalling the end of a contract block explicitly</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static int CountWhitespace(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (text == null)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">throw new ArgumentNullException(&quot;text&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.EndContractBlock(); return text.Count(char.IsWhiteSpace);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just to be clear, the EndContractBlock method does </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">ab<a name="bookmark4444"></a>solutely nothing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> at execution time. It’s solely there for the benefit of the binary rewriter, which actually removes the call in the rewritten code. An alternative strategy is t<a name="bookmark4445"></a>o replace legacy contracts with the new ones. If you express another new style contract such as a postcondition after the legacy contract but before the main body of the code, the rewriter knows what to do automatically: you don’t need EndContractBlock in that situation. This has the additional benefit of expressing the postcondition, which has to be a good thing. But I’d personally go the whole hog and convert the preconditions to the new style of con-tracts—it makes the code more consistent, as well as making the rewriter include a more useful error message if the contract is violated. There’s not a lot of advantage to maintaining the legacy contracts—although they could make it slightly easier to have one build targeting a recent framework and using Code Contracts, and another build targeting (say) .NET 2.0 and using just legacy contracts. At that point, you’d only need to write an EndContractBlock method in your own Contract class, and you’d have compatibility. This is a fairly extreme case—it’d usually just be better to convert the code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth bearing in mind that even just using EndContractBlock could be considered a breaking change to existing code. Depending on your exact settings, you may</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">end up with a different exception being thrown by the contract checker, or the precondition being removed entirely, leaving your method to blithely execute its main code with potentially invalid parameters.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If the tools dete<a name="bookmark4446"></a>ct that you’re using code that isn’t part of a contract from within the contract section, it’ll report an error. There are cases that’ll fool the tools, but most problems will be caught this way.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve seen the basics of what we can do with contracts, we really need to look at how the tools involved use them. We’ll start off with the binary rewriter.</font></p>
<p><a name="bookmark421"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4447"></a>15.3 Rewriting binaries with ccrewrite and ccrefgen</font></p>
<p><a name="bookmark4448"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4449"></a>In the history of .NET, there have been many advances that have required two or more pieces of the ecosystem to both improve at the same time. Even features that don’t require any explicit library or runtime support (such as object initializers and anonymous types) have typically been designed to fit <a name="bookmark4450"></a>into a grander plan. In the case of Code Contracts, the library and the supporting tools really are critical to each other. You </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can </font><font style="font-size:x-small;font-family:Times New Roman, serif;">express some contracts in code but then ignore the t<a name="bookmark4451"></a>ools. The preconditions will be checked (so long a<a name="bookmark4452"></a>s you define the CONTRACTS_FULL or CONTRACTS_PRECONDITIONS preprocessor symbol); postconditions will generate an assertion telling you to use the rewriter; invariants simply won’t be called. Likewise you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use the binary rewriter without expressing any contracts—but don’t expect it to do anything useful.</font></p>
<p><a name="bookmark4453"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll look at documentation and static checking later, but the rewriter is at the core of Code Contracts. Let’s see what it can do.</font></p>
<p><a name="bookmark422"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4454"></a>15.3.1 Simple rewriting</font></p>
<p><a name="bookmark4455"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Just as the name suggests, the binary rewriter takes the assembly you’ve just built and rewrites parts of it. Usually it replaces the original assembly, but you can ask it to create a new one in another directory instead. Some of the operations are pretty much what you’d expect, but there are sophisticated features too. Let’s start with the obvious ones. For each method, the rewriter will rewrite it so that it follows this sequence of events:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Preconditions are checked.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Initial state is captured for OldValue method calls.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The functional part of the code executes (including any assertions and assumptions being checked; they aren’t moved around by the binary rewriter).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Postconditions are checked.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Invariants are checked on public methods.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Unless you’ve already specified a message in the contract, the rewriter examines your source code and r<a name="bookmark4456"></a>ewrites the contract to use the actual code for the message. You have to build a PDB file for it to extract the source, but the default settings for Visual Studio work fine for both debug and release builds. The target of the contract call is also changed—instead of using the version of Contract in mscorlib, a new type is created</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">in the rewritten assembly called _ContractsRuntime. This contains everythin<a name="bookmark4457"></a>g</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">required at execution time, and also has a nested type called ContractException, which is the exception type used by default for failed contracts that didn’t have another one specified explicitly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Various options may remove some of these checks; for instance, you may only want to check preconditions for a release build, or only check contracts for public methods. You can use the Perform Runtime Contract Checking and Only Public Surface Contracts options in the project property page to control which contracts are included in the rewritten file.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The rewriter’s behavior can be tweaked in a number of ways, and I’m not going to delve into every available switch, but I’ll cover the most important options. If you can imagine some form of flexibility that might be useful, chances are ccrewrite supports it. This should reinforce the idea that contracts aren’t normal code. The C# compiler doesn’t know anything special about contracts</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">—it</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> thinks they’re normal code—but the rewriter can radically change how your code behaves.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you look inside the rewritten code, you’ll see that there’s slightly more to it even in the simplest case. Just in case you use a method o<a name="bookmark4458"></a>r property with a contract as part of evaluating anoth<a name="bookmark4459"></a>er contract, there’s a recursion guard to stop the contract from blowing up the stack. Combining all of this together, our simplest contract method is rewritten as the following.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.6 A simple contract after binary rewriting</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private static int CountWhitespace(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">if (_ContractsRuntime.insideContractEvaluation &lt;= 4)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">try</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">_ContractsRuntime.insideContractEvaluation++;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">_ContractsRuntime.Requires(text != null, null,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;text != null&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">finally</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">_ContractsRuntime.insideContractEvaluation--;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return text.Count(char.IsWhiteSpace);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Fortunately you’ll rarely need to dive into the details of this, but it can make for some interesting reading—particularly when other options are involved. What appears to be a simple <a name="bookmark4460"></a>method can become quite complex. Any concerns about the impact on performance should be<a name="bookmark4461"></a> measured rather than guessed, but i<a name="bookmark4462"></a>t’s worth considering that this extra complexity may reduce the CLR’s ability to inline code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Another way to introduce complexity is to bring inheritance into the picture. That’s true in general, but Code Contracts brings an extra (welcome) twist.</font></p>
<p><a name="bookmark423"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4463"></a>15.3.2 Contract inheritance</font></p>
<p><a name="bookmark4464"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4465"></a><a name="bookmark4466"></a>It’s hard to say what I like best about Code Contracts, but contract inheritance is certainly one of the neatest features. It can be summed up in two rules:</font></p>
<p><a name="bookmark4467"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;<a name="bookmark4468"></a>When you override a method (or implement an interface method), you inherit its contracts.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;You <a name="bookmark4469"></a>can’t add extra pr<a name="bookmark4470"></a>econditions to inherited ones, but you can make invariants and postconditions stronger.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s get<a name="bookmark4471"></a> the second rule out of the way first. It’s really about Liskov’s Substitution Principle (see <a href="http://mng.bz/sb2w">http://mng.bz/sb2w</a>): if a caller only knows that it’s using an interface, and its call meets all the preconditions in the interface, it would be unfair to claim that it violated a contract that you happen to want on your implementation. But you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> guarantee that your implementation goes above and beyond the call of duty when it comes to postconditions and invariants.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Bearing that in mind, how does the first rule work? Essentially the rewriter inserts all the inherited preconditions and postconditions into the methods as it goes, and makes any invariant methods call the base invariant method if there is one. The following listing shows an example of this, as well as displaying the order in which the contracts are tested.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.7 Contract inheritance with concrete classes</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[Pure] static bool Report(string text) {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(text); return true;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Base {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public virtual void VirtualMethod(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Requires(Report(&quot;Base precondition&quot;)), Contract.Ensures(Report(&quot;Base postcondition&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">class Derived : Base {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public override void VirtualMethod(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Ensures(Report(&quot;Derived postcondition&quot;));</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Base d = new Derived(); d.VirtualMethod(&quot;&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Report method O is used to simulate a condition that’s always satisfied, and also give an indication of what’s going on without having to decompile the code. The code</font></p>
<p><a name="bookmark4472"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">does nothing other than check the fake condition. We have a virtual method declared in Base </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and overridden in Derived </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">; both have postconditions but only the base declaration is allowed to specify preconditions. In the downloadable source code version, there are also invariants in both classes to demonstrate inheritance there, too. The output of listing 15.7 makes it clear that even though the override in Derived doesn’t call base.VirtualMethod(), the contracts are still enforced:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Base precondition Derived postcondition Base postcondition</font></p>
<p><a name="bookmark4473"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4474"></a>In the case of invariants, the base invariant is called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">before</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the derived one.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">BREAKING INVARIANTS SNEAKILY Invariants are only applied to </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">public</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> methods... and the rewriter only applies the invariant of the class that it knows about. If a public method in a base class calls a protected virtual method in a derived class, that method may break the derived class’s invariant without it being checked. There’s an example in the full source code, and there are other ways of observing an object while its invariants are broken unless you’re careful.</font></p>
<p><a name="bookmark4475"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4476"></a>The lesson is to not assume that invariants are bulletproof. You should understand when they’re expected to hold, and if you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> expose the object in a broken state (such as via a callback), you should document that clearly.</font></p>
<p><a name="bookmark4477"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s all well and good, I hear you say, but what about abstract methods and interfaces? How can we express the contracts for methods we’re not implementing? Good question. I’m perso<a name="bookmark4478"></a>nally somewhat wary of class inheritance—I think it’s easy to abuse and hard to design well. Interfaces, though, are great—it’d be a pity if we couldn’t express contracts on them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Fortu<a name="bookmark4479"></a>nately, we can. We just need to create a new abstract class to implement the interface or derive from the <a name="bookmark4480"></a>abstract class, purely for the sake of expressing contracts. This is called th<a name="bookmark4481"></a>e </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">contract class.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> We then decorate the interface or ab<a name="bookmark4482"></a>stract class with a [ContractClass(...)] attribute, and also add a [ContractClassFor(...)] attribute to the contract class. The contract class implements the methods just by a series of contract calls, and the contracts are automatically applied to any implementations (assuming the appropriate rewriter options are turned on).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The next listing shows a simple interface with a contract class and an implementation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.8 Specifying contracts for an interface</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ContractClass(typeof(ICaseConverterContracts))] public interface ICaseConverter {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string Convert(string text);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ContractClassFor(typeof(ICaseConverter))] &nbsp;&nbsp;&nbsp;„</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">internal abstract class ICaseConverterContracts : ICaseConverter</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public string Convert(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Requires(text != null);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Ensures(Contract.Result&lt;string&gt;() != null); return default(string);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private ICaseConverterContracts() {}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class CurrentCultureUpperCaseFormatter : ICaseConverter {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public string Convert(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return text.ToUpper(CultureInfo.CurrentCulture);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is basically the simplest interface I could imagine with useful pre- and postconditions. It’s meant to convert a string to a particular case (lower, upper, title, and so on). You should never pass in a null reference, and implementations should never return a null reference. The interface specifies that its contracts are in ICaseConver<a name="bookmark4483"></a>ter-Contr<a name="bookmark4484"></a>acts </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and that refers back to the interface </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. The suggested con<a name="bookmark4485"></a>vention is to name the contract class after the interface, just with a Contracts suffix. This looks slightly odd, as ther<a name="bookmark4486"></a>e’s then a class with an I-prefixed name, but it’s effectively just representing metadata about the interface. It’s not a normal class in terms of implementing real behavior. (The CLR considers it to be an entirely normal class, of course— only the Code Contracts tools and we as developers make the distinction.) You may wish to consider keeping the contracts class in the same file as the interface, again with the justification that it’s really just metadata and not a separate concept.<sup><a name="footnote106"></a><a href="#bookmark4487">106</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In the contracts-only implementation of Convert, we express the precondition and postcondition in the normal way </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">before returning a defau<a name="bookmark4488"></a>lt value </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. You could explicitly return null of course—I just find that using default (...) gives more of a hint that this isn’t meant to be treated as a real result. Of course this would actually violate the postcondition if we executed it, but that doesn’t matter, as this code is only present for the sake of the contracts. To make sure that we never really create an instance of the contract class, I've given it a private constructor which is never called from the class itself </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. I've also made it internal so that it won’t confuse developers in other projects.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Finally we’ve implemented the interface in a normal way in CurrentCulture-UpperCaseFormatter. The implementation doesn’t specify any contracts or do any checks itself </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">G</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Instead it relies on the binary rewriter to enforce the contracts at execution time.</font></p>
<p><a name="bookmark4489"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Admittedly the contract is separated from the interface itself, but apart from that, this is a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">great</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> situation to be in. We don’t have to test that the interface implementations <a name="bookmark4490"></a><a name="bookmark4491"></a>honor the preconditions, and although w<a name="bookmark4492"></a>e may write tests to try to provoke the postconditions being violated in corner cases, we can be confident that such violations won’t silently be propagated to calling code (assuming the appropriate rewriter settings, of course). Callers can also be certain of what they’re allowed to do—the preconditions are clearly stated, and implementations can’t have added their own ones. Of course there’s nothing to stop an implementation from checking and throwing an ArgumentException anyway, bu<a name="bookmark4493"></a>t in a system based on Code Contracts, this is a conscious violation of best practices, rather than the accidental introduction of an extra requirement.</font></p>
<p><a name="bookmark424"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4494"></a><a name="bookmark4495"></a><a name="bookmark4496"></a>15.3.3 Contract reference assemblies</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Code Contracts has more capabilities up its virtual sleeves. Sometimes you may not want the contracts to be present in the execu<a name="bookmark4497"></a>table code, but you want to let callers use the contracts anyway. Another tool (ccrefgen)<a name="bookmark4498"></a> lets you build a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">contract reference assembly </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to distribute along with your normal assembly. The contract reference assembly contains all the types, interfaces, methods, and so on of the original assembly, but with no implementation except the orig<a name="bookmark4499"></a>inal contracts. It’ll have the same name as the original assembly, but with .Contracts at the end. For example, an assembly of Skeety-Soft.Media would have a contract reference assembly called SkeetySoft.Media. Contracts.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When another developer adds a reference to your main assembly, the Code Contract tools will look for the contract reference assembly to go with it. If it finds the contracts, it can use those for static checking and also enforce the preconditions in the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">caller’s</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> assembly. For example, consider the code in the following listing, which is split between a simple library class and a call to it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.9 Adding preconditions at the call site</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class PreconditionDemo {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void DontPassInNull(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Requires(text != null); Console.WriteLine(&quot;In DontPassInNull()&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new PreconditionDemo().DontPassInNull(&quot;hello&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Suppose the class library is built with execution-time contract checking turned off, but with a separate co<a name="bookmark4500"></a>ntract reference assembly. The calling assembly can tick Call-site Requires Checking in the Code Contacts project property page, at which point the last line is converted into something like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Diagnostics.Contracts.Wrappers.ContractAssemblyDemo. PreconditionDemo.NV$DontPassInNull(new PreconditionDemo(), &quot;hello&quot;)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The extra type here has been built<a name="bookmark4501"></a> into the calling assembly; its NV$DontPassInNull method executes the preconditions copied from the contract reference assembly (in</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">the normal way, with calls to_ContractsRuntime.Requires) and then calls the real</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">DontPassInNull method if the preconditions pass. It’s all seamless to the caller, which gets the same behavior as if preconditions were turned on in the target assembly. This way the caller gets to choose whether it wants contracts enforced, without requiring two different copies of the same assembly (one with contracts enabled and one without).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ONLY PRECONDITIONS ARE COPIED Using Call-site Requires Checking doesn’t enforce postconditions or invariants. In some cases it wouldn’t be able to— they can refer to the internal state of an object, which may not be visible to the caller. That shouldn’t be a problem—you do trust the code you’re calling to be perfect, don’t you? Seriously, it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">is</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> a matter of trust—and knowing what to expect. If you believe that it’s more likely that there’s a bug in your code than the code you’re calling (which is certainly the case when I’m developing against the BCL, for example) then there’s still a lot of value to having just the preconditions checked.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course if you turn this feature on and the target assembly also has execution-time checking, you’ll end up testing the preconditions twice, which isn’t ideal.</font></p>
<p><a name="bookmark425"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4502"></a>15.3.4 Failure behavior</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So far we’ve looked carefully at how to express the contracts and whether they’re checked, but hardly considered what happens when they’re violated. The behavior on failure is relatively complicated and highly tweakable, but it usually boils down to three possible options:</font></p>
<p><a name="bookmark4503"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4504"></a>■ &nbsp;&nbsp;&nbsp;A normal exception type will be thrown if you’ve specified one in a precondition.</font></p>
<p><a name="bookmark4505"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The system may raise an assertion err<a name="bookmark4506"></a>or window or break into the debugger if you’re alr<a name="bookmark4507"></a>eady debugging.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;A ContractException (created by the binary rewriter) will be thrown otherwise.</font></p>
<p><a name="bookmark4508"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The decision for whether to provoke an assertion failure or throw a ContractException is controlled by the Assert on Contract Failure option in the project properties. Note that it’s an either/or option. If you trigger an assertion failure but then ignore it, the code will proceed normally—it doesn’t throw a ContractException afterward. ContractException is deliberately designed to be uncatchable—you can’t refer to it in your own code. This is like the C# compiler generating unspeakable names for anonymous types and iterators.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The only way of catching a ContractException is to catch Exception. This is usually reserved for the top level of an application’s stack, where you might want to prevent one bad request from bringing down a whole server—although you generally</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">need to be careful of situations where you should terminate the whole process a<a name="bookmark4509"></a>nyway. The rationale for this is that you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">should</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> never be catching contract violations: they indicate bugs rather than some external failure, and it’s hard to sensibly proceed in the face of “I’m calling code and something’s gone wrong, but I've no idea what.”</font></p>
<p><a name="bookmark4510"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">All of this talk of exceptions and assertions is assuming you haven’t included any custom error handling of your own. A global event is raised whenever a contract fails: </font><font style="font-size:x-small;font-family:Courier New, monospace;">Contract.ContractFailed</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. This allows subscribers to observe the failure and optionally state that it has been handled. A handled failure won’t trigger an exception or break into the debugger. The following listing shows an example of this sort of masking, as well as showing what information is available in the event.</font></p>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">Listing 15.10 Masking a contract with </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.ContractFailed</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void RequireNonNullArgument(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Requires(text != null, &quot;Don't pass in null&quot;); Console.WriteLine(&quot;In method body&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void HandleFailure(object sender,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ContractFailedEventArgs args)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;{0}: &nbsp;&nbsp;&nbsp;{1}; &nbsp;&nbsp;&nbsp;{2}&quot;, &nbsp;&nbsp;&nbsp;args.FailureKind,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">args.Condition, args.Message); args.SetHandled();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.ContractFailed += HandleFailure; RequireNonNullArgument(null);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We start off with a method with a precondition </font><font style="font-size:medium;font-family:Corbel;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. This could be any contract that’s easily violated, but we’re just checking for argument non-nullity. Nothing new here. If the precondition is satisfied, we print out a diagnostic message.</font></p>
<p><a name="bookmark4511"></a><font style="font-size:x-small;font-family:Courier New, monospace;">HandleFailure </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">C</font><font style="font-size:medium;font-family:Times New Roman, serif;"> is the met<a name="bookmark4512"></a>hod we’re going to use to create an </font><font style="font-size:x-small;font-family:Courier New, monospace;">Event-Handler&lt;ContractFailedEventArgs&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">delegate for the </font><font style="font-size:x-small;font-family:Courier New, monospace;">ContractFailed </font><font style="font-size:x-small;font-family:Times New Roman, serif;">event. First it writes out the kind of failure (precondition, postcondition, invariant, assertion, or assumption), the condition that failed (in this case </font><font style="font-size:x-small;font-family:Courier New, monospace;">text != null</font><font style="font-size:x-small;font-family:Times New Roman, serif;">), and the message (if any—in this case “Don’t pass in null”). It then claims that we’ve handled the failure. If there are multiple handlers, they’ll still all get called, but only one handler needs to call </font><font style="font-size:x-small;font-family:Courier New, monospace;">SetHandled </font><font style="font-size:x-small;font-family:Times New Roman, serif;">for the fail<a name="bookmark4513"></a>ure to be considered as handled. </font><font style="font-size:x-small;font-family:Courier New, monospace;">ContractFailedEventArgs </font><font style="font-size:x-small;font-family:Times New Roman, serif;">also has a </font><font style="font-size:x-small;font-family:Courier New, monospace;">SetUnwind </font><font style="font-size:x-small;font-family:Times New Roman, serif;">method (not shown in this example), which has a similar but opposite effect: it ensures that even if </font><font style="font-size:x-small;font-family:Courier New, monospace;">SetHandled </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">has</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> been called, the normal escalation policy is still applied.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To test the method, we first attach the event handler </font><font style="font-size:medium;font-family:Corbel;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and then call the method in a way that’ll violate the precondition </font><font style="font-size:medium;font-family:Corbel;font-weight:bold;">Q</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Despite the failure, we still get into the method body. Here’s the output:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Precodition: text != null; Don't pass in null In method body</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Anoth<a name="bookmark4514"></a>er way of influencing what happens on contract failure is to use </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">custom rewriter methods</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. In the project pr<a name="bookmark4515"></a>operties page, you can specify an assembly and class to use. Any of the static m<a name="bookmark4516"></a>ethods present in that class which match the signatures used by the contract’s runtime will be used instead of the default behavior. For example, if you want to change how assertions are handled, you’d write a method like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public static void Assert(bool cond, string userMsg, string condText)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Checking condition {0}&quot;, condText);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(&quot;Result of check? {0}&quot;, cond);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Any required methods that aren’t available in the class are given the usual behavior. See the documen<a name="bookmark4517"></a>tation provided with the Code Contracts download for the other method signatures.</font></p>
<p><a name="bookmark4518"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Changing the failure behavior either for a whole assembly (using custom methods) or a whole AppDomain (using the ContractFailed event) isn’t something you’ll want to do for normal applications. It’s mostly useful if you’re writing a custom framework that’ll execute third-party code: a test harness or a plug-in system, for example. It’s worth knowing about what can happen, mostly so that if you’re executing in an environment that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> change the <a name="bookmark4519"></a>failure mode, you won’t be surprised. I expect most mainstream unit test frameworks to gain support for Code Contracts in the near future. Most of the time, you should be thinking about any differences in behavior you want to see between a debug build and a release build. We’ll discuss these decisions later.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As we’ve seen, the precise behavior of a contract failure depends on many fac-tors—a full treatment is beyond the scope of this book, and would be irrelevant to most developers. For more details, you ca<a name="bookmark4520"></a>n consult the documentation—also I’d recommend posting on the Code Contracts user forum if you want to check anything particularly out of the ordinary (see <a href="http://mng.bz/43E0">http://mng.bz/43E0</a>). The Code Contracts team monitors the forum closely, and can provide advice taking into account the many available options and their implications.</font></p>
<p><a name="bookmark4521"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The binary rewriter’s job is to change how the code behaves at execution time. The next tool we’ll look at is the static checker, which affects how your code behaves at compile time.</font></p>
<p><a name="bookmark426"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4522"></a>15.4 Static checkin<a name="bookmark4523"></a>g</font></p>
<p><a name="bookmark4524"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The static checker (cccheck) checks at compile time that you won’t break contracts at execution time. In some ways, the static typing we’ve been used to for years is a restrictive version of what the static checker can do. Just as the normal C# compiler checks that your code obeys the “type contracts” in every method we declare (the number and types of the parameters, for example), the static checker analyzes the more complex contracts expressed earlier and warns you if it believes you may break them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Currently, the static che<a name="bookmark4525"></a>cker is only available if you’re either using Code Contracts under the academic license or you have the Visual Studio 2010 Premium or Ultimate edition installed. This may change in the future, but even if you can’t use the static checker yourself, it’s worth being aware of what it can <a name="bookmark4526"></a>and can’t do. This will help you to think in terms of contracts, leading to more robust and understandable code that leaves fellow developers in less doubt as to how they should interact with it. Whether or not you use an automated checker, more information is <a name="bookmark4527"></a>always useful when you perform your own mental checking for your code’s correctness.</font></p>
<p><a name="bookmark427"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4528"></a>15.4.1 Getting started with static checking</font></p>
<p><a name="bookmark4529"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Let’s look at a simple example first. Yet again, it deals with nullity of input and output values. I should probably emphasize that contracts can be a lot more complex than this, but in my experience nullity is the single biggest irritation in terms of knowing what <a name="bookmark4530"></a>an API expe<a name="bookmark4531"></a>cts and will provide. It’s not surprising that it gained its own syntax in Spec#, or that F# avoids even the possibility of null values wherever it can. It also helps that it’s extremely easy to demonstrate in examples. The following listing asks the static checker to prove a number of contracts—some successfully, and some not.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.11 Experimenting with the static checker and simple contracts</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static string DontPassMeNull(string input)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Requires(input != null);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Ensures(Contract.Result&lt;string&gt;() != null); return input;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static string MightReturnNull()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return &quot;Not null really&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DontPassMeNull(&quot;definitely okay&quot;); DontPassMeNull(MightReturnNull()); DontPassMeNull(null);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To work out what the static checker is going to do, we have to th<a name="bookmark4532"></a>ink about where things might go wrong. Precondi<a name="bookmark4533"></a>tions need to be checked at call sites, invariants need to be checked at each exit point of each public method, and postconditions need to be checked at each exit point of the method they’re declared in. Assertions and assumptions are checked at their location within the program text. Neither invariants nor normal postconditions (simple Ensures calls) are checked if the method throws an exception. In listing 15.11 we have four contracts to check: the postcondition of DontPassMeNull </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(once; there’s only one exit point) and the precondition of the same method (we call it three times).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The postcondition check passes: the checker knows that input can’t be null due to the precondition. Likewise the first call to DontPassMeNull will definitely pass </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">©</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—the string literal is definitely not null. After that, things get trickier. The next line </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">might </font><font style="font-size:x-small;font-family:Times New Roman, serif;">not be a bug, and by inspection we can tell that MightReturnNull </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">Q </font><font style="font-size:x-small;font-family:Times New Roman, serif;">never </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">actually </font><font style="font-size:x-small;font-family:Times New Roman, serif;">returns a null reference. The precondition will always pass—but the checker can’t</font></p><img src="images/63.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure 15.2 Static check results in Visual Studio 2010</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">prove it. It doesn’t try to infer a postcondition of return value non-nullity for Might-ReturnNull, even though it could prove that such a contract would always pass. It doesn’t know that the precondition will always fail, either, so it reports a result of “unproven.” The final call is easy: the checker knows that the precondition will never pass, so it reports a definite failure. Figure 15.2 shows the results in the Error List window in Visual Studio.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Before I move on from this example, I want to go back to the point about how the checker treats MightReturnNull. It’s tempting to think of this as a limitation of the checker, but it’s not.<sup>10</sup> If a method wants to say that it guarantees never to return a null reference, it should declare that as a contract. If it doesn’t make that guarantee, then a later change to return a null reference is valid—it still conforms to the contract of the method. To go back to our static typing analogy, it’s like a method that’s declared to return IEnumerable&lt;string&gt;. You may happen to know that the current implementation always returns a List&lt;string&gt;, but it’d be unwise to blindly cast the result: a future implementation could use an iterator block or return an array, for example. Of course, if you come across this situation in your code, you may decide that the method really </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">should</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> guarantee that it returns a non-null value; the correct fix is to add the contract. Otherwise, you can either use Contract.Assume or explicitly handle the case where it returns null.</font></p>
<p><a name="bookmark4534"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">THE STATIC CHECKER STOPS ON FAILURE If the checker detects that a certain call will </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> fail a precondition (or t<a name="bookmark4535"></a>hat an assertion will always fail) then it treats the end of the call as unreachable. Any other statements that could normally only be reached via that point of failure aren’t checked for correctness.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That means when you fix one problem, you may find there was another one waiting on the next line, which hadn’t been reported because the checker knew you’d already have failed by then.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">On the other hand, some requirements don’t need to be explicitly stated... the static checker is happy to try to prove them for you anyway.</font></p>
<p><a name="bookmark4536"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4537"></a>Whenever you call an instance member (a real one, not an extension method) on a reference type value, there’s an implicit requirement that the reference mustn’t be null. If you turn on the Implicit Non-null Obligations option then the checker will detect potential problems of dereferencing null values.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IMPLICIT NON-NULL OBLIGATIONS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One way to think about implicit non-null obligations is to imagine that every instance member on every reference type started with a precondition like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Requires(this != null);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you turn on the Implicit Non-null Obligations option in Visual Studio, the checker tries to prove that obligation—again, using the contracts available on other members. The following listing shows an example of this, fetching strings from methods or using a literal—and then trying to dereference the relevant variables.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.12 Testing implicit non-null obligations</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static string WontReturnNull()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Ensures(Contract.Result&lt;string&gt;() != null); return &quot;Guaranteed not null&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static string MightReturnNull()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return &quot;A later implementation may return null&quot;;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string literal = &quot;Obviously not null&quot;; string wontBeNull = WontReturnNull(); string mightBeNull = MightReturnNull();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(literal.Length);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(wontBeNull.Length);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(mightBeNull.Length);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is similar to listing 15.11, but using implicit contracts instead of an explicit precondition. We have three variables O—one initialized with a string literal, one initialized with a method that has a postcondition to guarantee that it won’t return null, and one initialized with a method that doesn’t make any guarantees. When we try to print out the length of each string ©, the first two calls are fine, but the checker reports a warning on the last one: “Possibly calling a method on a null reference ‘mightBeNull’.” Of course, as with any contract, the checker can perform a lot more complex reasoning than this. There may be several code paths that initialize the variable, and so long as the checker can prove that any time it’s deferenced it’s definitely not null, it won’t issue a warning. I want to highlight this explicitly because all of the examples in this chapter are quite simple—that’s the nature of book examples—but real-world code tends to have more complexity. If you use the checker against your own code,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">you’ll see just how much it can work out—or how many possible bugs are lurking in your source.</font></p>
<p><a name="bookmark4538"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">IMPLICIT ARRAY BOUNDS OBLIGA<a name="bookmark4539"></a>TIONS</font></p>
<p><a name="bookmark4540"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Another implicit obligation occurs when accessing arrays. Though .NET arrays can have a nonzero lower bound, <a name="bookmark4541"></a>any single-dimensional array accessed directly with an indexer in C# <a name="bookmark4542"></a>has to be a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">vector</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in CLR terminology. These are much faster than rectangular arrays and arrays with a nonzero lower bound, and the static checker can attempt to prove that you never violate either bound if you have the Implicit Array Bounds Obligations option ticked. The following listing shows a simple example of where you might go wrong.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.13 Invalid indexing due to a typo</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main(string[] args)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">for (int i = 0; i &lt;= args.Length; i++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(args[i]);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve accidentally used &lt;= instead of &lt;&nbsp;in the for statement </font><font style="font-size:medium;font-family:Times New Roman, serif;font-weight:bold;">O</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. Normally this would only show up at execution time (hopefully in a test), but with Code Contracts, the checker reports a compile-time warning of “Array access might be above the upper bound.” In other cases it’ll be more definite, with warnings such as “Array access IS above the upper bound.” The exact details of the message depend on whether the checker detects that the code will fail every time the expression is evaluated or only on some occasions. In this case, although it’ll definitely fail eventually, it’ll be okay for the first args.Length iterations—hence the “might” part of the warning.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">That’s relatively simple—it’s pretty obvious that we’ll be venturing outside the bounds of the array. The checker can be somewhat more impressive, though. It’s reasonably common when working with arrays to iterate through one array to populate another. The sizes of the arrays are related, but not necessarily the same. The following listing shows an example of this, populating a new string array by alternating between a value from an original array and the default value (null).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.14 More complex array bounds checking</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">static void Main(string[] args)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string[] copy = new string[args.Length *2-1]; for (int i = 0; i &lt;&nbsp;args.Length; i++)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">copy[i * 2] = args[i];</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Here the access to args[i] is obviously okay, but what about copy[i * 2] ? The checker detects the relationship between the lengths of the two arrays, and performs arithmetic and range analysis to check whether the index is still valid. If you look carefully at the size of the new array, you’ll see I've deliberately reduced the size by one to avoid having a trailing null value—so that a copy of [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] becomes [&quot;a&quot;, null, &quot;b&quot;, null, &quot;c&quot;], for example. If you change the array index used to copy[i * 2 + 1], the checker will realize that on the last iteration, that’ll go out of bounds. Maybe I’m easily impressed, but I think that’s pretty clever.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Even that’s not all—we still have a potential problem, even in this code. We won’t access any invalid indexes in the array, but what if the original array (args) is empty? We’ll end up trying to create a new array with a<a name="bookmark4543"></a> negative size. The checker spots this and adds a warning: “Suggested precondition: Contract.Requires(0 &lt;= ((int) (args.Length) * 2 - 1));.” This precondition is stricter than the simpler precondition we might’ve coded by hand (Contract.Requires(args.Length &gt;&nbsp;0)) to cover the case where the array length is so big that doubling it overflows the bounds of Int32.</font></p>
<p><a name="bookmark4544"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4545"></a>You might be wondering why it hasn’t also prompted us to require that args not b<a name="bookmark4546"></a>e null. The answer is that it normally would, but it realises that Main is an entry point, and so in normal use args won't be null anyway.</font></p>
<p><a name="bookmark4547"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IMPLICIT ARITHMETIC OBLIGATIONS</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The final kind of implicit obligation is arith<a name="bookmark4548"></a>metic. Currently there are two kinds of arithmetic checking provided: division by zero, and negation of the minimum value of signed integer types. In many ways the latter is a more insidious problem than the former: at least if you try to divide by zero you’ll get an exception, rather than bad data. To show the danger of negating <a name="bookmark4549"></a>minimal integers, the following listing shows a flawed implementation of IComparer&lt;T&gt;.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.15 An incorrect implementation of a “reverse comparer”</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class BadReverseComparer&lt;T&gt; : IComparer&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private readonly IComparer&lt;T&gt; original;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public BadReverseComparer(IComparer&lt;T&gt; original)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Requires(original != null); this.original = original;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int Compare(T x, T y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return -original.Compare(x, y);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The aim of listing 15.15 is to reverse the order of an existing comparison. IComparer &lt;T&gt; is a nicely composable interface: you can write implementations that chain to other comparisons to provide a secondary sort order, compare two elements by</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">properties, or reverse the comparison order like we’re attempting here—it’s great. Unf<a name="bookmark4550"></a>ortunately, there’s a nasty trap waiting in this implementation—a trap that unit tests alone may well not spot. This implementation works perfectly well except in on<a name="bookmark4551"></a>e specific situation: when the value returned by original.Compare is int.MinValue. Due to the range of integers available, -int.MinValue is still int.MinValue, so that particular comparison wouldn’t be reversed. Fortunately, when you have Implicit Arithmetic Obligations turned on, Code Contracts spots this potential problem and issues a warning: “Possible negation of MinValue of type Int32.” Just in case you’re wondering, the correct<sup><a name="footnote107"></a><a href="#bookmark4552">107</a></sup> fix to this is to reverse the order of the arguments passed to the original comparison, like this:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public int Compare(T x, T y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return original.Compare(y, x);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><a name="bookmark4553"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Obviously the checker performs appropriate analysis first: it won’t report a warning if it can prove that the value you’ll be negating can never be the minimum value for the type. Although only two checks are performed at t<a name="bookmark4554"></a>he moment, I wouldn’t be surprised to see more added later, such as possible overflows in a checked context.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You may be wondering why all these are only options—options which are turned off by default. It turns out you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> have too much of a good thing.</font></p>
<p><a name="bookmark429"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4555"></a>15.4.3 Selective checking</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s not often you see documentation for a product that pretty much discourages you from using it, but the Code Contracts user manual is blunt about static checking being tricky to use effectively. Aside from some fairly subtle behavior, the biggest problem is likely to be information overload. It’s one thing to start a project from scratch and use static checking every step of the way, but applying it to an existing code base can be daunting. Just as an example, I imported my small utility project (MiscUtil—see <a href="http://mng.bz/xDMt">http://mng.bz/xDMt</a>) and turned on static checking for normal contracts and all the implicit obligations. After I’d turned up the maximum number of warnings, the checker found 555 unproven contracts and suggested 220 preconditions. This is overwhelming even for a relatively small amount of code—for a full commercial application it’d be a positive avalanche.</font></p>
<p><a name="bookmark4556"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Code Contracts provides two ways of managing this situation: baselines and an attribute to control what’s checked.</font></p>
<p><a name="bookmark4557"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">USING BASELINES TO HIGHLIGHT NEW ISSUES</font></p>
<p><a name="bookmark4558"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Suppose you want to start using Code Contracts on an existing code base that currently raises thousands of warnings in the static checker. There are two major concerns: first, you want to make sure the code doesn’t get any worse. You should avoid</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">introducing any new violations. Second, you want to nibble away at the warnings a chunk at a time. Baselines help with the first problem.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The idea of a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">baseline</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is that it’s a “known bad” build result. Usually in software engineering we have known </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">good</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> versions, but in t<a name="bookmark4559"></a>his case we know that our code is bad in terms of having lots of unprovable contracts—we need to know </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">where</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> it’s bad. To use baselines you just specify a filename in the Code Contracts project properties. This is relative to the location of the assembly that’s being checked: the default value is ..\ ..\baseline.xml, which will be in the project’s root directory for default build configurations.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When the static checker is invoked, it first looks for an existing baseline file. If the file doesn’t exist, the check is performed as normal and the results are written to the baseline file. Otherwise, the checker loads the results from the existing file and doesn’t report errors it had already seen, only showing new problems. A new file is also generated with the new problems. The new file has the same name as the normal baseline file, but with </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">.new</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> appended to the end. The files are just simple XML, so you can easily analyze them with external tools if you want to, merge t<a name="bookmark4560"></a>hem together (order isn’t important in the file), and include them in continuous build reports. In addition to preventing new issues, you could also use baselines to show positive progress: as you fix some issues, you can rename the baseline file, rebuild, and then see how many problems have been fixed by comparing the two.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Another approach to managing an initially unwieldy code base is to only perform static checking on certain parts of the project.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">USING [CONTRACTVERIFICATION] TO CONTROL CHECKING</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’re trying to actively remove some of the existing warnings produced by the static checker, it can hel<a name="bookmark4561"></a>p to focus on one piece of code at a time. You can apply the [ContractVerification] attribute to specify whether an assembly, type, or individual member should be checked. The following listing shows how simple it is.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.16 Applying checking selectively with [ContractVerification]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[assembly:ContractVerification(false)]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ContractVerification(true)] public class CheckedType {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void CheckedMethod() {}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ContractVerification(false)] public void UncheckedMethod() {}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public class UncheckedType {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public void UncheckedMethod() {}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ContractVerification(true)] public void CheckedMethod() {}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Obviously there’s nothing to be checked in any of the methods in listing 15.16, but the names should be clear enough. The main point of the listing is to demonstrate how pseudo-inheritance of contract verification works. Each type inherits the assembly’s attribute value unless it specifies the attribute itself, and likewise each member inherits the value from its containing type. So in listing 15.16, although the assembly-level attribute turns off static checking O, it can be turned back on at the type Q or member level Q—and turned off again at the member level O if it’s turned on <a name="bookmark4562"></a>for the type. It’s important to note that this is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> related to normal type inheritance. A class derived from CheckedType within the same assembly wouldn’t be checked by default, for example.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One subtlety is worth knowing about as well. As we’ve seen in previous chapters, in some cases the C# compiler creates extra types and methods for you—in particular, for anonymous functions and iterator blocks. The C# compiler doesn’t know anything about [ContractVerification], so it doesn’t propagate the value to any extra members created as a result of complex transformations. For <a name="bookmark4563"></a>example, if Unchecked-Type.CheckedMethod used a complex lambda expression in its body, that code wouldn’t be checked, because as far as the static checker is concerned, the code would be in a separate method without the attribute applied to it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With judicious use of this attribute, you can choose to tackle one type or even one method at a time, fixing up any contractual requirements as you go. One other reason to apply this attribute may be if your codebase is too large to run the static checker over during development—while implementing a new class or subsystem, you may want to only check the new code, leaving full checking of the whole project to the continuous build system. You could temporarily add [ContractVerification(false)] to the whole assembly, and then add [ContractVerification(true)] to the new types. To avoid the danger of accidentally checking this into source control and disabling static checking for everyone, you might want to define a preprocessor symbol for this purpose, and add code like the following to AssemblyInfo.cs:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">#if SELECTIVE_STATIC_CHECKING [assembly:ContractVerification(false)]</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">#endif</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can then define a build configuration based on Debug but including that symbol, making it trivial to develop with selective checking turned on.</font></p>
<p><a name="bookmark4564"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The final tool available is ccdocgen, which </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">doesn’t</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> require Visual Studio Premium or Ultimate; it generates XML documentation from your contracts.</font></p>
<p><a name="bookmark430"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4565"></a>15.5 Documenting contract<a name="bookmark4566"></a>s with ccdocgen</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is one area of contracts that’s simple from the point of view of the code you write: you don’t need to change a thing in order to document your contracts. Simply tick the Emit Contracts<a name="bookmark4567"></a> into XML Doc File check box, and when you build your normal XML documentation, the contracts will be emitted too. Listing 15.17 shows a class with a single public method including contracts, and an invariant.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing 15.17 Automatically documenting method contracts with ccdocgen</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// &lt;summary&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// Class summary.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// &lt;/summary&gt; public sealed class DocDemo {</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">private int callCount = 0;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ContractInvariantMethod] private void Invariant()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Invariant(callCount &gt;= 0);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Invariant(callCount &lt;&nbsp;100, &quot;Wrap at 100.&quot;);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// &lt;summary&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// Method summary.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// &lt;/summary&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">/// &lt;returns&gt;The input, reversed.&lt;/returns&gt; public string Reverse(string text)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Contract.Requires&lt;ArgumentNullException&gt;(text != null, &quot;text&quot;); Contract.Ensures(text != null); callCount = (callCount + 1) % 100; char[] chars = text.ToCharArray();</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Array.Reverse(chars); return new string(chars);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s nothing remarkable here in terms of the contracts. For the sake of showing variety in the generated XML, I’ve specified a description in one Contract.Invariant call and forced the use of ArgumentNullException for the precondition in the method. The complete generated XML documentation for the class looks like this (reformatted slightly):</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;doc&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;assembly&gt;&lt;name&gt;CcDoc&lt;/name&gt;&lt;/assembly&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;members&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;member name=&quot;T:CcDoc.DocDemo&quot;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;summary&gt;Class summary.&lt;/summary&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;invariant&gt;callCount &amp;gt;= 0&lt;/invariant&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;invariant description=&quot;Wrap at 100.&quot;&gt; callCount &amp;lt; 100 &lt;/invariant&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/member&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;member name=&quot;M:CcDoc.DocDemo.Reverse(System.String)&quot;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;summary&gt;Method summary.&lt;/summary&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;returns&gt;The input, reversed.&lt;/returns&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;requires description=&quot;text&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">exception=&quot;T:System.ArgumentNullException&quot;&gt; text != null &lt;/requires&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;exception cref=&quot;T:System.ArgumentNullException&quot;&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">text == null &lt;/exception&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;ensures&gt;text != null&lt;/ensures&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/member&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/members&gt;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&lt;/doc&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s fairly simple, but there are a few things to note about the generated documentation:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The text of the contract elements comes from the code: in some cases this can cause private information to leak into documentation, such as the name of the callCount variable. This isn’t m<a name="bookmark4568"></a>uch of a problem, but y<a name="bookmark4569"></a>ou should be aware of it—and make sure your variables have appropriate names! Adding a description to the contract method call can add clarity here; it’ll be emitted in the description attribute.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;An exception element has been generated for us because we explicitly specified the exception to throw if the precondi<a name="bookmark4570"></a>tion isn’t met. If you let Code Contracts throw the default ContractException, this element isn’t generated.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;The requires element also specifies the exception that’ll be thrown if the precondition fails; again, this would be omitted in the default case.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Some other elements can <a name="bookmark4571"></a>be generated; at the time of this writing this list only consists of pure (for pure methods) and ensuresOnThrow (for postconditions that apply even when exceptions are thrown). Likewise the documentation can indicate when contracts have been inherited from a base class or interface. I've omitted these features from the example for the sake of brevity, but the Code Contracts documentation goes into more detail.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Once you have the XML, you’re free to do with it as you p<a name="bookmark4572"></a>lease. The Code Contracts documentation gives instructions for patching Sandcastle to make it render the elements appropriately, and no doubt other documentation transformation tools will adapt <a name="bookmark4573"></a>to include them in<a name="bookmark4574"></a> the future. Unfortunately, at the time of this writing Visual Studio’s own IntelliSense doesn’t display the contracts within the IDE, making the feature slightly less valuable. But it’s possible that plug-ins may improve this situation over time. We still have the core benefit that the contracts are expressed in a single place, and then used for documentation, compile-time checking, and execution-time checking. There’s no way for the three aspects to get out of sync with each other.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Now that we’ve looked at the tools, let’s consider some of the broader questions raised by Code Contracts.</font></p>
<p><a name="bookmark431"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4575"></a>15.6 Practical contracts</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">MAY CONTAIN NUTS This section is very subjective, and contains only trace amounts of technical information. If you’re happy enough to work out the best way of using contracts for yourself, you won’t miss out on anything by skipping to the chapter summary.</font></p>
<p><a name="bookmark4576"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Unless you happen to have used a language supporting Design by Contract before, you may sometimes find yourself unsure of how to proceed with Code Contracts. If you’re using it in conjunction with test-driven development, what should you write first: the contract or the implementation? Should you write unit tests for the contracts? When is it appropriate to let ContractException be thrown, and when should you throw a standard .NET exception such as ArgumentNullException? Should your release builds check contracts or not?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ll think about all of these questions in this section, but I don’t promise to come up with concrete answers for everything. At the time of this writing, Code Contracts is a young and evolving product. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Nobody</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> has much experience with it, and I don’t claim to be an exception. Furthermore, many of these decisions are heavily dependent on your exact situation, and some are a matter of personal taste too. Hopefully with the discussion in this section, you’ll be in a good position to work out a strategy that’s right for you and your team.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Code Contracts user manual has guidance too, including situations where you don’t want to run the binary rewriter at all. For the rest of this section I've assumed that you’re happy to run the rewriter: it gives you a lot more control and options for no real disadvantages other than build time.</font></p>
<p><a name="bookmark432"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4577"></a>15.6.1 Philosophy: what’s in a contract?</font></p>
<p><a name="bookmark4578"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4579"></a>First, it’s worth thinking about what contracts mean to you—in particular what preconditions mean. To some people, they indicate the expected input states under which the method guarantees to operate correctly. This is a bit like having a warranty for a vacuum cleaner, which means the manufacturer will repair it if it breaks under normal conditions. They’re not going to fix the cleaner if you start attacking it with a hammer, and the company won’t try to guarantee you won’t be injured in such a situation either. In other words, if you break the terms of the warranty,<a name="bookmark4580"></a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all bets are off.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> People who regard contracts in this way are likely to have Debug.Assert calls within their existing code: they’r<a name="bookmark4581"></a>e measures to help you iron out any wrinkles in your code before you ship, but if a bug creeps through and violates the preconditions in the released code, there’s no telling what might happen. Likewise with postconditions: you’ve made a best effort to ensure that all the bugs have been fixed during development, but if a bug is still lurking, you could end up with an invalid result. There probably won’t be unit tests for failing preconditions, because there’s no particular expected behavior.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To other people, contracts are a firmer guarantee: they not only say that the code will execute in a particular way if the preconditions are met, but also that the code won’t execute at all if they fail. This is more like a height limit for a roller-coaster ride: the theme park isn’t just willing to guarantee your safety if you’re above a certain height, but they’ll actively prevent you from putting yourself into danger if you fail to meet their criteria. Developers with this mentality are more l<a name="bookmark4582"></a>ikely to have explicit tests for bad argument values, throwing ArgumentNullException and so on, regardless of whether the code is built in debug or release mode. Postconditions have been harder <a name="bookmark4583"></a><a name="bookmark4584"></a>to express until now, but this attitude is likely to encourage their enforcement in release builds too: a guarantee that the method really will </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">never</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> silently return a value that the contract forbids, or leave the object in an invalid state. Preconditions are likely to have unit tests, as otherwise there’s nothing to test the guarantees.</font></p>
<p><a name="bookmark4585"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth noting that these different groups may agree on what the contracts for any particular operation should be: whether a particular value is a valid input, whether the method should guarantee the range of its return value, and so on. The difference is in what the behavior should be when that contract is violated. I’m not going to claim that either attitude is wrong, although I tend to favour the latter approach. I generally dislike code that behaves significantly differently in a debug build than in a release build. Whichever side you come down on, try to achieve consistency within a project—which for most developers will mean discussing the issue with other team members.</font></p>
<p><a name="bookmark433"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4586"></a>15.6.2 How do I get started?</font></p>
<p><a name="bookmark4587"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4588"></a>Everyone has a different development style. Personally I like test-first coding, although I’m not as strict with myself as I’d like to be, and I couldn’t really claim that all my design is </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">test-driven.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Before contracts, you already had the choice of whether to design the API first, the implementation first (changing the design as you went along), or the tests first. Now we have to add contracts into the mixture. Fortunately, I don’t think it’s as bad as it sounds, because I think each of those steps naturally yields its own set of contracts.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Sometimes tests will provoke contracts—usually preconditions. When you’re writing success case unit tests, think about what else you could be passing into the method, or other ways you could set up the object. Are there some combinations or arguments that don’t make sense? C<a name="bookmark4589"></a>an you express them as contracts?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Sometimes the implementation will provoke contracts, both private ones (assertions and assumptions) and public ones (usually postconditions). It can be hard to know exactly what your code is willing to guarantee until you’ve written it, but if you can see something that’ll certainly be true when you exit, consider telling the caller about it as a postcondition.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Invariants are more likely to come out of the higher-level design of the class, as they affect the whole type instead of specific members. <a name="bookmark4590"></a>One possibly obvious piece of advice: don’t even think about invariants for immutable types. If something can’t vary its state, it can’t<a name="bookmark4591"></a> break an invariant. Instead, if there are rules that must be adhered to on construction, those should be preconditions.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Don’t worry about capturing absolutely </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">everything,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> though. Just like with unit testing, it’s better to have a few good contracts than decide that because you don’t have enough time to put full functional contracts in for everything, you won’t bother at all. Likewise it’s worth thinking carefully about what you guarantee: though a weak postcondition is less useful for callers right now, it does give you more flexibility in the future. Try to think about the logical guarantees you want to make, even if the implementation can guarantee a lot more.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">UNIT TESTING CONTRACTS</font></p>
<p><a name="bookmark4592"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4593"></a>With legacy contracts, I tend to write unit tests to prove the contracts. Sometimes this feels like a waste of time—if you have several parameters, none of which can be null, having a test for each of them can get extremely boring. But it does prove that the behavior matches the documentation. With Code Contracts, you get that for free: if the autogenerated documentation includes a contract, it must be present in the code. That doesn’t mean the contracts will be checked at execution time, of course—but unless you run your unit tests with every build configuration, a test couldn’t check that anyway. I find it’s particularly clean when you’re implementing an interface, as then most of the contracts will be specified entirely separately from your implementation anyway, so there’s less of a feeling of cheating.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s entirely reasonable to write unit tests to provoke corner cases that you suspect may break the contracts, of course. That’s just normal testing where you should test the expe<a name="bookmark4594"></a>cted result, and you’ll get the added benefit of the contract performing sanity checking too.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you decide you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> want to test that your contracts are present and being checked, <a name="bookmark4595"></a>you may find a slight problem if you’re using the default ContractException. It’s designed to be uncatchable at a fine-grained level, which makes it hard to use in traditional test framework “expect this action to throw this exception” assertions. I suspect that test frameworks will gradually evolve to include explicit support for this scenario, but until then one alternative is to use your own custom rewriter methods in a debug build. For instance, they could throw a publicly available exception instead of the hidden ContractException, in which case you could expect that public exception just like any other failure. All of this is obviously unnecessary if you’re using the old-style exceptions. Speaking of that sort of choice, let’s think about how you might want to configure Code Contracts in the first place.</font></p>
<p><a name="bookmark434"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4596"></a>15.6.3 Options, options everywhere</font></p>
<p><a name="bookmark4597"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">You can’t fault Code Contracts when it comes to flexibility. Combining the various features of the tools with different build configurations, you can achieve almost any effect you want. The difficult part isn’t the tweaking—it’s deciding what you want to start with.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CHOOSING A FAILURE MODE</font></p>
<p><a name="bookmark4598"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Unless y<a name="bookmark4599"></a>ou start creating your own custom rewriter methods or subscribing to the ContractFailed event, you have four mutually exclusive options for what should happen if a contract is violated:</font></p>
<p><a name="bookmark4600"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4601"></a>■ &nbsp;&nbsp;&nbsp;The appl<a name="bookmark4602"></a>ication stops with an assertion failure, allowing you to break into the debugger.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;A Contra<a name="bookmark4603"></a>ctException is thrown, which can’t be caught except as a blanket Exception.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;A standard .NET exception is thrown, which can be caught by client code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Nothing—the code continues as if no contracts were involved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Some of this can be decided on a per-configuration basis—in particular, whether to use ContractException or assertions, and how many contracts to check—whereas the decision to use standard .NET exceptions requires the types to be specified in the co<a name="bookmark4604"></a>de itself. Though you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">could</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> write every precondition twice, using preprocessor symbols to determine which to use for a given configuration, it sounds like a step too far to me.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Unless you’re migrating an existing project with legacy contra<a name="bookmark4605"></a>cts to use Code Contracts, I’d personally recommend using the nongeneric Requires method, which will either assert or throw a ContractException. It results in the simplest code, and you don’t have to repeat the parameter name for ArgumentException-related preconditions. The familiarity of existing exceptions tugs at me a little, but fundamentally the type of the exception doesn’t provide any extra information beyond what’s already in the contract—and removing the possibility of catching specific exceptions is a step toward encouraging appropriate exception handling policies. One disadvantage of ContractException is that because you can’t explicitly catch it, it’s hard to write unit tests to check your contracts, as we’ve just see<a name="bookmark4606"></a>n.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you build a contract reference assembly, you can let your callers have some control over what happens too. There’s little point in building a reference assembly if the contracts are present in the rewritten binary anyway, though. Having said that, a reference assembly will only help with certain contracts.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CONTRACT TYPES</font></p>
<p><a name="bookmark4607"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Different contract types can have different behavior associated with them. There isn’t </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">complete</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> freedom about what to do here—you can’t easily make some contracts fail with a ContractException and others fail with an assertion error, for example—but the binary rewriter does let you specify the general level of contracts to keep in the rewritten binary:</font></p>
<p><a name="bookmark4608"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">None</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—All con<a name="bookmark4609"></a>tracts, including legacy ones, will be rem<a name="bookmark4610"></a>oved.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Release requires</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—Legacy contracts and preconditions that specify a standard .NET excep<a name="bookmark4611"></a>tion will be included.</font></p>
<p><a name="bookmark4612"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4613"></a>■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Preconditions</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—As above, but with preconditions throwing ContractException included a<a name="bookmark4614"></a>s well.</font></p>
<p><a name="bookmark4615"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4616"></a><a name="bookmark4617"></a>■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Pre a<a name="bookmark4618"></a>nd post</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—As above, but with Contract. Ensures (and Contract. EnsuresOn-Throw) c<a name="bookmark4619"></a>alls included.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Everything</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—The above, with invariants, assertions, and assumptions included.</font></p>
<p><a name="bookmark4620"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">If you really want to include some of the later items but exclude earlier ones, you could use C# preprocessor directives to achieve another degree of flexibility. For example, you may want full contract checking in an ideal world, but have some postconditions that are just too expensive to validate in release builds. You could use a preprocessor symbol of EXPENSIVE_CONTRACTS and only define it in debug builds, or even have a separate build configuration. That leads us to consider what kinds of build you want in the first place.</font></p>
<p><a name="bookmark4621"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DIFFERENT CHOICES FOR DIFFERENT PROJECTS </font><font style="font-size:x-small;font-family:Times New Roman, serif;">This is a good example of where different projects may have different requirements. The BCL team is scrupulous in unit testing their contracts, and their binaries ship with a relatively small set of contracts included at execution time. They’re in a fairly unique position—they have relatively little idea of how the code is going to be used, so any performance impact from contracts could be serious. They also don’t have the luxury of letting users decide which version to run against—we really don’t want to start having different configurations of .NET installed on end-user machines for different contract preferences. Your own requirements will no doubt be different, so think about them carefully.</font></p>
<p><a name="bookmark4622"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Additionally, there’s the question of where the contracts are applied. If your code has a lot of contracts for debugging and verification purposes but at execution time you mostly care about the behavior at the boundaries between your code and third-party assemblies, you can turn on the Only Public Surface Contracts option.</font></p>
<p><a name="bookmark4623"></a><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">BUILD CONFIGURATIONS</font></p>
<p><a name="bookmark4624"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Visual Studio creates projects with Debug and Release configurations by default. The general idea is that you develop using the Debug configuration but then ship using Release. But what counts as “shipping”? Code is used in an increasingly diverse way— shipping a shrink-wrapped consumer application is very different from <a name="bookmark4625"></a>deploying your code to the one-and-only server running your producti<a name="bookmark4626"></a>on web service, which is also different from releasing a new version of an open source library. Try to wor<a name="bookmark4627"></a>k out who’ll want to use the code and in what context. If you’re building a class library, do you know the other deve<a name="bookmark4628"></a>lopers and their needs? Will some developers be concerned about the performance of checking contracts frequently? Are they li<a name="bookmark4629"></a>kely to know about Code Contracts, and perhaps want to use the static checker against your library’s contracts (even if perhaps you don’t use the checker yourself)?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’re building an application, so the code won’t be consumed by other developers, only users, that makes life easier: you can decide the behavior </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">you</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> want to give you confidence that the application won’t malfunction, and tune the settings accordingly. Open source projects are easy in the other direction: at least then if you don’t guess your users’ needs correctly, they can change the settings and rebuil<a name="bookmark4630"></a>d the code themselves. The hardest situation is perhaps that of the component vendor, shipping class libraries as binaries to paying cu<a name="bookmark4631"></a>stomers.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can introduce more flexibility in what you ship by creating multiple build con-figurations—some with full checking, others with only public AP<a name="bookmark4632"></a>I checking of preconditions, and so on. Beware of the cost of maintaining a large number of configurations, though—especially if other variables are involved other than contracts. You probably don’t want to get into the business of building multiple versions to target different vers<a name="bookmark4633"></a>ions of the .NET framework </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">and</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> different levels of contracts </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">and </font><font style="font-size:x-small;font-family:Times New Roman, serif;">different optimizatio<a name="bookmark4634"></a>n levels, and so on.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Assertion failures are reasonable for debug builds (whether you’re the one doing the debugging or not), but are almost certainly not right for anything that might</font></p>
<p><a name="bookmark4635"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">reasonably be called a release build. This can be decided on a per-configuration basis easily from the options. I know this goes against my earlier point of debug and release builds behaving differently, but at least in both cases execution of that unit of work will halt—it’s just the difference between bubbling up a nearly uncatchable exception to a top-level handler and raising an ugly but attention-grabbing assertion window.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">WHY NOT VALIDATE EVERYTHING?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’d generally suggest writing defensive code that validates both<a name="bookmark4636"></a> its inputs and its own behavior. There’s one obvious potential drawback: performance. Checking a contract is clearly more work than not checking it. If you stick to contract<a name="bookmark4637"></a>s that are cheap to validate, they’re unlikely to become a performance bottleneck other than for small meth<a name="bookmark4638"></a>ods called a huge number of times—but if you have any performance benchmarks, it’d be worth running them both with and without execution time contract checking so you can tell for sure. As ever, it’s hard to make accurate guesses about performance—so don’t. Gather data that’s as realistic as possible, and base your decision on that.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you have internal methods that are called frequently, you may find that just restricting contracts to the public API is good enough. If you do turn execution-time contract checking off, and you’re building a class library, it makes sense to build a contract reference assembly. There are no downsides to this, other than the build taki<a name="bookmark4639"></a>ng slightly longer, and it at least gives others the option of running call site validation or static checking against your code.</font></p>
<p><a name="bookmark436"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4640"></a>15.7 Summary</font></p>
<p><a name="bookmark4641"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">I have high hopes for Code Contracts. I suspect it’ll take a while to gain traction, partly as it requires an additional download even before you get started, and partly because some of its goodness is currently only available to Visual Studio Premium and Ultimate users. But I believe it addresses some of the issues that have frustrated developers for a long time.</font></p>
<p><a name="bookmark4642"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s worth acknowledging that part of the problem is that the type system in .NET isn’t quite rich enough to start with. If non-nullable reference types were embedded in .NET and C#, a whole class of preconditions and postconditions would be u<a name="bookmark4643"></a>nnecessary now.<sup><a name="footnote108"></a><a href="#bookmark4644">108</a></sup> Likewise the fact that .NET doesn’t have any notion similar to const in C++ is a source of pain whenever you want to return a read-only view of an object to a caller, or declare that you won’t mutate the state of any incoming objects. Code Contracts doesn’t address this latter issue yet, but I wouldn’t be surprised to hear that engineers were thinking hard about it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Contracts become more helpful the more widely used they are, particularly in terms of static checking. There’s no guarantee that Code Contracts will become an industry-wide expectation—that in two years’ time you’d be considered mad to ship a</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">commercial component library without a contracts reference assembly. Microsoft is effectively bootstrapping the ecosystem by adding contracts to the BCL, and we can hope that leading library vendors (both free and commercial) will adopt them over time. Until then, you can still benefit from them within your own code, in terms of simple execution-time checking, autogenerated documentation, automatic contract inheritance, possibly static analysis, and above all the encouragement to just stop and think about what you need and what you’re prepare<a name="bookmark4645"></a>d to guarant<a name="bookmark4646"></a>ee.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">At a deep level, all code is about communication: expressing ideas about what you want to achieve. It’s no coincidence that if you look at the features C# has gained over the years, almost all of them involve communicating common and useful ideas in a simple manner. It’s one of the ways our industry is attempting to manage the increasing complexity we’re all faced with. Code Contracts is another weapon in the armory. Don’t just think of it as a way of making sure that your code isn’t faced with inappropriate values at execution time. Think of it as a means of letting your code speak with clarity and precision—whether that’s to the tools, the code maintainer, other developers using your API, or even yourself.</font></p>
<p><a name="bookmark4647"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">Whither now ?</font></p>
<p><a name="bookmark22"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4648"></a>This chapter covers</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;The evolution of C#</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;.NET meets computer science</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;How </font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">you</font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;"> can make a difference</font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">■ &nbsp;&nbsp;&nbsp;The wider world of computing</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">So that’s C#—as far as version 4, anyway. Rather than leave you with an abrupt context switch from Code Contracts to the appendixes, I wanted to wind down with a few thoughts about how far we’ve come and where we might be going.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course, any forward-looking statements expressed in this chapter should be taken with a large bucket of salt. Please don’t try to return this book for a refund if I’m completely wrong. Retrospective statements are likely—but not guaranteed— to be more accurate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">These musings cover more than just C#, but that’ll be our starting point. From there we’ll work outward, through the .NET ecosystem to the whole computing industry.</font></p>
<p><a name="bookmark437"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4649"></a>16.1 C#—mixing tradition and modernity</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# h<a name="bookmark4650"></a>as come a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">really</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> long way—and in a short space of time, for a mainstream language. The more users a language has, and the less tolerant they are of pain, the</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">harder it is to introduce change. Banks and other large enterprises aren’t<a name="bookmark4651"></a> likely to be overjoyed if they hear that your latest and greatest release is incompatible wi<a name="bookmark4652"></a>th earlier versions. As such, the C# team is extremely cautious about breaki<a name="bookmark4653"></a>ng changes: they do exist, but they’re rare and usually provoke a compile-time warning.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Within that restrictive environment, C# has taken its <a name="bookmark4654"></a>Java-like roots and r<a name="bookmark4655"></a>aced away, developing features that massively increase productivity and maintainability. I know, I sound like a complete fanboy... but if you’ve been reading this book from the start and I haven’t yet convinced you about the truth of this statement, then frankly I’ve failed.</font></p>
<p><a name="bookmark4656"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Despite being in its fourth major version, C# feels like a lean language to me. Admittedly this is entirely in terms of the cod<a name="bookmark4657"></a>e you end up writing: C# has inevitably gained weight in terms of language complexity, and the designers will need to be wary of just how many more features they can add before they end up with a language that’s too big for anyone to know well. But the efficiency of expression is appealing— as I mentioned in chapter 1, C# has learned <a name="bookmark4658"></a>some lessons from dynamic languages while remaining almost entirely statically typed.</font></p>
<p><a name="bookmark4659"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a name="bookmark4660"></a><a name="bookmark4661"></a>So what’s coming next? At the time of this writing, little is known about C# 5. The concept of a “compiler as a service” has been discussed, but it’s not clear </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> what that means o<a name="bookmark4662"></a>r when it’ll come. Will it allow custom code to be injected into the compiler pipeline? Will it allow small sections of code to be compiled and executed without requiring whole class definitions? Will it actually change the language itself at all? We’ll have to wait to find out.</font></p>
<p><a name="bookmark4663"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s more that C# could take from functional languages, <a name="bookmark4664"></a>mind you. The Mono team have already implemented more suppo<a name="bookmark4665"></a>rt for .NET 4’s Tuple types within t<a name="bookmark4666"></a>he C# language, and options for pattern matching and bette<a name="bookmark4667"></a>r support for immutable types would be welcome, too. Though languages such as F# have advanced type inference (going well beyond what C# provides with implicitly typed local variables), I’d personally be surprised to see this make it into C#. But then again, I was surprised by the support for dynamic typing in C# 4.</font></p>
<p><a name="bookmark4668"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">What’s becoming increasingly clear is th<a name="bookmark4669"></a>at we’re living in a he<a name="bookmark4670"></a>terogeneous world. Web developers alrea<a name="bookmark4671"></a>dy have to know HTML, CSS, and JavaScript as well as whatever backend technologies they’re using—and the same theme is taking hold on the server and desktop too. Let’s think about what else is happening in .NET, and the effect on C# developers.</font></p>
<p><a name="bookmark438"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4672"></a>16.2 Computer science and .NET</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It feels to me like the nature of development is changing.<a name="bookmark4673"></a> It’s hard to measure—at least as an individual—but it seems that computer science is having something of a revival. After years of some develo<a name="bookmark4674"></a>pers complaining that nobody ever seem<a name="bookmark4675"></a>s to know about fundamental data structures, the community is tal<a name="bookmark4676"></a>king about monads, proving code correctness, patterns of asynchronous computation, and any number of other topics that were previously the realm of the academic computer scientist.</font></p>
<p><a name="bookmark4677"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Of course this is a slight exaggeration—there have always been pockets of industry doing interesting work like this—but Microsoft is bringing more of these theories and technologies into the mainstream. Whether by design or coincidence, .NET has become a wonderful experimental playground for advanced technology with its roots in old computer science.</font></p>
<p><a name="bookmark4678"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In this book I’ve given you a taste of technologies such as Code Contracts, Parallel Extensions, and Reactive Extensions. There are many other projects though, at various stages of completion:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Pex tries to “explore” your code, generating automated tests to take every possible path by passing in different data, generated through intelligent code analysis (see<a name="bookmark4679"></a> <a href="http://mng.bz/0iAW">http://mng.bz/0iAW</a>).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;CHESS finds bugs in concurrent code that could be hard to spot by inspection, hard to test for with normal unit tests, and hard to spot in production (see <a href="http://mng.bz/FM55">http://mng.bz/FM55</a>).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;F# is a functional language that aims to bridge the fun<a name="bookmark4680"></a>ctional/object-oriented divide,<a name="bookmark4681"></a> and which is now fully supported in Visual Studio.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Axum is a new language for parallel programs, based on actors and message passing (see <a href="http://mng.bz/Zyus">http://mng.bz/Zyus</a>).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This isn’t an exhaustive list, and each of these projects is ambitious with a lot of potential. But it’s not at all obvious which ones will make a lasting impression on the developer community. In five ye<a name="bookmark4682"></a>ars, will contracts be as common as unit tests? Will we think back o<a name="bookmark4683"></a>n synchronous RPCs and shudder in horror? Will we switch effortlessly between Python, C#, and F# (or something even newer) without needing a coffee break to change mental gears?</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I’<a name="bookmark4684"></a>m convinced of one truth: the future of these projects will depend on the alpha geeks of the .NET world as much as anyone else. The fact that you’re reading a fairly advanced C# book suggests you probably belong in that set, so I’d <a name="bookmark4685"></a>urge you to consider picking up one of these technologies and r<a name="bookmark4686"></a>unning with it. Blog about it. Show it to your colleagues. Speak about it at a user group.<sup><a name="footnote109"></a><a href="#bookmark4687">109</a></sup> Be passionate about it, and change the world.</font></p>
<p><a name="bookmark439"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4688"></a>16.3 The world of computing</font></p>
<p><a name="bookmark4689"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">In fact, the world is going to change whether you do something or not. I finished drafting<a name="bookmark4690"></a> the first edition of this book in l<a name="bookmark4691"></a>ate 2007... around the same time that Android was announced, and I sa<a name="bookmark4692"></a>w an iPhone and a netbook for the first t<a name="bookmark4693"></a>ime. Google AppEngine and Windows Azure hadn’t been announced; Amazon EC2 was still in beta.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We live in a different world today. Perhaps this hasn’t impacted your daily work yet, in an obvious way, but it will. Even if you don’t write mobile applications or use cloud</font></p>
<p><a name="bookmark4694"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">computing, the APIs, standards, and engineering techni<a name="bookmark4695"></a>ques will affect how you write code... and maybe when you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">do</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> need your code to scale to hundreds or thousands of servers, it won’t be quite as hard as i<a name="bookmark4696"></a>t would’ve been without these changes.</font></p>
<p><a name="bookmark4697"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">The shift to parallel processing continues unabated, with even netbooks gai<a name="bookmark4698"></a>ning multicore processors. Projects such as Parallel Extensions and Reactive Extensi<a name="bookmark4699"></a>ons will certainly help, but they’re no free lunch. Moving beyond the imperative model will be painful, but fascinating at the same time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Meanwhile, the p<a name="bookmark4700"></a>erformance trade-offs we’ve always had to make are changing too. Solid state drives are becoming increasingly affordable and networks are becoming more diverse, ranging from ulta-fast connections in data centers to “occasionally connected” mobile broadband connections—which themselves vary immensely in terms of bandwidth. Software engineering has to account for the environment in which the code will run, which can affect all aspects of the design and implementation. As developers we need to be receptive to different ideas and approaches—and with the staggering pace of technological change, we have to be able to learn at speed too.</font></p>
<p><a name="bookmark440"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;"><a name="bookmark4701"></a>16.4 Farewell</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s my fond hope that this book has shaken you up a bit. If most of the material has been new to you, then I hope it’s made sense—and that the bits which didn’t quite sink in on a first read are more comprehensible next time you look at them. If you’re already an experienced C# developer and this was a refresher, I hope you’ve still found something new—whether that’s an aspect of the language you weren’t aware of, or perhaps a different approach to thinking about a problem.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Beyond that, I hope I’ve helped to nurture a sense of excitement—not through screaming exclamation points and shiny examples, but through a sense that C# can help you to express your ideas more clearly and concisely than ever before. This doesn’t have to be a passion about the language itself—it’s reallyjust a tool, after all— but about what it’ll let you achieve. Don’t think of the vehicle in isolation; imagine where you want to go, and be glad that C# will make the journey that bit easier. With any luck, this book will have helped you to steer in the right direction and get the most out of the language. It’s time we parted, so farewell and </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">bon voyage,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> wherever C# takes you.</font></p>
<p><a name="bookmark4702"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">appendix A LINQ standard query operators</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are many standard query operators in LINQ, only some of which are supported directly in C# query expressions—the others have to be called manually as normal methods. Some of the standard query operators are demonstrated in the main text of the book, but they’re all listed in this appendix. Most of the examples use the following two sample sequences:</font></p><div>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string[] words int[] numbers =</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">= {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;}; {0, 1, 2, 3, 4};</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For completeness I’ve included the operators we’ve already seen, although in most cases chapter 11 contains more detail on them than I’ve provided here. The behavior specified here is that of LINQ to Objects; other providers may work differently. For each operator, I’ve specified whether it uses deferred or immediate execution. If an operator uses deferred execution, I've also indicated whether it streams or buffers its data.</font></p>
<p><a name="bookmark4703"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">Aggregation</font></p><div>
<p><a name="bookmark441"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.1</font></p></div><br clear="all"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The aggregation operators (see table A.1) all result in a single value rather than a sequence. Average and Sum all operate either on a sequence of numbers (any of the built-in numeric types) or on a sequence of elements with a delegate to convert from each element to one of the built-in numeric types. Min and Max have overloads for numeric types, but can also operate on any sequence either using the default comparer for the element type or using a conversion delegate. Count and LongCount are equivalent to each other, just with different return types. Both of these have two over-loads—one that just counts the length of the sequence, and one that takes a predicate: only elements matching the predicate are counted.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table A.1 Examples of aggregation operators</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression</font></p></td><td colspan="2">
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">numbers.Sum()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">10</font></p></td><td>
<p></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">numbers.Count()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">5</font></p></td><td>
<p></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">numbers.Average()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">2</font></p></td><td>
<p></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table A.1 Examples of aggregation operators </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">(continued)</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">numbers.LongCount(x =&gt; x % 2 == 0)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Min(word =&gt; word.Length)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Max(word =&gt; word.Length)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">numbers.Aggregate(&quot;seed&quot;<sub>;</sub></font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(current, item) =&gt; current + item, result =&gt; result.ToUpper())</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">3 </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(as a </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">long</font><font style="font-size:x-small;font-family:Times New Roman, serif;">; there are three even numbers)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">3</font><font style="font-size:x-small;font-family:Times New Roman, serif;">(</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;one&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;two&quot;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">5</font><font style="font-size:x-small;font-family:Times New Roman, serif;">(</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;three&quot;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SEED01234</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The most generalized aggregation operator (shown in the bottom row of table A.1) is just called Aggregate. All the other aggregation operators could be expressed as calls to Aggregate, although it’d be relatively painful to do so. The basic idea is that there’s always a “result so far,” starting with an initial seed. An aggregation delegate is applied for each element of the input sequence: the delegate takes the result so far and the input element, and produces the next result. As a final optional step, a conversion is applied from the aggregation result to the return value of the method. This conversion may result in a different type, if necessary. It’s not quite as complicated as it sounds, but you’re still unlikely to use it often.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All of the aggregation operators use immediate execution. The overload for Count that doesn’t use a predicate is optimized for implementations of ICollection and ICollection&lt;T&gt;; in that situation it’ll use the Count property of the collection without reading any data.<sup><a name="footnote110"></a><a href="#bookmark4704">110</a></sup></font></p>
<p><a name="bookmark4705"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.2 Concatenation</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s a single concatenation operator: Concat (see table A.2). As you might expect, this operates on two sequences, and returns a single sequence consisting of all the elements of the first sequence followed by all the elements of the second. The two input sequences must be of the same type, execution is deferred, and all data is streamed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table A.2 Concat example</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">numbers.Concat(new[] {2, 3, 4, 5, 6})</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">6</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">5</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><sub>4</sub>,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">3</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">2</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><sub>4</sub>,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">3</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">2</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">1</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">0</font></p></td></tr>
</table>
<p><a name="bookmark4706"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.3 Conversion</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The conversion operators cover a fair range of uses, but they all come in pairs.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The examples in table A.3 use two additional sequences to demonstrate Cast and OfType:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">object[] allStrings = {&quot;These&quot;, &quot;are&quot;, &quot;all&quot;, &quot;strings&quot;}; object[] notAllStrings = {&quot;Number&quot;, &quot;at&quot;, &quot;the&quot;, &quot;end&quot;, 5};</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Table A.3 Conversion examples</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">allStrings.Cast&lt;string&gt;()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;These&quot;, &quot;are&quot;, &quot;all&quot;, &quot;strings&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;string&gt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">allStrings.OfType&lt;string&gt;()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;These&quot;, &quot;are&quot;, &quot;all&quot;, &quot;strings&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;string&gt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">notAllStrings.Cast&lt;string&gt;()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Exception is thrown while iterating, at point of failing conversion</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">notAllStrings.OfType&lt;string&gt;()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Number&quot;, &quot;at&quot;, &quot;the&quot;, &quot;end&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;string&gt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">numbers.ToArray()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">0, 1, 2, 3, 4 </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int[]</font><font style="font-size:x-small;font-family:Times New Roman, serif;">)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">numbers.ToList()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">0, 1, 2, 3, 4 </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;int&gt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.ToDictionary(w =&gt; w.Substring(0, 2))</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Dictionary contents: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;ze&quot;: &quot;zero&quot; &quot;on&quot;: &quot;one&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;tw&quot;: &quot;two&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;th&quot;: &quot;three&quot; &quot;fo&quot;: &quot;four&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Key is first character of word words.ToLookup(word =&gt; word[0])</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Lookup contents:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">'z': &quot;zero&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">'o': &quot;one&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">'t': &quot;two&quot;, &quot;three&quot; 'f': &quot;four&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.ToDictionary(word =&gt; word[0])</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Exception: can only have one entry per key, so fails on </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">'t'</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ToArray and ToList are fairly self-explanatory: they read the whole sequence into memory, returning it either as an array or as a List&lt;T&gt;. Both use immediate execution.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Cast and OfType convert an untyped sequence into a typed one, either throwing an exception (for Cast) or ignoring (for OfType) elements of the input sequence that aren’t implicitly convertible to the output sequence element type using an unboxing or reference conversion. This may also be used to convert typed sequences into more specifically typed sequences, such as converting IEnumerable&lt;object&gt; to IEnumerable&lt;string&gt;. These use deferred execution and stream their input data.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ToDictionary and ToLookup both take delegates to obtain the key for any particular element; ToDictionary returns a dictionary mapping the key to the element type, whereas ToLookup returns an appropriately typed ILookup&lt;,&gt;. A lookup is like a dictionary where the value associated with a key isn’t one element but a sequence of elements. Lookups are generally used when duplicate keys are expected as part of normal operation, whereas a duplicate key will cause ToDictionary to throw an</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">exception. More complicated overloads of both methods allow a custom IEquality-Comparer&lt;T&gt; to be used to compare keys, and a conversion delegate to be applied to each element before it is put into the dictionary or lookup. Both of these methods use immediate execution.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two additional operators that I haven’t provided examples for: AsEnumerable or AsQueryable. They don’t affect the results in an immediately obvious way, so they can’t really be demonstrated here. Instead, they affect the manner in which the query is executed. Queryable.AsQueryable is an extension method on IEnumerable that returns an IQueryable (both types being generic or nongeneric, depending on which overload you pick). If the IEnumerable you call it on is already an IQueryable, it just returns the same reference—otherwise it creates a wrapper around the original sequence. The wrapper allows you to use all the normal Query-able extension methods, passing in expression trees, but when the query is executed the expression tree is compiled into normal IL and executed directly, using the LambdaExpression.Compile method shown in section 9.3.2.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Enumerable.AsEnumerable is an extension method on IEnumerable&lt;T&gt; and has a trivial implementation, simply returning the reference it was called on. No wrappers are involved—it just returns the same reference. This forces the Enumerable extension methods to be used in subsequent LINQ operators. Consider the following query expressions:</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Filter the users in the database with LIKE from user in context.Users where user.Name.StartsWith(&quot;Tim&quot;) select user;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Filter the users in memory</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">from user in context.Users.AsEnumerable()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">where user.Name.StartsWith(&quot;Tim&quot;) select user;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The second query expression forces the compile-time type of the source to be IEnumerable&lt;User&gt; instead of IQueryable&lt;User&gt;, so all the processing is done in memory instead of at the database. The compiler will use the Enumerable extension methods (taking delegate parameters) instead of the Queryable extension methods (taking expression tree parameters). Normally you want to do as much processing as possible in SQL, but when there are transformations that require local code, you sometimes have to force LINQ to use the appropriate Enumerable extension methods. Of course this isn’t specific to databases: the theme of forcing the tail of a query to use Enumerable is applicable for other providers too, if they’re based on IQueryable or something similar.</font></p>
<p><a name="bookmark4707"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.4 Element operators</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">This is another selection of query operators that are grouped in pairs (see table A.4). This time, the pairs all work the same way. There’s a simple version that picks a single element if it can or throws an exception if the specified element doesn’t exist, and a</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">version with OrDefault at the end of the name. All of these operators use immediate execution.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Table A.4 Single element selection examples</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.ElementAt(2)</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;two&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.ElementAtOrDefault(lO)</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.First()</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;zero&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.First(w =&gt; w.Length == 3)</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;one&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.First(w =&gt; w.Length == 10)</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Exception: no matching elements</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.FirstOrDefault (w =&gt; w.Length == 10)</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Last()</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;four&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Single()</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Exception: more than one element</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.SingleOrDefault()</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Exception: more than one element</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Single(word =&gt; word.Length ==</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">5)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;three&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Single(word =&gt; word.Length ==</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">10)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Exception: no matching elements</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.SingleOrDefault (w =&gt; w.Length == 10)</font></p></td><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The operator names are easily understood: First and Last return the first and last elements of the sequence respectively, throwing an InvalidOperationException if the sequence is empty. Single returns the only element in a sequence, throwing an exception if the sequence is empty or has more than one element. ElementAt returns a specific element by index—the fifth element, for example. An ArgumentOutOf-RangeException is thrown if the index is negative or too large for the actual number of elements in the collection. In addition, there’s an overload for all of the operators other than ElementAt to filter the sequence first—for example, First can return the first element that matches a given condition.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The OrDefault versions of these methods suppress the exceptions I’ve just described (returning the default value for the element type instead) except in one case: SingleOrDefault will return a default value if the sequence is empty, but if there’s more than one element it’ll still throw an exception, just like Single. This is designed for situations where if everything’s correct, the sequence will have zero or one element. If you want to cope with sequences that may have more elements, use FirstOrDefault instead.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All of the overloads that don’t have a predicate parameter are optimized for instances of IList&lt;T&gt;, as they can access the correct element without iterating.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s no optimisation when a predicate is involved—it wouldn't make sense for most calls, although it could make a big difference when finding the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">last</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> matching element in a list, by moving backward from the end. At the time of this writing that case isn’t optimized, but it could change in a future version.</font></p>
<p><a name="bookmark4708"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.5 Equality</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s only one standard equality operator: SequenceEqual (see table A.5). This just compares two sequences for element-by-element equality, including order. For instance, the sequence 0, 1, 2, 3, 4 isn’t equal to 4, 3, 2, 1, 0. An overload allows a specific IEqualityComparer&lt;T&gt; to be used when comparing elements. The return value is just a Boolean, and is computed with immediate execution.</font></p><div>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Table A.5 Sequence equality examples</font></p></div><br clear="all"/>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.SequenceEqual</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(new[]{&quot;zero&quot;,&quot;one&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;two&quot;,&quot;three&quot;,&quot;four&quot;})</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">True</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.SequenceEqual</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(new[]{&quot;ZERO&quot;,&quot;ONE&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;TWO&quot;,&quot;THREE&quot;,&quot;FOUR&quot;})</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">False</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.SequenceEqual</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(new[]{&quot;ZERO&quot;,&quot;ONE&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;TWO&quot;,&quot;THREE&quot;,&quot;FOUR&quot;},</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StringComparer.OrdinallgnoreCase)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">True</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Again, LINQ to Objects misses a trick here in terms of optimization: if both sequences have an efficient way of retrieving their counts, it would make sense to check whether those are equal before comparing the elements themselves. As it is, the implementation just walks through both sequences until it reaches the end or finds an inequality.</font></p>
<p><a name="bookmark4709"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.6 Generation</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Out of all the generation operators (see table A.6), only one acts on an existing sequence: DefaultIfEmpty. This returns either the original sequence if it’s not empty, or a sequence with a single element otherwise. The element is normally the default value for the sequence type, but an overload allows you to specify which value to use.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are three other generation operators that are just static methods in Enumerable:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Range generates a sequence of integers, with the parameters specifying the first value and how many values to generate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Repeat generates a sequence of any type by repeating a specified single value for a specified number of times.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Empty generates an empty sequence of any type.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All of the generation operators use deferred execution and stream their output—in other words, they don’t just prepopulate a collection and return that. The exception is </font><font style="font-size:x-small;font-family:Courier New, monospace;">Empty</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which returns an empty array of the correct type. An empty array is completely immutable, so the same array can be returned for every call for the same element type.</font></p>
<p><font style="font-size:x-small;font-family:Franklin Gothic Demi, sans-serif;">Table A.6 Generation examples</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">numbers.DefaultIfEmpty()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">4</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">3</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">2</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">1</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">0</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new int[0].DefaultIfEmpty()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">0 </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(within an </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;int&gt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">new int[0].DefaultIfEmpty(10)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">10 </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(within an </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;int&gt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Enumerable.Range(15, 2)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">15, 16</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Enumerable.Repeat(25, 2)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">25, 25</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Enumerable.Empty&lt;int&gt;()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">An empty </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable&lt;int&gt;</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two grouping operators, but one of them is </font><font style="font-size:x-small;font-family:Courier New, monospace;">ToLookup</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which we’ve already seen in section A.3 as a conversion operator. That just leaves </font><font style="font-size:x-small;font-family:Courier New, monospace;">GroupBy</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which we examined in section 11.6.1 in the form of the </font><font style="font-size:x-small;font-family:Courier New, monospace;">group </font><font style="font-size:x-small;font-family:Times New Roman, serif;">... </font><font style="font-size:x-small;font-family:Courier New, monospace;">by </font><font style="font-size:x-small;font-family:Times New Roman, serif;">clause in query expressions. It uses deferred execution, but buffers its results: when you start iterating over the resulting sequence of groups, the whole of the input is consumed.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The result </font><font style="font-size:x-small;font-family:Courier New, monospace;">o</font><font style="font-size:x-small;font-family:Times New Roman, serif;">f </font><font style="font-size:x-small;font-family:Courier New, monospace;">GroupBy </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is a sequence of appropriately typed </font><font style="font-size:x-small;font-family:Courier New, monospace;">IGrouping&lt;,&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">elements. Each element has a key and a sequence of elements that match that key. In many ways, this is just a different way of looking at a lookup—instead of having random access to the groups by key, the groups are enumerated in turn. The order in which the groups are returned is the order in which their respective keys are discovered. Within a group, the order is the same as in the original sequence.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;">GroupBy </font><font style="font-size:x-small;font-family:Times New Roman, serif;">has a daunting number of overloads, allowing you to specify not only how a key is derived from an element (which is always required) but also optionally the following:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;How to compare keys.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;A projection from an original element to the element within a group.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;A projection that takes both a key and a sequence of matching elements. The overall result in this case is just a sequence of elements of the result type of the projection.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table A.7 contains examples of the second and third options, as well as the simplest form. Custom key comparisons are slightly more long-winded to demonstrate, but they work in the obvious way.</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.GroupBy(word =&gt; word.Length)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Key: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">4; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Sequence: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;zero&quot;, &quot;four&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Key: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">3; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Sequence: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;one&quot;, &quot;two&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Key: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">5; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Sequence: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;three&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.GroupBy</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(word =&gt; word.Length, // Key word =&gt; word.ToUpper() // Group element</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Key: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">4; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Sequence: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;ZERO&quot;, &quot;FOUR&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Key: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">3; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Sequence: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;ONE&quot;, &quot;TWO&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Key: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">5; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Sequence: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;THREE&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Project each (key, group) pair to string words.GroupBy</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(word =&gt; word.Length,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(key, g) =&gt; key + &quot;: &quot;&nbsp;+ g.Count())</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">1</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">5</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">2</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">3</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">2</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;"><sub>4</sub>:</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The option specified by the last bullet point is rarely used in my experience.</font></p>
<p><a name="bookmark4710"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.8 Joins</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Two operators are specified as join operators: Join and GroupJoin, both of which we saw in section 11.5 using the join and join ... into query expression clauses respectively. Each method takes several parameters: two sequences, a key selector for each sequence, a projection to apply to each matching pair of elements, and optionally a key comparison.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For Join the projection takes one element from each sequence and produces a result; for GroupJoin the projection takes an element from the left sequence (in the chapter 11 terminology—the first one specified, usually as the sequence the extension method appears to be called on) and a sequence of matching elements from the right sequence. Both use deferred execution, and stream the left sequence but read the right sequence in its entirety when the first result is requested.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For the join examples in table A.8, we’ll match a sequence of names (Robin, Ruth, Bob, Emma) against a sequence of colors (Red, Blue, Beige, Green) by looking at the first character of both the name and the color, so Robin will join with Red and Bob will join with both Blue and Beige, for example.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Table A.8 Join examples</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">names.Join // Left sequence (colors, // Right sequence name =&gt; name[0], // Left key selector color =&gt; color[0], // Right key selector // Projection for result pairs (name, color) =&gt; name + &quot;&nbsp;- &quot;&nbsp;+ color</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Robin - Red&quot;, &quot;Ruth - Red&quot;, &quot;Bob - Blue&quot;, &quot;Bob - Beige&quot;</font></p></td></tr>
</table>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">names.GroupJoin</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(colors,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">name =&gt; name[0], color =&gt; color[0],</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Projection for key/sequence pairs (name, matches) =&gt; name + &quot;: &quot;&nbsp;+</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">string.Join(&quot;/&quot;, matches.ToArray())</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Robin: Red&quot;, &quot;Ruth: Red&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Bob: Blue/Beige&quot;, &quot;Emma: &quot;</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Note that Emma doesn’t match any of the colors—the name doesn’t appear at all in the results of the first example, but it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> appear in the second, with an empty sequence of colors.</font></p>
<p><a name="bookmark4711"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.9 Partitioning</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The partitioning operators either </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">skip</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> an initial part of the sequence, returning only the rest, or </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">take</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> only the initial part of a sequence, ignoring the rest. In each case, you can either specify how many elements are in the first part of the sequence or specify a condition—the first part of the sequence continues until the condition fails. After the condition fails for the first time, it isn’t tested again—it doesn’t matter whether later elements in the sequence match. All of the partitioning operators use deferred execution and stream their data</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Partitioning effectively divides the sequence into two distinct parts, either by position or by predicate. In each case if you concatenate the results of Take or TakeWhile with the results of the corresponding Skip or SkipWhile, providing the same argument to both calls, you’ll end up with the original sequence: each element will occur exactly once, in the original order. This is demonstrated by the calls in table A.9.</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table A.9 Partitioning examples</font></p></td><td>
<p></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Take(2)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;zero&quot;, &quot;one&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Skip(2)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;two&quot;, &quot;three&quot;, &quot;four&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.TakeWhile(word =&gt; word.Length &lt;= 4)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.SkipWhile(word =&gt; word.Length &lt;= 4)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;three&quot;, &quot;four&quot;</font></p></td></tr>
</table>
<p><a name="bookmark4712"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.10 Projection</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen two projection operators (Select and SelectMany) in chapter 11. Select is a simple one-to-one projection from source element to a result element. Select-Many is used when there are multiple from clauses in a query expression: each element</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">in the original sequence is used to generate a new sequence. Both projection operators (see table A.10) use deferred execution.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Table A.10 Projection examples</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Select(word =&gt; word.Length)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">4, 3, 3, 5, 4</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Select</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">((word, index) =&gt; index.ToString() + &quot;: &quot;&nbsp;+word)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;0: zero&quot;, &quot;1: one&quot;, &quot;2: two&quot;, &quot;3: three&quot;, &quot;4: four&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.SelectMany</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(word =&gt; word.ToCharArray())</font></p></td><td>
<p><font style="font-size:xx-small;font-family:Times New Roman, serif;">■P LM</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(U (U £ (U 0 in</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">o</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(U0 3 </font><font style="font-size:xx-small;font-family:Times New Roman, serif;">N^O</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.SelectMany ((word, index) =&gt; Enumerable.Repeat(word, index))</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;one&quot;, &quot;two&quot;, &quot;two&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;three&quot;, &quot;three&quot;, &quot;three&quot;, &quot;four&quot;, &quot;four&quot;, &quot;four&quot;, &quot;four&quot;</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are additional overloads we didn’t see in chapter 11. Both methods have overloads that allow the index within the original sequence to be used in the projection, and SelectMany either flattens all of the generated sequences into a single sequence without including the original element at all, or uses a projection to generate a result element for each pair of elements. Multiple from clauses always use the overload that takes a projection. (Examples of this are long-winded, and not included here. See chapter 11 for more details.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">.NET 4 introduces a new operator called Zip. This isn’t officially a standard query operator according to MSDN, but it’s worth knowing about anyway. It takes two sequences and applies the specified projection to each pair: the first element from each sequence, then the second element from each sequence, and so on. The resulting sequence finishes when </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">either</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the source sequences does. Table A. 11 shows two examples of Zip, using the names and colors from section A.8. Zip uses deferred execution and streams its data.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Table A.11 Zip examples</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">names.Zip(colors, (x, y) =&gt; x + &quot;-&quot; + y)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Second sequence stops early names.Zip(colors.Take(3),</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">(x, y) =&gt; x + &quot;-&quot; + y)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Robin-Red&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Ruth-Blue&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Bob-Beige&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Emma-Green&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Robin-Red&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Ruth-Blue&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;Bob-Beige&quot;</font></p></td></tr>
</table>
<p><a name="bookmark4713"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.11 Quantifiers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The quantifier operators shown in table A.12 all return a Boolean value, using immediate execution:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;All checks whether all the elements in the sequence satisfy the given predicate.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Any checks whether any of the elements in the sequence satisfy the given predicate, or whether there are any elements at all for the parameterless overload.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Contains checks whether the sequence contains a particular element, optionally specifying a comparison to use.</font></p>
<p><a name="bookmark4714"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Table A.12 Quantifier examples</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.All(word =&gt; word.Length &gt;&nbsp;3)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(</font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;one&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;two&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">have exactly three letters)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.All(word =&gt; word.Length &gt;&nbsp;2)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">True</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Any()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(the sequence isn’t empty)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Any(word =&gt; word.Length == 6)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">false </font><font style="font-size:x-small;font-family:Times New Roman, serif;">(no six-letter words)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Any(word =&gt; word.Length == 5)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">true (&quot;three&quot; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">satisfies the condition)</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Contains(&quot;FOUR&quot;)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">False</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Contains(&quot;FOUR&quot;,</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">StringComparer.OrdinalIgnoreCase)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">True</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Any is a particularly useful operator that’s often forgotten. If you’re trying to find out whether a sequence contains any items (or any items matching a predictate) it’s much better to use source.Any(...) than source.Count (...) &gt;&nbsp;0. They should give the same results, but Any can stop as soon as it’s found the first item, whereas Count has to count </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the items, even though you only need to know whether the result is nonzero.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The overload for Contains that doesn’t specify a custom comparison is optimized if the source implements ICollection&lt;T&gt; by delegating to the interface implementation. This means Enumerable.Contains() will still be fast when called on a Hash-Set&lt;T&gt;, for example.</font></p>
<p><a name="bookmark4715"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.12 Filtering</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The two filtering operators are OfType and Where. For details and examples of the OfType operator, see the conversion operators section (A.3). The Where operator returns a sequence containing all the elements matching the given predicate. It has an overload to allow the predicate to take account of the element’s index. It’s unusual to require the index, and the where clause in query expressions doesn’t use this overload. Where always uses deferred execution and streams its data. Table A.13 demonstrates both overloads.</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Where(word =&gt; word.Length &gt;&nbsp;3)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;zero&quot;, &quot;three&quot;, &quot;four&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Where</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;zero&quot;, // index=0, length=4</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">((word, index) =&gt; index &lt;&nbsp;word.Length)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;one&quot;, // index=1, length=3</font></p></td></tr>
<tr><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;two&quot;, // index=2, length=2</font></p></td></tr>
<tr><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;three&quot;, // index=3, length=5</font></p></td></tr>
<tr><td>
<p></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Not &quot;four&quot;, index=4, length=4</font></p></td></tr>
</table>
<p><a name="bookmark4716"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.13 Set-based operators</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s natural to be able to consider two sequences as sets of elements. The four set-based operators all have two overloads, one using the default equality comparison for the element type, and one where the comparison is specified in an extra parameter. All of them use deferred execution.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Distinct operator is the simplest—it acts on a single sequence, and just returns a new sequence of all the distinct elements, discarding duplicates. The other operators also make sure they only return distinct values, but they act on two sequences:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Intersect returns elements that appear in both sequences.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Union returns the elements that are in either sequence.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Except returns elements that are in the first sequence but not in the second. (Elements that are in the second sequence but not the first are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">not</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> returned.)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">For the examples of these operators in table A.14, we’ll use two new sequences: abbc (&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;) and cd (&quot;c&quot;, &quot;d&quot;).</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">abbc.Distinct()</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">abbc.Intersect(cd)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">abbc.Union(cd)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">abbc.Except(cd)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">cd.Except(abbc)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;a&quot;, &quot;b&quot;, &quot;c&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;c&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; &quot;a&quot;, &quot;b&quot;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;d&quot;</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table A.14 Set-based examples</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All of these operators use deferred execution, but the buffering/streaming distinction is slightly more complicated. Distinct and Union both stream their input sequences, whereas Intersect and Except read the whole of the right input sequence to start with, but then stream the left input sequence in a similar way to the join operators. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">All </font><font style="font-size:x-small;font-family:Times New Roman, serif;">these operators keep a set of the elements they’ve already returned so as not to return duplicates. This means that even Distinct and Union are unsuitable for sequences that are too large to fit into memory—unless you know that there will be a limited set of distinct elements.</font></p>
<p><a name="bookmark4717"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">A.14 Sorting</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">We’ve seen all the sorting operators before: OrderBy and OrderByDescending provide a primary ordering, whereas ThenBy and ThenByDescending provide subsequent orderings for elements that aren’t differentiated by the primary one. In each case a projection is specified from an element to its sorting key, and a comparison (between keys) can also be specified. Unlike some other sorting algorithms in the framework (such as List&lt;T&gt;.Sort), the LINQ orderings are </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">stable</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—in other words, if two elements are regarded as equal in terms of their sorting key, they’ll be returned in the order they appeared in the original sequence.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The final sorting operator is Reverse, which simply reverses the order of the sequence. All of the sorting operators (see table A.15) use deferred execution, but buffer their data.</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Table A.15 Sorting examples</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Expression</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Result</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.OrderBy(word =&gt; word)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;four&quot;, &quot;one&quot;, &quot;three&quot;, &quot;two&quot;, &quot;zero&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Order words by second character words.OrderBy(word =&gt; word[1])</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;zero&quot;, &quot;three&quot;, &quot;one&quot;, &quot;four&quot;, &quot;two&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Order words by length;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// equal lengths returned in original // order</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.OrderBy(word =&gt; word.Length)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;one&quot;, &quot;two&quot;, &quot;zero&quot;, &quot;four&quot;, &quot;three&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.OrderByDescending (word =&gt; word.Length)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;three&quot;, &quot;zero&quot;, &quot;four&quot;, &quot;one&quot;, &quot;two&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Order words by length and then // alphabetically</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.OrderBy(word =&gt; word.Length) .ThenBy(word =&gt; word)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;one&quot;, &quot;two&quot;, &quot;four&quot;, &quot;zero&quot;, &quot;three&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">// Order words by length and then // alphabetically backwards words.OrderBy(word =&gt; word.Length) .ThenByDescending(word =&gt; word)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;two&quot;, &quot;one&quot;, &quot;zero&quot;, &quot;four&quot;, &quot;three&quot;</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">words.Reverse()</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">&quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;one&quot;, &quot;zero&quot;</font></p></td></tr>
</table>
<p><a name="bookmark442"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark4718"></a>appendix B Generic collections in .NET</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are many generic collections in .NET, and the list has grown over time. This appendix covers the most important generic collection interfaces and classes to know about. There are additional nongeneric collections in System.Collections, System. Collections.Specialized, and System.ComponentModel, but I won’t be covering those here. Likewise I won’t be mentioning the LINQ interfaces, such as ILookup&lt;TKey, TValue&gt;. This appendix is more reference than guidance—think of it as an alternative to navigating around MSDN while you’re coding. Obviously MSDN will provide more details in most cases, but the aim here is to allow you to quickly skim over the various interfaces and implementations available when choosing a particular collection to use in your code.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I haven’t indicated the thread safety of each collection, but MSDN can provide more details. None of the normal collections support multiple concurrent writers; some support a single writer with concurrent readers. Section B.6 lists the concurrent collections that have been added to .NET 4.</font></p>
<p><a name="bookmark4719"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.1 Interfaces</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Almost all the interfaces you need to know about are in the System.Collections. Generic namespace. Figure B.1 shows how the major interfaces are related; I’ve included the nongeneric IEnumerable as the interface root as well.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As we’ve already seen several times, the most fundamental generic collection interface is IEnumerable&lt;T&gt;, representing a sequence of items that can be iterated over. IEnumerable&lt;T&gt; allows you to ask for an iterator of type IEnumerator&lt;T&gt;. The separation between the iterable sequence and the iterator enables multiple iterators to run independently over the same sequence at the same time. If you want to think in database terms, a table is an IEnumerable&lt;T&gt;, whereas a cursor is an IEnumerator&lt;T&gt;. These are the only variant collection interfaces covered in this chapter, becoming IEnumerable&lt;out T&gt; and IEnumerator&lt;out T&gt; in .NET 4; all the other interfaces involve values of the element type going both in and out of members, so they have to be invariant.</font></p><img src="images/64.png"/>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Figure B.1 Interfaces in </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Collections.Generic</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Next comes ICollection&lt;T&gt;—this extends IEnumerable&lt;T&gt;, but adds two properties (Count and IsReadOnly), mutation methods (Add, Remove, Clear), CopyTo (which copies the contents to an array), and Contains (which determines if the collection contains a particular element). All the standard generic collection implementations implement this interface.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IList&lt;T&gt; is all about positioning: it provides an indexer, InsertAt and RemoveAt (to match Add/Remove but with positions), and IndexOf (to determine the position of an element within the collection). Iterating over an IList&lt;T&gt; will generally return the item at index 0, then index 1, and so on. This isn’t thoroughly documented, but it’s a reasonable assumption to make. Likewise, it’s usually expected that random access to an IList&lt;T&gt; by index is efficient.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IDictionary&lt;TKey, TValue&gt; represents a mapping from a unique key to a value for that key. The values don’t have to be unique, and may be null; keys can’t be null. Dictionaries can be regarded as collections of key/value pairs, which is why IDictionary&lt;TKey, TValue&gt; extends ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;. Values can be retrieved with the indexer or TryGetValue; unlike the nongeneric IDictionary type, if you attempt to fetch the value for a missing key, the indexer of IDictionary&lt;TKey, TValue&gt; throws KeyNotFoundException. The purpose of TryGetValue is to allow you to detect missing keys in situations where it’s expected in normal operation.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ISet&lt;T&gt; is a new interface to .NET 4, representing a distinct set of values. It’s been retrospectively applied to HashSet&lt;T&gt; from .NET 3.5, as well as a new implementation—SortedSet&lt;T&gt;—being introduced in .NET 4.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Usually it’s fairly clear which interface (and even implementation) you want to use when </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">implementing</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> functionality. It can be significantly harder to decide how to expose that collection as part of an API: the more specific you are in what you return, the more your callers will be able to rely on additional functionality specified by those types. This may make the caller’s life easier, at the expense of future flexibility within your implementation. I usually prefer to use interfaces for the return types of methods and properties, rather than guaranteeing a particular implementation class. You should also think carefully before exposing a mutable collection in an API, particularly if that collection represents part of the state of the object or type. Returning either a copy or a read-only wrapper around the collection is usually preferable, unless the whole purpose of the method is to allow mutation via the returned collection.</font></p>
<p><a name="bookmark4720"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.2 Lists</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In many ways lists are the simplest and most natural type of collection. There are many implementations in the framework, with different abilities and performance characteristics. A few big-hitters are used all over the place, and some more esoteric ones are used for specialist situations.</font></p>
<p><a name="bookmark4721"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.2.1 List&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">List&lt;T&gt; is the default choice for lists in most cases. It implements IList&lt;T&gt; and therefore ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, and IEnumerable. Additionally, it implements the nongeneric ICollection and IList interfaces, boxing and unboxing as required, and performing execution-time type checks to make sure that new elements are always of a type that’s compatible with T.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Internally List&lt;T&gt; stores an array, and it keeps track of both the logical size of the list and the size of the backing array. Adding an element is either a simple case of setting the next value in the array, or (if the array is already full) copying the existing contents into a new, bigger array and then setting the value. This means the operation has complexity of O(1) or O(n) depending on whether the values need to be copied. The expansion strategy isn’t documented—and therefore isn’t guaranteed—but in practice the approach has always been to expand to double the newly required size. This results in an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">amortized complexity</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of O(1) for appending an item to the end of the list: sometimes it’ll be more, but that becomes increasingly rare as the list grows larger.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">You can explicitly manage the size of the backing array by getting and setting the Capacity property; the TrimExcess method has the effect of making the capacity exactly equal to the current size. In practice this is rarely necessary, but if you already know the eventual size of the list when you create it, you can pass an initial capacity into the constructor, which can avoid unnecessary copying.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Removing an element from a List&lt;T&gt; requires all the later elements to be copied down, so its complexity is O(n - k) where k is the index of the element you’re removing; trimming the tail of a list is cheaper than removing the head. On the other hand, if you’re trying to remove an element by value instead of by index (Remove rather than RemoveAt), you’ll effectively end up with an O(n) operation wherever the element is: each element either has to be checked for equality or shuffled down.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Various methods on List&lt;T&gt; act as a sort of precursor to LINQ. ConvertAll projects one list into another; FindAll filters the original list into a new list containing only the values that match the specified predicate. Sort performs a sort using either the default equality comparer for the type or one specified as an argument. There’s a big difference between Sort and the OrderBy of LINQ, though: Sort modifies the contents of the original list, rather than yielding an ordered copy. Also, Sort is unstable, whereas OrderBy is stable: equal elements in the original list may be reordered when using Sort. One aspect of List&lt;T&gt; which isn’t supported by LINQ is binary search: if you have a list that’s already sorted in the right way for the value you’re looking for, the BinarySearch method is more efficient than using the linear IndexOf search.<sup><a name="footnote111"></a><a href="#bookmark4722">111</a></sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One somewhat controversial aspect of List&lt;T&gt; is the ForEach method. This does exactly what it sounds like—it iterates over the list and executes a delegate (specified as an argument to the method) for each value. Many developers have requested that this be added as an extension method for IEnumerable&lt;T&gt;, but this has been resisted so far; Eric Lippert makes the case for it being philosophically troubling on his blog (see <a href="http://mng.bz/Rur2">http://mng.bz/Rur2</a>). Calling ForEach using a lambda expression seems overkill to me; on the other hand, if you already have a delegate you want to execute on each element on the list, you might as well get ForEach to do that for you, as it’s already there.</font></p>
<p><a name="bookmark4723"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.2.2 Arrays</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Arrays are in some senses the lowest level of collection in .NET. All arrays derive directly from System.Array, and they’re the only collections with direct support in the CLR. Single-dimensional arrays implement IList&lt;T&gt; (and the interfaces it extends) and the nongeneric IList and ICollection interfaces; rectangular arrays only support the nongeneric interfaces. Arrays are always mutable in terms of their elements, but always fixed in terms of their size. All the mutating methods of the collection interfaces (such as Add and Remove) are explicitly implemented, and throw Not-SupportedException.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Arrays of reference types are always covariant: there’s an implicit conversion from a Stream [] reference to Object[ ], for example, and an explicit conversion the other way round.<sup>2</sup> This means that changes to the array have to be verified at execution time—the array itself knows what type it is, so if you try to store a non-Stream reference in a Stream[] by converting the array reference to an Object[] first, an Array-TypeMismatchException will be thrown.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There are two different flavors of array as far as the CLR is concerned. A </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">vector</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> is a single-dimensional array with a lower bound of 0; anything else just counts as an </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">array. </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Vectors perform better, and are what you almost always use in C#. An array of the form T[][] is still a vector, but with an element type of T[]; only </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">rectangular arrays</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> in C# such as new string [10, 2 0] end up as arrays in CLR terminology. You can’t create an array with a nonzero lower bound directly in C#—you have to use Array.Create-Instance, which allows you to specify lower bounds, lengths, and the element type individually. If you create a single-dimensional array with a nonzero lower bound, you then can’t successfully cast it to T[] —the compiler will allow the cast, but it will fail at execution time.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The C# compiler has built-in support for arrays in a number of ways. Not only does it know about how to create and index them, but it also supports them directly in foreach loops: if you iterate using an expression that’s known to be an array at compile time, that iteration will use the Length property and the array indexer, rather than creating an iterator object. This is more efficient, but the performance difference is usually negligible.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Like List&lt;T&gt;, arrays support methods such as ConvertAll, FindAll, and Binary-Search—although in the case of arrays, these are static methods of the Array class, taking the array as the first parameter.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">To come back to my first point, arrays are pretty low-level data structures. They’re important as the building blocks for many other collections, and they’re efficient in appropriate situations, but you should think twice before using them too heavily. Again, Eric has blogged on this topic, labeling them “somewhat harmful” (see <a href="http://mng.bz/3jd5">http://</a> <a href="http://mng.bz/3jd5">mng.bz/3jd5</a>). I don’t want to overstate this point, but it’s worth at least being aware of the shortcomings of arrays when choosing a collection type.</font></p>
<p><a name="bookmark4724"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.2.3 LinkedList&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When is a list not a list? When it’s a linked list. LinkedList&lt;T&gt; is a list in many ways— in particular, it’s a collection that maintains the order in which you add items—but it doesn’t implement IList&lt;T&gt;. This is because it doesn’t obey the implied contract of efficient access by index. It’s a classical computer science doubly linked list: it maintains a head node and a tail node; each node has a reference to the next and previous node within the list. Each node is exposed as a LinkedListNode&lt;T&gt;, which is handy if you want to maintain an insertion/removal point somewhere in the middle of the list. The list explicitly maintains a size, so accessing the Count property is efficient.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Linked lists are inefficient in terms of space compared with array-backed lists, as well as not supporting indexed operations—but they’re fast at inserting or removing elements at arbitrary points in the list, so long as you have a reference to the node at the relevant point. These operations have O(1) complexity, as all that’s required is fixing up the next/previous references in the surrounding nodes. Inserting or removing from the head or tail of the list is just a special case of this where there’s always immediate access to the node you need to change. Iterating (either forward or backward) is also efficient, as it’s just a matter of following the chain of references.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although LinkedList&lt;T&gt; implements the standard methods such as Add (which adds to the tail of the list), I’d suggest using the explicit AddFirst and AddLast methods to make it clear exactly what’s going on. There are matching RemoveFirst and RemoveLast methods, and First and Last properties. All of these return the nodes within the list rather than the values of those nodes; the properties return a null reference if the list is empty.</font></p>
<p><a name="bookmark4725"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.2.4 Collection&lt;T&gt;, BindingList&lt;T&gt;, ObservableCollection&lt;T&gt;, and KeyedCollection&lt;TKey, Tltem&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Collection&lt;T&gt; is a member of the System.Collections.ObjectModel namespace, as are all the remaining lists we’re going to look at. Like List&lt;T&gt;, it implements both the generic and nongeneric collection interfaces.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Though you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use Collection&lt;T&gt; on its own, it’s more commonly used as a base class. It always acts as a wrapper to another list: you either specify one in the constructor, or a new List&lt;T&gt; will be created behind the scenes. All mutating actions on the collection go through protected virtual methods (InsertItem, SetItem, RemoveItem, and ClearItems); derived classes can intercept these methods, raising events or providing other custom behavior. The wrapped list is accessible to derived classes via the Items property. If this list is read-only, the public mutating methods throw an exception rather than calling the virtual methods; you don’t need to recheck this when you override them.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">BindingList&lt;T&gt; and ObservableCollection&lt;T&gt; derive from Collection&lt;T&gt; in order to provide binding capabilities. BindingList&lt;T&gt; has been available since .NET 2.0, but ObservableCollection&lt;T&gt; was introduced with Windows Presentation Foundation (WPF). Of course you don’t have to use them for data binding in user interfaces—you may have your own reasons to be interested in changes to a list. In that case, you should see which collection provides notifications in a more useful form in order to decide which to use. Of course, you’ll only be notified of changes that occur through the wrapper: if the underlying list is shared with other code that may modify it on its own, that won’t raise any events in the wrapper.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">KeyedCollection&lt;TKey, TItem&gt; is a sort of hybrid between a list and a dictionary, allowing an item to be fetched by key as well as by index. Unlike normal dictionaries, the key should be effectively embedded within the item, rather than being independent. In many cases this is natural—for example, you might have a Customer type with a CustomerID property. KeyedCollection&lt;,&gt; is an abstract class: derived classes implement the GetKeyForItem method to provide a way of extracting a key from any item added to the collection. In our customer scenario, the GetKeyForItem method would just return the ID for the given customer. Just like a dictionary, the key must be unique within the collection—attempting to add another item with the same key will fail with an exception. Though null keys aren’t permitted, GetKeyForItem can return null (if the key type is a reference type), in which case the key will be ignored (and the item won’t be fetchable by its key).</font></p>
<p><a name="bookmark4726"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.2.5 ReadOnlyCollection&lt;T&gt;and ReadOnlyObservableCollection&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Our final two lists are more wrappers, providing read-only access even when the underlying list is mutable. Again, both generic and nongeneric collection interfaces are implemented. A mixture of explicit and implicit interface implementation is used so that callers using a compile-time expression of the concrete type will be discouraged from using mutating operations that will fail.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ReadOnlyObservableCollection&lt;T&gt; derives from ReadOnlyCollection&lt;T&gt; and implements the same INotifyCollectionChanged and INotifyPropertyChanged interfaces as ObservableCollection&lt;T&gt;. A ReadOnlyObservableCollection&lt;T&gt; instance can only be constructed with an Observable&lt;T&gt; backing list. Even though the collection is still read-only for callers, they can observe changes made elsewhere to the backing list.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Though usually I’d advise using an interface when deciding the return type of methods in an API, it can be useful to deliberately expose ReadOnlyCollection&lt;T&gt; to provide a clear indication to callers that they won’t be able to modify the returned collection. But you’ll still need to document whether the underlying collection may be changed elsewhere, or whether it’s effectively constant.</font></p>
<p><a name="bookmark4727"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.3 Dictionaries</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The choices for dictionaries in the framework are much more limited than that of lists. There are only three mainstream nonconcurrent implementations of IDictionary&lt;TKey, TValue&gt;, although it’s also implemented by ExpandoObject (as we saw in chapter 14), ConcurrentDictionary (which we’ll look at along with the other concurrent collections), and RouteValueDictionary (used for routing web requests, particularly in ASP.NET MVC).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just as a reminder after all those lists, the primary purpose of a dictionary is to provide an efficient lookup from a key to a value.</font></p>
<p><a name="bookmark4728"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.3.1 Dictionary&lt;TKey, TValue&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Unless you have specialist requirements, Dictionary&lt;TKey, TValue&gt; is the default choice of dictionary in much the same way that List&lt;T&gt; is the default list implementation. It uses a hash table to implement an efficient lookup (see <a href="http://mng.bz/qTdH">http://mng.bz/</a> <a href="http://mng.bz/qTdH">qTdH</a>)—although of course this means that the efficiency of the dictionary depends on how good your hashing function is. You can either use the default hashing and equality functions (calls to </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Equals </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and GetHashCode within the key objects themselves) or specify an IEqualityComparer&lt;TKey&gt; as a constructor argument. The simplest use case for this is to implement a dictionary with string keys, which uses the keys in a case-insensitive way as shown in the following listing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing B.1 Demonstration of custom key comparisons in a dictionary</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var comparer = StringComparer.OrdinalIgnoreCase; var dict = new Dictionary&lt;String<sub>/</sub> int&gt;(comparer); dict[&quot;TEST&quot;] = 10;</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(dict[&quot;test&quot;]);</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although the keys within a dictionary have to be unique, the hash codes don’t. It’s perfectly acceptable for two unequal keys to have the same hash: this is known as a </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">hash collision,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> and although it reduces the efficiency of the dictionary slightly, it’ll still function correctly. The dictionary </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">will</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> fail if the keys are mutable and change their hash code after they’ve been inserted into the dictionary. Mutable dictionary keys are almost always a bad idea, but if you absolutely </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">have</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to use one, make sure you don’t change it after insertion.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The exact details of the implementation of the hash table are unspecified and may change over time, but one important aspect can cause confusion: </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">there’s no ordering guarantee within</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Dictionary&lt;TKey, TValue&gt;, </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">even though it might appear that way.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> If you add items to a dictionary and then iterate over it, you may see the items come out in the insertion order, but </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">please don’t rely on it.</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> It’s somewhat unfortunate that as a quirk of the implementation, just adding entries tends to preserve order—an implementation which happened to scramble the order naturally would probably cause less confusion.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Like List&lt;T&gt;, Dictionary&lt;TKey, TValue&gt; keeps its entries in an array and expands this when it needs to, leading to amortized O(1) expansion. Access by key is also O(1) assuming a reasonable hash: if all the keys have the same hash code, you’ll end up with O(n) access as the dictionary has to check each key in turn for equality. In most practical scenarios this isn’t an issue.</font></p>
<p><a name="bookmark4729"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.3.2 SortedList&lt;TKey, TValue&gt;and SortedDictionary&lt;TKey, TValue&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A casual observer might imagine that a class named SortedList&lt;, &gt;&nbsp;would be a list... but no. Both of these types are actually dictionaries, and neither implements IList&lt;T&gt; at all. It might be more informative for them to be named ListBacked-SortedDictionary and TreeBackedSortedDictionary, but it’s too late to change now.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s a lot of commonality between these two classes: both use an IComparer &lt;TKey&gt; instead of an IEqualityComparer&lt;TKey&gt; to compare keys, and both maintain the keys in a sorted fashion, based on that comparison. Both have O(log n) performance when finding values, effectively performing a binary search. But their internal data structures are very different: SortedList&lt;, &gt;&nbsp;maintains an array of entries which is kept sorted, whereas SortedDictionary&lt;,&gt; uses a red-black tree structure (see <a href="http://mng.bz/K1S4">http://mng.bz/K1S4</a>). This leads to significant differences in insertion and removal times as well as memory efficiency. If you’re creating a dictionary from mostly sorted data, a SortedList&lt;,&gt; will populate efficiently: if you imagine the steps involved in keeping a List&lt;T&gt; sorted, you can see that adding a single item to the end of the list is cheap (O(1) if you ignore expansion), whereas adding items randomly is expensive, as it involves copying existing items (O(n) in the worst case). Adding items to the balanced tree in a SortedDictionary&lt;,&gt; is always fairly cheap (O(log n) complexity) but it involves a separate tree node on the heap for each entry, leading to more overhead and memory fragmentation than the array of key/value entry structures in a SortedList&lt;, &gt;.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Both collections expose their keys and values as separate collections, and in both cases the returned collection is live in that it’ll change as the underlying dictionary changes. But the collections exposed by a SortedList&lt;,&gt; implement IList&lt;T&gt;—so you can effectively access entries by sorted key index if you really want to.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">I don’t want to put you off too much with all this talk of complexity: unless you have a very large amount of data, you probably don’t need to worry much about which implementation you use. If you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> likely to have vast numbers of entries in your dictionary, you should carefully analyze the performance characteristics of both collections to work out which one to use.</font></p>
<p><a name="bookmark4730"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.4 Sets</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Prior to .NET 3.5, there was no public set collection in the framework at all. When developers needed something to represent a set in .NET 2.0, they’d typically use a Dictionary&lt;,&gt;, using the set items as keys and providing dummy values. This situation was improved somewhat with HashSet&lt;T&gt; in .NET 3.5, and now .NET 4 has added a SortedSet&lt;T&gt; and a common ISet&lt;T&gt; interface. Although logically a set interface could consist merely of Add/Remove/Contains operations, ISet&lt;T&gt; specifies a number of other operations to manipulate the set (ExceptWith, IntersectWith, Symmetric-ExceptWith, UnionWith) and to test for various more complex conditions (SetEquals, Overlaps, IsSubsetOf, IsSupersetOf, IsProperSubsetOf, IsProperSupersetOf). The parameters for all of these methods are expressed in terms of IEnumerable&lt;T&gt; rather than ISet&lt;T&gt;, which is initially surprising, but means that sets interact with LINQ in a natural way.</font></p>
<p><a name="bookmark4731"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.4.1 HashSet&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A HashSet&lt;T&gt; is effectively a Dictionary&lt;, &gt;&nbsp;without the values. It has the same performance characteristics, and again you can specify an IEqualityComparer&lt;T&gt; to customise how items are compared. Once more, you must not rely on a HashSet&lt;T&gt; maintaining the order in which you add values.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One additional feature supported by HashSet&lt;T&gt; is the RemoveWhere method, which removes any entry that matches a given predicate. This allows you to prune a set without worrying about the normal prohibition against modifying a collection while you iterate over it.</font></p>
<p><a name="bookmark4732"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.4.2 SortedSet&lt;T&gt; (.NET 4)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just like our HashSet&lt;T&gt; comparison with Dictionary&lt;,&gt;, a SortedSet&lt;T&gt; is like a valueless SortedDictionary&lt;,&gt;. It maintains a red-black tree of values, providing O(log n) complexity for addition, removal, and containment checking. When you iterate over the set, the values will be yielded in a sorted order.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It provides the same RemoveWhere method as HashSet&lt;T&gt; (despite this not being in the interface) and additionally provides properties (Min and Max) to return the minimum and maximum values. A more intriguing method is GetViewBetween, which returns another SortedSet&lt;T&gt; offering a view on the original set between a lower and upper bound, both of which are inclusive. This is a mutable, live view—changes to the view are reflected in the original set, and vice versa. Listing B.2 demonstrates this.</font></p>
<p><a name="bookmark4733"></a><font style="font-size:x-small;font-family:Times New Roman, serif;">Listing B.2 Observing changes in a sorted set via a view</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">var baseSet = new SortedSet&lt;int&gt; { 1, 5, 12, 20, 25 }; var view = baseSet.GetViewBetween(10, 20); view.Add(14);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(baseSet.Count); foreach (int value in view)</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">{</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Console.WriteLine(value);</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">}</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although GetViewBetween is convenient, it’s not entirely free: operations on the view may be more expensive than expected, in order to keep internal consistency. In particular, accessing the Count property of a view is an O (n) operation if the underlying set has changed since the last tree walk. Like all powerful tools, this should be used with care.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">One final feature of SortedSet&lt;T&gt;: it exposes a Reverse () method that allows you to iterate over it in reverse order. This isn’t used by Enumerable.Reverse(), which buffers the contents of the sequence it’s called on; if you know you’ll want to access a sorted set in reverse order, it may be useful to keep an expression of type Sorted-Set&lt;T&gt; instead of using a more general interface type, just so that you can access this more efficient implementation.</font></p>
<p><a name="bookmark4734"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.5 Queue&lt;T&gt; and Stack&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Queues and stacks are staples of every computer science course. They’re sometimes referred to as FIFO (first in, first out) and LIFO (last in, first out) structures respectively. The basic idea is the same for both data structures: you add items to the collection, and at some other point you remove them. The difference is the order in which they’re removed: a queue acts like a queue in a shop, where the first person to join the queue is the first to be served; a stack acts like a stack of plates where the last plate placed on the top is the first to be taken off it. One common use for queues and stacks is to maintain a list of work items still to process.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Just as with LinkedList&lt;T&gt;, though you </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">can</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> use the normal collection interface methods to access queues and stacks, I’d recommend using the class-specific ones to make your code clearer.</font></p>
<p><a name="bookmark4735"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.5.1 Queue&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Queue&lt;T&gt; is implemented with a circular buffer (see <a href="http://mng.bz/mKeq">http://mng.bz/mKeq</a>): essentially it maintains an array, with an index remembering the next slot to add an item into, and another index remembering the next slot to take an item from. If the add index catches up with the remove index, the contents are copied into a larger array.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Queue&lt;T&gt; provides the Enqueue and Dequeue methods to add and remove items; a Peek method allows you to see what item will be dequeued next, without actually removing it. Both Dequeue and Peek throw InvalidOperationException if they’re called on an empty queue. Iterating over the queue yields values in the order they’d be dequeued.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Stack&lt;T&gt; implementation is even simpler than Queue&lt;T&gt;—you can think of it as being just like a List&lt;T&gt;, but with a Push method to add a new item to the end of the list, Pop to remove the final item, and Peek to look at the final item without removing it. Again, Pop and Peek throw InvalidOperationException when called on an empty stack. Iterating over the stack yields values in the order they’d be popped—so the most recently added value is yielded first.</font></p>
<p><a name="bookmark4736"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.6 Concurrent collections (.NET 4)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">As part of Parallel Extensions in .NET 4, there are several new collections in a new System.Collections.Concurrent namespace. These are designed to be safe in the face of concurrent operations from multiple threads, with relatively little locking. The namespace also contains three classes that are used for partitioning collections for parallel operations, but we won’t be looking at those here.</font></p>
<p><a name="bookmark4737"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.6.1 IProducerConsumerCollection&lt;T&gt; and BlockingCollection&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Three of the new collections implement the new IProducerConsumerCollection&lt;T&gt; interface, which is designed to be used with BlockingCollection&lt;T&gt;. When describing queues and stacks, I mentioned that they’re often used to store work items for later processing; the producer/consumer pattern is a way of executing these work items concurrently. Sometimes there’s a single producer thread creating work and multiple consumer threads executing the work items. In other cases the consumers can also be producers—for example, a web crawler may process a web page and discover more links to be crawled later.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IProducerConsumerCollection&lt;T&gt; acts as an abstraction for the data storage of the producer/consumer pattern, and BlockingCollection&lt;T&gt; wraps this in an easy-to-use form and also provides the ability to limit how many items can be buffered at any one time. BlockingCollection&lt;T&gt; assumes that nothing else will be adding to the wrapped collection directly; all the interested parties should use the wrapper for both adding and removing work items. The constructor overloads that don’t take an IProducerConsumerCollection&lt;T&gt; parameter use a ConcurrentQueue&lt;T&gt; for backing storage.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The IProducerConsumerCollection&lt;T&gt; only provides three particularly interesting methods: ToArray, TryAdd, and TryTake. ToArray copies the current contents of the collection to a new array; this is a snapshot of the collection at the point when the method is called. TryAdd and TryTake both follow the normal TryXXX pattern, returning a Boolean value to indicate success or failure, and they do what you’d expect: attempt to add an item to the collection, or attempt to remove one from the collection. Allowing an efficient failure mode reduces the need for locking. In a Queue&lt;T&gt; for example, you’d want to hold a lock in order to combine the operations of “test whether there are any items in the queue” and “dequeue an item if there is one”— otherwise Dequeue could throw an exception.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">BlockingCollection&lt;T&gt; layers blocking behavior on top of these nonblocking methods, with a host of overloads to allow timeouts and cancellation tokens to be specified. Usually you won’t need to use BlockingCollection&lt;T&gt; or IProducer-ConsumerCollection&lt;T&gt; directly; you’ll call other parts of Parallel Extensions that’ll use them for you. It’s worth knowing they’re there, though, in case you need your own custom behavior.</font></p>
<p><a name="bookmark4738"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.6.2 ConcurrentBag&lt;T&gt;, ConcurrentQueue&lt;T&gt;, ConcurrentStack&lt;T&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The framework comes with three implementations of IProducerConsumer-Collection&lt;T&gt;. Essentially they differ in terms of the order in which items are retrieved: the queue and stack act as you’d expect them to from their nonconcurrent equivalents, whereas ConcurrentBag&lt;T&gt; doesn’t guarantee any ordering.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">All three implement IEnumerable&lt;T&gt; in a thread-safe way. The iterator returned by GetEnumerator() will iterate over a snapshot of the collection; you can modify the collection while you’re iterating, and the changes won’t be seen within the iterator. All three also offer a TryPeek method which is similar to TryTake, but which doesn’t remove a value from the collection. Unlike TryTake, this method isn’t specified in IProducerConsumerCollection&lt;T&gt;.</font></p>
<p><a name="bookmark4739"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.6.3 ConcurrentDictionary&lt;TKey, TValue&gt;</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ConcurrentDictionary&lt;TKey, TValue&gt; implements the standard IDictionary&lt;TKey, TValue&gt; interface (whereas none of the concurrent collections implements IList&lt;T&gt;) and is essentially a thread-safe hash-based dictionary. It supports multiple threads reading and writing concurrently, and also allows thread-safe iteration— although unlike the three collections from the previous section, modifications made to the dictionary while iterating may or may not be reflected in the iterator.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s more to it than just thread-safe access. Whereas normal dictionary implementations basically offer add-or-update via the indexer, and add-or-throw via the Add method, ConcurrentDictionary&lt;TKey, TValue&gt; offers a veritable smorgasbord of options. You can update the value associated with a key based on its previous value, get a value based on a key or add it if the key wasn’t present beforehand, conditionally update a value only if it was what you expected it to be before, and many other possibilities, all of which act atomically. It’s all bewildering to start with, but Stephen Toub of the Parallel Extensions team has a blog post giving details of when you should use which method (see <a href="http://mng.bz/WMdW">http://mng.bz/WMdW</a>).</font></p>
<p><a name="bookmark4740"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">B.7 Summary</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The .NET framework contains a rich set of collections (although not a particularly rich collection of sets). These have been gradually growing along with the rest of the framework, although the most commonly used collections are likely to be List&lt;T&gt; and Dictionary&lt;TKey, TValue&gt; for some time to come. There are certainly data structures that could be added in the future, but the benefit always has to be weighed</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">against the cost of adding something to the core framework. Maybe we’ll see explicitly tree-based APIs in the future, rather than them being an implementation detail of existing collections. Maybe we’ll see Fibonacci heaps, weak-reference caches, and the like—but as we’ve seen, there’s already a lot for developers to take in, and there’s a risk of information overload. If there’s a particular data structure you need for your project, it’s worth looking online for an open source implementation; Wintellect’s Power Collections have a particularly strong history as an alternative to the built-in collections (see <a href="http://mng.bz/plaM">http://mng.bz/plaM</a>). But in most cases, the framework is likely to be adequate for your needs: hopefully this appendix has expanded your horizons slightly in terms of what’s available out of the box.</font></p>
<p><a name="bookmark443"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;"><a name="bookmark4741"></a>appendix C Version summaries</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The version numbers in .NET can be confusing sometimes. The framework, runtime, Visual Studio, and C# are all numbered separately. This appendix is a quick guide to how they fit together and the major features in each release. In each case I’ve described the features from releases 2.0 and upward; listing all the features of .NET 1.0 and 1.1 would be fairly pointless.</font></p>
<p><a name="bookmark4742"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.1 Desktop framework major releases</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When developers refer to releases of .NET, they usually mean the major releases of the desktop framework. In most cases, a framework release has been accompanied by a release of Visual Studio (or Visual Studio .NET, as it was named for the 2002 and 2003 releases). The exception to this was .NET 3.0, which was essentially only a set of libraries (although those libraries were pretty significant). A set of Visual Studio 2005 extensions was made available for the new features, but Visual Studio 2008 contained more support. Table C.1 shows which version of which aspect of the framework was released when.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">When .NET 3.5 was released, .NET 2.0 SP1 and .NET 3.0 SP1 were also released; these contained the 2.0 SP1 CLR and BCL. Similarly, .NET 3.5 SP1’s release coincided with .NET 2.0 SP2 and .NET 3.0 SP2.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Visual Studio 2008 was the first release to support </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">multitargeting,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> you can choose which version of the framework you want to build for. In many cases you can use new features of C# while targeting an earlier release—this is basically the case if the</font></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Table C.1 Desktop framework releases and their components</font></p>
<table border="1">
<tr><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Date</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Framework</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Visual Studio</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">C#</font></p></td><td>
<p><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CLR</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">February 2002</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">1.0</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2002</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">1.0</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">1.0</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">April 2003</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">1.1</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2003</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">1.2</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">1.1</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">November 2005</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2.0</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2005</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2.0</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2.0</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">November 2006</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">3.0</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">(Extensions to 2005)</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">n/a</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2.0</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">November 2007</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">3.5</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2008</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">3.0</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2.0 SP1</font></p></td></tr>
<tr><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">April 2010</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">4</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2010</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">4.0</font></p></td><td>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">4.0</font></p></td></tr>
</table>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">feature is implemented solely by compiler magic, without any support from the CLR or libraries. More information on how to do this is available on the book’s website (see <a href="http://mng.bz/YpRB">http://mng.bz/YpRB</a>)—in some cases there are workarounds if a feature doesn’t quite work out of the box. It’s worth noting that if you target .NET 2.0 (you can’t target 1.0 or 1.1) from Visual Studio 2008 or 2010, you’ll actually be targeting the relevant service pack (2.0 SP1 or 2.0 SP2); this means it’s possible to build code that uses new features from a service pack (one notable introduction was System.DateTimeOffset in 2.0 SP1) and then find it fails if you try to run it on a machine that genuinely has the original release of .NET 2.0. Personally I’d try to update machines to at least run the latest service pack—and ideally a more recent full framework release.</font></p>
<p><a name="bookmark4743"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.2 C# language features</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’ve read the whole book, you should be able to write this section yourself. (It’s tempting to leave a bunch of blank lines for you to fill in, but I’m not </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">quite</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that lazy.) One trivial fact: the version number of 1.2 in table C.1 isn’t a typo; looking at the specifications, Microsoft really did skip 1.1 in order to release a C# 1.2 compiler with .NET 1.1. The changes in version 1.2 were mostly minor, but there was one significant change in the long term: it’s only from C# 1.2 and onward that the translated code for a foreach loop tests whether the iterator implements IDisposable and disposes of it accordingly. As we’ve seen, this change is crucial for iterator blocks that have resources to clean up.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Anyway, for the sake of completeness, here are the language features, along with the chapter references for more details.</font></p>
<p><a name="bookmark4744"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.2.1 C# 2.0</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The major features of C# 2 were generics (see chapter 3), nullable types (chapter 4), anonymous methods and other delegate-related enhancements (chapter 5), and iterator blocks (chapter 6). Additionally, several smaller features were introduced: partial types, static classes, properties with different access modifiers for getters and setters, namespace aliases, pragma directives, and fixed-sized buffers. See chapter 7 for more details.</font></p>
<p><a name="bookmark4745"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.2.2 C# 3.0</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 3 primarily built toward LINQ, although many features are useful elsewhere. Automatic properties, implicit typing of arrays and local variables, object and collection initializers, and anonymous types are all covered in chapter 8. Lambda expressions and expression trees (chapter 9) extended the delegate-related progress made in version</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2.0, and extension methods (chapter 10) provided the last ingredient for query expressions (chapter 11). Partial methods were only added in C# 3, but are covered with the inclusion of partial types in chapter 7.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">C# 4.0 has some features aimed at interoperability, but doesn’t have the same singlemindedness of C# 3.0. Again there’s a reasonably clear divide between the small features shown in chapter 13 (named arguments, optional parameters, better COM interop, generic variance) and the huge feature of dynamic typing (chapter 14).</font></p>
<p><a name="bookmark4746"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.3 Framework library features</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’d be impossible to list all of the new features in the framework in a sensible fashion here. In particular, each area of the framework (Windows Forms, ASP.NET, and so on) gets extra features in each release—not just the core base class library. I’ve included the features I believe are the most important highlights. MSDN has a far more comprehensive list at <a href="http://mng.bz/6tiZ">http://mng.bz/6tiZ</a>.</font></p>
<p><a name="bookmark4747"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.3.1 .NET 2.0</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The biggest features in the 2.0 libraries supported those of the CLR and languages: generics and nullable types. Whereas nullable types didn’t require many changes, many of the generic collections we’re used to now have been present since .NET 2.0— and the reflection API had to be updated accordingly.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Many areas received relatively minor updates, such as support for compression, multiple active result sets (MARS) over a single connection to SQL Server, and many static helper I/O methods such as File.ReadAllText. It’s probably fair to say that these weren’t as significant as the changes to user interface frameworks.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ASP.NET gained master pages, precompilation abilities, and various new controls. Windows Forms took a big leap in terms of layout abilities with TableLayoutPanel and similar classes, as well as better support for performance enhancements such as double buffering, a new data binding model, and ClickOnce deployment. Back-groundWorker was introduced in .NET 2.0 to make it easier to update a UI safely in multithreaded applications; it’s not strictly part of Windows Forms, although that was its primary use case until Windows Presentation Foundation arrived in .NET 3.0. Speaking of which...</font></p>
<p><a name="bookmark4748"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.3.2 .NET 3.0</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">.NET 3.0 was somewhat curious as a “major” release with no CLR changes, no language changes, and no changes to existing libraries. Instead, it consisted of four new libraries:</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Windows Presentation Foundation (WPF) is the next-generation user interface framework; this was a revolution rather than an evolution of Windows Forms, although the two can live side by side. It has a very different model to Windows Forms, being much more compositional in nature. Silverlight’s user interface is based on WPF.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Windows Communication Foundation (WCF) is an architecture for building service-oriented applications; it’s extensible rather than being limited to a single protocol, and aims to unify the existing RPC-like communication channels such as remoting.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">■</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> &nbsp;&nbsp;&nbsp;Windows Workflow Foundation (WF) is a system for building workflow applications.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Windows CardSpace is a secure identity system.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Of these four areas, WPF and WCF have flourished whereas WF and CardSpace appear not to have taken off so well. That’s not to say that the latter technologies aren’t being used, or that they won’t become more important in the future—but they’re not nearly as widespread at the time of this writing.</font></p>
<p><a name="bookmark4749"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.3.3 .NET 3.5</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The big new feature in .NET 3.5 was LINQ, supported by C# 3.0 and VB 9. This included LINQ to Objects, LINQ to SQL, LINQ to XML, and expression tree support underlying it.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Other areas also gained important features. it became a lot easier to use AJAX in ASP.NET; WCF and WPF each gained a whole host of improvements; an add-in framework (System.AddIn) was introduced; various new cryptography algorithms were included, and much more. As a developer interested in both concurrency and time-related APIs, I feel obliged to draw your attention to the introduction of Reader-WriterLockSlim and the much-needed TimeZonelnfo and DateTimeOffset types. If you’re using .NET 3.5 or higher but still relying on DateTime everywhere, you should be aware that there are better options available.<sup>1</sup></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">.NET 3.5 SP1’s most notable library feature was the introduction of the Entity Framework and related ADO.NET technologies, but again other technologies had minor improvements as well. Also importantly, .NET 3.5 SP1 introduced the Client Profile—a smaller version of the desktop .NET framework which doesn’t include a lot of the libraries aimed at server-side development. This allows a smaller deployment footprint for client-only applications.</font></p>
<p><a name="bookmark4750"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.3.4 .NET 4</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">A lot of work has been going into the .NET 4 libraries for a long time, in various guises. The DLR is a huge addition, and we’ve also looked at Parallel Extensions and Code Contracts in other chapters—two of the areas I find most exciting, looking to the future. As usual, the user interface technologies have a raft of improvements, although notably the focus for rich client changes is WPF rather than Windows Forms. A lot of tweaks have been made to existing core APIs to just make them that much easier to use—such as String.Join accepting an IEnumerable&lt;T&gt; instead of insisting on a string array. These aren’t earth-shattering improvements ready to revolutionize the world—but if they make every developer’s life just a little bit simpler, that can have a large cumulative impact. We’ve already seen how some of the existing generic interfaces and delegates have become covariant or contravariant (lEnumerable&lt;T&gt; becoming IEnumerable&lt;out T&gt; and Action&lt;T&gt; becoming Action&lt;in T&gt;, for example) but there are new types to explore as well.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">There’s a new namespace for numerical calculations, System.Numeric. At the time of this writing it only contains the BigInteger and Complex types, but I wouldn’t be surprised to see BigDecimal join them in the future. There are other new types within the System namespace, such as Lazy&lt;T&gt; for lazily initialized values and a Tuple family of generic classes that provide the same sort of functionality as our Pair&lt;T1, T2&gt; class from chapter 3, but for up to eight type parameters.<sup><a name="footnote112"></a><a href="#bookmark4751">112</a></sup> Tuple also supports </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">structural comparisons</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> as represented by the new IStructuralEquatable and IStructural-Comparable interfaces in the System.Collections namespace. Although the full Reactive Extensions classes we used in chapter 12 aren’t in .NET 4, the core interfaces IObserver&lt;T&gt; and IObservable&lt;T&gt; are in the System namespace. I’ve brought up these specific items because though new areas like the Managed Extensibility Framework (MEF) get a lot of attention, it’s easy to overlook simple types like these. It’s good to see that time is being spent all over the framework, not just on shiny new cool stuff.</font></p>
<p><a name="bookmark4752"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.4 Runtime (CLR) features</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CLR changes are often less visible to many developers than new library and language features. Obviously there are some particularly shiny features such as generics that’ll catch everyone’s attention, but others are less obvious. The CLR has also changed less frequently than either the language or the framework libraries, at least in terms of major releases.</font></p>
<p><a name="bookmark4753"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.4.1 CLR 2.0</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">In addition to generics, the CLR required one extra change to support the new language features of C# 2: the behavior of boxing and unboxing nullable value types that we explored in chapter 4.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CLR 2.0 had other major changes. The most significant ones were support for 64-bit processors (both x86 and IA64) and the ability to host the CLR within SQL Server 2005. The SQL Server integration required new hosting APIs to be designed, so that the host could have a lot more control over the CLR, including how it allocates memory and threads. This allows a diligent host to make sure that code running in the CLR won’t compromise other aspects of a critical process, such as a database.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">.NET 3.5 included CLR 2.0 SP1, and .NET 3.5 SP1 included CLR 2.0 SP2; these had relatively minor changes such as tweaks to the access that code in a DynamicMethod has to private members of another type. Of course, the CLR team is always looking for ways to improve performance as well, with improvements in garbage collection, the JIT, startup times, and so on.</font></p>
<p><a name="bookmark4754"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.4.2 CLR 4.0</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Although the CLR didn’t need to change in order to accommodate the DLR, the team has still been hard at work. The highlights include</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Interop marshalling performance and consistency improvements with IL stubs everywhere (see <a href="http://mng.bz/56H6">http://mng.bz/56H6</a>)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;A background garbage collector to replace the concurrent collector in CLR 2.0</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;An improved security model based around transparency, which is the successor to Code Access Security (CAS)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Type equivalence, used to support the embedded PIA feature of C# 4</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">■ &nbsp;&nbsp;&nbsp;Side-by-side execution of different CLRs within the same process</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">More details of all of these features are available on the CLR team blog (<a href="http://blogs.msdn.com/clrteam/">http://</a> <a href="http://blogs.msdn.com/clrteam/">blogs.msdn.com/clrteam/</a>).</font></p>
<p><a name="bookmark4755"></a><font style="font-size:medium;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.5 Related frameworks</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s rare for anything in computing to do well with a one-size-fits-all model, and .NET is no exception. Even the desktop framework isn’tjust a single version really: there’s the client profile, the 32-bit and 64-bit JITs, and the server and workstation CLRs tuned for different tasks. Beyond that, there are separate frameworks that have their own version history, tailored to different environments.</font></p>
<p><a name="bookmark4756"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.5.1 Compact Framework</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Compact Framework (see <a href="http://mng.bz/6880">http://mng.bz/6880</a>) was originally aimed at mobile devices running Windows Mobile. Since then it has been retargeted for Xbox 360, Windows Phone 7, and Symbian S60.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Compact Framework major release schedule has traditionally mirrored that of the desktop framework, although there’s no release corresponding to .NET 3.0. Just to keep things interesting, the most up-to-date release (used by some Windows Mobile devices and WP7) is version 3.7.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Early versions of the Compact Framework were missing some fairly core functionality, which was largely filled by community efforts; later releases have plugged many of the more significant gaps, although obviously it’s still a subset of the desktop framework. The GUI layer depends on the exact platform; for example, on the Xbox 360 you’d use XNA, Windows Mobile supports Windows Forms, and WP7 supports both XNA and Silverlight. Code running on the Compact Framework is JIT-compiled and garbage collected, although the Compact Framework collector isn’t generational like the ones in the desktop framework.</font></p>
<p><a name="bookmark4757"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.5.2 Silverlight</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Silverlight (<a href="http://silverlight.net/">http://silverlight.net/</a>) is aimed at running applications either within browsers, or (as of Silverlight 3) in a sandboxed environment, usually originally installed from a browser. As such, it’s a natural competitor to Flash—but as a C# developer, it has the obvious advantage of allowing you to write applications in a familiar language against a familiar library. Silverlight installs a streamlined CLR (called CoreCLR—see <a href="http://mng.bz/G32M">http://mng.bz/G32M</a>) and class library—for example, the nongeneric collections aren’t supported, and neither is Windows Forms. The presentation layer of Silverlight is based on WPF, but they’re not identical. It has particularly strong support for media, with features such as deep zoom and adaptive video streaming.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Silverlight 1 was released in September 2007, although it was restricted to a mixture of XAML to construct the UI and JavaScript for logic. It wasn’t until Silverlight 2 was released in October 2008 that the full experience of delivering Silverlight applications built with C# became a reality. Some of the features from CoreCLR (side-by-side CLR hosting within a single process, and the declarative transparency security model) are now features in the desktop CLR for version 4.0. It also included an early version of the Dynamic Language Runtime.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Progress continued unabated, with Silverlight 3 being released in July 2009 with more controls, more video codecs, as well as offline and out-of-browser applications. The Silverlight team repeated the nine-month release cycle, releasing Silverlight 4 in the same week as .NET 4 with another long list of new features. Windows Phone 7 supports Silverlight 3 and some features of Silverlight 4.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Microsoft has cooperated with the Mono team on the Moonlight project (see <a href="http://mng.bz/FGd4">http://mng.bz/FGd4</a>), an open source implementation of Silverlight running on Linux.</font></p>
<p><a name="bookmark4758"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;font-style:italic;">C.5.3 Micro Framework</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The Micro Framework (see <a href="http://mng.bz/D9qy">http://mng.bz/D9qy</a>) is a tiny implementation of .NET, designed to run on very constrained devices. It doesn’t support generics, it’s interpreted rather than JIT-compiled, and only ships with a limited set of classes—but it </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">does</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> include a presentation layer, built around WPF. In order to save space, you only need to deploy the parts of the framework you actually need—at its smallest, it can take up a mere 390 KB. Obviously this is a somewhat niche area, but the ability to write managed code for embedded devices has great appeal. It won’t be suitable for all situations—it’s not a real-time system, for example—but where it’s applicable, it’s likely to drastically improve developer productivity.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">The release history hasn’t followed that of the desktop framework at all: it was first seen in the SPOT watch in 2004, but version 1.0 was released in 2006. Since then it has iterated several times in rapid succession. Version 4.0 of the Micro Framework shipped on November 19, 2009—and in a move that still delights and surprises me, the majority of this version was released open source under the Apache 2.0 license. Some libraries such as the TCP/IP stack and cryptography implementations are still closed for various reasons; these companion libraries can be downloaded in binary form for specific architectures.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">With so many versions of so many different components, it’s easy to get confused— and even easier to confuse someone else. As a final piece of advice (and I mean final—it's hard to sneak anything deep and meaningful into an index), I recommend that you try to be as clear as possible on this topic when communicating with others. If you’re using anything other than the desktop framework, say so. If you’re going to quote a version number, specify exactly what you mean—“3.0” could mean using C# 2.0 and .NET 3.0, or it could mean using C# 3.0 and .NET 3.5. Aside from anything else, after you’ve read this book, you have </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">absolutely no excuse</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for claiming you’re using “C# 3.5”—unless you’re deliberately trying to wind me up.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">PS—You can stop reading now. Go and have some fun with C# instead of trawling through the index looking for Easter eggs.</font></p>
<p><a name="bookmark4759"></a><font style="font-size:x-large;font-family:Times New Roman, serif;font-weight:bold;font-style:italic;">index</font></p>
<p><a name="bookmark4760"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">Symbols</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2130">:: namespace alias</a> qualifier 191 <a href="#bookmark1469">? modifier 113</a> <a href="#bookmark1548">?? 121</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark1547">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>null coalescing operator <a href="#bookmark2165">.aspx 195</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4499">.Contracts, suffix for contract</a> reference assemblies 469 <a href="#bookmark4059">.ini, configuration files 414</a> <a href="#bookmark608">.NET 21</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark957">2.0 52</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2752">extension methods 262</a> 3.5</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2753">attribute supporting</a> extension methods 262 <a href="#bookmark2772">extension methods in the</a> framework 265 <a href="#bookmark930">introduction of Func and</a> Action 50 <a href="#bookmark3042">SP1 293</a> <a href="#bookmark3494">4, observable interfaces 351</a> <a href="#bookmark611">Passport 21</a> <a href="#bookmark1218">‘ generics 89</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3081">* transparent identifiers 300</a> <a href="#bookmark3753">/l 385, </a><a href="#bookmark3990">409</a> <a href="#bookmark3746">/</font><font style="font-size:x-small;font-family:Times New Roman, serif;text-decoration:underline;">link</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> 385</font></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3747">/r 385</a></font></p>
<p><a name="bookmark444"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3748">/reference 385</a> <a href="#bookmark1515">&amp;&nbsp;operator 117</a> <a href="#bookmark2144">#pragma 194</a> <a href="#bookmark2159">checksum 195</a> <a href="#bookmark2151">warning 194</a> == operator</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1139">overloading and</a> generics 77 <a href="#bookmark1071">reference type</a> constraints 70 <a href="#bookmark1134">unconstrained type</a> parameters 77 <a href="#bookmark1074">value type constraints 70</a> <a href="#bookmark2479">=&gt; 230</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1516">| operator 117</a> </font><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">Numerics</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">64-bit processors 525</font></p>
<p><a name="bookmark4761"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">A</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3881">aborting threads 398</a> <a href="#bookmark1362">about:blank, comparison with</a> null references 104 <a href="#bookmark4087">abstract base class compared</a> with duck typing 418 <a href="#bookmark4475">abstract methods 467</a> <a href="#bookmark2095">abstract modifier, static</a> classes 188 <a href="#bookmark1031">abstraction 62</a> abuse</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4477">class inheritance 467</a> <a href="#bookmark4338">general-purpose extension</a> methods 455 <a href="#bookmark4525">academic license, Code</a> Contracts 472 <a href="#bookmark1850">access from nested types 159</a> access modifiers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2234">automatic properties 205</a> <a href="#bookmark2118">defaults 189</a> <a href="#bookmark2040">partial types 182</a> <a href="#bookmark2106">properties 189</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2240">accessors 205</a> Action<a href="#bookmark1685"> 139</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2470">Action delegate types 229</a> <a href="#bookmark1622">action delegates 133</a> <a href="#bookmark469">Active Record 3</a> <a href="#bookmark4002">ActiveSheet 409</a> actual type</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4177">dynamic binding 430</a> <a href="#bookmark1279">adapter pattern 94, </a><a href="#bookmark1289">96</a> Add 509</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3013">collection initializers 289</a> <a href="#bookmark2352">method 216-</a><a href="#bookmark2357">217</a> <a href="#bookmark3372">method on XContainer 340</a> <a href="#bookmark3892">add/remove blocks,</a> events 399 AddFirst 513</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4082">addition, implicit conversion</a> of operands 417 AddLast 513 <a href="#bookmark3799">AddRange 390</a> <a href="#bookmark1383">ADO.NET 106, </a>524 Aggregate 496 <a href="#bookmark2857">aggregation 273,</a><a href="#bookmark3328"> 336</a> operators 495 <a href="#bookmark622">ahead-of-time compilation 22</a> AJAX 524 <a href="#bookmark677">Albahari, Joe 24</a> <a href="#bookmark1593">aliases 128</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2289">alternative to implicit</a> typing 209 <a href="#bookmark2127">for namespaces and</a> types 190 <a href="#bookmark3847">aliasing, out parameters 395</a> All 505</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2980">AllDefects (and related</a> properties) 285 <a href="#bookmark4684">alpha geeks 492</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4693">Amazon EC2 492</a> ambiguity</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4155">dynamic conversions 427</a> <a href="#bookmark4098">dynamic typing 420</a> <a href="#bookmark3683">overloading 379</a> <a href="#bookmark2235">terminology 205</a> amortized complexity 510, 515 analysis</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3598">argument types 367</a> <a href="#bookmark3290">query translations 329</a> <a href="#bookmark3396">Ancestors 342</a> <a href="#bookmark3397">AncestorsAndSelf 342</a> <a href="#bookmark4690">Android 492</a> <a href="#bookmark1024">angle brackets 62, </a><a href="#bookmark1214">88</a> <a href="#bookmark1701">unspeakable names 140</a> <a href="#bookmark689">annotated specification 25</a> <a href="#bookmark3392">Annotations 342</a> <a href="#bookmark2273">anonymous functions 208,</a> <a href="#bookmark2464">229, </a><a href="#bookmark4169">429</a> <a href="#bookmark4762">better conversions 254</a> <a href="#bookmark2649">inferred return types 247</a> <a href="#bookmark2680">overloading 253</a> <a href="#bookmark506">anonymous methods 11</a><a href="#bookmark514">-12,</a> <a href="#bookmark921">50,</a><a href="#bookmark1681"> 138,</a><a href="#bookmark1962"> 172</a> <a href="#bookmark1740">ambiguity 144</a> <a href="#bookmark2429">anonymous types 224</a> <a href="#bookmark2387">as typeless expressions 219</a> <a href="#bookmark1742">capturing variables 144</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark1742">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>captured variables <a href="#bookmark2461">compared with lambda</a> expressions 229 <a href="#bookmark4197">dynamic code 433</a> <a href="#bookmark1725">ignoring parameters 143</a> <a href="#bookmark1689">lack of contravariance 140</a> <a href="#bookmark4763">prohibition on iterator</a> blocks 161 <a href="#bookmark2444">readability 227</a> <a href="#bookmark1712">returning values 141</a> <a href="#bookmark2638">type inference 246</a> <a href="#bookmark942">anonymous object</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark942">initializers 51, </a><a href="#bookmark2395">221</a> <a href="#bookmark937">anonymous types 51,</a><a href="#bookmark2390"> 220</a> <a href="#bookmark4764">conversion to XElement</a> and XAttribute 341 <a href="#bookmark3104">inner join keys 301</a> <a href="#bookmark3162">keys for grouping 311</a> <a href="#bookmark2818">projections 270</a> <a href="#bookmark2826">ToString 271</a> <a href="#bookmark3076">used for transparent</a> identifiers 299 Any 505</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Apache 2.0 license 527 <a href="#bookmark4587">API design 484, </a>514 <a href="#bookmark2597">API querying 243</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4313">APIs 453</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3427">designing to work with</a> LINQ 345 <a href="#bookmark3694">parameter names 379</a> applicable methods</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3680">overload resolution 378</a> <a href="#bookmark2681">overloading 253, </a><a href="#bookmark3686">379</a> <a href="#bookmark4765">application domains 81</a> <a href="#bookmark3711">Application, Word 381</a> <a href="#bookmark2007">Arbiter 177</a> <a href="#bookmark2912">architecture 279</a> <a href="#bookmark3806">AreaComparer 391</a> <a href="#bookmark3865">ArgumentException 397, </a><a href="#bookmark4490">469</a> <a href="#bookmark2770">ArgumentNullException 265,</a> <a href="#bookmark2899">277, </a><a href="#bookmark4340">455,</a><a href="#bookmark4383"> 457, </a><a href="#bookmark4582">483</a> ArgumentOutOfRange-Exception 499 <a href="#bookmark497">arguments 8,</a><a href="#bookmark593"> 20</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1036">comparing type and method</a> arguments 63 <a href="#bookmark2674">conversions to parameter</a> types 252 <a href="#bookmark4147">dynamic values 426</a> <a href="#bookmark2078">evaluation of partial</a> methods 186 <a href="#bookmark3655">evaluation order 374</a> <a href="#bookmark3579">terminology 366</a> <a href="#bookmark1106">type inference 74</a> <a href="#bookmark1976">validation 173,</a><a href="#bookmark2887"> 276</a> <a href="#bookmark1881">iterator blocks 164,</a><a href="#bookmark1978"> 174</a> <a href="#bookmark3548">validation in LINQ</a> operators 357 <a href="#bookmark4544">arithmetic obligations 477</a> <a href="#bookmark2628">arithmetic, generics 245</a> <a href="#bookmark4538">array bounds obligations 476</a> <a href="#bookmark477">ArrayList 5, </a><a href="#bookmark827">40,</a><a href="#bookmark969"> 53, </a><a href="#bookmark1184">84,</a><a href="#bookmark3033"> 292</a> <a href="#bookmark643">arrays 22, </a><a href="#bookmark815">40, </a><a href="#bookmark858">43,</a><a href="#bookmark2189"> 197, </a><a href="#bookmark2932">280, </a>511 CLR terminology 512 <a href="#bookmark821">covariance 40, </a><a href="#bookmark1261">92</a> <a href="#bookmark2378">implicit typing 219</a> <a href="#bookmark2327">populating with object</a> initializers 214 <a href="#bookmark825">ArrayTypeMismatchException</a> <a href="#bookmark825">40, </a>511 <a href="#bookmark1539">as operator 120</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3858">breaking changes 396</a> <a href="#bookmark4157">dynamic types 427</a> <a href="#bookmark809">ASCII 39</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">AsEnumerable 498 <a href="#bookmark3458">AsOrdered 349</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark653">ASP.NET 23,</a><a href="#bookmark2164"> 195,</a><a href="#bookmark3885"> 399, </a>523-524 <a href="#bookmark3445">AsParallel 347</a> AsQueryable 498 assemblies</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2402">anonymous types 221</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3739">COM 385</a> <a href="#bookmark4498">contract reference</a> assemblies 469 <a href="#bookmark2137">extern aliases 193</a> <a href="#bookmark666">references 23</a> <a href="#bookmark4455">rewriting, Code</a> Contracts 464 <a href="#bookmark2212">signing 200</a> <a href="#bookmark2213">AssemblyInfo.cs 200</a> <a href="#bookmark4397">Assert method, Code</a> <a href="#bookmark4397">Contracts 458, </a><a href="#bookmark4423">461</a> <a href="#bookmark4394">assertions 458, </a><a href="#bookmark4615">486</a> <a href="#bookmark4419">Code Contracts 461</a> <a href="#bookmark4503">error windows 470</a> <a href="#bookmark4600">failures 485, </a><a href="#bookmark4634">487</a> assignment</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2565">expression trees 239</a> <a href="#bookmark3898">field-like events 399</a> <a href="#bookmark2519">lambda expressions 234</a> <a href="#bookmark1109">unaffected by type</a> inference 74 <a href="#bookmark3252">associations, LINQ to SQL 323</a> <a href="#bookmark4398">Assume method, Code</a> <a href="#bookmark4398">Contracts 458, </a><a href="#bookmark4424">461</a> <a href="#bookmark1782">assumptions 149, </a><a href="#bookmark4616">486</a> <a href="#bookmark4420">Code Contracts 461</a> <a href="#bookmark3080">asterisk, transparent</a> identifiers 300 <a href="#bookmark3459">AsUnordered 349</a> asynchronous <a href="#bookmark4676">computation 491</a> <a href="#bookmark4766">delegate invocation 31</a> <a href="#bookmark3531">I/O 356</a> <a href="#bookmark1118">operations 76</a> <a href="#bookmark1988">service access 175</a> <a href="#bookmark3878">atomicity, locking 398</a> <a href="#bookmark3398">Attributes 342</a> <a href="#bookmark4237">attributes 437</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2754">extension methods 262</a> <a href="#bookmark571">LINQ to XML 18,</a><a href="#bookmark3347"> 338</a> <a href="#bookmark484">automatic properties 7,</a><a href="#bookmark2224"> 204</a><a href="#bookmark2236">205</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">builder pattern</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2375">implementation 219</a> <a href="#bookmark3673">encouraging mutability 376</a> <a href="#bookmark2508">lambda expression</a> examples 233 <a href="#bookmark3850">automatic variance 396</a> Average 495 <a href="#bookmark3393">axis methods, LINQ to</a> XML 342 <a href="#bookmark4681">Axum 492</a></font></p>
<p><a name="bookmark4767"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">B</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1217">back tick, generics 89</a> <a href="#bookmark4671">back-end technologies 491</a> <a href="#bookmark776">BackgroundWorker 35, </a>523 backing fields</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark487">automatically implemented</a> properties 7 <a href="#bookmark3897">field-like events 399</a> <a href="#bookmark2228">trivial properties 205</a> <a href="#bookmark4651">backward compatibility 491</a> <a href="#bookmark2285">balance, using implicitly typed</a> local variables 209 base types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2037">partial types 181</a> <a href="#bookmark2098">static classes 188</a> <a href="#bookmark1692">base, anonymous methods 140</a> <a href="#bookmark4556">baselines 478</a> <a href="#bookmark681">basic multilingual plane 25</a> <a href="#bookmark958">BCL 52</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4768">Beginlnvoke, delegate</a> method 31 <a href="#bookmark1123">BeginXXX 76</a> <a href="#bookmark4297">behavior 448</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2691">adding with inheritance 256</a> <a href="#bookmark3632">changes to optional parame</a>ter defaults 371 <a href="#bookmark4133">DLR rules 424</a> <a href="#bookmark701">encapsulated in delegates 28</a> <a href="#bookmark1821">behavioral patterns 156</a> <a href="#bookmark1543">benchmarks 121,</a><a href="#bookmark4769"> 347, </a><a href="#bookmark4638">488</a> <a href="#bookmark4770">best accessible type 430</a> <a href="#bookmark4493">best practices 469</a> <a href="#bookmark2679">better conversions 253</a> <a href="#bookmark2758">extension methods 263</a> Biglnteger 525 <a href="#bookmark1365">binary data 104</a> <a href="#bookmark1511">binary operators 117</a> <a href="#bookmark3836">binary representations 395</a> <a href="#bookmark4357">binary rewriter 456, </a><a href="#bookmark4395">458, </a><a href="#bookmark4444">463</a><a href="#bookmark4448">464, </a><a href="#bookmark4505">470</a> <a href="#bookmark2545">BinaryExpression 237</a> BinarySearch 511-512 <a href="#bookmark4125">binders 424-</a><a href="#bookmark4137">425</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4260">parameters to TryXXX</a> methods 444 <a href="#bookmark4286">BindGetMember 447</a> <a href="#bookmark962">binding 52, </a><a href="#bookmark3927">403, </a><a href="#bookmark4771">406, </a>513 <a href="#bookmark4091">explicit interface</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">implementation 419 <a href="#bookmark2576">expression tree</a> parameters 241 BindingList 513 <a href="#bookmark3702">black magic, COM 380</a> <a href="#bookmark4772">Bloch, Joshua 80</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2489">block, as a lambda expression</a> body 231 <a href="#bookmark2003">blocking, parallelism 176</a> BlockingCollection 518 <a href="#bookmark2564">blocks, expression trees in</a> .NET 4 239 <a href="#bookmark4685">blogs 492</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3659">blood spatter pattern 375</a> <a href="#bookmark1030">blueprints 62</a> <a href="#bookmark2490">body of a lambda</a> expression 231 <a href="#bookmark1934">boilerplate code 170</a> <a href="#bookmark1526">bool?, behavior of &amp;&nbsp;and |</a> operators 119 <a href="#bookmark1397">Boolean, flag indicating</a> nullity 106 <a href="#bookmark889">bottlenecks 46, </a><a href="#bookmark4637">488</a> <a href="#bookmark2662">bounds, type inference 249</a> <a href="#bookmark903">boxing 47,</a><a href="#bookmark1000"> 59, </a><a href="#bookmark1185">84,</a><a href="#bookmark1387"> 106, </a>510 <a href="#bookmark1193">avoiding in C# 1 85</a> <a href="#bookmark1018">Hashtable 61</a> Nullable<a href="#bookmark1435"> 110</a> <a href="#bookmark1589">using type constraints to</a> avoid 128 <a href="#bookmark1091">boxing conversions 71</a> <a href="#bookmark3838">invalid in generic</a> variance 395 <a href="#bookmark1706">braces 141, </a><a href="#bookmark4345">455</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4773">removing in lambda</a> expressions 231 <a href="#bookmark3693">breaking changes 379, </a><a href="#bookmark4652">491</a> <a href="#bookmark1796">capturing loop variables 151</a> <a href="#bookmark3855">caused by generic</a> variance 396 <a href="#bookmark4774">delegate variance 137</a> <a href="#bookmark3890">field-like events 399</a> <a href="#bookmark521">brevity 13</a> bridging</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2878">fluent interfaces 275</a> <a href="#bookmark4299">static and dynamic code 448</a> <a href="#bookmark857">browser 43</a> <a href="#bookmark2950">buffering 282, </a>495</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3555">custom LINQ operators 358</a> <a href="#bookmark3133">group joins 306</a> <a href="#bookmark3163">grouping 312</a> <a href="#bookmark3111">inner joins 302</a> <a href="#bookmark3468">Parallel LINQ 350</a> <a href="#bookmark2784">buffering data 267</a> <a href="#bookmark843">bugs 42,</a><a href="#bookmark3622"> 370, </a><a href="#bookmark3973">407,</a><a href="#bookmark4235"> 437, </a><a href="#bookmark4581">483</a> <a href="#bookmark1418">mutability 108</a> <a href="#bookmark3664">side effects and argument</a> ordering 375 <a href="#bookmark4622">build configurations 487</a> <a href="#bookmark2371">builder pattern 218</a> <a href="#bookmark3433">building blocks, concurrency</a> with Parallel LINQ 346</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3900">Burrows, Chris 399</a> <a href="#bookmark1979">business logic 174</a> <a href="#bookmark4052">business rules 413</a> <a href="#bookmark2121">Button, unqualified name</a> ambiguity 190 <a href="#bookmark3154">by, contextual keyword 311</a> <a href="#bookmark2714">byte arrays 258</a> <a href="#bookmark1364">byte, non-nullability 104</a> <a href="#bookmark1337">bytecode 100</a></font></p>
<p><a name="bookmark4775"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">C</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark698">C 28,</a><a href="#bookmark804"> 38</a> Co<a href="#bookmark4354"> 455</a> <a href="#bookmark693">C# 1 27</a> <a href="#bookmark2517">pain of sorting and</a> filtering 234 <a href="#bookmark690">C# team 25, </a><a href="#bookmark3862">396</a> <a href="#bookmark805">C++ 38,</a><a href="#bookmark1140"> 78, </a><a href="#bookmark1252">91</a> <a href="#bookmark1324">compilation model 99</a> <a href="#bookmark4642">const 488</a> <a href="#bookmark1319">templates 99</a> <a href="#bookmark1322">C++0x 99</a> <a href="#bookmark4254">caching 441</a> <a href="#bookmark4119">DLR 422</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2548">expression trees 237,</a><a href="#bookmark2609"> 244</a> <a href="#bookmark2521">lambda expressions 235</a> <a href="#bookmark4135">multi-level 425</a> <a href="#bookmark2581">Call 242, </a><a href="#bookmark4306">450</a> <a href="#bookmark4639">call site validation 488</a> <a href="#bookmark4140">call sites 425, </a><a href="#bookmark4171">429</a> <a href="#bookmark4123">DLR 423</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4532">precondition checking 473</a> <a href="#bookmark4476">callbacks 467</a> <a href="#bookmark2011">iterator execution flow 177</a> <a href="#bookmark3851">callers, affected by variance</a> changes 396 <a href="#bookmark3867">caller-specified variance 397</a> CallSite <a href="#bookmark4124">423</a> <a href="#bookmark4500">Call-site Requires</a> Checking 469 <a href="#bookmark3460">cancellation tokens 349, </a>519 Capacity 510</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1758">captured variables 145,</a><a href="#bookmark2463"> 229,</a> <a href="#bookmark3005">288</a> <a href="#bookmark1768">behavior 146</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1784">generating extra classes 149,</a> <a href="#bookmark1802">152</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1804">guidelines 153</a> <a href="#bookmark1777">lifetime 148</a> <a href="#bookmark1771">motivation 147</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark1744">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>anonymous methods <a href="#bookmark3145">Cartesian product 308</a> CAS 526</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4265">case sensitivity 445</a> <a href="#bookmark3203">LINQ queries 318</a> <a href="#bookmark4776">Cast 95,</a><a href="#bookmark3804"> 391, </a>497 casting 10,<a href="#bookmark806"> 39,</a><a href="#bookmark2277"> 209</a> <a href="#bookmark1741">anonymous methods 144</a> <a href="#bookmark3914">COM 402</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4046">dynamic types 413, </a><a href="#bookmark4080">417, </a><a href="#bookmark4194">433</a> <a href="#bookmark983">generics 58, </a><a href="#bookmark1290">96, </a><a href="#bookmark3816">393</a> <a href="#bookmark1542">is and as operators 121</a> <a href="#bookmark1339">Java generics 100</a> <a href="#bookmark1473">nullable types 113,</a><a href="#bookmark1521"> 119</a> <a href="#bookmark3950">Office APIs 404</a> <a href="#bookmark3684">overload resolution 379</a> <a href="#bookmark3764">reduced by PIA linking 386</a> <a href="#bookmark3792">reference conversions 389</a> to resolve overload <a href="#bookmark3688">ambiguity 379</a> <a href="#bookmark1016">with Hashtable 61</a> <a href="#bookmark4509">catching contract</a> violations 471 <a href="#bookmark2868">Catchphrase 274</a> <a href="#bookmark4362">cccheck 456, </a><a href="#bookmark4524">472</a> <a href="#bookmark4363">ccdocgen 456</a> <a href="#bookmark1984">CCR. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Concurrency and Coordination Runtime <a href="#bookmark4366">ccrefgen 456, </a><a href="#bookmark4497">469</a> <a href="#bookmark4361">ccrewrite 456</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3355">CDATA, LINQ to XML 338</a> <a href="#bookmark4001">Cells 409</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark465">ceremony 3, </a><a href="#bookmark480">5, </a><a href="#bookmark2347">216</a> <a href="#bookmark2840">chaining 272-</a><a href="#bookmark2855">273</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2702">extension methods 257,</a><a href="#bookmark2803"> 268</a> <a href="#bookmark2791">iterators 267</a> <a href="#bookmark3266">change tracking, LINQ to</a> SQL 325 <a href="#bookmark3482">Channel 9 351</a> <a href="#bookmark3731">Chars 383</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4553">checked context 478</a> <a href="#bookmark2161">checksum pragmas 195</a> <a href="#bookmark4679">CHESS 492</a> <a href="#bookmark3351">child content, LINQ to</a> XML 338 <a href="#bookmark4239">child elements 437</a> <a href="#bookmark1841">circular buffers 158, </a>517 <a href="#bookmark4022">Civilization IV 411</a> <a href="#bookmark4308">clarity 451</a> class</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark859">keyword 43</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1065">reference type constraints 69</a> <a href="#bookmark984">class hierarchy 58</a> <a href="#bookmark4627">class libraries 487</a> <a href="#bookmark3825">classes, lack of generic</a> variance 394 Clear 509 ClearItems 513</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark638">CLI 22,</a><a href="#bookmark1081"> 71,</a><a href="#bookmark1464"> 112,</a><a href="#bookmark3729"> 383</a> <a href="#bookmark1618">Click event 132</a> ClickOnce 523 Client Profile 524 <a href="#bookmark2419">cloning 223</a> <a href="#bookmark3378">LINQ to XML content 340</a> <a href="#bookmark1233">closed constructed types, speci</a>fying in reflection 90 <a href="#bookmark1032">closed types 63</a> <a href="#bookmark1221">generics 89</a> <a href="#bookmark4777">static fields 82</a> <a href="#bookmark1743">closures 144-</a><a href="#bookmark1747">145,</a><a href="#bookmark1815"> 155,</a><a href="#bookmark1939"> 170</a> <a href="#bookmark4694">cloud computing 493</a> <a href="#bookmark4778">CLR 20,</a><a href="#bookmark640"> 22,</a><a href="#bookmark929"> 50, </a><a href="#bookmark4779">84,</a><a href="#bookmark2180"> 196,</a><a href="#bookmark2220"> 203,</a> 511,525 <a href="#bookmark956">generic variance 52,</a><a href="#bookmark3826"> 394</a> <a href="#bookmark3883">handling thread aborts 398</a> <a href="#bookmark1536">non-involvement in lifted</a> operators 120 <a href="#bookmark3723">parameterized</a> properties 383 <a href="#bookmark888">size of references 45</a> <a href="#bookmark1439">support for nullable value</a> types 110 <a href="#bookmark3844">support for ref and out</a> parameters 395 <a href="#bookmark4152">CLR types, conversions to/</a> from dynamic 427 <a href="#bookmark4348">CLS compliance 455</a> <a href="#bookmark2346">clutter 215</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2287">code with explicit typing 209</a> <a href="#bookmark3760">CoClass 386</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Code Access Security 526 <a href="#bookmark2532">code as data 236</a> <a href="#bookmark4314">Code Contracts 453, </a><a href="#bookmark4520">472, </a>524 <a href="#bookmark4419">assertions 461</a> <a href="#bookmark4421">assumptions 461</a> <a href="#bookmark4566">automatic</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">documentation 480 <a href="#bookmark4558">baselines 478</a> <a href="#bookmark4464">contract inheritance 466</a> <a href="#bookmark4494">contract reference</a> assemblies 469 <a href="#bookmark4780">implicit obligations 475</a> <a href="#bookmark4407">invariants 459</a> <a href="#bookmark4427">legacy contracts 462</a> <a href="#bookmark4385">postconditions 458</a> <a href="#bookmark4370">preconditions 456</a> <a href="#bookmark4521">static checker 472</a> <a href="#bookmark1391">code generators 106,</a><a href="#bookmark2017"> 179-</a><a href="#bookmark2022">180,</a> <a href="#bookmark2049">183,</a><a href="#bookmark2133"> 192</a> <a href="#bookmark1597">code smells 129</a> <a href="#bookmark2167">CodeChecksumPragma 195</a> <a href="#bookmark2536">CodeDOM 236, </a><a href="#bookmark2561">239,</a><a href="#bookmark2589"> 242, </a><a href="#bookmark3945">403</a> <a href="#bookmark4116">CodeDomProvider 421</a> <a href="#bookmark2014">coding standards 178</a> <a href="#bookmark3506">cold observables 353</a> <a href="#bookmark3442">collation, results in Parallel</a> LINQ 346 <a href="#bookmark486">collection initializers 7,</a><a href="#bookmark2310"> 211,</a> <a href="#bookmark2342">215,</a><a href="#bookmark3010"> 289, </a><a href="#bookmark3908">401</a> <a href="#bookmark3671">encouraging mutability 376</a> <a href="#bookmark2509">lambda expression</a> examples 233 <a href="#bookmark2350">method 216-</a><a href="#bookmark2360">217</a> <a href="#bookmark2348">requirements 216</a> <a href="#bookmark2355">within object initializers 217</a> Collection&lt;T&gt; 513 <a href="#bookmark832">CollectionBase 41</a> <a href="#bookmark4781">collections 6,</a><a href="#bookmark985"> 58,</a><a href="#bookmark1056"> 68,</a><a href="#bookmark2928"> 280</a> <a href="#bookmark2343">populating with collection</a> initializers 215 <a href="#bookmark1722">sorting with custom</a> comparisons 142 <a href="#bookmark3645">colon, named arguments 372</a> <a href="#bookmark2433">columns, selecting in SQL</a> queries 225 <a href="#bookmark587">COM 19,</a><a href="#bookmark2262"> 207,</a><a href="#bookmark3700"> 380, </a><a href="#bookmark3913">402</a> <a href="#bookmark4127">handling in C# binder 424</a> <a href="#bookmark3724">parameterized</a> properties 383 <a href="#bookmark3737">Primary Interop</a> Assemblies 385 <a href="#bookmark752">Combine 33,</a><a href="#bookmark1605"> 131</a> <a href="#bookmark3863">generic variance 396</a> <a href="#bookmark749">combining delegates 33</a> <a href="#bookmark1096">combining type constraints 73</a> <a href="#bookmark3755">ComImport 386</a> <a href="#bookmark2138">command line 193</a> <a href="#bookmark3752">command line options, linking</a> PIAs 385 commas</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1025">separating type</a> parameters 62 <a href="#bookmark1213">used to indicate number of</a> type parameters 88 <a href="#bookmark845">comments 42,</a><a href="#bookmark3642"> 372</a> <a href="#bookmark639">Common Language Infrastruc</a><a href="#bookmark639">ture. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> CLI <a href="#bookmark4782">Common Language Runtime.</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> CLR <a href="#bookmark4645">communication 489</a> <a href="#bookmark4322">Code Contracts 453</a> <a href="#bookmark3648">named arguments 373</a> <a href="#bookmark975">community 54,</a><a href="#bookmark2018"> 180, </a><a href="#bookmark4100">420</a> <a href="#bookmark2881">debate over extension</a> methods 275 <a href="#bookmark1440">influence over CLR boxing</a> behavior 110 <a href="#bookmark1303">scientific developers 97</a> <a href="#bookmark3573">uptake of LINQ 361</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Compact Framework 526 <a href="#bookmark649">compact profile 22</a> <a href="#bookmark1705">compactness 140</a> <a href="#bookmark1581">Compare 126</a> <a href="#bookmark3896">CompareExchange 399</a> Comparer<a href="#bookmark1147"> 78</a>,<a href="#bookmark3829"> 394</a> Comparer.Defaul<a href="#bookmark1456">t 112,</a><a href="#bookmark3565"> 358</a> <a href="#bookmark1127">CompareTo 76,</a><a href="#bookmark2522"> 235</a> Comparison<a href="#bookmark1720"> 142</a>,<a href="#bookmark2513"> 233</a> <a href="#bookmark4440">purity 463</a> <a href="#bookmark1575">comparisons 126</a> <a href="#bookmark2828">for sorting 271</a> <a href="#bookmark3201">LINQ query operators 318</a> <a href="#bookmark539">nullable types 14</a> <a href="#bookmark1066">reference type constrained</a> values 70 compatibility</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark718">delegate types and</a> <a href="#bookmark718">methods 29,</a><a href="#bookmark1671"> 137</a> <a href="#bookmark1272">generic variance 93</a> <a href="#bookmark1628">method group</a> conversions 133 <a href="#bookmark918">method signatures and</a> delegates 49 <a href="#bookmark1374">compilation errors 105</a> <a href="#bookmark810">invalid casts 39</a> <a href="#bookmark2559">compilation, expression</a> <a href="#bookmark2559">trees 238,</a><a href="#bookmark2613"> 244</a> <a href="#bookmark2554">Compile 238, </a>498 <a href="#bookmark2555">Compile method,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">LambdaExpression 238 <a href="#bookmark801">compile time 38</a> <a href="#bookmark3928">binding 403</a> <a href="#bookmark4321">contract checking 453</a> <a href="#bookmark624">compiler 22,</a><a href="#bookmark1901"> 167,</a><a href="#bookmark3812"> 392</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark961">binding with dynamic types</a> in C# 4 52 <a href="#bookmark1482">code generated using nul</a>lable types 115 <a href="#bookmark2031">combining source for partial</a> types 181 <a href="#bookmark3751">command line for linking</a> PIAs 385 <a href="#bookmark2570">creating strongly typed</a> expression trees 239 <a href="#bookmark3114">detecting key selector</a> reversal 303 <a href="#bookmark3981">embedded for dynamic</a> typing 408 <a href="#bookmark4184">errors on dynamic code 432</a> <a href="#bookmark2136">extern aliases 193</a> <a href="#bookmark3323">ignorance of Enumerable</a> and Queryable 334 <a href="#bookmark1786">implementation of anony</a>mous methods 149</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2178">implementation of fixed-size</a> buffers 196 <a href="#bookmark2221">importance in C# 3</a> features 204 <a href="#bookmark3643">inability to verify</a> comments 372 <a href="#bookmark4662">pipeline 491</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark989">providing more information</a> via casts 58 <a href="#bookmark2073">removing unimplemented</a> partial methods 185 <a href="#bookmark917">role in delegate features 49</a> <a href="#bookmark2583">shortcut for obtaining a</a> MethodInfo 242 <a href="#bookmark2321">support for object</a> initializers 213 translations</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">demonstration with a</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3008">dummy provider 288</a> <a href="#bookmark2916">query expressions 280,</a> <a href="#bookmark2994">287</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3849">verifying variance 396</a> <a href="#bookmark1679">warnings 138,</a><a href="#bookmark1694"> 140</a> <a href="#bookmark4659">compiler as a service 491</a> <a href="#bookmark3757">CompilerGeneratedAttribute</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">386</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">compile-time checking</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1003">generics and static typing 59</a> <a href="#bookmark2601">limitations 244</a> <a href="#bookmark2592">LINQ queries 243</a> <a href="#bookmark3011">compile-time duck typing 289</a> <a href="#bookmark1200">compile-time efficiency 87</a> <a href="#bookmark4182">compile-time errors 431</a> <a href="#bookmark829">compile-time type safety 40</a> <a href="#bookmark478">compile-time types 5,</a><a href="#bookmark790"> 37, </a><a href="#bookmark2276">208</a> <a href="#bookmark4180">dynamic binding 431</a> <a href="#bookmark2385">implicitly typed arrays 219</a> <a href="#bookmark1305">Complex 97, </a>525 <a href="#bookmark1809">complexity 154, </a><a href="#bookmark4461">465, </a><a href="#bookmark4657">491</a> <a href="#bookmark1255">language design choices 92,</a> <a href="#bookmark2388">220</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2964">new C# features 284</a> <a href="#bookmark3532">reducing with LINQ to</a> Rx 356 <a href="#bookmark4783">ComplexNumber 97</a> <a href="#bookmark3705">compliance, C# 4</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">specification 380 <a href="#bookmark580">Component Object Model.</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> COM <a href="#bookmark4630">component vendors 487</a> <a href="#bookmark549">composition 16,</a><a href="#bookmark2612"> 244,</a><a href="#bookmark2837"> 272</a> <a href="#bookmark4429">compound contracts 462</a> compression 523 <a href="#bookmark1765">computer science 145, </a><a href="#bookmark4673">491</a> <a href="#bookmark900">defining pass by</a> reference 46</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4329">formal specification and</a> verification 454 <a href="#bookmark3800">Concat 390, </a>496</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark757">(strings) comparison with</a> Delegate.Combine 33 <a href="#bookmark869">concatenation 44</a> concatenation operator 496 <a href="#bookmark1323">concepts, C++ 99</a> <a href="#bookmark1992">concurrency 175</a> collections 508, 519 <a href="#bookmark3434">programming 346</a> <a href="#bookmark1985">Concurrency and Coordina</a>tion Runtime 175 ConcurrentDictionary 514, 519 <a href="#bookmark2756">conditional code 263</a> <a href="#bookmark1531">conditional logical</a> operators 119 <a href="#bookmark1471">conditional operator 113,</a><a href="#bookmark1550"> 122,</a> <a href="#bookmark1586">127</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3933">confidence 403</a> <a href="#bookmark4016">configuration 411,</a><a href="#bookmark4049"> 413</a> <a href="#bookmark4055">active via the DLR 414</a> <a href="#bookmark3264">connection management,</a> LINQ to SQL 325 <a href="#bookmark488">consistency 7,</a><a href="#bookmark1710"> 141,</a><a href="#bookmark2042"> 182, </a><a href="#bookmark3856">396,</a> <a href="#bookmark4585">484</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark553">LINQ 16,</a><a href="#bookmark2771"> 265, </a><a href="#bookmark2955">284</a> <a href="#bookmark3198">naming conventions 318</a> <a href="#bookmark2984">console 286</a> <a href="#bookmark3619">const 369</a> <a href="#bookmark4643">C++ 488</a> <a href="#bookmark3311">Constant 332</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1326">constant expressions, C++ tem</a>plate arguments 99 <a href="#bookmark3312">Constant, method of</a> Expression 332 <a href="#bookmark544">constants 15</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3612">default parameter values 368</a> <a href="#bookmark2363">unchanging collections 218</a> <a href="#bookmark1067">constrained type</a> parameters 70 constraints <a href="#bookmark4209">dynamic 434</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1059">generic type constraints 69</a> <a href="#bookmark1028">constructed types 62, </a><a href="#bookmark1212">88</a> <a href="#bookmark4591">construction, preconditions for</a> immutable types 484 <a href="#bookmark1077">constructor type constraints 70</a> <a href="#bookmark2304">constructors 211, </a><a href="#bookmark4253">441</a> <a href="#bookmark2412">anonymous types 223</a> <a href="#bookmark2092">default provided by</a> compiler 187 <a href="#bookmark1082">discrepancy between C# and</a> CLI 71 <a href="#bookmark4202">dynamic code 434</a> constructors </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">(continued) </font><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4159">dynamic invocation 428</a> <a href="#bookmark1077">generic type constraints 70</a> <a href="#bookmark1040">generic types 64</a> <a href="#bookmark3668">immutable types 376</a> <a href="#bookmark2298">implicitly typed local</a> variables 210 <a href="#bookmark2331">multiple parameters causing</a> confusion 214 of Nullable<a href="#bookmark1411"> 107</a> <a href="#bookmark2325">shorthand with object</a> initializers 213 <a href="#bookmark2312">using arguments for</a> initialization 211 <a href="#bookmark2089">utility classes 187</a> <a href="#bookmark4784">XElement 340</a> Contains 505, 509 context</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1763">in anonymous methods 145</a> <a href="#bookmark3022">propagated with range</a> variables 290 <a href="#bookmark560">contextual keywords 16,</a><a href="#bookmark3020"> 290</a> <a href="#bookmark3968">dynamic 406</a> <a href="#bookmark2033">partial 181</a> <a href="#bookmark1063">type constraints 69</a> <a href="#bookmark2005">continuation-passing style 176</a> continuations <a href="#bookmark3178">multiple 316</a> <a href="#bookmark3168">query continuations 314</a> <a href="#bookmark4785">ContinueWith 175</a> <a href="#bookmark4560">continuous build 479</a> Contract class</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4360">Code Contracts 456</a> <a href="#bookmark4396">last reference marking end of</a> contracts 458 <a href="#bookmark4480">contract classes, abstract classes</a> and interfaces 467 <a href="#bookmark4382">contract failure handlers 457</a> <a href="#bookmark4786">contract inheritance 466</a> <a href="#bookmark4364">contract reference</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4364">assemblies 456, </a><a href="#bookmark4441">463, </a><a href="#bookmark4495">469,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4606">486</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4446">contract section 464</a> <a href="#bookmark4481">ContractClass 467</a> <a href="#bookmark4482">ContractClassFor 467</a> <a href="#bookmark4381">ContractException 457, </a><a href="#bookmark4457">465,</a> <a href="#bookmark4507">470, </a><a href="#bookmark4570">482, </a><a href="#bookmark4601">485</a> <a href="#bookmark4595">catching in unit tests 485</a> <a href="#bookmark4510">ContractFailed 471, </a><a href="#bookmark4599">485</a> <a href="#bookmark4512">ContractFailedEventArgs 471</a> <a href="#bookmark4411">ContractInvariantMethod-</a>Attribute 460 <a href="#bookmark4787">ContractPublicPropertyName-</a>Attribute 457 <a href="#bookmark4516">contracts runtime 472</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4451">CONTRACTS_FULL 464</a> CONTRACTS.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4449">PRECONDITIONS 464</a> <a href="#bookmark4788">__ContractsRuntime 465</a> <a href="#bookmark4561">ContractVerificationAttribute</a> 479</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1533">contradictory behavior, opera</a>tors on nullable types 120 <a href="#bookmark955">contravariance 52, </a><a href="#bookmark1282">95,</a><a href="#bookmark3778"> 388</a> <a href="#bookmark1688">anonymous methods 140</a> <a href="#bookmark922">delegates 50,</a><a href="#bookmark1608"> 131,</a><a href="#bookmark1642"> 134</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark1614">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>delegates, contra-variance IObserver <a href="#bookmark3496">351</a> <a href="#bookmark3818">nesting 394</a> <a href="#bookmark840">parameters 41</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark954">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>generic variance <a href="#bookmark1638">contravariance, C# 2 134</a> <a href="#bookmark2859">controversy, extension</a> methods 273 <a href="#bookmark3805">convenience 391</a> conventions</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4483">class contract names 468</a> <a href="#bookmark1659">event handling 136</a> <a href="#bookmark3196">lambda expression</a> parameters 317 <a href="#bookmark2893">namespaces and extension</a> methods 276 <a href="#bookmark1044">type parameter names 65</a> <a href="#bookmark1703">unspeakable names 140</a> conversion operators 496 <a href="#bookmark1086">conversion type constraints 71</a> <a href="#bookmark1093">restrictions 72</a> <a href="#bookmark1293">working around</a> invariance 96 conversions</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2678">&quot;better than&quot; other</a> conversions 253 <a href="#bookmark3685">argument types to parameter</a> types 379 <a href="#bookmark1086">generic type constraints 71</a> <a href="#bookmark3827">generic variance support in</a> the CLR 394 <a href="#bookmark4044">GetVariable 413</a> <a href="#bookmark2682">involving anonymous</a> functions 253 <a href="#bookmark3413">LINQ to XML 343</a> <a href="#bookmark2644">method groups and</a> overloading 246 <a href="#bookmark1485">Nullable&lt;T&gt;</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Nullable <a href="#bookmark2943">projections in LINQ 282</a> <a href="#bookmark4304">Convert 450</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1048">ConvertAll 65,</a><a href="#bookmark1055"> 67, </a><a href="#bookmark1278">94,</a><a href="#bookmark2427"> 224,</a><a href="#bookmark2816"> 270,</a> 511-512 <a href="#bookmark3814">Converter&lt;TInput, TOutput&gt;</a> variance 393 <a href="#bookmark1989">coordination 175-</a><a href="#bookmark2001">176</a> <a href="#bookmark1277">copying collections, work</a>around for limitations in generics 94 <a href="#bookmark906">copying values, boxing 47</a> <a href="#bookmark855">copying, value type and refer</a>ence type behavior 43 <a href="#bookmark853">copyright 43</a> <a href="#bookmark2717">CopyTo 258, </a>509 CoreCLR 527</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark606">corner cases 21,</a><a href="#bookmark1927"> 170, </a><a href="#bookmark4492">469, </a><a href="#bookmark4592">485</a> <a href="#bookmark2012">coroutines 178</a> <a href="#bookmark992">correctness 59</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4319">Code Contracts 453</a> <a href="#bookmark4527">contracts 473</a> <a href="#bookmark3137">Count 307, </a><a href="#bookmark4789">358, </a>495, 509 property of ICollection and ICollection&lt;T&gt; <a href="#bookmark4089">418</a> <a href="#bookmark3283">count with SQL for joins 328</a> <a href="#bookmark953">covariance 52, </a><a href="#bookmark1262">92,</a><a href="#bookmark3776"> 388</a> arrays 511</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark925">delegates 50,</a><a href="#bookmark1609"> 131,</a><a href="#bookmark1643"> 134</a> IObservable <a href="#bookmark3495">351</a> <a href="#bookmark822">of arrays 40</a> <a href="#bookmark833">return types 41</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark951">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>generic variance;<a href="#bookmark1610"> </a>delegates, covariance <a href="#bookmark1178">CPU, cost ofJIT</a> compilation 83 <a href="#bookmark3465">CPU-bounded tasks 350</a> CreateInstance 512 <a href="#bookmark3303">CreateQuery, method of</a> IQueryProvider 330 <a href="#bookmark3139">cross joins 308</a> <a href="#bookmark4175">CSharpArgumentInfo 430</a> <a href="#bookmark3946">CSharpCodeProvider 403</a> <a href="#bookmark4668">CSS 491</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2886">cultural issues 275</a> <a href="#bookmark3226">culture 321</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1192">Current 85,</a><a href="#bookmark1835"> 157,</a><a href="#bookmark1871"> 162,</a><a href="#bookmark1879"> 164,</a><a href="#bookmark1909"> 168,</a> <a href="#bookmark2948">282,</a><a href="#bookmark3500"> 352</a> <a href="#bookmark1833">cursor iterators 157</a> <a href="#bookmark3560">custom comparisons 358</a> <a href="#bookmark3200">LINQ query operators 318</a> <a href="#bookmark1195">custom iteration types 85</a> <a href="#bookmark4598">custom rewriter methods 485</a> <a href="#bookmark4514">Code Contracts 472</a> <a href="#bookmark2358">cyclic relationships 217</a></font></p>
<p><a name="bookmark4790"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">D</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2985">data binding 286, </a><a href="#bookmark4067">415, </a>513, 523 <a href="#bookmark3250">Data Connections, Visual</a> <a href="#bookmark3250">Studio 323</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3263">data contexts, LINQ to</a> SQL 325 <a href="#bookmark569">data extraction, XML 18</a> <a href="#bookmark2986">data grids 286</a> <a href="#bookmark3055">data integrity 296</a> <a href="#bookmark2926">data models, LINQ 280</a> <a href="#bookmark1825">data pipelines 156</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2482">lambda expressions 230</a> <a href="#bookmark2805">data processing, pipelines of</a> extension methods 268 data sources <a href="#bookmark2956">consistency 284</a> <a href="#bookmark550">LINQ 16,</a><a href="#bookmark2445"> 228</a> <a href="#bookmark4674">data structures 491</a> <a href="#bookmark885">data transfer types 45</a> <a href="#bookmark566">databases 17-</a><a href="#bookmark572">18,</a><a href="#bookmark1994"> 175,</a><a href="#bookmark2432"> 225, </a><a href="#bookmark4791">228,</a> <a href="#bookmark2842">272,</a><a href="#bookmark3219"> 320,</a><a href="#bookmark3236"> 322</a> <a href="#bookmark3086">joins 301</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark530">nullable fields 14,</a><a href="#bookmark970"> 53,</a><a href="#bookmark1366"> 105</a> <a href="#bookmark4018">rules engines 411</a> <a href="#bookmark3260">DataContext 325</a> <a href="#bookmark2785">DataReader 267</a> <a href="#bookmark2786">DataSet 267</a> <a href="#bookmark3381">dates, LINQ to XML</a> content 340 <a href="#bookmark884">DateTime 45,</a><a href="#bookmark1130"> 76,</a><a href="#bookmark1420"> 108,</a><a href="#bookmark3412"> 343</a> <a href="#bookmark1353">non-nullability 104</a> <a href="#bookmark1129">DateTime.MinValue 76</a> <a href="#bookmark1372">magic value pattern 105</a> DateTimeOffset 522, 524 <a href="#bookmark3135">DateTimeRange 306</a> <a href="#bookmark1384">DBNull 106</a> <a href="#bookmark3882">deadlocks 398</a> <a href="#bookmark4343">debug builds, assertions 455</a> <a href="#bookmark4342">Debug.Assert 455, </a><a href="#bookmark4426">461, </a><a href="#bookmark4580">483</a> <a href="#bookmark2162">debugger 195, </a><a href="#bookmark4281">446, </a><a href="#bookmark4602">485</a> <a href="#bookmark4792">debugging 213, </a><a href="#bookmark4021">411, </a><a href="#bookmark4506">470</a> <a href="#bookmark531">decimal 14</a> declarations</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2270">implicitly typed local</a> variables 208 <a href="#bookmark1562">out parameters 124</a> <a href="#bookmark4793">partial methods 186</a> <a href="#bookmark4211">using dynamic 434</a> <a href="#bookmark3979">var and dynamic 408</a> <a href="#bookmark3221">declarative style 320</a> <a href="#bookmark4352">contracts 455</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3368">LINQ to XML construction</a> pattern 340 <a href="#bookmark558">programming 16</a> <a href="#bookmark4161">decompilation 428</a> deep zoom 527 <a href="#bookmark1457">Default (Equality-</a>Comparer&lt;T&gt; <a href="#bookmark1457">property) 112,</a><a href="#bookmark3564"> 358</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2092">default constructors 187</a> <a href="#bookmark1412">Nullable&lt;T&gt; 107</a> <a href="#bookmark3730">default members 383</a> <a href="#bookmark4077">default operator 417</a> <a href="#bookmark4488">contract classes 468</a> <a href="#bookmark3616">optional parameters 368</a> <a href="#bookmark3727">default properties 383</a> <a href="#bookmark1112">default value expressions 75</a> <a href="#bookmark525">default values 14-</a><a href="#bookmark541">15,</a><a href="#bookmark3615"> 368</a> <a href="#bookmark2250">fields in structs 206</a> <a href="#bookmark3587">optional parameters 366</a> <a href="#bookmark3610">restrictions 368</a> specifying for <a href="#bookmark3595">parameters 367</a> <a href="#bookmark1112">default(T) 75</a> DefaultIfEmpty 500 defaulting</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1555">null coalescing operator 123</a> defaults</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2117">private access modifiers 189</a> <a href="#bookmark2854">defect tracking 273,</a><a href="#bookmark2971"> 285</a> <a href="#bookmark4635">defensive code 488</a> <a href="#bookmark2938">deferred execution 282, </a>495 <a href="#bookmark3556">custom LINQ operators 358</a> <a href="#bookmark1006">definite assignment 60,</a><a href="#bookmark3846"> 395</a> <a href="#bookmark1117">output parameters 76</a> <a href="#bookmark3052">degenerate query</a> expressions 295 <a href="#bookmark3463">degree of parallelism 349</a> <a href="#bookmark714">Delegate 29</a> delegate</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark712">ambiguity of term 29</a> <a href="#bookmark508">keyword 11, </a><a href="#bookmark864">43,</a><a href="#bookmark1686"> 140,</a><a href="#bookmark1728"> 143</a> <a href="#bookmark1621">delegate creation</a> expressions 133 <a href="#bookmark1668">variance 137</a> <a href="#bookmark708">delegate instances 28</a> <a href="#bookmark2520">caching 235</a> <a href="#bookmark3001">LINQ 288</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1780">referring to captured</a> variables 148 <a href="#bookmark1725">delegate parameters 143</a> <a href="#bookmark705">delegate types 28, </a><a href="#bookmark863">43</a> <a href="#bookmark2470">Action&lt;... &gt;&nbsp;229</a> <a href="#bookmark2683">conversions involving anony</a>mous functions 254 <a href="#bookmark2558">expression trees 238</a> <a href="#bookmark2465">Func&lt;...&gt; 229</a> <a href="#bookmark505">delegates 10, </a><a href="#bookmark644">22,</a><a href="#bookmark694"> 28,</a><a href="#bookmark3317"> 334</a> <a href="#bookmark723">action 30</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1940">alternative approach to</a> iteration 170 <a href="#bookmark1681">anonymous methods. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See </font><font style="font-size:x-small;font-family:Times New Roman, serif;">anonymous methods <a href="#bookmark4794">asynchronous invocation 31</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1599">C# 2 130</a> <a href="#bookmark749">combining 33</a> <a href="#bookmark1672">compatibility 137</a> <a href="#bookmark719">in C# 1 30</a> <a href="#bookmark919">in C# 2 49</a> <a href="#bookmark2550">compiling from expression</a> trees 238 <a href="#bookmark923">constructing with lambda</a> expressions 50 <a href="#bookmark1611">contravariance, C# 2 131,</a> <a href="#bookmark1638">134-</a><a href="#bookmark1658">135</a> <a href="#bookmark1613">covariance, C# 2 131,</a><a href="#bookmark1638"> 134,</a> <a href="#bookmark1664">136</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark765">exceptions 34</a> <a href="#bookmark4225">ExpandoObject 436</a> <a href="#bookmark771">field-like events 34</a> <a href="#bookmark731">garbage collection 30</a> <a href="#bookmark1052">generic 66</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3766">generic variance 387,</a><a href="#bookmark3809"> 392</a> <a href="#bookmark753">immutability 33</a> <a href="#bookmark2447">in process data</a> processing 228 <a href="#bookmark1814">increased use in .NET</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">2.0 154 <a href="#bookmark706">invocation 28,</a><a href="#bookmark733"> 31,</a><a href="#bookmark1607"> 131</a> <a href="#bookmark755">invocation list 33</a> <a href="#bookmark4795">invoking asynchronously 31</a> <a href="#bookmark2940">LINQ 282</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark758">meaning of combining</a> null 33 <a href="#bookmark1053">method group</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1053">conversions 67,</a><a href="#bookmark4796"> 133</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark4797">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>method group conversions <a href="#bookmark746">motivation 32</a> <a href="#bookmark1938">option for iteration</a> pattern 170 <a href="#bookmark764">order of execution 34</a> <a href="#bookmark750">removing 33</a> <a href="#bookmark778">summary of C# 1 35</a> <a href="#bookmark727">target 30, </a><a href="#bookmark745">32</a> delegates, contravariance <a href="#bookmark1614">C# 2 131,</a><a href="#bookmark1648"> 135</a> delegates, covariance <a href="#bookmark1610">C# 2 131,</a><a href="#bookmark1639"> 134,</a><a href="#bookmark1663"> 136</a> <a href="#bookmark4056">Dependency Injection 414</a> <a href="#bookmark594">deployment 20</a> <a href="#bookmark2903">deprecation 277</a> Dequeue 517</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark877">derivation, reference types and</a> value types 45 <a href="#bookmark2436">derived data, anonymous</a> types 225 <a href="#bookmark3401">DescendantNodes 343</a> <a href="#bookmark3402">DescendantNodesAndSelf 343</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3399">Descendants 342</a> <a href="#bookmark3400">DescendantsAndSelf 342</a> <a href="#bookmark3060">descending, contextual</a> keyword 296 <a href="#bookmark4072">deserialization 415</a> <a href="#bookmark1416">design 108,</a><a href="#bookmark4798"> 161</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4478">class inheritance 467</a> <a href="#bookmark1973">LINQ 173</a> <a href="#bookmark3424">LINQ to XML 345</a> <a href="#bookmark3734">named indexers 384</a> <a href="#bookmark2103">static classes 188</a> <a href="#bookmark3903">variance 400</a> <a href="#bookmark4576">Design by Contract 483</a> <a href="#bookmark1822">design patterns 156</a> designers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2024">code generation 180</a> <a href="#bookmark3245">LINQ to SQL 323</a> desktop framework 521 <a href="#bookmark658">development platforms 23</a> <a href="#bookmark3472">DevLabs 350, </a><a href="#bookmark4372">456</a> <a href="#bookmark3253">diagrams, LINQ to SQL</a> models 323 <a href="#bookmark1450">dictionaries, using nullable</a> keys 111 Dictionary<a href="#bookmark1007"> 60</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Dictionary&lt;TKey, TValue&gt; 514 <a href="#bookmark2351">collection initializers 216</a> <a href="#bookmark1017">DictionaryEntry 61</a> <a href="#bookmark4274">dir, Python 445</a> <a href="#bookmark2157">disabling warnings 195</a> <a href="#bookmark4093">dispatch, single and</a> multiple 419 <a href="#bookmark618">Dispose 22, </a><a href="#bookmark1204">87,</a><a href="#bookmark1896"> 167,</a><a href="#bookmark1947"> 171</a> <a href="#bookmark4799">invariants 460</a> Distinct 506</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3441">distribution, tasks in Parallel</a> LINQ 346 <a href="#bookmark4548">division by zero 477</a> <a href="#bookmark585">DLR 19, </a><a href="#bookmark963">53, </a><a href="#bookmark3919">402, </a><a href="#bookmark4107">421</a> <a href="#bookmark4012">interoperability 410</a> <a href="#bookmark2607">using expression trees 244</a> <a href="#bookmark3366">document model, LINQ to</a> XML 339 <a href="#bookmark4229">Document Object Model 436</a> <a href="#bookmark4271">documentation 445</a> <a href="#bookmark4564">Code Contracts 480</a> collection mutability 514 <a href="#bookmark3551">custom LINQ operators 358</a> <a href="#bookmark830">for weakly typed collection</a> usage 40 <a href="#bookmark4332">informal contracts 454</a> <a href="#bookmark3095">joins 301</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2897">null first parameters for</a> extension methods 277 <a href="#bookmark990">type safety 59</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3364">DocumentElement 338</a> <a href="#bookmark3361">documents, LINQ to XML 338</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3359">DOM 338, </a><a href="#bookmark4227">436</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2869">domain specific languages 274,</a> <a href="#bookmark3955">405</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3186">dot notation 317,</a><a href="#bookmark3271"> 326, </a><a href="#bookmark3389">341</a> <a href="#bookmark3206">advantages over query</a> expressions 318 double buffering 523 <a href="#bookmark1379">double, special values 106</a> doubly linked list 512 <a href="#bookmark4279">drill down 446</a> <a href="#bookmark2874">DSLs. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> domain specific languages <a href="#bookmark3486">duality, LINQ to Rx 351</a> <a href="#bookmark468">duck typing 3,</a><a href="#bookmark4800"> 210,</a><a href="#bookmark3012"> 289, </a><a href="#bookmark3952">404,</a> <a href="#bookmark4085">418</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3431">Duffy, Joe 346</a> duplicate keys 497 duplicates 506 <a href="#bookmark1578">duplication 126</a> <a href="#bookmark3592">overloading 367</a> <a href="#bookmark2862">Dyer, Wes 274</a> <a href="#bookmark601">dynamic 20, </a><a href="#bookmark3910">401, </a><a href="#bookmark3961">405</a> <a href="#bookmark4005">COM variants 409</a> <a href="#bookmark4145">compiler behavior 426</a> <a href="#bookmark960">contextual keyword 52</a> <a href="#bookmark4216">dynamic behavior 435</a> <a href="#bookmark4244">dynamic calls,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">DynamicObject 440 <a href="#bookmark4187">dynamic code restrictions 432</a> <a href="#bookmark595">dynamic contextual</a> keyword 20 <a href="#bookmark4156">dynamic expressions,</a> conversions 427 <a href="#bookmark584">Dynamic Language Runtime.</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> DLR <a href="#bookmark461">dynamic languages 3,</a><a href="#bookmark583"> 19, </a><a href="#bookmark4656">491</a> <a href="#bookmark4009">interoperating with C# 4 410</a> <a href="#bookmark1310">dynamic methods 98</a> <a href="#bookmark467">dynamic typing 3,</a><a href="#bookmark596"> 20,</a><a href="#bookmark792"> 37,</a><a href="#bookmark959"> 52,</a> <a href="#bookmark2258">207, </a><a href="#bookmark2611">244</a> <a href="#bookmark1242">alternative to reflection 91</a> <a href="#bookmark3948">benefits 404</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2563">expression tree support 239</a> <a href="#bookmark4092">gotchas 419</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4218">responding dynamically 435</a> <a href="#bookmark1313">working around limitations</a> in generics 98 <a href="#bookmark4282">Dynamic View, Visual Studio</a> debugger 446 <a href="#bookmark4801">DynamicAttribute 405, </a><a href="#bookmark4212">435</a> <a href="#bookmark4278">DynamicMetaObject 445-</a><a href="#bookmark4284">446</a> <a href="#bookmark4114">DynamicMethod 421, </a>525 <a href="#bookmark4242">DynamicObject 440</a></font></p>
<p><a name="bookmark4802"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">E</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2792">eager evaluation 267</a> <a href="#bookmark4803">early out, iterator blocks 165</a> <a href="#bookmark688">ECMA 25, </a><a href="#bookmark1165">81</a> <a href="#bookmark473">e-commerce 4</a> <a href="#bookmark4804">Effective Java 80</a> <a href="#bookmark2951">efficiency 282</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3794">generic variance 389</a> <a href="#bookmark3540">standard query</a> operators 357 <a href="#bookmark4328">Eiffel 454</a> <a href="#bookmark2879">Eini, Oren 275</a> <a href="#bookmark844">elegance 42,</a><a href="#bookmark3542"> 357, </a><a href="#bookmark4103">420</a> element operators 498 ElementAt 499 <a href="#bookmark3403">Elements 343</a> <a href="#bookmark4238">elements 437</a> <a href="#bookmark3356">LINQ to XML 338</a> <a href="#bookmark3404">ElementsAfterSelf 343</a> <a href="#bookmark3405">ElementsBeforeSelf 343</a> <a href="#bookmark3297">ElementType, property of</a> IQueryable 330 <a href="#bookmark671">ellipsis in code snippets 23</a> <a href="#bookmark3440">embarrassingly parallel</a> tasks 346 <a href="#bookmark3991">Embed Interop Types 409</a> <a href="#bookmark2356">embedded collections 217</a> <a href="#bookmark2333">embedded objects 214</a> <a href="#bookmark2359">with collection</a> initializers 217 <a href="#bookmark3131">embedded sequences, group</a> joins 306 embedding</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4025">languages within C# 411</a> <a href="#bookmark3754">Primary Interop</a> Assemblies 385 <a href="#bookmark1569">emphasis 125</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2290">&quot;what&quot; vs &quot;how&quot; 210</a> <a href="#bookmark872">Empty 44, </a>500 empty arrays 501 <a href="#bookmark3132">empty sequences, group joins</a> matching no elements 306 <a href="#bookmark476">encapsulation 4,</a><a href="#bookmark1570"> 125,</a><a href="#bookmark1950"> 171,</a><a href="#bookmark2112"> 189</a> <a href="#bookmark696">delegates 28</a> <a href="#bookmark774">events 35</a> <a href="#bookmark4805">enclosing types 189</a> <a href="#bookmark1951">encodings 171</a> <a href="#bookmark3589">reading files 366</a> <a href="#bookmark4443">EndContractBlock 463</a> <a href="#bookmark4806">EndInvoke, delegate</a> method 31 <a href="#bookmark1119">EndXXX 76</a> <a href="#bookmark4583">enforcement</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4583">preconditions 484</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Enqueue 517 <a href="#bookmark4392">Ensures 458, </a><a href="#bookmark4612">486</a> <a href="#bookmark4618">EnsuresOnThrow 486</a> <a href="#bookmark3877">Enter 398</a> <a href="#bookmark2054">entities 183,</a><a href="#bookmark3242"> 323</a> <a href="#bookmark3267">change tracking 325</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark2053">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>partial types <a href="#bookmark3238">Entity Framework 322, </a>524 <a href="#bookmark4546">entry point, Code</a> Contracts 477 <a href="#bookmark862">enum 43</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1094">restriction on type</a> constraints 72 <a href="#bookmark2774">Enumerable 265, </a><a href="#bookmark2920">280,</a><a href="#bookmark3316"> 334</a> <a href="#bookmark861">enumeration 43</a> <a href="#bookmark3254">mapping in LINQ to</a> SQL 323 <a href="#bookmark4807">terminology clash 157</a> <a href="#bookmark642">enumerators 22</a> <a href="#bookmark2831">environment 271</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2864">adapting via extension</a> methods 274 <a href="#bookmark1749">closures 145,</a><a href="#bookmark1816"> 155</a> <a href="#bookmark2278">Environment.GetCommandLin</a> eArgs 209 <a href="#bookmark1152">equality 78</a> <a href="#bookmark3105">joins 301</a> Nullable<a href="#bookmark1447"> 111</a> <a href="#bookmark1513">equality operators 117, </a>500 <a href="#bookmark1146">EqualityComparer&lt;T&gt; 78</a> <a href="#bookmark909">Equals 48,</a><a href="#bookmark1155"> 79,</a><a href="#bookmark1580"> 126</a> <a href="#bookmark2415">anonymous types 223</a> Nullable</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">implementation<a href="#bookmark1445"> 111</a> <a href="#bookmark3107">equals, contextual keyword 302</a> <a href="#bookmark4247">Equals() 440</a> <a href="#bookmark3140">equijoins 308</a> <a href="#bookmark3082">erasure, transparent</a> identifiers 300 <a href="#bookmark686">errata 25</a> errors</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2720">checking 258</a> <a href="#bookmark4183">dynamic code 431</a> <a href="#bookmark3813">messages 392</a> <a href="#bookmark2150">pragma directives 194</a> <a href="#bookmark4035">escaping string literals 412</a> <a href="#bookmark3944">eval 403</a> evaluation order</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3656">named arguments 374</a> <a href="#bookmark1549">null coalescing operator 121</a> <a href="#bookmark2873">Evans, Eric 274</a> <a href="#bookmark728">event handlers 30,</a><a href="#bookmark927"> 50,</a><a href="#bookmark1612"> 131,</a><a href="#bookmark3498"> 352</a> <a href="#bookmark1660">conventions 136</a> <a href="#bookmark2507">lambda expression</a> examples 233 <a href="#bookmark2524">lambda expressions 235</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1651">EventArgs 135-</a><a href="#bookmark1661">136,</a><a href="#bookmark2530"> 236</a> <a href="#bookmark1615">EventHandler 131,</a><a href="#bookmark1652"> 135</a> <a href="#bookmark768">events 34,</a><a href="#bookmark2067"> 185,</a><a href="#bookmark2481"> 230,</a><a href="#bookmark3497"> 352</a> <a href="#bookmark1732">avoiding nullity checks 143</a> <a href="#bookmark3889">changes to field-like events in</a> C# 4 399 <a href="#bookmark772">subscription 34</a> <a href="#bookmark920">subscriptions 50,</a><a href="#bookmark1662"> 136</a> <a href="#bookmark4619">everything Code Contracts</a> retention option 486 <a href="#bookmark4101">evil uses of dynamic typing 420</a> <a href="#bookmark498">evolution 8,</a><a href="#bookmark510"> 12-</a><a href="#bookmark522">13,</a><a href="#bookmark545"> 15</a> <a href="#bookmark581">Excel 19, </a><a href="#bookmark3995">409</a> Except 506 <a href="#bookmark4603">Exception 485</a> <a href="#bookmark4508">catching</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ContractException 470 <a href="#bookmark1375">exceptions 105,</a><a href="#bookmark4808"> 231</a> <a href="#bookmark4335">documentation 454</a> <a href="#bookmark767">during delegate</a> invocation 34 <a href="#bookmark4293">dynamic responses 448</a> <a href="#bookmark4405">handling postconditions 459</a> <a href="#bookmark4376">preconditions 456</a> <a href="#bookmark4504">specified in</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">preconditions 470 <a href="#bookmark3038">thrown by Cast 293</a> <a href="#bookmark811">thrown by invalid casts 39</a> <a href="#bookmark879">thrown for invalid</a> conversions 45 <a href="#bookmark1120">TryXXX pattern 76</a> <a href="#bookmark3501">while iterating over a</a> sequence 352 ExceptWith 516 <a href="#bookmark1530">exclusive OR operator 119</a> <a href="#bookmark4142">executable caches 425</a> <a href="#bookmark4031">Execute 412</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3329">aggregation operators 336</a> <a href="#bookmark3301">method of</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IQueryProvider 330 <a href="#bookmark4032">ExecuteFile 412</a> <a href="#bookmark2594">execution model, abstracted by</a> expression trees 243 <a href="#bookmark3464">execution modes, Parallel</a> LINQ 350 <a href="#bookmark2809">execution order, clarity with</a> extension methods 268 execution patterns <a href="#bookmark1889">finally blocks 165</a> <a href="#bookmark1866">sequential appearance of</a> iterator blocks 161 <a href="#bookmark3276">execution plans 327</a> execution time</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark824">array access checks 40</a> <a href="#bookmark4333">contract checking 454</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3926">execution-time types, virtual</a> dispatch 403 <a href="#bookmark4418">Exists 461</a> <a href="#bookmark1719">exit points 142</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4533">invariant and postcondition</a> checking 473 <a href="#bookmark4219">ExpandoObject 435, </a>514 <a href="#bookmark3957">experimental style 405</a> <a href="#bookmark1011">experimentation 60</a> <a href="#bookmark669">experiments with code from</a> the book 23 explicit conversions <a href="#bookmark3409">LINQ to XML 343</a> <a href="#bookmark1633">method groups 134</a> <a href="#bookmark1431">Nullable&lt;T&gt; 108</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark1430">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>Nullable&lt;T&gt;,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">explicit conversions <a href="#bookmark836">explicit interface</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark836">implementation 41, </a><a href="#bookmark1199">86</a> <a href="#bookmark4809">dynamic typing 419</a> <a href="#bookmark795">explicit typing 38,</a><a href="#bookmark2305"> 211</a> <a href="#bookmark2478">explicitly typed parameter lists,</a> lambda expressions 230 <a href="#bookmark3030">explicitly typed range</a> variables 292 <a href="#bookmark2541">Expression class 237-</a><a href="#bookmark2553">238,</a><a href="#bookmark2999"> 288</a> <a href="#bookmark4051">expression evaluator 413</a> <a href="#bookmark3937">Watch and Immediate</a> windows 403 <a href="#bookmark1311">expression trees 98,</a><a href="#bookmark2456"> 228,</a><a href="#bookmark2535"> 236,</a> <a href="#bookmark3322">334</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4134">behavior in DLR rules 425</a> <a href="#bookmark2559">compiling 238</a> <a href="#bookmark2567">conversion from lambda</a> expressions 239 <a href="#bookmark3964">dynamic typing 405, </a><a href="#bookmark4168">429,</a> <a href="#bookmark4287">447</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2560">enhancements in .NET 4</a> <a href="#bookmark2560">239,</a><a href="#bookmark4115"> 421</a> <a href="#bookmark3002">LINQ 288</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2571">restrictions on lambda</a> expression conversions 240 <a href="#bookmark2604">used outside LINQ 244</a> <a href="#bookmark2579">visualizer in Visual Studio</a> 2010 242 <a href="#bookmark3298">Expression, property of</a> IQueryable 330 expressions</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2326">in object initializers 213</a> <a href="#bookmark793">static typing 37, </a><a href="#bookmark3922">403</a> <a href="#bookmark868">value as a reference type or</a> value type 43 <a href="#bookmark2544">ExpressionType 237</a> <a href="#bookmark538">expressive code 14, </a><a href="#bookmark1249">91,</a><a href="#bookmark2845"> 272,</a> <a href="#bookmark4646">489</a> extended types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2737">of an extension method 260</a> options around <a href="#bookmark2895">namespaces 276</a> <a href="#bookmark2046">Extensible Application Markup</a> Language 183 extension methods 11,<a href="#bookmark939"> 51-</a><a href="#bookmark945">52,</a> <a href="#bookmark4810">134,</a><a href="#bookmark2700"> 257, </a><a href="#bookmark4339">455</a> <a href="#bookmark4811">calling 261</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2745">compile-time discovery 262</a> <a href="#bookmark4084">creating TimeSpan</a> values 418 <a href="#bookmark2726">declaring 259</a> <a href="#bookmark4190">dynamic code 433</a> <a href="#bookmark3536">extending LINQ to</a> Objects 357 <a href="#bookmark2888">guidance 276</a> <a href="#bookmark3502">LINQ to Rx 353</a> <a href="#bookmark3420">LINQ to XML 344</a> <a href="#bookmark2880">restrictions 275</a> used by query <a href="#bookmark2921">expressions 280</a> <a href="#bookmark2755">ExtensionAttribute 262</a> Extensions class <a href="#bookmark3421">LINQ to XML 344</a> <a href="#bookmark2134">extern aliases 192</a> <a href="#bookmark1787">extra classes, generated to hold</a> captured variables 149</font></p>
<p><a name="bookmark4812"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">F</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4531">F# 473, </a><a href="#bookmark4667">491</a> <a href="#bookmark3939">F# Interactive 403</a> <a href="#bookmark3313">factory methods 333,</a><a href="#bookmark3674"> 376, </a><a href="#bookmark4255">441</a> <a href="#bookmark2542">expression trees 237</a> <a href="#bookmark1085">factory pattern 71,</a><a href="#bookmark1958"> 172, </a><a href="#bookmark4206">434</a> <a href="#bookmark3310">FakeQuery 332</a> <a href="#bookmark3309">FakeQueryProvider 332</a> <a href="#bookmark1505">false operator 117</a> <a href="#bookmark770">field-like events 34-</a><a href="#bookmark777">35</a> <a href="#bookmark3887">changes in C# 4 399</a> fields</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark487">automatically implemented</a> properties 7 <a href="#bookmark2228">backing trivial</a> properties 205 <a href="#bookmark3974">dynamic 408</a> <a href="#bookmark3891">field-like events 399</a> <a href="#bookmark1409">in Nullable&lt;T&gt; 107</a> <a href="#bookmark2272">lack of implicit typing 208</a> <a href="#bookmark2320">object initializers 213</a> FIFO 517 <a href="#bookmark1201">file handles 87</a> <a href="#bookmark1928">files, iterating over lines</a> elegantly 170 <a href="#bookmark2708">FileStream 258</a> <a href="#bookmark499">filtering 9,</a><a href="#bookmark1714"> 141,</a><a href="#bookmark1965"> 173,</a><a href="#bookmark2794"> 267,</a><a href="#bookmark2856"> 273,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2937">281, </a><a href="#bookmark3046">294</a> <a href="#bookmark3115">before joins 303</a> <a href="#bookmark2516">lambda expressions 234</a> <a href="#bookmark3509">LINQ to Rx 354</a> operators 505 <a href="#bookmark1317">finalizers 98</a> <a href="#bookmark4813">invariants 460</a> <a href="#bookmark1206">finally 87,</a><a href="#bookmark1862"> 161,</a><a href="#bookmark1946"> 171</a> <a href="#bookmark4814">FindAll 13,</a><a href="#bookmark1776"> 148,</a><a href="#bookmark1972"> 173</a><a href="#bookmark1981">-174,</a><a href="#bookmark2510"> 233,</a> 511-512 First 499 LinkedList&lt;T&gt; 513 <a href="#bookmark1924">first edition, Range class 170</a> <a href="#bookmark2666">first phase, type inference 249</a> FirstOrDefault 499 <a href="#bookmark2176">fixed 196</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2660">fixed type variables 249</a> <a href="#bookmark2179">FixedBufferAttribute 196</a> <a href="#bookmark4815">fixed-size buffers 196</a> flags</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1396">for nullable values 106</a> <a href="#bookmark534">indicating missing values 14</a> Flash 526 flattening</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3514">LINQ to Rx 355</a> <a href="#bookmark3418">LINQ to XML 344</a> <a href="#bookmark3141">flattening sequences 308</a> <a href="#bookmark2041">flexibility 182,</a><a href="#bookmark3634"> 371,</a><a href="#bookmark3807"> 391, </a><a href="#bookmark4631">487</a> <a href="#bookmark555">LINQ 16,</a><a href="#bookmark576"> 19</a> <a href="#bookmark4597">options for Code</a> Contracts 485 <a href="#bookmark1378">float, special values 106</a> <a href="#bookmark1377">floating-point numbers 106</a> <a href="#bookmark2669">flow chart, type inference in</a> C# 3 250 <a href="#bookmark3886">flow control 399</a> <a href="#bookmark1872">flow of execution, iterators 162</a> <a href="#bookmark2866">fluent interfaces 274</a> <a href="#bookmark4816">fluent notation 317</a> <a href="#bookmark465">fluff 3,</a><a href="#bookmark480"> 5,</a><a href="#bookmark1573"> 126,</a><a href="#bookmark2347"> 216</a> <a href="#bookmark4015">Foord, Michael 411</a> for statements</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1794">capturing the loop</a> variable 151 <a href="#bookmark2281">implicitly typed local</a> variables 209 <a href="#bookmark4417">ForAll 461</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4817">ForEach 13,</a><a href="#bookmark4818"> 140, </a><a href="#bookmark2514">233, </a>511 foreach 10,<a href="#bookmark513"> 12,</a><a href="#bookmark1829"> 157,</a><a href="#bookmark1878"> 163</a> <a href="#bookmark1795">capturing the loop</a> variable 151 <a href="#bookmark1203">disposal of iterator 87,</a><a href="#bookmark1898"> 167,</a> <a href="#bookmark3558">358, </a>522 <a href="#bookmark1188">generics 85</a> <a href="#bookmark986">implicit casting 58</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">foreach statements <a href="#bookmark2408">anonymous types 222</a> <a href="#bookmark2282">implicitly typed local</a> variables 209 <a href="#bookmark3120">foreign keys 304</a> <a href="#bookmark3583">formal parameters 366</a> <a href="#bookmark4325">formal specification 454</a> <a href="#bookmark2035">forward references 181</a> <a href="#bookmark2872">Fowler, Martin 274</a> framework 521</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1537">non-involvement in lifted</a> operators 120 <a href="#bookmark2914">support for LINQ 280</a> <a href="#bookmark3988">uses of dynamic typing 408</a> <a href="#bookmark614">framework libraries 21</a> <a href="#bookmark1354">frequently asked questions,</a> nullity 104 <a href="#bookmark2194">friend assemblies 198</a> from</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2989">contextual keyword 286</a> <a href="#bookmark3142">multiple from clauses 308</a> <a href="#bookmark3530">FromEvent 356</a> <a href="#bookmark3940">fsi, F# Interactive 403</a> <a href="#bookmark2122">fully qualified names 190</a> <a href="#bookmark931">Func&lt;...&gt; delegate types 50,</a> <a href="#bookmark2466">229,</a><a href="#bookmark3815"> 393</a> <a href="#bookmark1754">function 145</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1328">function names, C++ template</a> arguments 99 <a href="#bookmark699">function pointers 28</a> <a href="#bookmark471">functional programming 4,</a> <a href="#bookmark1598">129,</a><a href="#bookmark2453"> 228,</a><a href="#bookmark2502"> 233,</a><a href="#bookmark2590"> 243,</a><a href="#bookmark2834"> 272,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3669">376</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3220">declarative style 320</a> <a href="#bookmark4660">languages 491</a> <a href="#bookmark2713">functionality, adding to existing</a> types 258 <a href="#bookmark4047">functions, interoperability 413</a> <a href="#bookmark883">fundamental units, value</a> types 45 <a href="#bookmark1797">future changes 151</a></font></p>
<p><a name="bookmark4819"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">G</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark621">garbage collection 22,</a><a href="#bookmark1393"> 106,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2187">197, </a><a href="#bookmark4113">421</a> <a href="#bookmark1777">captured variables 148</a> <a href="#bookmark731">delegates 30</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark912">effect of excessive boxing 48</a> <a href="#bookmark1915">iterators 168</a> <a href="#bookmark1183">garbage collector, generics 84</a> <a href="#bookmark2068">generated code 185,</a><a href="#bookmark2126"> 190</a> <a href="#bookmark3212">equivalence of dot notation</a> and query expressions 319 <a href="#bookmark1917">iterators 168</a> <a href="#bookmark2060">generated files 183</a> generation operators 500 <a href="#bookmark3035">generic collections 292, </a>508 <a href="#bookmark1051">generic delegate types 66</a> <a href="#bookmark2471">Action 229</a> <a href="#bookmark2468">Func 229</a> <a href="#bookmark1288">generic helper class 95</a> <a href="#bookmark1237">generic method definitions,</a> retrieving through reflection 91 <a href="#bookmark1020">generic methods 62,</a><a href="#bookmark1046"> 65,</a><a href="#bookmark1104"> 74, </a><a href="#bookmark1295">96</a> <a href="#bookmark1236">reflection 90</a> <a href="#bookmark2645">type inference 246</a> <a href="#bookmark1210">generic type definition 88</a> <a href="#bookmark1230">specifying in reflection 90</a> <a href="#bookmark1043">generic type inference. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> type inference <a href="#bookmark1021">generic types 62</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1009">example with Dictionary</a> &lt;TKey, TValue&gt; 60 <a href="#bookmark4069">reflection 415</a> <a href="#bookmark1105">unaided by type</a> inference 74 <a href="#bookmark4820">generic variance 12,</a><a href="#bookmark952"> 52, </a><a href="#bookmark1259">92, </a>525 <a href="#bookmark3767">C# 4 387</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3848">explicit declaration</a> requirement 396 <a href="#bookmark3870">Java 397</a> <a href="#bookmark3822">restrictions 394</a> generics 10,<a href="#bookmark933"> 51, </a><a href="#bookmark968">53,</a><a href="#bookmark978"> 57</a> <a href="#bookmark2406">anonymous types 222</a> <a href="#bookmark1032">closed types 63, </a><a href="#bookmark1222">89</a> <a href="#bookmark1028">constructed types 62</a> <a href="#bookmark1333">Java 100</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1316">lack of generic properties</a> etc 98 <a href="#bookmark1248">limitations 91</a> <a href="#bookmark1033">open types 63, </a><a href="#bookmark1220">89</a> <a href="#bookmark2630">operators 245</a> <a href="#bookmark1041">pronunciation 64</a> <a href="#bookmark4821">reflection 88</a> <a href="#bookmark1059">type constraints 69</a> <a href="#bookmark1037">type parameter</a> substitution 63 <a href="#bookmark1162">ubiquity within language</a> specification 81 <a href="#bookmark1029">unbound types 62</a> <a href="#bookmark3733">get_, avoided by named</a> indexers 384 <a href="#bookmark2186">GetConsoleScreenBufferEx</a> 196</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4246">GetDynamicMemberNames()</a> <a href="#bookmark4246">440, </a><a href="#bookmark4277">445</a> <a href="#bookmark1190">GetEnumerator 85,</a><a href="#bookmark1832"> 157-</a><a href="#bookmark1842">158,</a> <a href="#bookmark1857">160,</a><a href="#bookmark1870"> 162,</a><a href="#bookmark1961"> 172,</a><a href="#bookmark3488"> 351</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1234">GetGenericArguments 90</a> <a href="#bookmark1227">GetGenericTypeDefinition 89</a> <a href="#bookmark910">GetHashCode 48,</a><a href="#bookmark1156"> 79, </a><a href="#bookmark4248">440</a> <a href="#bookmark2416">anonymous types 223</a> <a href="#bookmark1424">Nullable&lt;T&gt;</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">implementation 108 <a href="#bookmark766">GetInvocationList 34</a> GetKeyForItem 513 <a href="#bookmark4262">GetMemberBinder 444</a> <a href="#bookmark4130">GetMetaObject 424, </a><a href="#bookmark4250">440</a> <a href="#bookmark1239">GetMethods 91</a> <a href="#bookmark2107">getters 189,</a><a href="#bookmark2238"> 205</a> <a href="#bookmark4822">GetType 48, </a><a href="#bookmark1231">90</a> <a href="#bookmark1459">GetUnderlyingType 112</a> <a href="#bookmark1422">GetValueOrDefault 108</a> <a href="#bookmark4039">GetVariable 413</a> GetViewBetween 516 <a href="#bookmark4823">global namespace alias 192</a> <a href="#bookmark4038">global scope, IronPython 412</a> <a href="#bookmark3325">glue, Queryable methods 335</a> <a href="#bookmark2171">gmcs 195</a> <a href="#bookmark2483">goes to, lambda</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">expressions 230 <a href="#bookmark4824">Google 93,</a><a href="#bookmark2055"> 183</a> <a href="#bookmark4689">AppEngine 492</a> <a href="#bookmark965">gotchas, dynamic typing 53</a> <a href="#bookmark2876">grammar, domain specific</a> languages 274 <a href="#bookmark4050">graphing 413</a> <a href="#bookmark1312">Gravell, Marc 98,</a><a href="#bookmark2627"> 245</a> <a href="#bookmark464">Groovy 3,</a><a href="#bookmark2882"> 275</a> <a href="#bookmark3152">group ... by 311</a> <a href="#bookmark3126">group joins 305</a> <a href="#bookmark3153">group, contextual keyword 311</a> <a href="#bookmark2852">GroupBy 273, </a><a href="#bookmark3166">313, </a>501 <a href="#bookmark2849">grouping 273</a> <a href="#bookmark3511">LINQ to Rx 354</a> <a href="#bookmark3165">order of results 312</a> <a href="#bookmark3157">grouping expressions 311</a> grouping operators 501 <a href="#bookmark3138">GroupJoin 307, </a>502 <a href="#bookmark655">GTK# 23</a> <a href="#bookmark4320">guarantees, Code</a> Contracts 453 guidance</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2430">anonymous types 225</a> <a href="#bookmark1804">captured variables 153</a> <a href="#bookmark3543">extending LINQ to</a> Objects 357 <a href="#bookmark2889">extension methods 276</a> <a href="#bookmark2301">implicit typing 211</a> <a href="#bookmark2168">GUIDs, checksum pragma</a> directives 195 <a href="#bookmark2308">gut feelings 211</a> <a href="#bookmark2300">implicit typing 210</a></font></p>
<p><a name="bookmark4825"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">H</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">hash collisions 515 hash tables 514 hashing</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1150">generic interfaces 78</a> <a href="#bookmark3106">joins 301</a> HashSet 516 <a href="#bookmark828">Hashtable 40,</a><a href="#bookmark1012"> 60</a><a href="#bookmark1013">-61,</a><a href="#bookmark1564"> 124</a> <a href="#bookmark540">HasValue 14,</a><a href="#bookmark1402"> 107</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark1403">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>Nullable, HasValue property <a href="#bookmark875">heap 44, </a><a href="#bookmark891">46,</a><a href="#bookmark1392"> 106,</a><a href="#bookmark1785"> 149,</a><a href="#bookmark2190"> 197</a> <a href="#bookmark474">hello, world 4</a> <a href="#bookmark1294">helper classes 96</a> <a href="#bookmark2084">helper methods 187</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2366">initializing collections 218</a> <a href="#bookmark1634">method group</a> conversions 134 <a href="#bookmark3385">hierarchical structure, code</a> mirroring XML document 340 <a href="#bookmark2503">higher-order functions 233,</a> <a href="#bookmark3817">393</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2071">hooks, partial methods 185</a> hosting languages <a href="#bookmark2870">fluent interfaces 274</a> <a href="#bookmark4026">within C# 411</a> <a href="#bookmark3508">hot observables 353</a> <a href="#bookmark4669">HTML 491</a> <a href="#bookmark2910">hyperbole 279</a></font></p>
<p><a name="bookmark4826"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">I</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark835">ICloneable 41</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2353">ICollection&lt;T&gt; 216, </a>496, 509510</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3552">optimizing LINQ</a> operators 358 <a href="#bookmark1126">IComparable&lt;T&gt; 76</a> IComparer 10,<a href="#bookmark3562"> 358</a>, <a href="#bookmark4549">477</a> <a href="#bookmark503">IComparer and</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark503">IComparer&lt;T&gt; 9,</a><a href="#bookmark1149"> 78, </a><a href="#bookmark1285">95,</a> <a href="#bookmark1723">142,</a><a href="#bookmark3797"> 389, </a>515 <a href="#bookmark1004">IDE 59,</a><a href="#bookmark2028"> 181,</a><a href="#bookmark2260"> 207, </a><a href="#bookmark4276">445</a> <a href="#bookmark4252">identity 441</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3268">DataContext 325</a> <a href="#bookmark1089">identity conversions 71,</a><a href="#bookmark3039"> 293</a> IDictionary 509</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4223">ExpandoObject 436</a> <a href="#bookmark1558">idioms 124</a> <a href="#bookmark1817">code 155, </a><a href="#bookmark4316">453</a> <a href="#bookmark2480">delegates 230</a> <a href="#bookmark4128">IDispatch 424</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark617">IDisposable 22, </a><a href="#bookmark1205">87,</a><a href="#bookmark1836"> 157,</a><a href="#bookmark1914"> 168,</a> <a href="#bookmark1948">171-</a><a href="#bookmark1960">172,</a><a href="#bookmark3490"> 351</a> iterator block</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1897">implementation 167</a> iterator disposal in foreach 522 <a href="#bookmark4129">IDynamicMetaObjectProvider</a> <a href="#bookmark4129">424, </a><a href="#bookmark4285">446</a> <a href="#bookmark4222">ExpandoObject 436</a> <a href="#bookmark1376">IEEE-754 106</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark950">IEnumerable 52, </a><a href="#bookmark1189">85, </a><a href="#bookmark1271">93,</a><a href="#bookmark3796"> 389,</a> <a href="#bookmark4090">418, </a>508 <a href="#bookmark2349">collection initializers 216</a> <a href="#bookmark1826">iterator blocks 156,</a><a href="#bookmark1844"> 159,</a><a href="#bookmark1913"> 168</a> <a href="#bookmark2929">LINQ 280,</a><a href="#bookmark3037"> 292,</a><a href="#bookmark3318"> 334</a> concurrent collections 519 <a href="#bookmark3415">returned from axis</a> methods 343 <a href="#bookmark1823">IEnumerator 156,</a><a href="#bookmark1847"> 159,</a><a href="#bookmark1912"> 168</a> IEqualityComparer<a href="#bookmark1148"> 78</a>, 498, 514</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1157">IEquatable 79</a> <a href="#bookmark1588">if/else blocks 128</a> <a href="#bookmark4264">IgnoreCase 445</a> IGroupedObservable<a href="#bookmark3512"> 354</a> IGrouping <a href="#bookmark3161">311</a>, 501 <a href="#bookmark625">IL 22, </a><a href="#bookmark2533">236, </a><a href="#bookmark2587">242, </a><a href="#bookmark2632">245, </a><a href="#bookmark4120">422</a> <a href="#bookmark3620">const and default parameter</a> values 369 <a href="#bookmark3720">faked ref arguments 382</a> <a href="#bookmark2322">generated for object</a> initializers 213 <a href="#bookmark788">type system 37, </a><a href="#bookmark1175">83, </a><a href="#bookmark1215">89,</a><a href="#bookmark1400"> 107,</a> <a href="#bookmark2764">263</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark626">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>Intermediate Language</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1483">ildasm 115,</a><a href="#bookmark1697"> 140,</a><a href="#bookmark1903"> 167, </a><a href="#bookmark4163">428</a> IList<a href="#bookmark3553"> 358</a>, 499, 509 <a href="#bookmark831">IList&lt;T&gt; 40, </a>510 <a href="#bookmark2953">immediate execution 283, </a>495 <a href="#bookmark3557">custom LINQ operators 358</a> <a href="#bookmark3941">Immediate window, Visual</a> Studio 403 <a href="#bookmark491">immutability 7,</a><a href="#bookmark1414"> 108,</a><a href="#bookmark2421"> 223,</a><a href="#bookmark3666"> 376,</a> <a href="#bookmark4666">491</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">collections 501, 514 <a href="#bookmark2549">expression trees 237,</a><a href="#bookmark2610"> 244</a> <a href="#bookmark4590">futility of invariants 484</a> <a href="#bookmark2801">method call chaining 268</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark492">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>mutability <a href="#bookmark2925">impedance mismatch 280, </a><a href="#bookmark4267">445</a> <a href="#bookmark3222">imperative model 320, </a><a href="#bookmark4699">493</a> implementation</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2074">partial methods 186</a> <a href="#bookmark4589">revealing contracts 484</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1974">simplicity of LINQ to</a> Objects 173 <a href="#bookmark1899">implementation details 167</a> <a href="#bookmark4164">dynamic typing 428</a> <a href="#bookmark1702">generated names 140</a> <a href="#bookmark3077">transparent identifiers 300</a> implicit conversions 10,<a href="#bookmark987"> 58,</a><a href="#bookmark1088"> 71,</a> <a href="#bookmark2653">248, </a><a href="#bookmark2677">252</a> <a href="#bookmark823">array covariance 40, </a>511 <a href="#bookmark1587">conditional operator 127</a> <a href="#bookmark3617">default parameter values 368</a> <a href="#bookmark1292">due to type constraints 96</a> <a href="#bookmark3967">dynamic 406</a> <a href="#bookmark2751">extension methods 262</a> <a href="#bookmark1389">for wrapper types 106</a> <a href="#bookmark3791">generic variance 389</a> <a href="#bookmark1631">method group</a> conversions 134 <a href="#bookmark1625">method groups 133</a> <a href="#bookmark1427">Nullable&lt;T&gt; 108</a> <a href="#bookmark2665">role in type inference 249</a> <a href="#bookmark3338">string to XName 338</a> <a href="#bookmark3343">string to XNamespace 338</a> <a href="#bookmark4003">to object 409</a> <a href="#bookmark1428">implicit conversions, Nullable&lt;T&gt;.</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Nullable&lt;T&gt;, implicit conversions <a href="#bookmark3284">implicit joins, LINQ to</a> SQL 329 <a href="#bookmark4827">implicit obligations 475</a> <a href="#bookmark4545">arithmetic 477</a> <a href="#bookmark4539">array bounds 476</a> <a href="#bookmark4536">non-nullity 475</a> <a href="#bookmark2670">implicit parameter lists, lambda</a> expressions 252 <a href="#bookmark797">implicit typing 38,</a><a href="#bookmark940"> 51,</a><a href="#bookmark2254"> 207, </a><a href="#bookmark2345">215</a> <a href="#bookmark2817">projections 270</a> <a href="#bookmark3034">range variables 292</a> <a href="#bookmark2378">implicitly typed arrays 219</a> <a href="#bookmark2642">type inference 246</a> <a href="#bookmark562">implicitly typed local</a> <a href="#bookmark562">variables 16,</a><a href="#bookmark938"> 51,</a><a href="#bookmark2254"> 207</a> <a href="#bookmark2394">anonymous types 221</a> <a href="#bookmark2505">lambda expression</a> examples 233 implicitly typed parameters <a href="#bookmark2492">anonymous methods 231</a> <a href="#bookmark3028">lambda expressions 292</a> <a href="#bookmark2648">type inference 246</a> <a href="#bookmark4432">impure code 462</a> <a href="#bookmark2990">in keyword 286</a> <a href="#bookmark3790">in modifier,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">contravariance 389 <a href="#bookmark1528">inclusive OR operator 119</a> <a href="#bookmark3199">inconsistency, naming</a> conventions 318</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2370">indentation 218</a> <a href="#bookmark1845">independence, multiple itera</a>tors over one collection 159 independent</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark517">responsibilities 13</a> <a href="#bookmark3194">index, overloads for Select and</a> Where 317 <a href="#bookmark3728">indexed properties 383</a> indexers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1015">Dictionary&lt;TKey,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">TValue&gt; 61 <a href="#bookmark3721">named 383</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3640">optional parameters and</a> named arguments 372 IndexOf 509, 511 <a href="#bookmark700">indirection 28</a> <a href="#bookmark747">delegates 33,</a><a href="#bookmark1616"> 132</a> <a href="#bookmark3422">InDocumentOrder 344</a> <a href="#bookmark4828">-infer 474</a> inference</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark564">implicitly typed local</a> <a href="#bookmark564">variables 16,</a><a href="#bookmark2264"> 207</a> <a href="#bookmark1101">type parameters for generic</a> methods 74 inferred return types <a href="#bookmark2650">anonymous functions</a> 247</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2684">comparing anonymous func</a>tion conversions 254 <a href="#bookmark4829">infinite loops 231</a> <a href="#bookmark2930">infinite sequences 280</a> <a href="#bookmark1382">infinity 106</a> <a href="#bookmark2625">infoof 245</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2692">inheritance 256,</a><a href="#bookmark3534"> 356, </a><a href="#bookmark4562">480</a> <a href="#bookmark4468">contracts 466</a> <a href="#bookmark4830">deriving from type parame</a>ters in C++ 100 <a href="#bookmark1674">method group</a> conversions 137 <a href="#bookmark3681">overload resolution 378</a> <a href="#bookmark1273">variance 93, </a><a href="#bookmark3773">387,</a><a href="#bookmark3832"> 395</a> <a href="#bookmark486">initialization 7,</a><a href="#bookmark2310"> 211</a> <a href="#bookmark2380">arrays 219</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3667">immutable types 376</a> <a href="#bookmark2271">implicitly typed local</a> variables 208 <a href="#bookmark2043">partial types 182</a> <a href="#bookmark2257">initialization expressions 207</a><a href="#bookmark2297">210</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2367">inline initialization for</a> &quot;constants&quot; 218 <a href="#bookmark1683">inline specification of delegate</a> actions 139 <a href="#bookmark4462">inlining 465</a> <a href="#bookmark3087">inner joins 301</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3116">use in object-oriented</a> code 304 <a href="#bookmark3096">inner sequence 301</a> INotifyCollectionChanged 514 INotifyPropertyChanged 514 <a href="#bookmark3782">input positions,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">contravariance 388 InsertAt 509 InsertItem 513 <a href="#bookmark2242">instance members 205</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1762">capturing this reference 145</a> instance methods <a href="#bookmark2763">calling on null</a> references 263 <a href="#bookmark741">delegate example 32</a> <a href="#bookmark2748">preferred over extension</a> methods 262 <a href="#bookmark726">using to create delegate</a> instances 30 <a href="#bookmark1874">instance variables, represent</a>ing local variables in iterators 162 <a href="#bookmark2975">instant messaging 285</a> <a href="#bookmark1789">instantiation of local</a> variables 149 <a href="#bookmark2900">instincts 277</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2299">integer literals, potential confu</a>sion with implicit typing 210 <a href="#bookmark3390">integration, with LINQ 342</a> <a href="#bookmark991">IntelliSense 59, </a><a href="#bookmark3692">379, </a><a href="#bookmark4008">410, </a><a href="#bookmark4574">482</a> <a href="#bookmark2744">extension methods 261,</a><a href="#bookmark2896"> 276</a> <a href="#bookmark4323">intentions, communicating via</a> Code Contracts 453 <a href="#bookmark865">interfaces 43,</a><a href="#bookmark1954"> 172,</a><a href="#bookmark3006"> 288,</a><a href="#bookmark3830"> 395,</a> <a href="#bookmark4208">434</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2698">adding functionality 256</a> <a href="#bookmark2417">anonymous types 223</a> <a href="#bookmark1263">array covariance 92</a> <a href="#bookmark3852">breaking changes 396</a> collections 508 <a href="#bookmark4331">comparison with</a> contracts 454 <a href="#bookmark697">comparison with</a> delegates 28 <a href="#bookmark4086">comparison with duck</a> typing 418 <a href="#bookmark4479">contract classes 467</a> <a href="#bookmark948">extension methods 52</a> <a href="#bookmark3768">generic variance 387,</a><a href="#bookmark3786"> 389</a> <a href="#bookmark4465">inherited contracts 466</a> <a href="#bookmark866">interface keyword 43</a> <a href="#bookmark3295">out-of-process LINQ</a> providers 330 <a href="#bookmark838">return type covariance 41</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2096">static classes 188</a> <a href="#bookmark1308">static members 98</a> <a href="#bookmark2245">Interlocked 206</a> <a href="#bookmark3070">intermediate computations, let</a> clauses 298 <a href="#bookmark2596">intermediate format, LINQ</a> queries 243 <a href="#bookmark627">Intermediate Language. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> IL <a href="#bookmark1636">intermediate variable, method</a> group conversions 134 <a href="#bookmark2197">internal accessibility 198</a> <a href="#bookmark4256">internal classes, hiding imple</a>mentation details 441 <a href="#bookmark2200">InternalsVisibleToAttribute</a> 198</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark582">interoperability 19,</a><a href="#bookmark603"> 21, </a><a href="#bookmark3699">380,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3958">405</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark631">interpreters 22, </a><a href="#bookmark3934">403, </a><a href="#bookmark3956">405, </a><a href="#bookmark4020">411</a> Intersect 506 IntersectWith 516 <a href="#bookmark3173">into, contextual keyword 314</a> <a href="#bookmark3291">introspection, LINQ</a> queries 329 <a href="#bookmark907">InvalidCastException 47, </a><a href="#bookmark4048">413</a> <a href="#bookmark1408">InvalidOperationException</a> <a href="#bookmark1408">107,</a><a href="#bookmark1494"> 117, </a>499, 517-518 <a href="#bookmark1266">invariance 92, </a><a href="#bookmark3784">388</a> <a href="#bookmark4414">Invariant method 460</a> <a href="#bookmark4410">invariants 459, </a><a href="#bookmark4617">486</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4473">breaking via inheritance 467</a> <a href="#bookmark4469">inherited contracts 466</a> <a href="#bookmark1208">Inversion of Control 88, </a><a href="#bookmark4057">414</a> invocation <a href="#bookmark707">delegates 28</a> <a href="#bookmark3899">field-like events 399</a> <a href="#bookmark754">invocation list 33</a> <a href="#bookmark738">Invoke 31,</a><a href="#bookmark1635"> 134</a> <a href="#bookmark735">delegate method 31-</a><a href="#bookmark742">32</a> <a href="#bookmark4259">InvokeMemberBinder 444, </a><a href="#bookmark4305">450</a> <a href="#bookmark1241">invoking methods,</a> reflection 91 IObservable<a href="#bookmark3483"> 351</a>, 525 IObserver <a href="#bookmark3484">351</a>, 525 IOrderedEnumerable<a href="#bookmark4831"> 298</a> <a href="#bookmark4832">iPad 22</a> <a href="#bookmark634">iPhone 22, </a><a href="#bookmark4691">492</a> <a href="#bookmark4833">iPod Touch 22</a> IProducerConsumer-Collection&lt;T&gt; 518 <a href="#bookmark3288">IQueryable 329-</a><a href="#bookmark3300">330,</a><a href="#bookmark3319"> 334</a> <a href="#bookmark3289">IQueryProvider 329</a> <a href="#bookmark604">IronPython 21, </a><a href="#bookmark964">53, </a><a href="#bookmark3912">402</a> <a href="#bookmark4138">binder reuse 425</a> <a href="#bookmark4010">using from C# 4 410</a> <a href="#bookmark3911">IronRuby 402</a> <a href="#bookmark4139">binder reuse 425</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1541">is operator 121</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3857">breaking changes 396</a> ISet 510, 516 <a href="#bookmark1245">IsGenericMethod 91</a> <a href="#bookmark1225">IsGenericType 89</a> <a href="#bookmark1235">IsGenericTypeDefinition 90</a> <a href="#bookmark2603">IsInterned 244</a> <a href="#bookmark2766">IsNullOrEmpty 264</a> <a href="#bookmark4073">isolating dynamic typing 416</a> IsProperSubsetOf 516 IsProperSupersetOf 516 IsReadOnly 509 IsSubsetOf 516 IsSupersetOf 516 IStructuralComparable 525 IStructuralEquatable 525 <a href="#bookmark2006">ITask 176</a><a href="#bookmark2008">-177</a> Items 513 <a href="#bookmark1830">iterable 157</a> <a href="#bookmark1828">iteration pattern 156</a> <a href="#bookmark1196">iteration variables, foreach</a> loops 86 <a href="#bookmark1854">iterator blocks 160-</a><a href="#bookmark1858">161,</a><a href="#bookmark3550"> 357,</a> <a href="#bookmark4167">429, </a>522 <a href="#bookmark1920">elegance 169</a> <a href="#bookmark1276">iterators 94,</a><a href="#bookmark1818"> 156,</a><a href="#bookmark3324"> 334</a> <a href="#bookmark1839">implementing in C# 1 157</a> <a href="#bookmark1918">real-life examples 169</a> <a href="#bookmark1860">yield type 161</a></font></p>
<p><a name="bookmark4834"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">J</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark466">Java 3, </a><a href="#bookmark1254">92</a><a href="#bookmark1269">-93</a> <a href="#bookmark1334">generics 100,</a><a href="#bookmark3871"> 397</a> <a href="#bookmark3478">JavaScript 350, </a><a href="#bookmark3943">403, </a><a href="#bookmark4670">491, </a>527 <a href="#bookmark629">JIT compiler 22,</a><a href="#bookmark4835"> 77, </a><a href="#bookmark4110">421, </a><a href="#bookmark4289">447</a> <a href="#bookmark4144">DLR caches 425</a> <a href="#bookmark2534">expression trees 236,</a><a href="#bookmark2614"> 244</a><a href="#bookmark2633">245</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark999">generics 59,</a><a href="#bookmark1135"> 77, </a><a href="#bookmark1173">83, </a><a href="#bookmark1325">99</a> <a href="#bookmark3124">Join 304, </a>502, 524</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3205">custom comparisons 318</a> <a href="#bookmark3177">join ... into, not a</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">continuation 316 join operators 502 <a href="#bookmark3528">join plans, LINQ to Rx 356</a> <a href="#bookmark3526">join-calculus 356</a> joins</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3278">LINQ to SQL 327</a> <a href="#bookmark3084">query expressions 301</a> <a href="#bookmark629">Just-In-Time compilation 22</a> </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark628">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> J</a>IT compiler <a href="#bookmark2782">just-in-time, iterator</a> <a href="#bookmark2782">behavior 266</a></font></p>
<p><a name="bookmark4836"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">K</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark650">kernel profile 22</a> <a href="#bookmark2423">Key modifier, VB anonymous</a> types 223 <a href="#bookmark3094">key selectors 301,</a><a href="#bookmark3216"> 319</a> <a href="#bookmark3160">Key, property in</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">IGrouping&lt;,&gt; 311 KeyedCollection 513 KeyNotFoundException 509 <a href="#bookmark1619">KeyPress event 132</a> <a href="#bookmark1655">KeyPressEventArgs 135</a> <a href="#bookmark1623">KeyPressEventHandler 133,</a> <a href="#bookmark1654">135</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">keys</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3158">grouping 311</a> <a href="#bookmark3103">joins 301</a> <a href="#bookmark2286">keystrokes, saved by implicit</a> typing 209 KeyValuePair<a href="#bookmark1039"> 64</a> <a href="#bookmark2354">KeyValuePair&lt;TKey,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2354">TValue&gt; 216, </a>509 <a href="#bookmark1481">Knuth, Donald 115</a></font></p>
<p><a name="bookmark4837"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">L</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4136">L0, L1, L2 caches, DLR 425</a> <a href="#bookmark2557">Lambda 238, </a><a href="#bookmark2580">242</a> <a href="#bookmark2452">lambda calculus 228</a> <a href="#bookmark507">lambda expressions 11,</a><a href="#bookmark519"> 13,</a><a href="#bookmark928"> 50,</a> <a href="#bookmark2451">228,</a><a href="#bookmark2475"> 230,</a><a href="#bookmark2998"> 288, </a><a href="#bookmark3321">334</a> <a href="#bookmark2520">caching 235</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2797">common uses in extension</a> methods 267 <a href="#bookmark2460">converting to delegates 229</a> <a href="#bookmark2569">converting to expression</a> trees 239 <a href="#bookmark4196">dynamic typing 433</a> <a href="#bookmark2526">event handlers 235</a> <a href="#bookmark2647">implicitly typed</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2647">parameters 246,</a><a href="#bookmark3027"> 292</a> <a href="#bookmark2668">inferring parameter and</a> return types 249 <a href="#bookmark4838">restrictions when converting</a> to expression trees 240 <a href="#bookmark4563">static checking 480</a> <a href="#bookmark2671">timing of checking the</a> body 252 <a href="#bookmark2637">type inference 246</a> <a href="#bookmark2448">lambda. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> lambda expression <a href="#bookmark2552">LambdaExpression 238</a> <a href="#bookmark3872">Langer, Angelika 397</a> <a href="#bookmark2965">language complexity 284</a> <a href="#bookmark3917">language design 402</a> <a href="#bookmark1256">language designers 92,</a><a href="#bookmark1602"> 130,</a> <a href="#bookmark2389">220, </a><a href="#bookmark4013">410</a> <a href="#bookmark551">Language Integrated Query 16</a> <a href="#bookmark1968">language integration 173</a> <a href="#bookmark687">language specification 25,</a><a href="#bookmark1466"> 113,</a> <a href="#bookmark1640">134,</a><a href="#bookmark2148"> 194,</a><a href="#bookmark2237"> 205</a> <a href="#bookmark1906">iterators 168</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark895">lack of guarantees of mem</a>ory layout 46 <a href="#bookmark2336">object initializer</a> terminology 214 <a href="#bookmark3174">query continuations 314</a> <a href="#bookmark3007">query expressions 288</a> <a href="#bookmark3079">transparent identifiers 300</a> <a href="#bookmark2639">type inference 246</a> <a href="#bookmark1164">ubiquity of generics 81</a> <a href="#bookmark612">languages 21</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1448">additional functionality for</a> nullable types 111 <a href="#bookmark1538">behavior with nullable</a> types 120 <a href="#bookmark1753">incorporating closures 145</a> Last 499 LinkedList&lt;T&gt; 513 <a href="#bookmark2339">layout of code, object</a> initializers 215 <a href="#bookmark1971">lazy evaluation 173</a><a href="#bookmark1982">-174,</a><a href="#bookmark2787"> 267</a> Lazy&lt;T&gt; 525 <a href="#bookmark2455">LDAP 228</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2547">leaf expressions, expression</a> trees 237 <a href="#bookmark670">learning 23</a> left outer joins</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3281">generated SQL 328</a> <a href="#bookmark3129">simulating with group</a> joins 306 <a href="#bookmark3101">left sequence 301</a> <a href="#bookmark4431">legacy contracts 462, </a><a href="#bookmark4608">486</a> let</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3067">contextual keyword 298</a> <a href="#bookmark3274">LINQ to SQL 326</a> <a href="#bookmark614">libraries 21</a><a href="#bookmark645">-22,</a><a href="#bookmark1121"> 76,</a><a href="#bookmark2694"> 256,</a><a href="#bookmark2865"> 274,</a> <a href="#bookmark4019">411</a> <a href="#bookmark4109">DLR 421</a> <a href="#bookmark4088">duck typing 418</a> <a href="#bookmark4839">generics 59</a> <a href="#bookmark3743">licensing 385</a> <a href="#bookmark1935">lifetime management 170</a> <a href="#bookmark1778">lifetime, captured variables 148</a> LIFO 517</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1497">lifted conversions 117</a> <a href="#bookmark1507">lifted operators 117</a> limitations</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark812">C# 1 type system 39</a> <a href="#bookmark1246">generics 91</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1704">line breaks 140</a> <a href="#bookmark1811">line count, bad measure of</a> complexity 154 <a href="#bookmark1943">LineReader 171</a> <a href="#bookmark1929">lines, iterating over a file 170</a> LinkedList 512 LinkedListNode 512 <a href="#bookmark3749">linking, Primary Interop</a> Assemblies 385 <a href="#bookmark548">LINQ 16,</a><a href="#bookmark949"> 52,</a><a href="#bookmark1941"> 170,</a><a href="#bookmark1966"> 173,</a><a href="#bookmark2219"> 203,</a> <a href="#bookmark2911">279,</a><a href="#bookmark3227">322</a> <a href="#bookmark2435">anonymous types 225</a> <a href="#bookmark2927">data model 280</a> <a href="#bookmark4199">dynamic code 434</a> <a href="#bookmark2591">key enabling aspects 243</a> <a href="#bookmark3185">query styles 317,</a><a href="#bookmark4840"> 319</a> standard query operators 495 <a href="#bookmark3230">third party providers 322</a> <a href="#bookmark2777">without query</a> expressions 265 </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark547">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>Language Integrated Query</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3293">LINQ providers, building your</a> own 329 <a href="#bookmark3239">LINQ to Entities 322</a> <a href="#bookmark4841">LINQ to Objects 173,</a><a href="#bookmark2449"> 228,</a><a href="#bookmark2960"> 284,</a> <a href="#bookmark3000">288,</a><a href="#bookmark3218"> 320,</a><a href="#bookmark3414"> 343, </a>495 <a href="#bookmark3803">covariance in C# 4 391</a> <a href="#bookmark2599">execution path 243</a> <a href="#bookmark3479">extended in</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">System.Interactive 351 <a href="#bookmark3539">extending 357</a> <a href="#bookmark3470">LINQ to Rx 350</a> <a href="#bookmark574">LINQ to SQL 18,</a><a href="#bookmark4842"> 228,</a><a href="#bookmark2957"> 284,</a><a href="#bookmark3232"> 322</a> <a href="#bookmark3262">DataContext 325</a> <a href="#bookmark2600">execution path 243</a> <a href="#bookmark3256">queries 325</a> <a href="#bookmark570">LINQ to XML 18,</a><a href="#bookmark3331"> 337, </a><a href="#bookmark4233">436</a> <a href="#bookmark3371">declarative construction 340</a> <a href="#bookmark3426">design decisions 345</a> <a href="#bookmark675">LINQPad 24,</a><a href="#bookmark2780"> 265</a> <a href="#bookmark4843">Lippert, Eric 30,</a><a href="#bookmark4844"> 161,</a><a href="#bookmark2626"> 245, </a><a href="#bookmark3902">400,</a> 511-512 <a href="#bookmark4471">Liskov’s Substitution</a> Principle 466 <a href="#bookmark482">List&lt;T&gt; 6,</a><a href="#bookmark967"> 53,</a><a href="#bookmark1049"> 65,</a><a href="#bookmark2934"> 280, </a>510 <a href="#bookmark2344">collection initializers 215</a> <a href="#bookmark2506">lambda expression</a> examples 233 <a href="#bookmark2931">lists 280</a> <a href="#bookmark2299">literals 210</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3613">default parameter values 368</a> <a href="#bookmark808">little-endian 39</a> <a href="#bookmark1687">local variable declarations,</a> <a href="#bookmark1687">anonymous methods 140</a> <a href="#bookmark893">local variables 46,</a><a href="#bookmark1783"> 149,</a><a href="#bookmark2313"> 212,</a> <a href="#bookmark3004">288,</a><a href="#bookmark3663"> 375</a> <a href="#bookmark3719">autogenerated for fake pass-</a>by-value 382 <a href="#bookmark1750">captured by anonymous</a> methods 145 <a href="#bookmark4214">dynamic 435</a> <a href="#bookmark3713">for pass-by-reference</a> parameters 381 <a href="#bookmark4845">implicit typing 207</a> <a href="#bookmark1789">instantiation 149</a> <a href="#bookmark1873">iterator blocks 162</a> <a href="#bookmark3978">restrictions on var 408</a> <a href="#bookmark4400">traditional postcondition</a> testing 458 <a href="#bookmark2111">locking 189,</a><a href="#bookmark2244"> 206, </a><a href="#bookmark3876">398, </a><a href="#bookmark4173">429, </a>518 <a href="#bookmark3894">field-like events 399</a> <a href="#bookmark2434">log files 225,</a><a href="#bookmark3150"> 310</a> <a href="#bookmark3259">Log, DataContext 325</a> <a href="#bookmark2110">logging 189,</a><a href="#bookmark2525"> 235, </a><a href="#bookmark3327">335</a> <a href="#bookmark4062">configuration 414</a> <a href="#bookmark3307">fake LINQ provider 331</a> <a href="#bookmark1942">logic 170</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1523">nullable Booleans 119</a> <a href="#bookmark2457">represented in expression</a> trees 228 <a href="#bookmark1527">logical AND operator 119</a> <a href="#bookmark1529">logical negation operator 119</a> logically related conditions <a href="#bookmark3050">combining in where</a> clauses 295 LongCount 495 <a href="#bookmark1793">loops, captured variables 150,</a> <a href="#bookmark1812">154</a> <a href="#bookmark899">l-values 46</a></font></p>
<p><a name="bookmark4846"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">M</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1320">macros 99</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark535">magic value pattern 14,</a><a href="#bookmark1370"> 105,</a> <a href="#bookmark3625">370</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4847">magic variables 232</a> <a href="#bookmark672">Main method, snippets 23</a> <a href="#bookmark4650">mainstream languages 490</a> <a href="#bookmark470">maintainability 4,</a><a href="#bookmark1810"> 154,</a><a href="#bookmark2693"> 256,</a> <a href="#bookmark3661">375, </a><a href="#bookmark4655">491</a> <a href="#bookmark496">maintenance 8, </a><a href="#bookmark4270">445</a> cost of multiple <a href="#bookmark4632">configurations 487</a> <a href="#bookmark1228">MakeGenericType 89</a> <a href="#bookmark4399">malformed contracts 458</a> <a href="#bookmark896">managed code 46</a> Managed Extensibility Framework 525 <a href="#bookmark3436">Mandelbrot 346</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3247">mapping, LINQ to SQL 323</a> MARS 523 <a href="#bookmark2185">marshalling 196, </a><a href="#bookmark4112">421</a> master pages 523 <a href="#bookmark1716">matching 141</a> <a href="#bookmark1301">Math 97</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1299">mathematical code 97</a> Max 495 SortedSet&lt;T&gt; 516 <a href="#bookmark1532">maybe, nullable logic 120</a> <a href="#bookmark2166">MD5 195</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3647">meaning, clarifying</a> arguments 373 <a href="#bookmark1936">mechanisms, iteration 170</a> <a href="#bookmark2974">media player 285</a> MEF 525 <a href="#bookmark4023">Meier, Sid 411</a> <a href="#bookmark3965">member invocation 405</a> <a href="#bookmark4179">member resolution 430</a> <a href="#bookmark2615">members, obtaining without</a> reflection 244 memory</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1177">cost of JIT compilation 83</a> <a href="#bookmark1002">generics 59</a> <a href="#bookmark2952">limit on buffering</a> operations 283 <a href="#bookmark890">overhead of extra</a> methods 46 <a href="#bookmark1394">overhead of objects 106</a> <a href="#bookmark1358">representation of null 104</a> memory fragmentation 515 <a href="#bookmark732">memory leaks 30</a> MemoryStream 136,<a href="#bookmark2712"> 258</a> <a href="#bookmark4511">messages, contract failures 471</a> <a href="#bookmark1338">metadata 100,</a><a href="#bookmark2624"> 245</a> <a href="#bookmark4486">contracts 468</a> <a href="#bookmark4213">DynamicAttribute 435</a> <a href="#bookmark3240">LINQ to SQL 323</a> <a href="#bookmark4121">metaobjects 422, </a><a href="#bookmark4251">440, </a><a href="#bookmark4290">447-</a><a href="#bookmark4291">448</a> <a href="#bookmark4063">metaprogramming 414</a> <a href="#bookmark4301">MetaRumpelstiltskin 448</a> method arguments <a href="#bookmark1036">compared with type</a> arguments 63 <a href="#bookmark2664">role in type inference 249</a> <a href="#bookmark2383">method calls, specifying arrays</a> as arguments 219 <a href="#bookmark1054">method group conversions 67,</a> <a href="#bookmark4797">133</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1630">ambiguity 134</a> <a href="#bookmark1676">breaking changes 137</a> <a href="#bookmark1626">method groups 133,</a><a href="#bookmark2274"> 208</a> <a href="#bookmark2641">complexities in</a> overloading 246 <a href="#bookmark4195">dynamic code 433</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">method invocation,</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4226">ExpandoObject 436</a> <a href="#bookmark1035">method parameters, compared</a> with type parameters 63 <a href="#bookmark715">method signatures 29</a> <a href="#bookmark1244">MethodInfo 91,</a><a href="#bookmark2573"> 241,</a><a href="#bookmark2619"> 244, </a><a href="#bookmark4303">449</a> <a href="#bookmark2584">compiler shortcut 242</a> <a href="#bookmark1669">MethodInvoker 137,</a><a href="#bookmark1764"> 145</a> methods</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark716">compatibility with delegate</a> types 29 <a href="#bookmark1645">delegate compatibility 134</a> <a href="#bookmark1695">generated by anonymous</a> methods 140 <a href="#bookmark1884">meaning of return</a> statements 164 <a href="#bookmark2279">using results with var 209</a> <a href="#bookmark3925">virtual dispatch 403</a> <a href="#bookmark2851">metrics 273</a> <a href="#bookmark4326">Meyer, Bertrand 454</a> <a href="#bookmark630">Micro Framework 22, </a>527 <a href="#bookmark2806">micro-optimization 268</a> <a href="#bookmark609">Microsoft 21-</a><a href="#bookmark641">22,</a><a href="#bookmark1902"> 167,</a><a href="#bookmark3228"> 322,</a><a href="#bookmark3703"> 380,</a> <a href="#bookmark4310">451,</a><a href="#bookmark4677"> 492</a> anonymous type</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2407">implementation 222</a> <a href="#bookmark1991">CCR and DSS Toolkit 175</a> choices around <a href="#bookmark2768">exceptions 265</a> <a href="#bookmark924">event pattern guidelines 50</a> <a href="#bookmark2152">pragma directives 194</a> <a href="#bookmark3473">Reactive Extensions 350</a> <a href="#bookmark1990">Robotics Studio 175</a> <a href="#bookmark3998">Microsoft.Office.Interop.Excel</a> 409</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2741">migrating, to use extension</a> methods 261 Min 495 SortedSet&lt;T&gt; 516 <a href="#bookmark4551">MinValue 478</a> <a href="#bookmark2719">miscellaneous utility</a> library 258 <a href="#bookmark1926">MiscUtil 170-</a><a href="#bookmark1944">171,</a><a href="#bookmark2885"> 275,</a><a href="#bookmark4848"> 341</a> <a href="#bookmark882">misinformation 45</a> <a href="#bookmark524">missing data 14</a> <a href="#bookmark2102">misuse of helper classes 188</a> <a href="#bookmark2454">ML 228</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2883">mocking 275, </a><a href="#bookmark3987">408</a> <a href="#bookmark3251">model databases 323</a> modifiers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2733">extension methods 260</a> <a href="#bookmark3649">out and ref with named</a> arguments 373 <a href="#bookmark4675">monads 491</a> <a href="#bookmark4849">Mondrian 93</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3879">monitors, locking changes in</a> C# 4 398 <a href="#bookmark632">Mono 22</a><a href="#bookmark654">-23,</a><a href="#bookmark2170"> 195, </a><a href="#bookmark3942">403, </a><a href="#bookmark4118">422,</a> <a href="#bookmark4661">491, </a>525 <a href="#bookmark633">MonoTouch 22</a> <a href="#bookmark2362">Monty Python 218</a> Moonlight 527 <a href="#bookmark2967">MoreLINQ 284,</a><a href="#bookmark3547"> 357</a> <a href="#bookmark1657">MouseEventArgs 135</a> <a href="#bookmark1656">MouseEventHandler 135</a> <a href="#bookmark1191">MoveNext 85,</a><a href="#bookmark1834"> 157,</a><a href="#bookmark1869"> 162-</a><a href="#bookmark1907">168,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2947">282, </a><a href="#bookmark3499">352</a> <a href="#bookmark4850">msbuild 456</a> <a href="#bookmark4371">mscorlib 456</a> <a href="#bookmark2966">MSDN 284,</a><a href="#bookmark3097"> 301,</a><a href="#bookmark3407"> 343</a> expression tree</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2546">documentation 237</a> <a href="#bookmark3860">multicast delegates, generic</a> variance 396 <a href="#bookmark713">MulticastDelegate 29</a> multiple active result sets 523 <a href="#bookmark1583">multiple criteria, sorting 126</a> <a href="#bookmark4093">multiple dispatch 419</a> <a href="#bookmark3142">multiple from clauses 308</a> <a href="#bookmark3066">multiple orderings, in one</a> orderby clause 298 <a href="#bookmark3179">multiple query</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">continuations 316 multiple type parameters <a href="#bookmark3821">variance 394</a> multitargeting 521 <a href="#bookmark492">mutability 7, </a>11,<a href="#bookmark1413"> 108,</a><a href="#bookmark2421"> 223</a> collections 510-511, 514 <a href="#bookmark3672">encouraged by C# 3 376</a> GetViewBetween 516 <a href="#bookmark2800">method call chaining 268</a> <a href="#bookmark4391">mutated state,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">postconditions 458 <a href="#bookmark880">myths, value types and refer</a>ence types 45</font></p>
<p><a name="bookmark4851"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">N</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4230">name/value pairs 436</a> <a href="#bookmark494">named arguments 8,</a><a href="#bookmark589"> 20,</a><a href="#bookmark4852"> 214,</a> <a href="#bookmark3637">372</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3656">evaluation order 374</a> <a href="#bookmark4853">in tandem with optional</a> parameters 376 <a href="#bookmark3689">to resolve overload</a> ambiguity 379 <a href="#bookmark597">named indexers 20,</a><a href="#bookmark3721"> 383</a> <a href="#bookmark3735">design decisions 384</a> <a href="#bookmark2131">namespace alias qualifier 191</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2128">namespace aliases 190,</a><a href="#bookmark2139"> 193</a> <a href="#bookmark2120">namespaces 190</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2750">extension methods 262, </a><a href="#bookmark2894">276</a> <a href="#bookmark3340">LINQ to XML 338</a> <a href="#bookmark1700">naming 140,</a><a href="#bookmark4854"> 373, </a><a href="#bookmark4236">437</a> <a href="#bookmark2143">avoiding collisions 194</a> <a href="#bookmark2232">collisions 205, </a><a href="#bookmark4855">440</a> <a href="#bookmark3907">compile-time duck</a> typing 401 <a href="#bookmark2740">extension methods 261, </a><a href="#bookmark2767">265</a> <a href="#bookmark1229">generic reflection</a> methods 89 <a href="#bookmark2501">lambda expression</a> parameters 232 <a href="#bookmark4074">overloading and dynamic</a> typing 416 <a href="#bookmark3691">parameters 379</a> <a href="#bookmark3676">readability benefit of object</a> initializers 377 <a href="#bookmark2124">scope in the real world 190</a> <a href="#bookmark4569">variables used in</a> contracts 482 naming conventions <a href="#bookmark4484">class contracts 468</a> <a href="#bookmark2877">extension methods 275</a> <a href="#bookmark3197">lambda expression</a> parameters 317 <a href="#bookmark4412">ObjectInvariant 460</a> <a href="#bookmark1044">type parameters 65, </a><a href="#bookmark4856">89</a> <a href="#bookmark1381">NaN</font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">.</a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> not a number <a href="#bookmark647">native code 22,</a><a href="#bookmark2173"> 196, </a><a href="#bookmark3983">408, </a><a href="#bookmark4111">421</a> <a href="#bookmark1176">generics 83</a> <a href="#bookmark2871">natural language, fluent</a> interfaces 274 <a href="#bookmark4302">nested classes 448</a> <a href="#bookmark3513">nested subscriptions, LINQ to</a> Rx 354 <a href="#bookmark1848">nested types 159,</a><a href="#bookmark2101"> 188-</a><a href="#bookmark2114">189</a> <a href="#bookmark1170">generics 82</a> <a href="#bookmark673">in snippets 24</a> <a href="#bookmark4489">interfaces 468</a> <a href="#bookmark3819">nested variance 394</a> <a href="#bookmark2711">NetworkStream 258</a> <a href="#bookmark2340">new keyword, object</a> initializers 215 <a href="#bookmark4445">new style contracts 463</a> <a href="#bookmark4106">Ng, Sam 421</a> <a href="#bookmark623">NGen 22</a> Noda Time 524 <a href="#bookmark3406">Nodes 343</a> nodes</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3345">LINQ to XML 338</a> <a href="#bookmark2538">of expression trees 237</a> <a href="#bookmark2543">NodeType property, expression</a> trees 237 <a href="#bookmark4607">none, Code Contracts reten</a>tion option 486 <a href="#bookmark2728">nongeneric classes, require</a>ment for extension methods 260 <a href="#bookmark1160">nongeneric helper classes 80</a> <a href="#bookmark2729">non-nested classes, require</a>ment for extension methods 260 <a href="#bookmark4537">non-null obligations 475</a> <a href="#bookmark3287">non-nullable fields, generating</a> inner joins 329 <a href="#bookmark4355">non-nullable reference</a> <a href="#bookmark4355">types 455, </a><a href="#bookmark4857">488</a> <a href="#bookmark4004">non-pointer types 409</a> <a href="#bookmark3559">nonrepeatable sequences 358</a> <a href="#bookmark2765">nonvirtual calls, instance</a> method calls on null references 264 <a href="#bookmark2486">nonvoid return types, lambda</a> expressions 231 <a href="#bookmark3056">no-op select clauses 296</a> <a href="#bookmark1380">not a number 106</a> <a href="#bookmark3083">notation, transparent</a> identifiers 300 notes 512</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2982">NotificationSubscription, sam</a>ple data model 285 NULL</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1367">database fields 105</a> <a href="#bookmark1535">SQL 120</a> <a href="#bookmark533">null 14,</a><a href="#bookmark972"> 53,</a><a href="#bookmark2275"> 208,</a><a href="#bookmark4858"> 248, </a><a href="#bookmark4079">417</a> <a href="#bookmark2386">as a typeless expression 219</a> <a href="#bookmark1132">comparisons with generic</a> <a href="#bookmark1132">values 77,</a><a href="#bookmark1520"> 118</a> <a href="#bookmark3614">default parameter values 368</a> <a href="#bookmark2898">extension methods 277</a> <a href="#bookmark3376">ignored in LINQ to XML</a> construction 340 <a href="#bookmark1461">language support for</a> Nullable&lt;T&gt; 112 <a href="#bookmark3626">magic value for optional</a> parameters 370 <a href="#bookmark1360">meaning of 104</a> <a href="#bookmark761">meaning when combining</a> delegates 33 <a href="#bookmark1478">nullable value types 114</a> <a href="#bookmark902">parameter passing 47</a> <a href="#bookmark1070">reference type constraints 70</a> <a href="#bookmark1128">results of</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CompareTo(null) 76 <a href="#bookmark1545">null coalescing operator 121,</a> <a href="#bookmark1576">126</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1584">used in comparisons 127</a> <a href="#bookmark1475">null literal 114</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">null references</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">boxing Nullable<a href="#bookmark1441"> 110</a> <a href="#bookmark2760">extension methods 263</a> <a href="#bookmark1462">null values 112</a> <a href="#bookmark1565">Hashtable 124</a> <a href="#bookmark1398">Nullable class 107,</a><a href="#bookmark1451"> 111</a> <a href="#bookmark3285">nullable fields, generating</a> outer joins 329 nullable types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1496">lifted conversions 117</a> <a href="#bookmark1467">meaning in the C#</a> specification 113 <a href="#bookmark537">nullable value types 14, </a><a href="#bookmark971">53,</a><a href="#bookmark1349"> 103</a> <a href="#bookmark1468">compared with &quot;nullable</a> type&quot; 113 <a href="#bookmark3408">conversions in LINQ to</a> XML 343 <a href="#bookmark1136">generic comparisons 77</a> <a href="#bookmark3627">optional parameters 370</a> <a href="#bookmark1407">underlying type 107</a> <a href="#bookmark536">Nullable&lt;T&gt; 14</a> <a href="#bookmark1436">boxing 110</a> <a href="#bookmark1411">constructors 107</a> <a href="#bookmark1485">conversions 116</a> <a href="#bookmark1412">default constructor 107,</a><a href="#bookmark1477"> 114</a> <a href="#bookmark1445">Equals method 111</a> <a href="#bookmark1426">explicit conversions 108,</a><a href="#bookmark1491"> 116</a> <a href="#bookmark1424">GetHashCode method 108</a> <a href="#bookmark1423">GetValueOrDefault</a> method 108 <a href="#bookmark1403">HasValue property 107,</a><a href="#bookmark1463"> 112</a> <a href="#bookmark1429">implicit conversions 108,</a><a href="#bookmark1491"> 116</a> <a href="#bookmark1462">null value 112</a> <a href="#bookmark1486">operators 116</a> <a href="#bookmark1425">ToString method 108</a> <a href="#bookmark1437">unboxing 110</a> <a href="#bookmark1404">Value property 107</a> <a href="#bookmark4529">nullity 473</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1733">nullity check, events 143</a> <a href="#bookmark1131">NullReferenceException 77,</a> <a href="#bookmark1444">111,</a><a href="#bookmark2762"> 263,</a><a href="#bookmark2769"> 265, </a><a href="#bookmark3972">407</a> <a href="#bookmark1442">unboxing 110</a> <a href="#bookmark3380">numbers, LINQ to XML</a> content 340</font></p>
<p><a name="bookmark4859"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">O</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">object</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2087">immediate base of helper</a> classes 187 <a href="#bookmark3375">LINQ to XML construction</a> pattern 340 <a href="#bookmark988">use before generics 58</a> <a href="#bookmark486">object initializers 7,</a><a href="#bookmark2310"> 211-</a><a href="#bookmark2319">213,</a> <a href="#bookmark2977">285</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3670">encouraging mutability 376</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3994">object model, Office 409</a> <a href="#bookmark2051">Object Relational</a> Mapping 183 <a href="#bookmark4413">ObjectInvariant,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">conventions 460 <a href="#bookmark2723">object-oriented code 259</a> <a href="#bookmark3123">object-oriented data models,</a> inner joins 304 <a href="#bookmark748">object-oriented</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">programming 33 <a href="#bookmark3235">object-relational mapping 322</a> objects</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark871">distinguishing from</a> references 44 <a href="#bookmark901">role in parameter passing 47</a> <a href="#bookmark3504">Observable&lt;T&gt; 353</a> ObservableCollection&lt;T&gt; 513 <a href="#bookmark3507">observables, hot and cold 353</a> <a href="#bookmark3489">observers 351</a> <a href="#bookmark1851">off-by-one errors 160</a> <a href="#bookmark3708">Office 380, </a><a href="#bookmark3954">404, </a><a href="#bookmark3993">409</a> <a href="#bookmark2973">office suite 285</a> <a href="#bookmark1280">OfType 95, </a>497, 505 <a href="#bookmark4403">OldValue 459</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3108">on, contextual keyword 302</a> <a href="#bookmark3492">OnCompleted 351</a> <a href="#bookmark3128">one-to-one correspondence,</a> group joins 306 <a href="#bookmark3493">OnException 351</a> <a href="#bookmark3491">OnNext 351</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4061">on-the-fly reconfiguration 414</a> <a href="#bookmark1224">open constructed types, reflec</a>tion with generics 89 <a href="#bookmark3231">open source 322</a> <a href="#bookmark4117">DLR 421</a> <a href="#bookmark4626">libraries 487</a> <a href="#bookmark1033">open types 63</a> <a href="#bookmark1220">generics 89</a> <a href="#bookmark1931">OpenText 170,</a><a href="#bookmark2283"> 209</a> <a href="#bookmark1517">operand types, operators or</a> nullable types 117 <a href="#bookmark1297">operator constraints 97</a> <a href="#bookmark1499">operators 117, </a><a href="#bookmark4075">416</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1124">default value expression 76</a> <a href="#bookmark2629">generics 245</a> <a href="#bookmark1487">Nullable&lt;T&gt; 116</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark1486">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>Nullable, operators <a href="#bookmark2961">overloaded terminology 284</a> <a href="#bookmark1449">provided by languages for</a> nullable types 111 <a href="#bookmark4442">purity 463</a> <a href="#bookmark2099">static classes 188</a> <a href="#bookmark1307">type constraints 97</a> <a href="#bookmark3916">optimization 402, </a><a href="#bookmark4070">415, </a><a href="#bookmark4633">487</a> <a href="#bookmark3549">LINQ operators 357,</a><a href="#bookmark3569"> 360,</a> 496, 500, 505</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark525">optional parameters 14-</a><a href="#bookmark543">15,</a><a href="#bookmark590"> 20,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3584">366</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3597">declaring 367</a> <a href="#bookmark4853">in tandem with named</a> arguments 376 <a href="#bookmark1554">optional values 123</a> <a href="#bookmark1551">order of evaluation, null</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">coalescing operator 123 <a href="#bookmark763">order of execution, multicast</a> delegates 34 OrderBy 11,<a href="#bookmark2821"> 270,</a><a href="#bookmark3062"> 297, </a>507, 511 <a href="#bookmark2823">OrderByDescending 270,</a><a href="#bookmark3064"> 297,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">507</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">OrderedParallelQuery<a href="#bookmark3452"> 348</a> <a href="#bookmark1151">ordering 78,</a><a href="#bookmark3058"> 296</a> <a href="#bookmark3599">arguments and</a> parameters 368 dictionaries 515 <a href="#bookmark2404">importance in anonymous</a> types 222 <a href="#bookmark2044">initialization 182</a> <a href="#bookmark3455">Parallel LINQ 348</a> <a href="#bookmark3202">OrdinalIgnoreCase 318</a> <a href="#bookmark2052">ORM. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Object Relational Mapping <a href="#bookmark3789">out modifier, covariance 389</a> <a href="#bookmark4860">out of process queries 228,</a><a href="#bookmark2595"> 243</a> out parameters</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2077">forbidden in partial</a> methods 186 <a href="#bookmark4861">inability to capture 145</a> <a href="#bookmark2494">lambda expressions 231</a> <a href="#bookmark3650">named arguments 373</a> <a href="#bookmark4389">postconditions 458</a> <a href="#bookmark1891">prohibited in iterator</a> blocks 165 <a href="#bookmark2734">restrictions on extension</a> methods 260 <a href="#bookmark3841">restrictions on generic</a> variance 395 <a href="#bookmark3607">restrictions on optional</a> parameters 368 <a href="#bookmark3843">OutAttribute 395</a> <a href="#bookmark3098">outer joins 301</a> <a href="#bookmark3282">LINQ to SQL 328</a> <a href="#bookmark3100">outer sequence 301</a> <a href="#bookmark1757">outer variables 145</a> <a href="#bookmark1116">output parameters 76,</a><a href="#bookmark1571"> 126</a> <a href="#bookmark1561">TryXXX pattern 124</a> output positions <a href="#bookmark3780">covariance 388</a> <a href="#bookmark3842">out parameters 395</a> <a href="#bookmark2155">Output window, warning</a> numbers 194 <a href="#bookmark1596">overengineering 129</a> <a href="#bookmark4554">overflows 478</a> <a href="#bookmark1395">overhead, memory used by</a> objects 106 Overlaps 516</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2636">overload resolution 246,</a><a href="#bookmark3014"> 289,</a> <a href="#bookmark3601">368, </a><a href="#bookmark3923">403, </a><a href="#bookmark4181">431</a> <a href="#bookmark3859">breaking changes due to</a> generic variance 396 <a href="#bookmark2749">extension methods 262</a> <a href="#bookmark1143">generic types 78</a> <a href="#bookmark1142">generics 78</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4198">lambda expressions and</a> dynamic typing 433 <a href="#bookmark3678">named arguments and</a> optional parameters 378 <a href="#bookmark2686">summary of changes in</a> C# 3 254 <a href="#bookmark1500">overloaded operators, nullable</a> types 117 <a href="#bookmark1198">overloading 86,</a><a href="#bookmark2643"> 246</a> <a href="#bookmark3591">alternative to optional</a> parameters 366 <a href="#bookmark2672">changes in C# 3 252</a> <a href="#bookmark3682">complicated by</a> inheritance 379 <a href="#bookmark3563">custom LINQ operators 358</a> <a href="#bookmark4150">dynamic arguments 426</a> <a href="#bookmark1956">Func delegate types 172</a> <a href="#bookmark3167">GroupBy 314</a> <a href="#bookmark1675">method group</a> conversions 137 <a href="#bookmark1629">method groups 133</a> <a href="#bookmark3192">query expressions and dot</a> notation 317 <a href="#bookmark4096">single and multiple</a> dispatch 419 <a href="#bookmark4862">overloads, Execute and</a> CreateQuery 330 <a href="#bookmark3695">overriding 380, </a><a href="#bookmark4095">419, </a><a href="#bookmark4466">466</a> <a href="#bookmark2050">partial types 183</a> <a href="#bookmark839">return type covariance 41</a> <a href="#bookmark4863">ownership 172</a></font></p>
<p><a name="bookmark4864"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">P</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2174">P/Invoke 196, </a><a href="#bookmark3985">408</a> <a href="#bookmark1574">pain points 126</a> <a href="#bookmark1154">Pair&lt;T1,T2&gt; 78</a> <a href="#bookmark1987">Parallel Extensions 175,</a><a href="#bookmark3432"> 346,</a> <a href="#bookmark4697">493, </a>518, 524 <a href="#bookmark3429">Parallel LINQ 346</a> <a href="#bookmark3446">ParallelEnumerable 347</a> <a href="#bookmark1998">parallelism 175,</a><a href="#bookmark3439"> 346, </a><a href="#bookmark4696">493</a> <a href="#bookmark3447">ParallelQuery 347-</a><a href="#bookmark3451">348</a> <a href="#bookmark3374">parameter array 340</a> <a href="#bookmark3604">optional parameters 368</a> <a href="#bookmark2575">parameter expressions 241</a> <a href="#bookmark2582">appearance in visualizer 242</a> <a href="#bookmark1727">parameter list 143</a> parameter names</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3023">from range variables 291</a> <a href="#bookmark3690">importance of names 379</a> <a href="#bookmark897">parameter passing 46</a> parameter type</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark841">contravariance 41</a> parameter types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1690">anonymous methods 140</a> <a href="#bookmark2675">conversion from argument</a> types 252 <a href="#bookmark710">delegates 29</a> <a href="#bookmark1734">parameter wildcarding 144</a> <a href="#bookmark2574">ParameterExpression 241</a> <a href="#bookmark3726">parameterized properties 383</a> <a href="#bookmark703">ParameterizedThreadStart 28,</a> <a href="#bookmark1738">144,</a><a href="#bookmark1773"> 147</a> <a href="#bookmark2093">parameterless</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2093">constructors 187, </a><a href="#bookmark2248">206,</a><a href="#bookmark2317"> 212</a> <a href="#bookmark3608">default parameter values 368</a> <a href="#bookmark1079">generic type constraints 70</a> <a href="#bookmark495">parameters 8</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1725">anonymous methods 143</a> <a href="#bookmark2572">binding in expression</a> trees 241 <a href="#bookmark1751">captured by anonymous</a> methods 145 <a href="#bookmark1035">comparing type and method</a> parameters 63 <a href="#bookmark936">contravariance 51</a> contravariance in <a href="#bookmark1649">delegates 135</a> <a href="#bookmark4336">documentation 454</a> <a href="#bookmark3975">dynamic 408</a> <a href="#bookmark4151">dynamic type 426</a> <a href="#bookmark2492">implicit typing in lambda</a> expressions 231 <a href="#bookmark2382">initializing arrays 219</a> <a href="#bookmark736">Invoke method on a delegate</a> type 31 <a href="#bookmark1887">iterator blocks 165</a> <a href="#bookmark2497">lambda expressions with a</a> single parameter 232 <a href="#bookmark2477">listing explicitly in</a> lambdas 230 <a href="#bookmark3584">optional 366</a> <a href="#bookmark2332">readability 214</a> <a href="#bookmark2730">required for extension</a> methods 260 <a href="#bookmark3580">terminology 366</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1107">type inference 74</a> <a href="#bookmark2527">using lambda expressions for</a> logging 236 <a href="#bookmark4384">ParamName 458</a> <a href="#bookmark3370">params 340</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3605">optional parameters 368</a> <a href="#bookmark3379">parent nodes, LINQ to XML</a> content 340 parentheses</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2324">constructor calls 213</a> <a href="#bookmark3209">query expressions and dot</a> notation 318 <a href="#bookmark2498">removing from lambda</a> expressions 232 <a href="#bookmark3930">parser 403</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2029">partial methods 181,</a><a href="#bookmark2065"> 184</a> <a href="#bookmark2019">partial types 180</a> <a href="#bookmark2043">initialization 182</a> <a href="#bookmark3255">LINQ to SQL 324</a> <a href="#bookmark2036">restrictions 181</a> <a href="#bookmark3868">partial variance 397</a> <a href="#bookmark2032">partial, contextual</a> keyword 181 <a href="#bookmark1585">PartialComparer 127</a> partitioning operators 503 <a href="#bookmark898">pass by reference 46</a> <a href="#bookmark4099">pathological cases 420</a> <a href="#bookmark4665">pattern matching 491</a> <a href="#bookmark1114">patterns 76,</a><a href="#bookmark1557"> 124,</a><a href="#bookmark2906"> 278</a> <a href="#bookmark1827">iterator 156</a> <a href="#bookmark2010">language support 177</a> <a href="#bookmark1368">nullability 105</a> <a href="#bookmark1875">pausing execution, iterator</a> blocks 162 <a href="#bookmark4456">pdb files 464</a> Peek</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Queue&lt;T&gt; 517 Stack&lt;T&gt; 518 <a href="#bookmark4268">perfection 445</a> <a href="#bookmark2191">performance 197, </a><a href="#bookmark4628">487, </a>523 <a href="#bookmark1544">as operator with nullable</a> value types 121 <a href="#bookmark913">boxing 48</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4460">Code Contracts 465, </a><a href="#bookmark4621">487</a><a href="#bookmark4636">488</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1179">cost of JIT compilation 83</a> <a href="#bookmark3915">dynamic typing 402, </a><a href="#bookmark4131">424</a> <a href="#bookmark4865">generic comparisons with</a> null 77 <a href="#bookmark998">generics 59, </a><a href="#bookmark1251">91, </a><a href="#bookmark1314">98</a> <a href="#bookmark1347">Java generics 101</a> <a href="#bookmark2807">LINQ 268,</a><a href="#bookmark3015"> 290,</a><a href="#bookmark3109"> 302</a> <a href="#bookmark887">of value and reference</a> types 45 <a href="#bookmark1122">TryXXX pattern 76</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">performance</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2293">characteristics 210</a> <a href="#bookmark2207">permissions 199</a> <a href="#bookmark3831">perspectives, viewing types and</a> objects 395 <a href="#bookmark4678">Pex 492</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2656">phases, type inference 248</a> <a href="#bookmark591">PIA. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Primary Interop Assemblies <a href="#bookmark2192">pinning 197</a> <a href="#bookmark2802">pipelines 268</a> <a href="#bookmark2446">LINQ 228</a> <a href="#bookmark2790">piping data 267</a> placeholders Result <a href="#bookmark4402">459</a> <a href="#bookmark1022">type parameters 62</a> <a href="#bookmark3854">planning, generic variance 396</a> <a href="#bookmark1257">platform designers 92</a> <a href="#bookmark3435">PLINQ 346</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4866">Point structures, mutability 108</a> <a href="#bookmark2736">pointer types, restrictions on</a> extension methods 260 <a href="#bookmark807">pointers 39,</a><a href="#bookmark2177"> 196, </a><a href="#bookmark4154">427</a> <a href="#bookmark3909">polymorphism 401, </a><a href="#bookmark4207">434</a> Pop 518 <a href="#bookmark3901">portability 400</a> <a href="#bookmark1831">position, iterators 157</a> <a href="#bookmark4388">postconditions 458, </a><a href="#bookmark4613">486</a> <a href="#bookmark4470">inherited contracts 466</a> Power Collections 520 <a href="#bookmark1258">power, language design</a> choices 92 <a href="#bookmark2907">practices 278</a> <a href="#bookmark2146">pragma directives 194</a> <a href="#bookmark2159">checksum 195</a> <a href="#bookmark2151">warnings 194</a> <a href="#bookmark4269">pragmatism 445</a> <a href="#bookmark4614">pre and post, Code Contracts</a> retention option 486 precompilation, ASP.NET 523 <a href="#bookmark4374">preconditions 456, </a><a href="#bookmark4610">486</a> <a href="#bookmark4611">Code Contracts retention</a> option 486 <a href="#bookmark4501">contract reference</a> assemblies 470 <a href="#bookmark4467">inherited contracts 466</a> <a href="#bookmark4543">suggested by static</a> checker 477 <a href="#bookmark4578">variations in meaning 483</a> <a href="#bookmark1492">predefined conversions 116</a> <a href="#bookmark1508">predefined operators 117</a> Predicate<a href="#bookmark2811"> 269</a> <a href="#bookmark4439">purity 463</a> <a href="#bookmark1715">predicates 141,</a><a href="#bookmark1970"> 173,</a><a href="#bookmark2942"> 282, </a>495 <a href="#bookmark2838">predictability 272</a> <a href="#bookmark1045">prefix, convention for type</a> parameter names 65 <a href="#bookmark2147">preprocessing directives 194</a> <a href="#bookmark2918">preprocessing, query</a> expressions 280 <a href="#bookmark2757">preprocessor symbols 263, </a><a href="#bookmark4604">486</a> <a href="#bookmark4452">Code Contracts 464</a> <a href="#bookmark1099">primary constraints 73</a> <a href="#bookmark592">Primary Interop Assemblies 20,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4867">385, </a><a href="#bookmark4000">409</a> <a href="#bookmark3117">primary keys 304</a> <a href="#bookmark3065">primary orderings 297</a> <a href="#bookmark2183">primitive types 196</a> private</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2115">access modifier 189</a> <a href="#bookmark2075">partial methods 186</a> <a href="#bookmark1849">private accessibility, from</a> nested types 159 <a href="#bookmark2086">private constructors, helper</a> methods 187 <a href="#bookmark4868">private fields 457</a> <a href="#bookmark2116">private members, access from</a> nested types 189 <a href="#bookmark2788">processing models, buffering</a> versus streaming 267 <a href="#bookmark2373">ProcessStartInfo 218</a> producer/consumer pattern 518 <a href="#bookmark2202">production assemblies 199</a> <a href="#bookmark4006">productivity 410, </a><a href="#bookmark4104">420, </a><a href="#bookmark4654">491</a> <a href="#bookmark648">profiles 22</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4356">program verifier, Spec# 455</a> project files <a href="#bookmark2063">editing for</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">dependencies 184 <a href="#bookmark2850">project management 273</a> <a href="#bookmark2424">projection initializers 223</a> projection operators 503 <a href="#bookmark2812">projections 269, </a><a href="#bookmark2944">282,</a><a href="#bookmark2993"> 287</a> <a href="#bookmark3159">grouping 311</a> <a href="#bookmark3510">LINQ to Rx 354</a> <a href="#bookmark2853">sorting 273</a> <a href="#bookmark2978">Projects, sample data</a> model 285 <a href="#bookmark4318">promises 453</a> <a href="#bookmark4081">promotion, addition</a> operands 417 pronunciation <a href="#bookmark1041">generics 64</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2484">lambda expressions 230</a> <a href="#bookmark2226">properties 204, </a><a href="#bookmark2622">244</a> <a href="#bookmark479">access modifiers 5-</a><a href="#bookmark481">6</a> <a href="#bookmark2403">anonymous types 222</a> <a href="#bookmark484">automatically</a> implemented 7</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3727">default 383</a> <a href="#bookmark4221">ExpandoObject 436</a> <a href="#bookmark2105">getter / setter access 189</a> <a href="#bookmark3675">mutability 377</a> <a href="#bookmark3122">navigation in object-oriented</a> models 304 <a href="#bookmark2426">projection initializers 224</a> <a href="#bookmark4433">purity 463</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2335">setting subproperties with</a> object initializers 214 <a href="#bookmark2316">setting with object</a> initializers 212 <a href="#bookmark2529">property descriptors 236</a> <a href="#bookmark944">property names, anonymous</a> types 52 <a href="#bookmark2100">protected access, prohibited in</a> static classes 188 <a href="#bookmark2027">protected methods 180</a> <a href="#bookmark2056">Protocol Buffers 183</a> <a href="#bookmark1957">provider pattern 172</a> <a href="#bookmark3761">proxying, COM 386</a> <a href="#bookmark852">public domain 43</a> <a href="#bookmark2204">public interface, unit</a> testing 199 <a href="#bookmark2210">public keys, friend</a> assemblies 199 <a href="#bookmark4474">public methods, invariants 467</a> <a href="#bookmark775">publish/subscribe pattern 35</a> <a href="#bookmark3476">pull model, LINQ to</a> Objects 350 <a href="#bookmark4571">pure methods 482</a> <a href="#bookmark4434">PureAttribute 463</a> <a href="#bookmark4435">purity 463</a> Push 518</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3475">push model, LINQ to Rx 350</a> <a href="#bookmark462">Python 3,</a><a href="#bookmark600"> 20,</a><a href="#bookmark3959"> 405, </a><a href="#bookmark4683">492</a></font></p>
<p><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">Q</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">quantifier operators 505 queries <a href="#bookmark3256">LINQ to SQL 325</a> <a href="#bookmark3394">LINQ to XML 342</a> <a href="#bookmark4869">observables 354</a> <a href="#bookmark3454">parallelizing 348</a> <a href="#bookmark3155">query continuations 311,</a><a href="#bookmark3170"> 314</a> <a href="#bookmark3180">multiple 316</a> <a href="#bookmark3003">query expression pattern 288,</a> <a href="#bookmark3533">356</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark557">query expressions 16,</a><a href="#bookmark1969"> 173,</a><a href="#bookmark2778"> 265,</a> <a href="#bookmark2813">269,</a><a href="#bookmark2917"> 280, </a>495 <a href="#bookmark3183">compared to dot</a> <a href="#bookmark3183">notation 317,</a><a href="#bookmark3210"> 319</a> <a href="#bookmark2958">consistency between LINQ</a> <a href="#bookmark2958">providers 284</a> query expressions </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">(continued) </font><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3171">continuation</a> translations 314 <a href="#bookmark3054">degenerate queries 295</a> <a href="#bookmark4201">dynamic code 434</a> <a href="#bookmark3036">explicitly typed range</a> variables 292 <a href="#bookmark3016">order of clauses 290</a> <a href="#bookmark2987">select clauses 286</a> <a href="#bookmark578">translation 19,</a><a href="#bookmark3261"> 325,</a><a href="#bookmark3320"> 334,</a><a href="#bookmark3535"> 356</a> <a href="#bookmark3025">type inference example 291</a> <a href="#bookmark3275">query optimizer 327</a> <a href="#bookmark2775">Queryable 265, </a><a href="#bookmark3294">330-</a><a href="#bookmark3306">331, </a><a href="#bookmark3314">334</a> <a href="#bookmark509">querying 12</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3299">QueryProvider, property of</a> IQueryable 330 Queue&lt;T&gt; 517</font></p>
<p><a name="bookmark4870"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">R</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2879">Rahien, Ayende 275</a> <a href="#bookmark2933">random numbers 280,</a><a href="#bookmark3567"> 359</a> <a href="#bookmark3566">Random, using carefully 359</a> <a href="#bookmark2781">Range 266, </a>500 <a href="#bookmark3997">Excel 409</a> <a href="#bookmark3505">LINQ to Rx 353</a> <a href="#bookmark3469">ParallelEnumerable 350</a> <a href="#bookmark3018">range variables 290, </a><a href="#bookmark3029">292</a> <a href="#bookmark3074">combined with transparent</a> identifiers 299 <a href="#bookmark3031">explicit typing 292</a> <a href="#bookmark3175">scope with query</a> continuations 315 <a href="#bookmark1922">Range&lt;T&gt; 170</a> <a href="#bookmark1341">raw types (Java) 100</a> <a href="#bookmark4535">reachability 474</a> <a href="#bookmark4871">Reactive Extensions 175, </a><a href="#bookmark2968">284,</a> <a href="#bookmark3474">350, </a><a href="#bookmark4698">493, </a>525 <a href="#bookmark1108">readability 74,</a><a href="#bookmark1799"> 152,</a><a href="#bookmark2338"> 215,</a><a href="#bookmark2701"> 257,</a> <a href="#bookmark2835">272</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3662">argument reordering 375</a> <a href="#bookmark1746">captured variables 145</a> <a href="#bookmark1711">consistency 141</a> <a href="#bookmark3223">declarative code 320</a> <a href="#bookmark2739">extension method</a> naming 261 <a href="#bookmark1617">extra methods for</a> delegates 132 <a href="#bookmark996">generics 59</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2222">implicit typing 204, </a><a href="#bookmark2288">209-</a><a href="#bookmark2296">210</a> <a href="#bookmark1923">iterator blocks 170</a> LINQ 11,<a href="#bookmark518"> 13,</a><a href="#bookmark554"> 16,</a><a href="#bookmark2499"> 232,</a><a href="#bookmark2808"> 268</a> <a href="#bookmark3367">LINQ to XML namespace</a> support 339 <a href="#bookmark2891">measuring objectively 276</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1627">method group</a> conversions 133 <a href="#bookmark3051">multiple where clauses 295</a> <a href="#bookmark3638">named arguments 372, </a><a href="#bookmark3698">380</a> <a href="#bookmark3687">naming 379</a> <a href="#bookmark1479">nullable types 114</a> <a href="#bookmark3181">query expressions and dot</a> notation 317 <a href="#bookmark4350">single exit point 455</a> <a href="#bookmark3215">transparent identifiers 319</a> <a href="#bookmark3714">using Word before C# 4 381</a> <a href="#bookmark1838">ReadAllLines 157,</a><a href="#bookmark1980"> 174</a> ReadAllText 523 ReaderWriterLockSlim 524 <a href="#bookmark3936">read-evaluate-print loop 403</a> <a href="#bookmark2716">ReadFully 258</a> <a href="#bookmark2709">reading from streams 258</a> <a href="#bookmark1933">ReadLine 170</a> <a href="#bookmark2414">read-only fields, anonymous</a> types 223 <a href="#bookmark4872">read-only properties 8, </a><a href="#bookmark2251">206</a> <a href="#bookmark2413">anonymous types 223</a> ReadOnlyCollection<a href="#bookmark2364"> 218</a> <a href="#bookmark1275">ReadOnlyCollection&lt;T&gt; 94,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">514</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">ReadOnlyObservableCollection &lt;T&gt; 514 <a href="#bookmark4126">receivers 424</a> <a href="#bookmark3633">recompilation 371, </a><a href="#bookmark4053">413</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3621">const and default values 369</a> <a href="#bookmark4060">reconfiguration, on the fly 414</a> <a href="#bookmark4542">rectangular arrays 476, </a>512 <a href="#bookmark4240">recursion 437</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4458">guard in Code Contracts 465</a> <a href="#bookmark3387">LINQ to XML</a> construction 341 red-black trees 515-516 <a href="#bookmark4054">redeployment 413</a> <a href="#bookmark4300">redirecting 448</a> <a href="#bookmark3744">redistribution 385</a> <a href="#bookmark3073">redundant computations 299</a> ref parameters <a href="#bookmark3845">CLR support 395</a> <a href="#bookmark3716">COM 382</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4873">inability to capture 145</a> <a href="#bookmark3785">invariance 389</a> <a href="#bookmark2495">lambda expressions 231</a> <a href="#bookmark3651">named arguments 373</a> <a href="#bookmark4390">postconditions 458</a> <a href="#bookmark1892">prohibited in iterator</a> blocks 165 <a href="#bookmark2735">restrictions on extension</a> methods 260 <a href="#bookmark3606">restrictions on optional</a> parameters 368</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1579">refactoring 126,</a><a href="#bookmark2061"> 183,</a><a href="#bookmark2616"> 244,</a><a href="#bookmark3541"> 357,</a> <a href="#bookmark3660">375</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1090">reference conversions 71,</a><a href="#bookmark1647"> 135,</a> <a href="#bookmark3040">293</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3793">generic variance 389,</a><a href="#bookmark3833"> 395</a> <a href="#bookmark1064">reference type constraints 69,</a> <a href="#bookmark1138">77</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1590">avoiding boxing 128</a> <a href="#bookmark532">reference types 14,</a><a href="#bookmark620"> 22, </a><a href="#bookmark848">42</a> <a href="#bookmark1264">array covariance 92</a> <a href="#bookmark1552">null coalescing operator 123</a> <a href="#bookmark1359">nullability 104</a> <a href="#bookmark3835">type arguments and generic</a> variance 395 <a href="#bookmark1386">wrapper for nullable value</a> types 106 <a href="#bookmark870">references 44</a> <a href="#bookmark1180">memory size 83</a> <a href="#bookmark3118">navigation in object-oriented</a> models 304 <a href="#bookmark3745">referencing, Primary Interop</a> Assemblies 385 <a href="#bookmark2208">reflection 199,</a><a href="#bookmark2621"> 244, </a><a href="#bookmark4149">426</a> <a href="#bookmark1083">generics 71, </a><a href="#bookmark4874">88</a> <a href="#bookmark1240">invoking methods 91</a> <a href="#bookmark2528">obtaining a MethodInfo 236,</a> <a href="#bookmark2585">242</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2631">operators and expression</a> trees 245 <a href="#bookmark1238">retrieving generic method</a> definitions 91 <a href="#bookmark1243">side-stepping with dynamic</a> <a href="#bookmark1243">typing 91, </a><a href="#bookmark3918">402</a><a href="#bookmark3947">-403, </a><a href="#bookmark4068">415</a> <a href="#bookmark1484">Reflector 115,</a><a href="#bookmark1698"> 140,</a><a href="#bookmark1904"> 167, </a><a href="#bookmark3057">296,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3759">386, </a><a href="#bookmark4162">428</a> <a href="#bookmark4041">reformatting 413</a> <a href="#bookmark664">refreshingly minty code 23</a> <a href="#bookmark2025">regions 180</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1181">register optimizations 84</a> <a href="#bookmark1014">regular expressions 61</a> <a href="#bookmark3119">relational data models, inner</a> joins 304 <a href="#bookmark1514">relational operators 117</a> <a href="#bookmark4584">release builds 484,</a><a href="#bookmark4620"> 486</a> <a href="#bookmark4344">assertions 455</a> <a href="#bookmark4609">release requires, Code Con</a>tracts retention option 486 <a href="#bookmark1207">releasing resources, foreach 87</a> <a href="#bookmark756">Remove 33,</a><a href="#bookmark1606"> 131, </a>509 RemoveAt 509 RemoveFirst 513 RemoveItem 513 RemoveLast 513 RemoveWhere 516</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark750">removing delegates 33</a> Repeat 500 <a href="#bookmark2440">repetitive code 226</a> <a href="#bookmark3935">REPL 403, </a><a href="#bookmark4275">445</a> <a href="#bookmark2798">Replace 267-</a><a href="#bookmark2799">268</a> <a href="#bookmark3596">required parameters 367-</a><a href="#bookmark3603">368</a> <a href="#bookmark4317">requirements 453</a> <a href="#bookmark4377">Requires 456, </a><a href="#bookmark4605">486</a> <a href="#bookmark4330">research 454</a> <a href="#bookmark1911">Reset 168</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4148">resolution, dynamic calls 426</a> <a href="#bookmark1959">resource acquisition, timing in</a> iterators 172 <a href="#bookmark1893">resource management,</a> iterators 165 <a href="#bookmark1202">resources, released after</a> iterating 87 <a href="#bookmark4298">responding dynamically 448</a> <a href="#bookmark3884">Response.Redirect 399</a> <a href="#bookmark3986">RESTful services 408</a> <a href="#bookmark2158">restoring warnings 195</a> <a href="#bookmark3602">restrictions 368</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3611">default parameter values 368</a> <a href="#bookmark4272">documenting 445</a> <a href="#bookmark4188">dynamic code 432</a> <a href="#bookmark3823">generic variance 394</a> <a href="#bookmark2268">implicitly typed local</a> variables 208 <a href="#bookmark1510">nullable type operators 117</a> <a href="#bookmark3600">optional parameters 368</a> <a href="#bookmark2036">partial types 181</a> Result <a href="#bookmark4401">459</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1883">return statements 164</a> <a href="#bookmark2654">implicit return types 248</a> <a href="#bookmark4875">lambda expressions 231</a> <a href="#bookmark1861">prohibited in iterator</a> blocks 161 return types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1717">anonymous methods 142</a> <a href="#bookmark717">compatibility with delegate</a> types 29 <a href="#bookmark926">compatibility, covariance of</a> delegates in C# 2 50 <a href="#bookmark837">covariance 41, </a><a href="#bookmark935">51</a> <a href="#bookmark1664">covariance in delegates 136</a> <a href="#bookmark711">delegates 29</a> <a href="#bookmark3976">dynamic 408</a> <a href="#bookmark2473">Func and Action 229</a> implementing IDynamic-<a href="#bookmark4296">MetaObjectProvider 448</a> <a href="#bookmark2651">inferred from anonymous</a> functions 247 <a href="#bookmark2485">lambda expressions 231</a> <a href="#bookmark737">of Invoke method on a dele</a>gate type 31 <a href="#bookmark1197">overloading 86</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1572">return values 126</a> <a href="#bookmark3779">covariance 388</a> <a href="#bookmark1559">indicators of success 124</a> <a href="#bookmark4387">postconditions 458</a> <a href="#bookmark1718">return, anonymous</a> methods 142 <a href="#bookmark4295">ReturnType 448</a> <a href="#bookmark1182">reuse, native code from JIT</a> compilation 84 <a href="#bookmark2783">Reverse 266,</a><a href="#bookmark2949"> 282,</a><a href="#bookmark3190"> 317, </a>507 <a href="#bookmark3527">missing from LINQ to</a> Rx 356 SortedSet 517 <a href="#bookmark680">reversing strings 25</a> <a href="#bookmark4453">rewriting, Code Contracts 464</a> <a href="#bookmark1553">right associativity, null coalesc</a>ing operators 123 <a href="#bookmark3099">right sequence 301</a> <a href="#bookmark2833">robustness 272, </a><a href="#bookmark4309">451</a> <a href="#bookmark997">aided by generics 59</a> <a href="#bookmark4097">dynamic typing 419</a> <a href="#bookmark3416">LINQ to XML queries 343</a> <a href="#bookmark4526">static checking 473</a> <a href="#bookmark3362">root element, LINQ to</a> XML 338 <a href="#bookmark3363">Root property,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">XDocument 338 RouteValueDictionary 514 <a href="#bookmark3091">rows, joins 301</a> <a href="#bookmark4682">RPCs 492</a> <a href="#bookmark3386">RSS 341</a> <a href="#bookmark463">Ruby 3, </a><a href="#bookmark3960">405</a> rules</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1110">C# 2 type inference 75</a> <a href="#bookmark4132">DLR 424</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2617">dynamic typing 244</a> <a href="#bookmark4017">rules engines 411</a> <a href="#bookmark4288">Rumpelstiltskin 447</a> <a href="#bookmark613">runtime 21-</a><a href="#bookmark637">22, </a>521 <a href="#bookmark878">behavior of casting 45</a> <a href="#bookmark3969">RuntimeBinderException 407</a></font></p>
<p><a name="bookmark4876"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">S</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2969">sample data model 285</a> <a href="#bookmark2979">SampleData 285</a> <a href="#bookmark4064">sandboxing 415, </a>526 <a href="#bookmark4572">Sandcastle 482</a> <a href="#bookmark4594">sanity checking 485</a> <a href="#bookmark1340">Java compiler 100</a> <a href="#bookmark3712">SaveAs, Word 381</a> <a href="#bookmark4695">scaling 493</a> schedulers</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3524">LINQ to Rx 355</a> <a href="#bookmark3286">schema 329</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3243">LINQ to SQL 323</a> <a href="#bookmark1752">Scheme 145</a> <a href="#bookmark1302">scientific community 97</a> <a href="#bookmark1759">scope 145-</a><a href="#bookmark1766">146,</a><a href="#bookmark1800"> 152</a> <a href="#bookmark1791">captured variables 149</a> <a href="#bookmark1890">finally blocks 165</a> <a href="#bookmark4037">IronPython 412</a> <a href="#bookmark3176">query continuations 315</a> <a href="#bookmark3113">range variables in joins 302</a> <a href="#bookmark4027">ScriptEngine 411</a> <a href="#bookmark4029">ScriptHost 411</a> <a href="#bookmark4014">scripting 411</a> <a href="#bookmark4028">ScriptRuntime 411</a> <a href="#bookmark4036">ScriptScope 412</a> <a href="#bookmark4030">ScriptSource 411</a> <a href="#bookmark2697">sealed classes, adding</a> functionality 256 sealed modifier <a href="#bookmark2097">static classes 188</a> <a href="#bookmark2090">utility classes 187</a> <a href="#bookmark2667">second phase, type</a> inference 249 <a href="#bookmark1100">secondary constraints 73</a> <a href="#bookmark1949">security 171,</a><a href="#bookmark2205"> 199, </a><a href="#bookmark4065">415</a> <a href="#bookmark2815">Select 269,</a><a href="#bookmark2945"> 282,</a><a href="#bookmark3195"> 317, </a>503 <a href="#bookmark2992">select, contextual keyword 287</a> <a href="#bookmark3147">SelectMany 310,</a><a href="#bookmark3419"> 344, </a>503 semantics</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3646">clarifying with named</a> arguments 373 <a href="#bookmark1373">magic value pattern 105</a> <a href="#bookmark886">value types and reference</a> types 45 <a href="#bookmark4877">semicolons, lambda</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4877">expressions 231,</a><a href="#bookmark2518"> 234</a> <a href="#bookmark516">separation of concerns 13</a> <a href="#bookmark1877">sequence diagrams 162</a> <a href="#bookmark3146">sequence of sequences 308</a> SequenceEqual 500 <a href="#bookmark1824">sequences 156,</a><a href="#bookmark2924"> 280</a> <a href="#bookmark3148">generating in</a> SelectMany 310 <a href="#bookmark3092">joins 301</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3428">produced and consumed by</a> LINQ to XML 345 <a href="#bookmark1867">sequential execution, appear</a>ance of iterator blocks 161 <a href="#bookmark2057">serialization 183,</a><a href="#bookmark2420"> 223, </a><a href="#bookmark2623">245</a> <a href="#bookmark3249">Server Explorer, Visual</a> Studio 323 <a href="#bookmark3043">service pack 1 293</a> service-oriented</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">applications 523 set-based operators 506</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">SetEquals 516 SetItem 513 <a href="#bookmark2108">setters 189,</a><a href="#bookmark2240"> 205</a> <a href="#bookmark4513">SetUnwind 471</a> <a href="#bookmark4042">SetVariable 413</a> <a href="#bookmark4878">Seurat, George 93</a> <a href="#bookmark2169">SHA-1 195</a> <a href="#bookmark4315">Shakespeare 453</a> <a href="#bookmark1801">sharing, captured variables 152</a> <a href="#bookmark4879">short methods 461</a> <a href="#bookmark1595">short-circuiting 128</a> <a href="#bookmark1925">shortcomings, first edition</a> Range class 170 shorthand</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark762">delegate combination 33</a> <a href="#bookmark739">delegate invocation 31</a> <a href="#bookmark3641">Show 372</a> shrink-wrapped</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4624">applications 487</a> side effects 11,<a href="#bookmark2079"> 186, </a><a href="#bookmark4341">455</a> <a href="#bookmark3658">argument evaluation 374</a> <a href="#bookmark4436">purity 463</a> side-by-side execution 526 <a href="#bookmark2829">side-effect-free code 271</a> <a href="#bookmark4517">signatures, custom rewriter</a> methods 472 <a href="#bookmark2206">signed assemblies 199</a> <a href="#bookmark2913">silver bullet 280</a> <a href="#bookmark3477">Silverlight 350, </a>526 <a href="#bookmark1808">simplicity 154</a> <a href="#bookmark485">simplification, automatically</a> implemented properties 7 <a href="#bookmark3270">Single 326, </a>499 <a href="#bookmark4094">single dispatch 419</a> <a href="#bookmark4349">single exit point 455</a> <a href="#bookmark1955">single method interfaces,</a> delegates 172 <a href="#bookmark4880">single parameter lambda</a> expressions 232 <a href="#bookmark1846">single responsibility</a> principle 159 <a href="#bookmark3443">single threading, Mandelbrot</a> generation 347 <a href="#bookmark984">single-class hierarchy 58</a> <a href="#bookmark4540">single-dimensional arrays 476</a> <a href="#bookmark3808">single-method interfaces 392</a> <a href="#bookmark702">comparison with</a> delegates 28 SingleOrDefault 499 <a href="#bookmark4174">site containers 429</a> <a href="#bookmark2972">SkeetySoft 285</a> Skip 503 SkipWhile 503 <a href="#bookmark2211">sn 199</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">snapshots 518-519 <a href="#bookmark663">snippets 23</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark674">Snippy 24,</a><a href="#bookmark1677"> 138,</a><a href="#bookmark2562"> 239, </a><a href="#bookmark4165">428</a> <a href="#bookmark4881">sock puppets 492</a> <a href="#bookmark2905">software engineering 278</a> <a href="#bookmark4700">solid state drives 493</a> <a href="#bookmark2064">Solution Explorer 184,</a><a href="#bookmark2142"> 194</a> <a href="#bookmark4882">Sondheim, Stephen 93</a> <a href="#bookmark504">Sort 10,</a><a href="#bookmark1724"> 142,</a><a href="#bookmark2512"> 233,</a><a href="#bookmark2830"> 271, </a>511 <a href="#bookmark1286">custom comparisons 95</a> <a href="#bookmark2292">SortedDictionary&lt;TKey,</a> <a href="#bookmark2292">TValue&gt; 210, </a>515 <a href="#bookmark2291">SortedList&lt;TKey, TValue&gt; 210,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">515</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">SortedSet&lt;T&gt; 510 <a href="#bookmark500">sorting 9,</a><a href="#bookmark1721"> 142,</a><a href="#bookmark2707"> 257,</a><a href="#bookmark2820"> 270</a> <a href="#bookmark1582">implementing custom</a> comparisons 126 <a href="#bookmark2515">lambda expressions 234</a> stability 511 sorting operators 507 <a href="#bookmark668">source code 23,</a><a href="#bookmark2991"> 286</a> <a href="#bookmark2163">source files, checksums 195</a> <a href="#bookmark4353">Spec# 455, </a><a href="#bookmark4530">473</a> <a href="#bookmark2091">specialization 187,</a><a href="#bookmark2695"> 256</a> <a href="#bookmark616">specification 22,</a><a href="#bookmark685"> 25,</a><a href="#bookmark2237"> 205</a> <a href="#bookmark3704">C# 4 compliance 380</a> <a href="#bookmark1166">ubiquity of generics 81</a> SPOT 527 <a href="#bookmark1534">SQL 120,</a><a href="#bookmark3017"> 290</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark565">converted from query</a> <a href="#bookmark565">expressions 17,</a><a href="#bookmark575"> 19,</a><a href="#bookmark2593"> 243,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3234">322, </a><a href="#bookmark3258">325</a> <a href="#bookmark3088">joins 301-</a><a href="#bookmark3110">302,</a><a href="#bookmark3130"> 306,</a><a href="#bookmark3280"> 328</a> SQL Server 523 <a href="#bookmark3237">SQL Server 2005 322, </a>525 <a href="#bookmark3277">SQL Server Management</a> Studio Express 327 <a href="#bookmark1219">square brackets, reflection over</a> generics 89 <a href="#bookmark874">stack 44, </a><a href="#bookmark894">46,</a><a href="#bookmark1781"> 149</a> <a href="#bookmark1767">stack frames 146</a> <a href="#bookmark4459">stack overflow, recursion in</a> Code Contracts 465 Stack&lt;T&gt; 518</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2954">standard query operators 284,</a> <a href="#bookmark3302">330, </a><a href="#bookmark3538">357, </a>495 <a href="#bookmark3453">parallel equivalents 348</a> <a href="#bookmark1084">standards 71</a> <a href="#bookmark2374">Start 218</a> <a href="#bookmark2602">StartsWith 244</a> state</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2002">asynchronous web service</a> calls 176 <a href="#bookmark4409">invariants 459</a> <a href="#bookmark1843">iterators 158</a> <a href="#bookmark2088">utility classes 187</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1868">state machines, generated for</a> iterator blocks 161 <a href="#bookmark2832">statefulness 271</a> <a href="#bookmark4367">static checker 456,</a><a href="#bookmark4425"> 461, </a><a href="#bookmark4523">472,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4629">487</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4416">restrictions on invariants 461</a> <a href="#bookmark1161">static classes 80,</a><a href="#bookmark2080"> 186,</a><a href="#bookmark2705"> 257</a> <a href="#bookmark4170">call site storage 429</a> <a href="#bookmark4192">extension methods and</a> dynamic code 433 <a href="#bookmark1454">Nullable 111</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2731">requirement for extension</a> methods 260 <a href="#bookmark1172">static constructors 82,</a><a href="#bookmark2246"> 206,</a><a href="#bookmark2365"> 218</a> <a href="#bookmark1168">static fields, generic types 81</a> <a href="#bookmark1171">static initializers 82</a> <a href="#bookmark1309">static interfaces 98</a> static members</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2241">automatic properties 205</a> <a href="#bookmark2243">thread safety 205</a> <a href="#bookmark946">static methods 52,</a><a href="#bookmark2699"> 256</a> <a href="#bookmark2804">chaining with extension</a> methods 268 custom rewriter methods <a href="#bookmark4515">(Code Contracts) 472</a> <a href="#bookmark743">delegate example 32</a> <a href="#bookmark4193">dynamic code 433-</a><a href="#bookmark4203">434</a> <a href="#bookmark724">using to create delegate</a> instances 30 <a href="#bookmark2083">utility classes 187</a> <a href="#bookmark2094">static modifier, static</a> classes 188 static types</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark789">expressions 37</a> <a href="#bookmark3696">targets of method calls 380</a> <a href="#bookmark605">static typing 21,</a><a href="#bookmark786"> 37,</a><a href="#bookmark1644"> 134, </a><a href="#bookmark2302">211,</a> <a href="#bookmark3906">401,</a><a href="#bookmark4658">491</a> <a href="#bookmark2556">expression trees 238</a> <a href="#bookmark943">implicitly typed local</a> variables 51 <a href="#bookmark4007">productivity 410</a> <a href="#bookmark2039">static variables,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">initialization 182 <a href="#bookmark1666">Stream 136</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1983">streaming 174,</a><a href="#bookmark2939"> 282, </a>495</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3554">custom LINQ operators 358</a> <a href="#bookmark3149">flattening and cross</a> joins 310 <a href="#bookmark3134">group joins 306</a> <a href="#bookmark3112">inner joins 302</a> <a href="#bookmark2789">streaming data 267</a> <a href="#bookmark1963">StreamReader 173</a> <a href="#bookmark2710">streams 258</a> <a href="#bookmark2718">StreamUtil 258</a> <a href="#bookmark4033">string literals, Python 412</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4438">String, purity 463</a> <a href="#bookmark826">StringCollection 40</a> <a href="#bookmark1153">StringComparer 78, </a><a href="#bookmark3204">318</a> strings</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark759">immutability 33</a> <a href="#bookmark679">reversing 25</a> <a href="#bookmark4883">strongly typed collections 6,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark785">36, </a><a href="#bookmark814">40,</a><a href="#bookmark934"> 51,</a><a href="#bookmark3044"> 293, </a><a href="#bookmark4200">434</a> <a href="#bookmark818">.NET 1.1 40</a> <a href="#bookmark1330">Stroustrup, Bjarne 100,</a><a href="#bookmark2605"> 244</a> struct</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2247">automatically implemented</a> properties 206 <a href="#bookmark860">keyword 43</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1068">value type constraints 70</a> structural comparisons 525 <a href="#bookmark2181">structures 196</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3211">style, query expressions and dot</a> notation 319 <a href="#bookmark876">subclassing, reference types</a> and value types 45 <a href="#bookmark2223">subjective readability 204</a> <a href="#bookmark3164">subsequences, grouping 312</a> <a href="#bookmark1037">substitution of type parameters</a> with type arguments 63 suffixes</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2198">attributes 198</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4485">I...Contracts 468</a> <a href="#bookmark4884">-suggest (command line</a> option) 474 <a href="#bookmark2848">Sum 272, </a>495 dynamic</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4076">implementation 416</a> <a href="#bookmark4437">purity 463</a> <a href="#bookmark661">super awesome code 23</a> <a href="#bookmark3072">supercomputers, string length</a> computations 299 <a href="#bookmark682">surrogate pairs 25</a> <a href="#bookmark1908">switch statements, iterator</a> blocks 168 Symbian S60 526 SymmetricExceptWith 516 <a href="#bookmark1594">symmetry 128</a> <a href="#bookmark4885">synchronous delegate</a> invocation 31 <a href="#bookmark1996">synchronous service access 175</a> <a href="#bookmark3732">SynonymInfo 383</a> <a href="#bookmark1604">syntactic sugar, delegates 131</a> syntax</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3931">checking in dynamic</a> languages 403 <a href="#bookmark552">consistency for queries in</a> LINQ 16 <a href="#bookmark2875">domain specific</a> languages 274</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3188">options for queries 317</a> <a href="#bookmark559">query expressions 16</a> System.AddIn 524 <a href="#bookmark817">System.Collections 40</a> System.Collections.Concurrent 518</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1145">System.Collections.Generic 78,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">508</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">System.Collections.Object-Model 513 <a href="#bookmark819">System.Collections.Specialized</a> 40</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1632">System.Delegate 134</a> <a href="#bookmark4359">System.Diagnostics.Contracts</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">456</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1075">System.Enum 70</a> <a href="#bookmark3480">System.Interactive 351</a> <a href="#bookmark3450">System.Linq, Parallel</a> LINQ 347 <a href="#bookmark2539">System.Linq.Expressions 237</a> <a href="#bookmark2085">System.Math 187</a> <a href="#bookmark1453">System.Nullable 111</a> System.Numeric 525 <a href="#bookmark3481">System.Reactive 351</a> <a href="#bookmark1076">System.ValueType 70</a> <a href="#bookmark3334">System.Xml.Linq 338</a></font></p>
<p><a name="bookmark4886"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">T</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">Table<a href="#bookmark3269"> 325</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">TableLayoutPanel 523 tables</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3144">cross joins 308</a> <a href="#bookmark3244">LINQ to SQL 323</a> <a href="#bookmark3121">navigating via joins 304</a> <a href="#bookmark3090">table-valued functions 301</a> Take 503 TakeWhile 503 <a href="#bookmark725">target, delegates 30,</a><a href="#bookmark744"> 32</a> <a href="#bookmark4143">Target, DLR cache 425</a> <a href="#bookmark2013">Tatham, Simon 178</a> <a href="#bookmark2307">team preferences 211,</a><a href="#bookmark2377"> 219,</a><a href="#bookmark2892"> 276</a> <a href="#bookmark1709">consistency in</a> formatting 141 <a href="#bookmark1805">tedious coding 153,</a><a href="#bookmark2439"> 226</a> <a href="#bookmark1329">template</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">metaprogramming 99 <a href="#bookmark1141">templates 78, </a><a href="#bookmark1253">91</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1390">code generation 106</a> <a href="#bookmark4887">temporary local variable, used</a> for object initializers 213 <a href="#bookmark2314">temporary values 212</a> <a href="#bookmark3273">temporary variable, let</a> clauses 326 <a href="#bookmark873">terminology 44,</a><a href="#bookmark2195"> 198,</a><a href="#bookmark2738"> 260</a> <a href="#bookmark2793">ambiguity of &quot;lazy&quot; and</a> &quot;eager&quot; 267 CLR arrays and vectors 512 <a href="#bookmark3775">covariance and</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">contravariance 388 <a href="#bookmark3184">dot notation and query</a> expressions 317 <a href="#bookmark1098">generic type constraints 73</a> <a href="#bookmark1027">generics 62</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1465">nullable type and nullable</a> value type 113 <a href="#bookmark3581">parameters and</a> arguments 366 <a href="#bookmark1756">variable classifications 145</a> wrapping and <a href="#bookmark1432">unwrapping 108</a> <a href="#bookmark2836">testable code 272</a> <a href="#bookmark4588">test-first coding 484</a> <a href="#bookmark1951">text encodings 171</a> <a href="#bookmark3588">reading files 366</a> <a href="#bookmark3354">text nodes, LINQ to XML 338</a> <a href="#bookmark1932">TextReader 170</a><a href="#bookmark1953">-171</a> <a href="#bookmark2824">ThenBy 270,</a><a href="#bookmark3063"> 297, </a>507 <a href="#bookmark2825">ThenByDescending 270,</a><a href="#bookmark3061"> 297,</a> 507</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2936">thinking in sequences 281</a> <a href="#bookmark2901">third-party libraries 277</a> <a href="#bookmark4518">changing contract</a> behavior 472 <a href="#bookmark3229">third-party LINQ providers 322</a> <a href="#bookmark1760">this 145,</a><a href="#bookmark1788"> 149</a> <a href="#bookmark1691">anonymous methods 140</a> <a href="#bookmark2249">constructor chaining 206</a> <a href="#bookmark2732">declaring extension</a> methods 260 <a href="#bookmark729">delegate target 30</a> <a href="#bookmark3895">locking 399</a> <a href="#bookmark4292">meta-object</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">construction 448 <a href="#bookmark1774">thread pool 147,</a><a href="#bookmark2000"> 176</a> <a href="#bookmark760">thread safety 33,</a><a href="#bookmark2239"> 205,</a><a href="#bookmark2839"> 272,</a><a href="#bookmark3893"> 399</a> <a href="#bookmark1775">threading 147,</a><a href="#bookmark2004"> 176,</a><a href="#bookmark3437"> 346, </a><a href="#bookmark4172">429</a> <a href="#bookmark1415">immutability 108,</a><a href="#bookmark2422"> 223</a> <a href="#bookmark3522">LINQ to Rx 355</a> <a href="#bookmark3523">ThreadPool (reactive</a> extensions) 355 <a href="#bookmark1807">threads 154,</a><a href="#bookmark1997"> 175, </a>518 <a href="#bookmark3880">robust locking 398</a> thread-safety 508 <a href="#bookmark1624">ThreadStart 133,</a><a href="#bookmark1670"> 137,</a><a href="#bookmark1739"> 144</a> <a href="#bookmark4888">ThreadStatic 81</a> <a href="#bookmark2233">throwaway code 205,</a><a href="#bookmark2309"> 211</a> timeouts 519 <a href="#bookmark3377">times, LINQ to XML</a> <a href="#bookmark3377">content 340</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1419">TimeSpan 108, </a><a href="#bookmark4083">417</a> <a href="#bookmark3629">timestamp 370</a> TimeZoneInfo 524 <a href="#bookmark2184">TIME_ZONE_INFORMATION</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">196</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3741">tlbimp. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Type Library Importer <a href="#bookmark3444">ToArray 347, </a>497, 518 <a href="#bookmark3191">ToDictionary 317, </a>497 <a href="#bookmark3208">ToList 318, </a>497 ToLookup 497, 501 <a href="#bookmark4889">Tony the Pony 492</a> <a href="#bookmark2058">tools 183</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4358">Code Contracts 456, </a><a href="#bookmark4450">464</a> <a href="#bookmark2266">tooltips 207</a> <a href="#bookmark2410">anonymous types 222</a> <a href="#bookmark2743">extension methods 261</a> <a href="#bookmark908">ToString 48,</a><a href="#bookmark3384"> 340, </a><a href="#bookmark4249">440</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2418">anonymous types 223,</a><a href="#bookmark2827"> 271</a> <a href="#bookmark4234">ExpandoObject 437</a> <a href="#bookmark1425">Nullable&lt;T&gt; 108</a> <a href="#bookmark2847">totals, calculating with</a> LINQ 272 Toub, Stephen 519 transaction management <a href="#bookmark3265">LINQ to SQL 325</a> transformations</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2230">automatically implemented</a> properties 205 <a href="#bookmark2935">LINQ sequences 281</a> translations</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3172">query continuations 314</a> <a href="#bookmark2915">query expressions 280, </a><a href="#bookmark2996">287</a> transparency 526 <a href="#bookmark3068">transparent identifiers 298</a> <a href="#bookmark3078">implementation 300</a> <a href="#bookmark3125">inner joins 305</a> <a href="#bookmark3214">query expression</a> readability 319 <a href="#bookmark3346">tree, LINQ to XML 338</a> <a href="#bookmark1010">trial and error 60</a> TrimExcess 510 <a href="#bookmark4034">triple quotes, Python string</a> literals 412 <a href="#bookmark2227">trivial properties 205,</a><a href="#bookmark2437"> 225-</a><a href="#bookmark2441">226</a> <a href="#bookmark1707">formatting 141</a> <a href="#bookmark1506">true operator 117</a> <a href="#bookmark1525">truth tables 119</a> <a href="#bookmark1864">try/catch and try/finally, in</a> iterator blocks 161 TryAdd 518 <a href="#bookmark4263">TryGetMember 444</a> TryGetValue 509 <a href="#bookmark4261">TryInvokeMember() 444</a> <a href="#bookmark1568">TryParse 125</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">TryPeek 519 TryTake 518 <a href="#bookmark1115">TryXXX pattern 76,</a><a href="#bookmark1567"> 125</a> <a href="#bookmark4245">DynamicObject 440, </a><a href="#bookmark4257">443</a> <a href="#bookmark3248">T-SQL 323</a> <a href="#bookmark4664">Tuple 491, </a>525 <a href="#bookmark1480">Turing, Alan 115</a> <a href="#bookmark2657">two-phase type inference 248</a> <a href="#bookmark2129">type aliases 190</a> <a href="#bookmark1026">type arguments 62,</a><a href="#bookmark1102"> 74, </a><a href="#bookmark1318">98,</a><a href="#bookmark2646"> 246,</a> <a href="#bookmark3801">391</a> <a href="#bookmark4210">dynamic 434</a> <a href="#bookmark3834">generic variance 395</a> <a href="#bookmark4043">GetVariable 413</a> <a href="#bookmark4378">preconditions 456</a> <a href="#bookmark1059">type constraints 69, </a><a href="#bookmark1287">95</a> <a href="#bookmark1591">avoiding boxing 128</a> <a href="#bookmark1064">class 69</a> <a href="#bookmark1096">combining 73</a> <a href="#bookmark1086">conversion 71</a> <a href="#bookmark1077">new() 70</a> <a href="#bookmark1304">numeric 97</a> <a href="#bookmark2038">partial types 181</a> <a href="#bookmark1099">primary 73</a> <a href="#bookmark1100">secondary 73</a> <a href="#bookmark1069">struct 70</a> <a href="#bookmark1092">type parameter</a> constraints 71 type declarations <a href="#bookmark4204">dynamic 434</a> <a href="#bookmark2034">partial 181</a> type equivalence 526 <a href="#bookmark1342">type erasure 101, </a><a href="#bookmark3873">397</a> <a href="#bookmark2458">type inference 228,</a><a href="#bookmark2635"> 246, </a><a href="#bookmark2997">287,</a> <a href="#bookmark3802">391, </a><a href="#bookmark4663">491</a> <a href="#bookmark2405">anonymous types 222,</a><a href="#bookmark2428"> 224</a> <a href="#bookmark1101">C# 2 74</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4185">dynamic code compile-time</a> checking 432 <a href="#bookmark4890">generics 69, </a><a href="#bookmark1159">80,</a><a href="#bookmark1458"> 112</a> <a href="#bookmark1296">hiding variance</a> workarounds 96 <a href="#bookmark564">implicitly typed local</a> <a href="#bookmark564">variables 16,</a><a href="#bookmark799"> 38,</a><a href="#bookmark2264"> 207, </a><a href="#bookmark3980">408</a> <a href="#bookmark3026">query expressions 291</a> <a href="#bookmark2685">summary of changes in</a> C# 3 254 <a href="#bookmark2658">two-phase (C# 3) 248</a> <a href="#bookmark2246">type initializers 206</a> <a href="#bookmark3740">Type Library Importer 385</a> <a href="#bookmark1023">type parameters 62, </a><a href="#bookmark1216">89</a> <a href="#bookmark1519">comparisons with null 118</a> <a href="#bookmark1092">constraints 71</a> <a href="#bookmark3788">covariance 389</a> covariance and <a href="#bookmark1283">contravariance 95</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4205">dynamic 434</a> <a href="#bookmark2474">Func and Action delegate</a> types 229 <a href="#bookmark1050">generic methods 65</a> <a href="#bookmark3774">generic variance 387</a> <a href="#bookmark4891">naming conventions 65</a> <a href="#bookmark2267">tooltips 207</a> <a href="#bookmark2540">Type property, expression</a> trees 237 <a href="#bookmark803">type safety 38,</a><a href="#bookmark995"> 59, </a><a href="#bookmark1250">91</a><a href="#bookmark1267">-92,</a><a href="#bookmark1385"> 106</a> <a href="#bookmark993">compile time vs execution</a> time 59 <a href="#bookmark1291">contravariance 96</a> <a href="#bookmark3772">generic variance 387</a> <a href="#bookmark782">type system 36, </a><a href="#bookmark4641">488</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark994">improving robustness 59</a> <a href="#bookmark2663">type variables, bounds 249</a> <a href="#bookmark1226">Type, System.Type 89</a> <a href="#bookmark3763">Type.GetTypeFromCLSID 386</a> <a href="#bookmark3710">Type.Missing 381</a> <a href="#bookmark1300">typedef 97</a> <a href="#bookmark4153">TypedReference 427</a> <a href="#bookmark3756">TypeIdentifier 386</a> <a href="#bookmark2384">typeless expressions 219</a> <a href="#bookmark4892">typeof 48,</a><a href="#bookmark1034"> 63,</a><a href="#bookmark1125"> 76,</a><a href="#bookmark1209"> 88, </a><a href="#bookmark1232">90,</a><a href="#bookmark2586"> 242,</a> <a href="#bookmark2620">244</a> <a href="#bookmark4215">dynamic 435</a> <a href="#bookmark1472">nullable types 113</a></font></p>
<p><a name="bookmark4893"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">U</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4347">uint 455</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1512">unary operators 117</a> <a href="#bookmark1029">unbound generic types 62, </a><a href="#bookmark1211">88</a> <a href="#bookmark904">unboxing 47, </a><a href="#bookmark1001">59,</a><a href="#bookmark1388"> 106, </a><a href="#bookmark4045">413, </a>510 <a href="#bookmark1194">avoiding in C# 1 85</a> <a href="#bookmark1443">choice of nullable or non-</a>nullable target type 110 <a href="#bookmark3041">conversions 293</a> <a href="#bookmark1474">uncertainty, ? modifier 114</a> <a href="#bookmark1095">Unconstrained Melody 72</a> <a href="#bookmark1061">unconstrained type</a> parameters 69 <a href="#bookmark1407">underlying type 107</a> <a href="#bookmark2661">unfixed type variables 249</a> <a href="#bookmark2072">unimplemented partial</a> methods 185 <a href="#bookmark1113">uninitialized fields, default</a> values 75 Union 506 UnionWith 516 <a href="#bookmark2884">unit testing 275,</a><a href="#bookmark3861"> 396</a> <a href="#bookmark4519">frameworks 472</a> <a href="#bookmark2062">unit tests 184,</a><a href="#bookmark2203"> 199,</a><a href="#bookmark3545"> 357</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4491">contracts 469, </a><a href="#bookmark4550">478, </a><a href="#bookmark4579">483, </a><a href="#bookmark4593">485</a> unit tests </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">(continued)</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3929">dynamic typing 403, </a><a href="#bookmark3970">407,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4186">432</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2368">sample data 218</a> <a href="#bookmark527">unknown values 14</a> <a href="#bookmark2188">UnmanagedType.ByValArray</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">197</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3456">unordered queries 349</a> <a href="#bookmark4559">unprovable contracts 479</a> <a href="#bookmark2123">unqualified names 190</a> <a href="#bookmark4534">unreachable code 474</a> <a href="#bookmark783">unsafe code 36,</a><a href="#bookmark2175"> 196, </a><a href="#bookmark3984">408</a> <a href="#bookmark4346">unsigned types 455</a> <a href="#bookmark1699">unspeakable names 140,</a><a href="#bookmark2231"> 205</a> <a href="#bookmark4415">invariants 460</a> <a href="#bookmark1905">iterators 167</a> <a href="#bookmark794">untyped variables 38</a> <a href="#bookmark1693">unverifiable code 140</a> <a href="#bookmark1488">unwrapping 116</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1434">nullable value types 108</a> <a href="#bookmark3341">URI, XML namespaces 338</a> <a href="#bookmark856">URLs 43</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1361">comparison with</a> references 104 <a href="#bookmark4686">user groups 492</a> <a href="#bookmark2021">user interfaces 180,</a><a href="#bookmark2843"> 272</a> <a href="#bookmark1493">user-defined conversions 116,</a> <a href="#bookmark4158">427</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3609">default parameter values 368</a> <a href="#bookmark3840">invalid in generic</a> variance 395 Nullable<a href="#bookmark1495"> 117</a> <a href="#bookmark1509">user-defined operators 117</a> <a href="#bookmark2981">Users, sample data model 285</a> <a href="#bookmark667">using directives 23,</a><a href="#bookmark1592"> 128,</a><a href="#bookmark1977"> 173,</a> <a href="#bookmark2125">190,</a><a href="#bookmark2140"> 193, </a><a href="#bookmark4191">433</a> <a href="#bookmark2747">extension methods 262</a> <a href="#bookmark1937">using statements 170</a> <a href="#bookmark2280">implicitly typed local</a> variables 209 <a href="#bookmark1895">iterator blocks 165</a> <a href="#bookmark3561">iterator disposal 358</a> <a href="#bookmark3630">UTC 371</a> <a href="#bookmark683">UTF-16 25</a> <a href="#bookmark1952">UTF-8 171, </a><a href="#bookmark3590">366</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3628">UTF8 (encoding property) 370</a> <a href="#bookmark947">utility code 52,</a><a href="#bookmark1926"> 170,</a><a href="#bookmark2082"> 186,</a><a href="#bookmark2706"> 257,</a> <a href="#bookmark2861">274</a></font></p>
<p><a name="bookmark4894"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">V</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2109">validation 189,</a><a href="#bookmark2229"> 205,</a><a href="#bookmark3677"> 377</a> <a href="#bookmark1976">arguments 173, </a><a href="#bookmark2887">276,</a><a href="#bookmark3546"> 357</a> <a href="#bookmark1881">iterator blocks 164,</a><a href="#bookmark1978"> 174</a> <a href="#bookmark4337">explicit vs implicit 455</a> <a href="#bookmark2069">partial methods 185</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1405">Value 107,</a><a href="#bookmark1522"> 119</a> <a href="#bookmark3999">Excel 409</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark1404">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>Nullable, Value property</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1069">value type constraints 70,</a><a href="#bookmark1133"> 77</a> <a href="#bookmark1406">Nullable&lt;T&gt; 107</a> <a href="#bookmark3839">value type conversions, invalid</a> in generic variance 395 <a href="#bookmark528">value types 14,</a><a href="#bookmark619"> 22, </a><a href="#bookmark849">42,</a><a href="#bookmark1343"> 101</a> <a href="#bookmark2696">adding functionality 256</a> <a href="#bookmark1417">immutability 108</a> <a href="#bookmark1356">null values 104</a> <a href="#bookmark973">nullability 53</a> <a href="#bookmark1410">Nullable&lt;T&gt; 107</a> <a href="#bookmark1080">satisfying constructor type</a> constraints 70 <a href="#bookmark1073">type constraints 70</a> <a href="#bookmark4404">ValueAtReturn 459</a> <a href="#bookmark561">var 16,</a><a href="#bookmark798"> 38,</a><a href="#bookmark941"> 51</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2393">anonymous types 221</a> <a href="#bookmark3977">comparison with</a> dynamic 408 <a href="#bookmark2256">contextual keyword 207</a> <a href="#bookmark2819">projections 270</a> variables <a href="#bookmark2381">arrays 219</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2566">assigning values in expres</a>sion trees 239 <a href="#bookmark489">automatically implemented</a> properties 7 <a href="#bookmark2228">backing trivial</a> properties 205 <a href="#bookmark1770">behavior when captured 146</a> <a href="#bookmark1327">C++ template arguments 99</a> <a href="#bookmark1563">declarations for out</a> parameters 124 <a href="#bookmark563">implicit typing 16</a> <a href="#bookmark892">location in memory 46</a> <a href="#bookmark4568">naming 482</a> <a href="#bookmark3718">pass-by-reference</a> parameters 382 <a href="#bookmark3021">range variables 290</a> <a href="#bookmark1363">value type values 104</a> <a href="#bookmark1265">variance 92</a> <a href="#bookmark3853">API design 396</a> <a href="#bookmark3769">C# 4 387</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1646">different flavors 135</a> <a href="#bookmark3820">nesting 394</a> <a href="#bookmark2261">VARIANT 207, </a><a href="#bookmark3951">404</a> <a href="#bookmark3837">variant conversions 395</a> <a href="#bookmark3765">variants 386</a> <a href="#bookmark2963">VB. </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"></a>See</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> Visual Basic <a href="#bookmark656">VB.NET 23</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark657">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> V</a>isual Basic <a href="#bookmark2263">VB6 207</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1331">vector&lt;T&gt; 100</a> <a href="#bookmark4541">vectors 476</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;">CLR terminology 512 <a href="#bookmark4327">verification 454</a> version numbers 521 <a href="#bookmark660">versioning 23,</a><a href="#bookmark1345"> 101,</a><a href="#bookmark3618"> 369,</a><a href="#bookmark3631"> 371</a> <a href="#bookmark3742">COM 385</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2902">extension methods 277</a> <a href="#bookmark3089">views 301</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1344">virtual machine, Java 101</a> <a href="#bookmark791">virtual methods 37, </a><a href="#bookmark842">41,</a><a href="#bookmark2026"> 180,</a> <a href="#bookmark2070">185,</a><a href="#bookmark3924"> 403</a> Collection 513 <a href="#bookmark4472">contracts 467</a> <a href="#bookmark2059">partial types 183</a> <a href="#bookmark4379">visibility, preconditions 457</a> <a href="#bookmark1042">Visual Basic 64,</a><a href="#bookmark3585"> 366,</a><a href="#bookmark3706"> 380,</a><a href="#bookmark3725"> 383,</a> <a href="#bookmark4266">445</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark588">COM support 19</a> <a href="#bookmark2962">VB 9 284</a> <a href="#bookmark676">Visual Studio 24,</a><a href="#bookmark2141"> 193-</a><a href="#bookmark2156">194,</a><a href="#bookmark2779"> 265,</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3246">323,</a> <a href="#bookmark3750">385, </a><a href="#bookmark4895">456, </a>521 <a href="#bookmark4573">Code Contracts 482, </a><a href="#bookmark4680">492</a> <a href="#bookmark2265">hovering for more</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2265">information 207,</a><a href="#bookmark2409"> 222,</a><a href="#bookmark2742"> 261</a> <a href="#bookmark4280">Visual Studio 2010 446</a> <a href="#bookmark2577">expression tree</a> visualizer 242 <a href="#bookmark4368">Premium and Ultimate</a> editions 456 <a href="#bookmark2578">visualizer, expression trees 242</a> <a href="#bookmark4294">void 448</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2472">return type of Action 229</a> <a href="#bookmark2076">void return type, partial</a> methods 186 <a href="#bookmark3758">_VtblGap 386</a></font></p>
<p><a name="bookmark4896"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">W</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2154">warnings 194, </a><a href="#bookmark4653">491</a> <a href="#bookmark1680">breaking changes 138</a> <a href="#bookmark2759">hidden extension</a> methods 263 <a href="#bookmark1518">nullable comparisons 118</a> <a href="#bookmark2149">pragma directives 194</a> <a href="#bookmark3938">Watch window, Visual</a> Studio 403 WCF 523</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark785">weak typing 36,</a><a href="#bookmark2259"> 207</a> <a href="#bookmark3992">APIs 409</a> <a href="#bookmark816">collections 40</a> <a href="#bookmark854">web pages, reference type</a> analogy 43 <a href="#bookmark577">web services 19</a><a href="#bookmark599">-20,</a><a href="#bookmark1995"> 175,</a><a href="#bookmark2598"> 243,</a> <a href="#bookmark2844">272,</a><a href="#bookmark2959"> 284, </a><a href="#bookmark4625">487</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2721">WebRequest 259</a> <a href="#bookmark2722">WebResponse 259</a> WF 524</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark2295">what versus how 210-</a><a href="#bookmark2306">211,</a><a href="#bookmark2860"> 273</a> <a href="#bookmark520">Where 13,</a><a href="#bookmark1967"> 173, </a><a href="#bookmark2795">267, </a><a href="#bookmark2946">282,</a><a href="#bookmark3048"> 294,</a> <a href="#bookmark3193">317, </a>505 where clause <a href="#bookmark3049">combining 294</a> <a href="#bookmark3009">contextual keyword 288</a> <a href="#bookmark1062">type constraints 69</a> <a href="#bookmark1837">while 157</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1708">whitespace 141,</a><a href="#bookmark2337"> 215</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4040">sensitivity of Python 413</a> <a href="#bookmark1346">wildcards, Java 101</a> <a href="#bookmark659">Windows 23</a> <a href="#bookmark2182">Windows APIs 196</a> <a href="#bookmark4692">Windows Azure 492</a> Windows CardSpace 524 Windows Communication Foundation 523 <a href="#bookmark652">Windows Forms 23,</a><a href="#bookmark4897"> 108,</a><a href="#bookmark1653"> 135,</a> <a href="#bookmark2023">180, </a>523 <a href="#bookmark610">Windows Live ID 21</a> Windows Mobile 526 Windows Phone 7 526 <a href="#bookmark4898">Windows Presentation</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4898">Foundation 108, </a>513, 523 Windows Workflow Foundation 524 Wintellect 520 <a href="#bookmark3461">WithCancellation 349</a> <a href="#bookmark3462">WithDegreeOfParallelism 349</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3466">WithExecutionMode 350</a> <a href="#bookmark3467">WithMergeOptions 350</a> <a href="#bookmark3707">Word 380</a> <a href="#bookmark3932">word processor 403</a> <a href="#bookmark3866">workaround 397</a> <a href="#bookmark3996">Worksheet, Excel 409</a> WPF 513, 523 <a href="#bookmark529">wrapper classes 14</a> <a href="#bookmark1433">wrapping, nullable value</a> types 108 <a href="#bookmark3971">WriteLine 407</a> <a href="#bookmark2724">WriteTo 259</a></font></p>
<p><a name="bookmark4899"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">X</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3335">X, prefix for LINQ to XML</a> types 338 <a href="#bookmark2047">XAML 183, </a>527</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;"><a href="#bookmark2048">See also</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> </a>Extensible Application Markup Language <a href="#bookmark3348">XAttribute 338</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3410">explicit conversion 343</a> Xbox 360 526 <a href="#bookmark3357">XCData 338</a> <a href="#bookmark3349">XComment 338</a> <a href="#bookmark3352">XContainer 338</a> <a href="#bookmark3350">XDeclaration 338</a> <a href="#bookmark3360">XDocument 338</a> <a href="#bookmark3358">XElement 338, </a><a href="#bookmark4232">436</a> <a href="#bookmark3411">conversions 343</a> <a href="#bookmark567">XML 17, </a><a href="#bookmark2369">218, </a><a href="#bookmark2919">280,</a><a href="#bookmark3332"> 337, </a><a href="#bookmark4231">436</a> <a href="#bookmark651">comments 23</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4058">configuration files 414</a> <a href="#bookmark4334">documentation 454, </a><a href="#bookmark4567">480</a> generated by</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4369">ccdocgen 456</a> <a href="#bookmark3383">formatting of numbers and</a> other data types 340 <a href="#bookmark3365">XmlDocument 338</a> <a href="#bookmark3593">XmlReader.Create, overload</a>ing complexity 367 <a href="#bookmark3594">XmlReaderSettings 367</a> XNA 526 <a href="#bookmark3337">XName 338</a> <a href="#bookmark3339">XNamespace 338</a> <a href="#bookmark3344">XNode 338</a> <a href="#bookmark3342">XObject 338</a> <a href="#bookmark3395">XPath 342,</a><a href="#bookmark3423"> 344</a> <a href="#bookmark3353">XText 338</a></font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark3382">conversion from object 340</a></font></p>
<p><a name="bookmark4900"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">Y</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark1855">yield return 160,</a><a href="#bookmark1880"> 164,</a><a href="#bookmark1945"> 171</a> <a href="#bookmark1863">restrictions 161</a> <a href="#bookmark1852">yield statements 160</a> <a href="#bookmark1860">yield type 161,</a><a href="#bookmark1910"> 168</a></font></p>
<p><a name="bookmark4901"></a><font style="font-size:small;font-family:Franklin Gothic Demi, sans-serif;">Z</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><a href="#bookmark4078">zero 417</a> Zip 504</font></p><div><img src="images/65.png"/></div><br clear="all"/>
<p><a name="bookmark493"><sup><a href="#footnote1">1</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> The C# 1 code could’ve been immutable too—I only left it mutable to simplify the changes for C# 2 and 3.</font></p>
<p><a name="bookmark511"><sup><a href="#footnote2">2</a></sup></a></p>
<p><a name="bookmark4820"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> C# 4 does provide one feature that can be relevant when sorting, called </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">generic variance,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> but giving an example here would require too much explanation. You can find the details near the end of chapter 13.</font></p>
<p><a name="bookmark515"><sup><a href="#footnote3">3</a></sup></a></p>
<p><a name="bookmark4814"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4817"></a></sup> In some ways, this is cheating. We could’ve defined appropriate delegates in C# 1 and called them within the loop. The </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">FindAll </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ForEach </font><font style="font-size:x-small;font-family:Times New Roman, serif;">methods in .NET 2.0 just encourage you to consider separation of concerns.</font></p>
<p><a name="bookmark602"><sup><a href="#footnote4">4</a></sup></a></p>
<p><a name="bookmark4778"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4782"></a></sup> Sort of, anyway. It’s a type as far as the C# compiler is involved, but the CLR doesn’t know anything about it.</font></p>
<p><a name="bookmark635"><sup><a href="#footnote5">5</a></sup></a></p>
<p><a name="bookmark4832"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4833"></a></sup> And the iPod Touch and iPad.</font></p>
<p><a name="bookmark720"><sup><a href="#footnote6">6</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;In addition to the parameter types, you have to match whether the parameter is in (the default), out, or ref. It’s reasonably rare to use out/ref parameters with delegates, though.</font></p>
<p><a name="bookmark721"><sup><a href="#footnote7">7</a></sup></a></p>
<p><a name="bookmark4843"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;This is a deliberately vague use of the word </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">stack</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> to avoid going into too much irrelevant detail. See Eric Lip-pert’s blog post “The void is invariant” for more information (<a href="http://mng.bz/4g58">http://mng.bz/4g58</a>).</font></p>
<p><a name="bookmark730"><sup><a href="#footnote8">8</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;Of course, if the action is an instance method and you’re trying to create a delegate instance from within a static method, you’ll still need to provide a reference to be the target.</font></p>
<p><a name="bookmark734"><sup><a href="#footnote9">9</a></sup></a></p>
<p><a name="bookmark4766"></a><font style="font-size:x-small;font-family:Courier New, monospace;"><sup><a name="bookmark4768"></a><a name="bookmark4794"></a><a name="bookmark4795"></a><a name="bookmark4806"></a><a name="bookmark4885"></a></font><font style="font-size:x-small;font-family:Times New Roman, serif;"></sup> &nbsp;&nbsp;&nbsp;For synchronous invocation, anyway. You can use BeginInvoke and EndInvoke to invoke a delegate instance asynchronously, but that’s beyond the scope of this chapter.</font></p>
<p><a name="bookmark740"><sup><a href="#footnote10">10</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Courier New, monospace;"><sup></font><font style="font-size:x-small;font-family:Times New Roman, serif;"></sup> &nbsp;&nbsp;&nbsp;Or any other kind of expression—but it’s usually a variable.</font></p>
<p><a name="bookmark773"><sup><a href="#footnote11">11</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> These aren’t their names in the compiled code; otherwise you could only have one event per type. The compiler creates two methods with names that aren’t used elsewhere, and a special piece of metadata to let other types know that there’s an event with the given name, and what its add/ remove methods are called.</font></p>
<p><a name="bookmark779"><sup><a href="#footnote12">12</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> There are very small changes to field-like events in C# 4. See section 4.2 for details.</font></p>
<p><a name="bookmark787"><sup><a href="#footnote13">13</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> This applies to most expressions too, but not quite all of them. Certain expressions don’t have a type, such as void method invocations, but this doesn’t affect C# 1’s status of being statically typed. I’ve used the word </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">variable</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> throughout this section to avoid unnecessary brain strain.</font></p>
<p><a name="bookmark800"><sup><a href="#footnote14">14</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Okay, not so hypothetical. See section 8.2 for C# 3’s implicitly typed local variable capabilities.</font></p>
<p><a name="bookmark820"><sup><a href="#footnote15">15</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> At least, the language allows them to be. You can use the </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Array </font><font style="font-size:x-small;font-family:Times New Roman, serif;">type for weakly typed access to arrays, though.</font></p>
<p><a name="bookmark846"><sup><a href="#footnote16">16</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> C# 4 introduces limited </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">generic</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> covariance and contravariance, but that’s not quite the same thing.</font></p>
<p><a name="bookmark911"><sup><a href="#footnote17">17</a></sup></a></p>
<p><a name="bookmark4822"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4892"></a></sup> Boxing will </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">always</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> occur when you call </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">GetType() </font><font style="font-size:x-small;font-family:Times New Roman, serif;">on a value type variable, because it can't be overridden. You should already know the exact type if you’re dealing with the unboxed form, so you can just use </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">typeof </font><font style="font-size:x-small;font-family:Times New Roman, serif;">instead.</font></p>
<p><a name="bookmark981"><sup><a href="#footnote18">18</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> By which I mean “convenient for the purposes of introducing the chapter”—not necessarily </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">accurate.</font></p>
<p><a name="bookmark1038"><sup><a href="#footnote19">19</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> It doesn’t always work </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">exactly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> that way—there are corner cases that break when you apply that simple rule— but it’s an easy way of thinking about generics that works in the vast majority of situations.</font></p>
<p><a name="bookmark1058"><sup><a href="#footnote20">20</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Well, aside from any C# 4 code that </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">explicitly</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> uses dynamic typing, anyway.</font></p>
<p><a name="bookmark1137"><sup><a href="#footnote21">21</a></sup></a></p>
<p><a name="bookmark4835"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4865"></a></sup> At the time of this writing, the code generated by the JIT compiler for comparing unconstrained type parameter values against null is extremely slow for nullable value types. If you constrain a type parameter </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to be non-nullable and then compare a value of type </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T? </font><font style="font-size:x-small;font-family:Times New Roman, serif;">against null, that comparison is much faster. This shows some scope for future JIT optimization.</font></p>
<p><a name="bookmark1144"><sup><a href="#footnote22">22</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> We’ll see in chapter 14 that dynamic typing provides the ability to resolve overloads at execution time.</font></p>
<p><a name="bookmark1158"><sup><a href="#footnote23">23</a></sup></a></p>
<p><a name="bookmark4804"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> The formula used for calculating the hash code based on <a name="bookmark4772"></a>the two “part” results comes from reading </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Effective Java, 2nd edition</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> (Prentice Hall PTR, 2008), by Joshua Bloch. It certainly doesn’t guarantee a good distribution of hash codes, but in my opinion it’s better than using a bitwise exclusive OR. See </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Effective Java</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> for more details, and for many other useful tips and design insights.</font></p>
<p><a name="bookmark1169"><sup><a href="#footnote24">24</a></sup></a></p>
<p><a name="bookmark4765"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4888"></a></sup> Well, one per application domain. For the purposes of this section, we’ll assume we’re only dealing with one application domain. The concepts for different application domains work the same with generics as with nongeneric types. Variables decorated with </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">[ThreadStatic] </font><font style="font-size:x-small;font-family:Times New Roman, serif;">violate this rule, too.</font></p>
<p><a name="bookmark1186"><sup><a href="#footnote25">25</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> When running on a 64-bit CLR, the overheads are bigger.</font></p>
<p><a name="bookmark1223"><sup><a href="#footnote26">26</a></sup></a></p>
<p><a name="bookmark4856"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> I deliberately bucked the convention of using a type parameter named </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, precisely so that we could tell the difference between the </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">T </font><font style="font-size:x-small;font-family:Times New Roman, serif;">in the </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">List&lt;T&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">declaration and the </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">X </font><font style="font-size:x-small;font-family:Times New Roman, serif;">in our method declaration.</font></p>
<p><a name="bookmark1274"><sup><a href="#footnote27">27</a></sup></a></p>
<p><a name="bookmark4824"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4878"></a><a name="bookmark4882"></a></sup> If these names mean nothing to you, check out their Wikipedia entries (<a href="http://mng.bz/pWl7">http:/<a name="bookmark4849"></a>/mng.bz/pWl7 </a>and <a href="http://mng.bz/1025">http://</a> <a href="http://mng.bz/1025">mng.bz/1025</a>). They have special meaning to me for different reasons: Mondrian is also the name of the code review tool we use at Google, and Seurat is the eponymous George of </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">Sunday in the Park with George</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—a wonderful musical by Stephen Sondheim.</font></p>
<p><a name="bookmark1284"><sup><a href="#footnote28">28</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> We’ll see in chapter 13 that there’s slightly more to it than that—but that’s the general principle.</font></p>
<p><a name="bookmark1306"><sup><a href="#footnote29">29</a></sup></a></p>
<p><a name="bookmark4783"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> This is assuming you’re not using .NET 4, of course, which already has </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Numerics.ComplexNumber</font><font style="font-size:x-small;font-family:Times New Roman, serif;">.</font></p>
<p><a name="bookmark1332"><sup><a href="#footnote30">30</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;The inventor of C++.</font></p>
<p><a name="bookmark1335"><sup><a href="#footnote31">31</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;Or 5.0, depending on which numbering system you use. Don’t get me started.</font></p>
<p><a name="bookmark1355"><sup><a href="#footnote32">32</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> It’s almost always </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">DateTime </font><font style="font-size:x-small;font-family:Times New Roman, serif;">rather than any other value type. I’m not entirely sure why—it’s as if developers inherently understand why a byte shouldn’t be null, but feel that dates are more inherently nullable.</font></p>
<p><a name="bookmark1421"><sup><a href="#footnote33">33</a></sup></a></p>
<p><a name="bookmark4866"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4897"></a><a name="bookmark4898"></a></sup> Most value types in the framework are immutable, but there are some commonly used exceptions—in particular, the </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Point </font><font style="font-size:x-small;font-family:Times New Roman, serif;">structures for both Windows Forms and Windows Presentation Foundation are mutable.</font></p>
<p><a name="bookmark1455"><sup><a href="#footnote34">34</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> You’ll learn more about static classes in chapter 7.</font></p>
<p><a name="bookmark1503"><sup><a href="#footnote35">35</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> The equality and relational operators are binary operators too, but we’ll see that they behave slightly differently than the others; hence their separation here.</font></p>
<p><a name="bookmark1566"><sup><a href="#footnote36">36</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Wouldn’t it be great if </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Hashtable </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Dictionary&lt;TKey,TValue&gt; </font><font style="font-size:x-small;font-family:Times New Roman, serif;">could take a delegate to call whenever a new value was required due to looking up a missing key? Situations like this would be a lot simpler.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> In case you’re wondering: </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">return people.Where(person =&gt; person.Age &lt;&nbsp;limit)</font></p>
<p><a name="bookmark1637"><sup><a href="#footnote37">37</a></sup></a></p>
<p><a name="bookmark4810"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Extension methods (see chapter 10) make the helper method approach somewhat more appealing if you’re using C# 3.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> I’ve removed the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">public delegate</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> part for reasons of space.</font></p>
<p><a name="bookmark1667"><sup><a href="#footnote38">38</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Return type covariance and parameter type contravariance can be used at the same time, although you’re unlikely to come across situations where it would be useful.</font></p>
<p><a name="bookmark1678"><sup><a href="#footnote39">39</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> In case you skipped the first chapter, Snippy is a tool I’ve used to create short but complete code samples. See section 1.7.1 for more details.</font></p>
<p><a name="bookmark1696"><sup><a href="#footnote40">40</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> We’ll see in section 5.5.4 that although there’s always a new method, it’s not always created where you might expect.</font></p>
<p><a name="bookmark1755"><sup><a href="#footnote41">41</a></sup></a></p>
<p><a name="bookmark4873"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;This is general comput<a name="bookmark4861"></a>er science terminology, not C# terminology.</font></p>
<p><a name="bookmark1761"><sup><a href="#footnote42">42</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;Excluding ref and out parameters</font></p>
<p><a name="bookmark1792"><sup><a href="#footnote43">43</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> In my view it’s also cleaner to redeclare the variable unless you explicitly need to maintain its value between iterations.</font></p>
<p><a name="bookmark1859"><sup><a href="#footnote44">44</a></sup></a></p>
<p><a name="bookmark4763"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4844"></a></sup> &nbsp;&nbsp;&nbsp;Or properties, as we’ll see later on. You can’t use an iterator block in an anonymous method, though.</font></p>
<p><a name="bookmark1865"><sup><a href="#footnote45">45</a></sup></a></p>
<p><a name="bookmark4798"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;If you want to know more about why these restrictions exist, Eric Lippert has a whole series of blog posts about these and other design decisions involving iterators: see <a href="http://mng.bz/EJ97">http://mng.bz/EJ97</a>.</font></p>
<p><a name="bookmark1886"><sup><a href="#footnote46">46</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> I personally find that the hoops you have to jump through to achieve this often make the code much harder to read than just having multiple return points, especially as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">try/finally </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is available for cleanup and you need to account for the possibility of exceptions occurring anyway. The point is that it can be done.</font></p>
<p><a name="bookmark1888"><sup><a href="#footnote47">47</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;Note that methods taking ref or out parameters can’t be implemented with iterator blocks.</font></p>
<p><a name="bookmark1894"><sup><a href="#footnote48">48</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;They also work as normal when execution leaves the relevant scope without reaching either a yield return or a yield break statement. I’m only focusing on the behavior of the two yield statements here because that’s where the flow of execution is new and different.</font></p>
<p><a name="bookmark1916"><sup><a href="#footnote49">49</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> The Microsoft C# compilers shipping with .NET 3.5 and 4 behave in the same way.</font></p>
<p><a name="bookmark1975"><sup><a href="#footnote50">50</a></sup></a></p>
<p><a name="bookmark4841"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Or to be more precise, LINQ to Objects. LINQ providers for databases and the like are far more complex.</font></p>
<p><a name="bookmark1993"><sup><a href="#footnote51">51</a></sup></a></p>
<p><a name="bookmark4785"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4871"></a></sup> &nbsp;&nbsp;&nbsp;In .NET 4, you’d usually use </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Task.ContinueWith </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to achieve similar results in a slightly different way... or perhaps Reactive Extensions.</font></p>
<p><a name="bookmark1999"><sup><a href="#footnote52">52</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;Well, mostly—it might still be inefficient, as we’ll see in a moment.</font></p>
<p><a name="bookmark2113"><sup><a href="#footnote53">53</a></sup></a></p>
<p><a name="bookmark4805"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Except nested types, which always have access to private members of their enclosing types.</font></p>
<p><a name="bookmark2199"><sup><a href="#footnote54">54</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Using reflection when running with suitable permissions doesn’t count.</font></p>
<p><a name="bookmark2253"><sup><a href="#footnote55">55</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> C# 4 changes the game yet again, allowing you to use dynamic typing where you want to, as we’ll see in chapter 14. One step at a time—C# was still fully statically typed up to and including version 3.</font></p>
<p><a name="bookmark2294"><sup><a href="#footnote56">56</a></sup></a></p>
<p><a name="bookmark4800"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> I realize this sounds a little like duck typing: “so long as it can quack, I’m happy.” The difference is that we’re still checking quackability at compile time, not execution time.</font></p>
<p><a name="bookmark2323"><sup><a href="#footnote57">57</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> <a name="bookmark4887"></a>In fact, the variable’s new value isn’t assigned until all the properties have been set. A temporary local variable is used until t<a name="bookmark4792"></a>hen. This is rarely important, but worth knowing to avoid confusion if you happen to break into the debugger halfway through the initializer.</font></p>
<p><a name="bookmark4852"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> C# 4 provides an alternative approach here using named arguments, which we’ll meet in chapter 13.</font></p>
<p><a name="bookmark2372"><sup><a href="#footnote58">58</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Named arguments in C# 4 help in this area, admittedly.</font></p>
<p><a name="bookmark2396"><sup><a href="#footnote59">59</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> If you already know LINQ, you may feel that this is a quaint way of summing the ages. I agree, calling </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">family.Sum(p =&gt; p.Age) </font><font style="font-size:x-small;font-family:Times New Roman, serif;">would be a lot neater—but let’s take things one step at a time.</font></p>
<p><a name="bookmark2450"><sup><a href="#footnote60">60</a></sup></a></p>
<p><a name="bookmark4791"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4860"></a></sup> LIN<a name="bookmark4842"></a>Q to Objects handles sequences of data within the same process. By contrast, providers such as LINQ to SQL offload the work to other out-of-process systems—databases, for example.</font></p>
<p><a name="bookmark2462"><sup><a href="#footnote61">61</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;The one feature available to anonymous methods but not lambda expressions is the ability to concisely ignore parameters. Look back at section 5.4.3 for more details if you’re interested, but in practice it’s not something you’ll really miss with lambda expressions.</font></p>
<p><a name="bookmark2469"><sup><a href="#footnote62">62</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;You may remember we met the version without any parameters (but one type parameter) in chapter 6.</font></p>
<p><a name="bookmark2487"><sup><a href="#footnote63">63</a></sup></a></p>
<p><a name="bookmark4808"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4829"></a></sup> &nbsp;&nbsp;&nbsp;Code paths throwing exceptions don’t need to return a value, of course, and neither do detectable infinite loops.</font></p>
<p><a name="bookmark2491"><sup><a href="#footnote64">64</a></sup></a></p>
<p><a name="bookmark4773"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4877"></a></sup> &nbsp;&nbsp;&nbsp;You can still use this syntax for a delegate with a void return type if you only need one statement. You omit the semicolon and the braces, basically.</font></p>
<p><a name="bookmark2500"><sup><a href="#footnote65">65</a></sup></a></p>
<p><a name="bookmark4847"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> That’s not to say it’s impossible. Some languages allow closures to be represented as simple blocks of code with a magic variable name to represent the common case of a single parameter.</font></p>
<p><a name="bookmark2655"><sup><a href="#footnote66">66</a></sup></a></p>
<p><a name="bookmark4858"></a><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup></sup> </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Returned expressions that don’t have a type, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">null </font><font style="font-size:x-small;font-family:Times New Roman, serif;">or another lambda expression, aren’t included in this set. Their validity is checked later, once a return type has been determined, but they don’t contribute to that decision.</font></p>
<p><a name="bookmark2676"><sup><a href="#footnote67">67</a></sup></a></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup></sup> </font><font style="font-size:x-small;font-family:Times New Roman, serif;">I’m assuming that all the methods are declared in the same class. When inheritance is involved as well, it becomes even </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">more</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> complicated. That aspect hasn’t changed in C# 3, though.</font></p>
<p><a name="bookmark2703"><sup><a href="#footnote68">68</a></sup></a></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup></sup> </font><font style="font-size:x-small;font-family:Times New Roman, serif;">If you’re getting fed up with hearing about how many features are “an important part of LINQ,” I don’t blame you—but that’s part of its greatness. There are lots of small parts, but the sum of them is very shiny. The fact that each feature can be used independently is an added bonus.</font></p>
<p><a name="bookmark2715"><sup><a href="#footnote69">69</a></sup></a></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup></sup> </font><font style="font-size:x-small;font-family:Times New Roman, serif;">Due to the nature of streams, this copying doesn’t necessarily </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">duplicate</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> the data—it just reads it from one stream and writes it to another. Although </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">copy</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> isn’t a strictly accurate term in this sense, the difference is usually irrelevant.</font></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup></sup> </font><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s even more general than that—the compiler doesn’t require </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Select </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to be a method, or </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">SampleData.AllUsers </font><font style="font-size:x-small;font-family:Times New Roman, serif;">to be a property access. So long as the translated code compiles, it’s happy. In almost every sensible case you’ll access either standard or extension methods, but I have a blog post with some particularly odd queries (see <a href="http://mng.bz/7E3i">http://mng.bz/7E3i</a>). I haven’t found this useful in practice, but I do like it as a way of hammering home how mechanical the translation process is, and how it doesn’t care about the </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">meaning</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> of the translated code.</font></p>
<p><a name="bookmark2941"><sup><a href="#footnote70">70</a></sup></a></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup></sup> </font><font style="font-size:x-small;font-family:Times New Roman, serif;">The various parameters involved are checked for nullity, though. This is important to bear in mind if you implement your own LINQ operators, as we’ll see in chapter 12.</font></p>
<p><a name="bookmark2976"><sup><a href="#footnote71">71</a></sup></a></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup></sup> </font><font style="font-size:x-small;font-family:Times New Roman, serif;">The marketing department of SkeetySoft isn’t particularly creative.</font></p>
<p><a name="bookmark3024"><sup><a href="#footnote72">72</a></sup></a></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup></sup> </font><font style="font-size:x-small;font-family:Times New Roman, serif;">In order to allow all the methods signatures in this chapter to fit on the printed page, I’ve omitted the </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">public </font><font style="font-size:x-small;font-family:Times New Roman, serif;">modifier. In reality they </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">are</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> all public though.</font></p>
<p><a name="bookmark3102"><sup><a href="#footnote73">73</a></sup></a></p>
<p><font style="font-size:xx-small;font-family:Franklin Gothic Demi, sans-serif;"><sup></sup> </font><font style="font-size:x-small;font-family:Times New Roman, serif;">It’s also valid for there to be two key types involved, with an implicit conversion from one to the other. One of the types must be a better choice than the other, in the same way that the compiler infers the type of an implicitly typed array. In my experience, you rarely need to consciously consider this detail.</font></p>
<p><a name="bookmark3136"><sup><a href="#footnote74">74</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> This is a simple implementation for the sake of the example—not a full-blown, general-purpose range.</font></p>
<p><a name="bookmark3187"><sup><a href="#footnote75">75</a></sup></a></p>
<p><a name="bookmark4816"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> That’s the term I’ll use from now on, but if you hear others talking about </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">fluent notation,</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> they probably mean the same thing.</font></p>
<p><a name="bookmark3272"><sup><a href="#footnote76">76</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Additional log output is generated showing some details of the data context, which I’ve cut to avoid distracting from the SQL. The console output also contains the summaries printed by the </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">foreach </font><font style="font-size:x-small;font-family:Times New Roman, serif;">loop, of course.</font></p>
<p><a name="bookmark3304"><sup><a href="#footnote77">77</a></sup></a></p>
<p><a name="bookmark4862"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;Well, the ones that keep deferring execution, such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Where </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Join</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. We’ll see what happens with the aggregations such as </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Count </font><font style="font-size:x-small;font-family:Times New Roman, serif;">in a while.</font></p>
<p><a name="bookmark3305"><sup><a href="#footnote78">78</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;Both </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Execute </font><font style="font-size:x-small;font-family:Times New Roman, serif;">and </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">CreateQuery </font><font style="font-size:x-small;font-family:Times New Roman, serif;">have generic and nongeneric overloads. The nongeneric versions make it easier to create queries dynamically in code. Compile-time query expressions use the generic version.</font></p>
<p><a name="bookmark3336"><sup><a href="#footnote79">79</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> I regularly forget whether it’s </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Xml. Linq </font><font style="font-size:x-small;font-family:Times New Roman, serif;">or </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Linq.Xml</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. I </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">would</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> say that if you remember that it’s an XML API first and foremost, you should be okay—but it’s clearly not working for me. Maybe you’ll have better luck.</font></p>
<p><a name="bookmark3373"><sup><a href="#footnote80">80</a></sup></a></p>
<p><a name="bookmark4784"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> In some ways it’s a shame that </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XElement </font><font style="font-size:x-small;font-family:Times New Roman, serif;">doesn’t implement </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IEnumerable</font><font style="font-size:x-small;font-family:Times New Roman, serif;">—as otherwise collection initializers would be another approach to construction. Never mind—using the constructor works neatly anyway.</font></p>
<p><a name="bookmark3388"><sup><a href="#footnote81">81</a></sup></a></p>
<p><a name="bookmark4764"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4848"></a></sup> One contributing factor to the readability is an extension method I created to convert anonymous types into elements, using the properties for child elements. If you’re interested, the code is freely available as part of my MiscUtil project (see <a href="http://mng.bz/xDMt">http://mng.bz/xDMt</a>). It only helps when the XML structure you need fits a certain pattern, but in that case it can reduce the clutter of </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">XElement </font><font style="font-size:x-small;font-family:Times New Roman, serif;">constructor calls significantly.</font></p>
<p><a name="bookmark3448"><sup><a href="#footnote82">82</a></sup></a></p>
<p><a name="bookmark4769"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Proper benchmarking is hard—particularly when threading is involved. I haven’t attempted to do rigorous measurements or anything of the kind. The timings given are just meant to be indicative of “faster” and “slower”; please take the numbers with a pinch of salt.</font></p>
<p><a name="bookmark3487"><sup><a href="#footnote83">83</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> For a more detailed examination of this duality—and the essence of LINQ itself—I recommend Bart de Smet’s “MinLinq” blog post at <a href="http://mng.bz/96Wh">http://mng.bz/96Wh</a>.</font></p>
<p><a name="bookmark3570"><sup><a href="#footnote84">84</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;The downloadable code contains the same test for implementations of </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ICollection&lt;T&gt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, just like </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Count() </font><font style="font-size:x-small;font-family:Times New Roman, serif;">does in .NET 4. It’s exactly the same block of code, just with a different type and a different variable name.</font></p>
<p><a name="bookmark3571"><sup><a href="#footnote85">85</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;I’m allowed to say that it’s clever because even though it’s my implementation, it’s not my idea.</font></p>
<p><a name="bookmark3582"><sup><a href="#footnote86">86</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Or Cavalleria Rusticana and Pagliacci if you’re feeling more highly cultured.</font></p>
<p><a name="bookmark3623"><sup><a href="#footnote87">87</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Or you could just accept that you’ll need to recompile everything if you change the value. In many contexts that’s a reasonable tradeoff.</font></p>
<p><a name="bookmark3635"><sup><a href="#footnote88">88</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> We almost need a second null-like special value, meaning “please use the default value for this parameter”— and allow that special value to be supplied either automatically for missing arguments or explicitly in the argument list. I’m sure this would cause dozens of problems, but it’s an interesting thought experiment.</font></p>
<p><a name="bookmark3736"><sup><a href="#footnote89">89</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> It might’ve been more interesting to display the actual meanings—but that leads to interop problems that aren’t relevant to this chapter. See the book’s website for more details.</font></p>
<p><a name="bookmark3762"><sup><a href="#footnote90">90</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Well, nearly. The object initializer makes it slightly more complicated because the compiler uses an extra temporary variable.</font></p>
<p><a name="bookmark3798"><sup><a href="#footnote91">91</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> In the full source code solution, these are exposed as properties on the static </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Shapes </font><font style="font-size:x-small;font-family:Times New Roman, serif;">class, but in the snippets version I’ve included the construction code where it’s needed, so you can tweak it easily if you want to.</font></p>
<p><a name="bookmark3953"><sup><a href="#footnote92">92</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> The Wikipedia article on duck typing has more information about the history of the term: <a href="http://en.wikipedia.org/wiki/Duck_typing">http://en.wikipedia.org/wiki/Duck_typing</a>.</font></p>
<p><a name="bookmark3963"><sup><a href="#footnote93">93</a></sup></a></p>
<p><a name="bookmark4801"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> In fact, </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">dynamic </font><font style="font-size:x-small;font-family:Times New Roman, serif;">doesn’t represent a specific CLR type. It’s really just </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Object </font><font style="font-size:x-small;font-family:Times New Roman, serif;">in conjunction with </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">System.Dynamic.DynamicAttribute</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. We’ll look at this in more detail in section 14.4, but for the moment you can pretend it’s a real type.</font></p>
<p><a name="bookmark4024"><sup><a href="#footnote94">94</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Or way of life, depending on how you view the world and your level of addiction to playing the game.</font></p>
<p><a name="bookmark4102"><sup><a href="#footnote95">95</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Arguably these aren’t mutually exclusive, but ideas which are both brilliant and evil are rarely suitable for production work.</font></p>
<p><a name="bookmark4141"><sup><a href="#footnote96">96</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> A lot of information is specific to a particular call site, as the binding rules will be different depending on things like which class it’s being called from.</font></p>
<p><a name="bookmark4166"><sup><a href="#footnote97">97</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Just as a reminder, </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Snippet </font><font style="font-size:x-small;font-family:Times New Roman, serif;">is the class generated by Snippy automatically.</font></p>
<p><a name="bookmark4178"><sup><a href="#footnote98">98</a></sup></a></p>
<p><a name="bookmark4770"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> It’s slightly more complicated than that—what if the actual type is internal to another assembly? We wouldn’t want that to be used as the type argument of a generic method via type inference, for example. The binder has the notion of a “best accessible type” based on the calling context and the actual type.</font></p>
<p><a name="bookmark4241"><sup><a href="#footnote99">99</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> There's a certain irony here—the names we know statically can be set dynamically, but the names we know dynamically have to use static typing.</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> If you’re not familiar with the fairy tale of Rumpelstiltskin, look at its wikipedia article (see <a href="http://mng.bz/0AN0">http://mng.bz/</a> <a href="http://mng.bz/0AN0">0AN0</a>). The example will make more sense afterward!</font></p>
<p><a name="bookmark4828"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4884"></a></sup> In fact, you can change this behavior with the </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-infer </font><font style="font-size:x-small;font-family:Times New Roman, serif;">option to the checker. By default the checker will infer postconditions for properties, but not methods. There’s a </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">-suggest </font><font style="font-size:x-small;font-family:Times New Roman, serif;">option that displays postconditions you might like to consider adding, but it doesn’t use this knowledge when checking for correctness.</font></p>
<p><a name="bookmark4365"><sup><a href="#footnote100">100</a></sup></a></p>
<p><a name="bookmark4850"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4895"></a></sup> &nbsp;&nbsp;&nbsp;It’s only part of the build if you’re using msbuild, either directly or from Visual Studio. If you’re running the C# compiler manually, you’ll need to run ccrewrite too. The same is true for the other tools.</font></p>
<p><a name="bookmark4373"><sup><a href="#footnote101">101</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;This screenshot was taken using Visual Studio 2010 Premium; static checking isn’t supported in Visual Studio 2010 Professional, so that part of the properties page may be blank. Additionally, the properties page is evolving with the tools—by the time you read this, it may have changed appearance and functionality.</font></p>
<p><a name="bookmark4380"><sup><a href="#footnote102">102</a></sup></a></p>
<p><a name="bookmark4787"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> You can decora<a name="bookmark4868"></a>te a private field with the [ContractPublicPropertyName] attribute. This lets you refer to the private field within preconditions, knowing that the caller can get at the same information with a property.</font></p>
<p><a name="bookmark4393"><sup><a href="#footnote103">103</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> We could also add a postcondition for the upper bound: the method will never return a value larger than the length of the text that’s passed in. I’m going to keep it simple here, though.</font></p>
<p><a name="bookmark4406"><sup><a href="#footnote104">104</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> The fix to this bug is just to use a local variable as the argument to </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">int.TryParse</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, and then conditionally copy the value into the </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">ref </font><font style="font-size:x-small;font-family:Times New Roman, serif;">parameter. The corrected code is in the downloadable source.</font></p>
<p><a name="bookmark4799"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4813"></a></sup> Finalizers and implementations of </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IDisposable.Dispose </font><font style="font-size:x-small;font-family:Times New Roman, serif;">don’t check the invariant at the end. It’s expected that the object may be unusable after disposal.</font></p>
<p><a name="bookmark4879"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> This is in no way meant to discourage you from trying to write short methods—short methods with preconditions and postconditions can sometimes remove the need for midmethod contracts. Sometimes it’s just too hard, though.</font></p>
<p><a name="bookmark4428"><sup><a href="#footnote105">105</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> In fact, </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Random.Next </font><font style="font-size:x-small;font-family:Times New Roman, serif;">now has contracts applied to it, so we could’ve used </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Assert </font><font style="font-size:x-small;font-family:Times New Roman, serif;">orjust let the checker work it out. Just pretend that it doesn’t have any contracts for the sake of the example—a lot of existing code doesn’t!</font></p>
<p><a name="bookmark4487"><sup><a href="#footnote106">106</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> If C# allowed interfaces to declare nested types, this would be an ideal situation to use that ability. Unfortunately, it doesn’t.</font></p>
<p><a name="bookmark4552"><sup><a href="#footnote107">107</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> That’s “correct” for the intention of reversing </font><font style="font-size:x-small;font-family:Times New Roman, serif;font-style:italic;">all</font><font style="font-size:x-small;font-family:Times New Roman, serif;"> comparisons. It violates the documentation of </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">IComparer&lt;T&gt;</font><font style="font-size:x-small;font-family:Times New Roman, serif;">, which states that a null reference is considered less than any non-null reference, assuming that the original comparison obeys the same rule.</font></p>
<p><a name="bookmark4644"><sup><a href="#footnote108">108</a></sup></a></p>
<p><a name="bookmark4857"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> Admittedly non-nullable reference types come with their own set of design difficulties (see <a href="http://mng.bz/">http://mng.bz/</a> fVfI). It’s not like this was a simple oversight in the design of .NET.</font></p>
<p><a name="bookmark4687"><sup><a href="#footnote109">109</a></sup></a></p>
<p><a name="bookmark4881"></a><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup><a name="bookmark4889"></a></sup> Public speaking isn’t as terrifying as it sounds. Or rather, it’s terrifying and exhilarating in equal measure. I advise the use of a sock puppet as a prop: if the whole thing falls apart, you can blame the puppet.</font></p>
<p><a name="bookmark4704"><sup><a href="#footnote110">110</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> There’s no such shortcut for </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">LongCount</font><font style="font-size:x-small;font-family:Times New Roman, serif;">. I’ve personally never seen this method used in LINQ to Objects.</font></p>
<p><a name="bookmark4722"><sup><a href="#footnote111">111</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> &nbsp;&nbsp;&nbsp;Binary search is O(log n) complexity; a linear search is O(n).</font></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> My personal feeling is that this still isn’t enough support for the complex and intriguing world of dates and times, which is why I started the Noda Time project (see <a href="http://mng.bz/S8e0">http://mng.bz/S8e0</a>), but at least with </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">TimeZoneInfo </font><font style="font-size:x-small;font-family:Times New Roman, serif;">there’s finally a clean way of representing a time zone other than the local one.</font></p>
<p><a name="bookmark4751"><sup><a href="#footnote112">112</a></sup></a></p>
<p><font style="font-size:x-small;font-family:Times New Roman, serif;"><sup></sup> The Mono C# compiler has experimental support for </font><font style="font-size:x-small;font-family:Courier New, monospace;font-weight:bold;">Tuple </font><font style="font-size:x-small;font-family:Times New Roman, serif;">at the language level, allowing multiple variables to be assigned from one tuple. I’m sure the Microsoft C# team has considered this too—it’ll be interesting to see whether anything similar shows up in C# 5.</font></p>
</body>
</html>